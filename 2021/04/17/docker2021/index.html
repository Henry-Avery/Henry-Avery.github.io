<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="docker2021, SHU19级小天爷( •̀ ω •́ )y">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="为什么要学习Docker?为了解决环境配置问题
怎样学习使用Docker?安装DockerDocker官网安装
Docker CE 的安装请参考官方文档。Windows版本
什么是Docker？
Docker 属于 Linux 容器的一种封">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>docker2021 | 小天爷的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小天爷的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小天爷的博客</div>
        <div class="logo-desc">
            
            商才士魂
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        docker2021
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/Docker/" target="_blank">
                            <span class="chip bg-color">Docker</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/学习笔记/" class="post-category" target="_blank">
                            学习笔记
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-04-17
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    Henry-Avery
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    68 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="为什么要学习Docker"><a href="#为什么要学习Docker" class="headerlink" title="为什么要学习Docker?"></a>为什么要学习Docker?</h2><p>为了解决环境配置问题</p>
<h2 id="怎样学习使用Docker"><a href="#怎样学习使用Docker" class="headerlink" title="怎样学习使用Docker?"></a>怎样学习使用Docker?</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网安装</a></p>
<p>Docker CE 的安装请参考官方文档。<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows版本</a></p>
<h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><blockquote>
<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<p>——阮一峰</p>
</blockquote>
<p>就跟git一样，是为了方便我们程序员的powerful tools 之一。</p>
<hr>
<h2 id="Datawhale的组队学Docker"><a href="#Datawhale的组队学Docker" class="headerlink" title="Datawhale的组队学Docker"></a>Datawhale的组队学Docker</h2><h3 id="启航"><a href="#启航" class="headerlink" title="启航"></a>启航</h3><blockquote>
<p>通过本次docker的组队学习，我们希望你能学到以下几个方面的能力：</p>
</blockquote>
<ul>
<li>了解什么是docker</li>
<li>docker镜像是怎么构建的</li>
<li>如何运行一个docker容器</li>
<li>docker之间的网络通信是怎么样的</li>
<li>docker中的数据如何做持久化存储</li>
<li>如何通过docker compose管理自己的项目</li>
<li>如何将自己的个人项目打造成容器化部署的形式</li>
</ul>
<h3 id="简介与安装"><a href="#简介与安装" class="headerlink" title="简介与安装"></a>简介与安装</h3><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言 (opens new window)</a>进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup (opens new window)</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace (opens new window)</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">OverlayFS (opens new window)</a>类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS (opens new window)</a>等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术 (opens new window)</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC (opens new window)</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer (opens new window)</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC (opens new window)</a>和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd (opens new window)</a>。</p>
<p>比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><strong>虚拟机</strong>在宿主机(host)中的OS上面是hypervisor(hypervisor)，然后依次建立虚拟机，虚拟化的仓库，然后安装程序。但是对于<strong>Docker</strong>来说，在宿主机(host)中的OS上面是Docker Engine，然后直接在Doker Engine安装应用。</p>
<h3 id="Docker三大基本概念"><a href="#Docker三大基本概念" class="headerlink" title="Docker三大基本概念"></a>Docker三大基本概念</h3><ul>
<li><p><strong>镜像</strong>（<code>Image</code>）</p>
</li>
<li><p><strong>容器</strong>（<code>Container</code>）</p>
</li>
<li><p><strong>仓库</strong>（<code>Repository</code>）</p>
</li>
</ul>
<h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h5 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h5><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS (opens new window)</a>的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
<h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的<strong>实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是<strong>进程</strong>，但与直接在宿主host执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间 (opens new window)</a>。</p>
<blockquote>
<p><strong>名称空间</strong>是<a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="noopener">Linux 内核</a>的一个特征，它划分了内核资源，使一组<a href="https://en.wikipedia.org/wiki/Process_(computing)" target="_blank" rel="noopener">过程</a>看到一组资源，而另一组进程看到一组不同的资源。该功能的工作原理是为一组资源和流程设置相同的命名空间，但这些命名空间是指不同的资源。资源可能存在于多个空间中。此类资源示例包括流程 ID、主机名、用户 ID、文件名称以及与网络访问相关的一些名称以及<a href="https://en.wikipedia.org/wiki/Interprocess_communication" target="_blank" rel="noopener">处理间通信</a>。</p>
</blockquote>
<p>因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://vuepress.mirror.docker-practice.com/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者 <a href="https://vuepress.mirror.docker-practice.com/data_management/bind-mounts.html" target="_blank" rel="noopener">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h4 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://vuepress.mirror.docker-practice.com/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h5 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h5><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器 (opens new window)</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器 (opens new window)</a>等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://vuepress.mirror.docker-practice.com/install/mirror.html" target="_blank" rel="noopener">安装 Docker</a> 一节中有详细的配置方法。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务 (opens new window)</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场 (opens new window)</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云镜像库 (opens new window)</a>等。</p>
<h5 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h5><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry (opens new window)</a>镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://vuepress.mirror.docker-practice.com/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p>
<h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><blockquote>
<p>开始学习前，我C盘已经不够10个G了，不知道能不能撑住。所以……</p>
<p>虚拟机的默认存储位置是C:\Users\Administrator.docker\machine\machines ，后期docke镜像文件会不断增加，为了给系统盘减负，最好将磁盘移动到其他位置。</p>
<p>ps:不想开虚拟机所以就在Windows上折腾了，能hello-world很开心</p>
</blockquote>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210414201843575.png" alt="hello"></p>
<h4 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p><strong>获取镜像</strong></p>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到</p>
<p>比如：</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker pull ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>列出镜像</strong></p>
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p>
<p><strong>删除本地镜像</strong></p>
<p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker image rm [选项] <镜像1> [<镜像2> ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>Untagged 和 Deleted</strong></p>
<p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210414202719907.png" alt="我这就是"></p>
<p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p>
<p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p>
<pre><code>$ docker image rm $(docker image ls -q redis)</code></pre><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p>
<pre><code>$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></pre><blockquote>
<p>然而我并没有用Linux，而且也没看懂Linux命令</p>
</blockquote>
<p><strong>Dockerfile制作镜像</strong></p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<pre><code>$ mkdir mynginx
$ cd mynginx
$ touch Dockerfile</code></pre><blockquote>
<p>我打开了vm打算装个乌班图重新开始。或者再在Windows上尝试一下</p>
</blockquote>
<p><a href="https://blog.csdn.net/zzq060143/article/details/91050272?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">Windows上docker使用教程</a></p>
<blockquote>
<p>touch好像是Linux命令，我直接在mynginx创建一个文件然后记事本打开输入。这里你可以换成echo test&gt; Dockerfile，就会生成Dockerfile 文件。</p>
</blockquote>
<p>其内容为：</p>
<pre><code>FROM nginx
RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<p><strong>FROM 指定基础镜像</strong></p>
<p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<pre><code>FROM scratch
...</code></pre><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<p><strong>RUN 执行命令</strong></p>
<p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li>
</ul>
<pre><code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><ul>
<li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<pre><code>FROM debian:stretch

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install</code></pre><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<pre><code>FROM debian:stretch

RUN set -x; buildDeps=&#39;gcc libc6-dev make wget&#39; \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<blockquote>
<p>Linux命令也能先看看，继续</p>
</blockquote>
<p><strong>构建镜像</strong></p>
<p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<pre><code>$ docker build -t nginx:v3 .
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM nginx
 ---&gt; e43d811ce2f4
Step 2 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
 ---&gt; Running in 9cdc27646c7b
 ---&gt; 44aa4490ce2c
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c</code></pre><blockquote>
<p>我在这遇到个小问题，ERROR [internal] load metadata for docker.io/library/nginx:latest，怀疑是挂了梯子的原因，关了代理之后就正常了。</p>
</blockquote>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p>
<p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p>
<pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p>
<blockquote>
<p>wait for 4 minutes</p>
</blockquote>
<p><strong>镜像构建上下文（Context）</strong></p>
<p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <code>Dockerfile</code> 中这么写：</p>
<pre><code>COPY ./package.json /app/</code></pre><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<pre><code>$ docker build -t nginx:v3 .
Sending build context to Docker daemon 2.048 kB
...</code></pre><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<blockquote>
<p>更多关于Dockerfile的内容可以移步：<a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/" target="_blank" rel="noopener">Dockerfile详解</a>，不过更多的内容还是大家在实践中逐渐熟悉，这样才能更了解里面的含义。</p>
</blockquote>
<p><strong>跨平台构建镜像</strong></p>
<p>在日常的工作中，我们常常有需求将一个程序运行在不同架构CPU的设备上，尤其在嵌入式领域，我们常常接触的各种开发板、路由器往往都是使用ARM架构的芯片，而我们日常开发的设备都是在x86平台。我们在x86平台写的程序需要运行在使用ARM芯片的开发板上，这时候就需要跨CPU构建程序。</p>
<p>总的来说跨平台构建程序有以下几种方式。</p>
<ul>
<li>直接在目标硬件编译 这是最直接的方法</li>
<li>使用交叉编译器 交叉编译器是专门为在给定的系统平台上运行而设计的编译器，作用是可以在一种CPU架构上编译出另一个CPU架构的可执行文件。最普遍的例子，开发人员开发安卓应用的时候几乎都在X86的平台上开发构建，但安卓应用很明显是ARM架构的，这其中就是交叉编译器在起作用</li>
<li>模拟目标硬件 模拟目标硬件最常见的开源模拟器是QEMU，QEMU是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道</li>
<li>通过binfmt_misc模拟目标硬件的用户空间 QEMU 除了可以模拟完整的操作系统之外，还有另外一种模式叫用户态模式（User mod）。该模式下 QEMU 将通过 binfmt_misc 在 Linux 内核中注册一个二进制转换处理程序，并在程序运行时动态翻译二进制文件，根据需要将系统调用从目标 CPU 架构转换为当前系统的 CPU 架构。最终的效果看起来就像在本地运行目标 CPU 架构的二进制文件。 通过 QEMU 的用户态模式，我们可以创建轻量级的虚拟机（chroot 或容器），然后在虚拟机系统中编译程序，和本地编译一样简单轻松。</li>
</ul>
<blockquote>
<p>好像目前我没法实操</p>
</blockquote>
<p><strong>构建跨架构的Docker镜像</strong></p>
<p>先跳过了</p>
<p><strong>镜像存储位置</strong></p>
<p>在操作系统中(Linux)，默认情况下 Docker 容器的存放位置在 /var/lib/docker 目录下面，可以通过命令查看</p>
<pre><code>docker info | grep &quot;Docker Root Dir&quot;</code></pre><p>我们使用docker pull 下载的镜像，都会存在这个目录下，当下载的镜像过多，或容器运行过程中产生大量数据导致存储容量不足时，可以修改镜像储存的位置，有以下几种方式修改docker默认储存位置</p>
<p><strong>使用软链接</strong></p>
<ul>
<li>首先停止docker 进程</li>
<li>然后进行链接</li>
</ul>
<pre><code>#stop
$ sudo systemctl stop docker
#move
$ mv /var/lib/docker /data/docker
#ln
$ ln -sf /data/docker /var/lib/docker</code></pre><ul>
<li>然后移动整个 /var/lib/docker 目录到空间比较大的目的路径。这时候启动 Docker 时发现存储目录依旧是 /var/lib/docker 目录，但是实际上是存储在数据盘 /data/docker 上了。</li>
</ul>
<p><strong>指定容器启动参数</strong></p>
<ul>
<li>在配置文件中指定容器启动的参数 –graph=/var/lib/docker 来指定镜像和容器存放路径。Docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致。在 Ubuntu 中的位置是 /etc/default/docker 文件，在 CentOS 中的位置是 /etc/sysconfig/docker 文件。</li>
</ul>
<pre><code>#Cent 7
# 更改储存位置
$ vi /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd --graph /new-path/docker

sudo systemctl restart docker </code></pre><ul>
<li>如果 Docker 的版本是 1.12 或以上的，可以修改或新建 daemon.json 文件。修改后会立即生效，不需重启 Docker 服务。</li>
</ul>
<pre><code># 修改配置文件
$ vim /etc/docker/daemon.json
{
    &quot;registry-mirrors&quot;:
        [&quot;http://7e61f7f9.m.daocloud.io&quot;],
    &quot;graph&quot;: &quot;/new-path/docker&quot;
}</code></pre><p><strong>System 下创建配置文件</strong></p>
<ul>
<li>在 /etc/systemd/system/docker.service.d 目录下创建一个 Drop-In 文件 docker.conf，默认 docker.service.d 文件夹不存在，必须先创建它。创建 Drop-In 文件的原因，是我们希望 Docker服务使用 docker.conf 文件中提到的特定参数，将默认服务所使用的位于 /lib/systemd/system/docker.service 文件中的参数进行覆盖。</li>
</ul>
<pre><code># 定义新的存储位置
$ sudo vi /etc/systemd/system/docker.service.d/docker.conf
[Service]
ExecStart=/usr/bin/dockerd --graph=&quot;/data/docker&quot; --storage-driver=devicemapper
# 重启
$ sudo systemctl start docker</code></pre><ul>
<li>/data/docker 就是新的存储位置，而 devicemapper 是当前 Docker 所使用的存储驱动。如果你的存储驱动有所不同，请输入之前第一步查看并记下的值。现在，你可以重新加载服务守护程序，并启动 Docker 服务了，这将改变新的镜像和容器的存储位置。为了确认一切顺利，运行 docker info 命令检查 Docker 的根目录。</li>
</ul>
<blockquote>
<p>因为docker pull 太慢所以待到图书馆关门，保安叔叔来赶人</p>
</blockquote>
<h4 id="Docker容器-1"><a href="#Docker容器-1" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>容器是 Docker 又一核心概念。简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<p>本节将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<p><strong>新建并启动容器</strong></p>
<p>所需要的命令主要为 <code>docker run</code>。其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<pre class="line-numbers language-c++"><code class="language-c++">docker run [-i -t -d -p -P -c] [--name]:在容器内运行一个应用程序
 -t :在新容器内指定一个伪终端或终端
 -i:允许你对容器内的标准输入进行交互
 -d：以进程方式运行容器，让容器在后台运行
 -p：设置端口
 -P：将容器内部使用的网络端口映射到我们使用的主机，就是让我们访问我们使用的主机就等同于访问到容器内部
 -c：command,后面接命令
 --name container name：指定容器名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从registry下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p><strong>启动已终止的容器</strong></p>
<p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<p><strong>停止容器</strong></p>
<p>docker stop可以停止运行的容器。理解：容器在docker host中实际上是一个进程，docker stop命令本质上是向该进程发送一个SIGTERM信号。如果想要快速停止容器，可使用docker kill命令，其作用是向容器进程发送SIGKILL信号。</p>
<p><strong>重启容器</strong></p>
<p>对于已经处于停止状态的容器，可以通过docker start重新启动。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker start bdf593fda8be
bdf593fda8be<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>docker start会保留容器的第一次启动时的所有参数。docker restart可以重启容器，其作用就是依次执行docker stop和docker start。容器可能因某种错误而停止运行。对于服务类容器，通常希望它能够自动重启。启动容器时设置–restart就可以达到效果。–restart=always意味着无论容器因何种原因退出（包括正常退出），都立即重启；</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -it ubuntu:15.10 /bin/echo --restart=always -d "Hello world"
--restart=always -d Hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>后台运行容器</strong></p>
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。下面举两个例子来说明一下。</p>
<p><strong>如果不使用 <code>-d</code> 参数运行容器。</strong></p>
<pre><code>$ docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
hello world
hello world
hello world
hello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p><strong>如果使用了 <code>-d</code> 参数运行容器。</strong></p>
<pre><code>$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关，只要命令不结束，容器也就不会退出。上述命令中，while语句不会让bash退出，因此该容器就不会退出。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<pre><code>$ docker container ls
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#39;while tr  2 minutes ago  Up 1 minute        agitated_wright</code></pre><p>使用-d启动容器后，会回到host终端；此时如果想要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker container logs [container ID or NAMES]
hello world
hello world
hello world
. . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>进入容器</strong></p>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台，启动完容器之后会停在host端；某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<p><code>attach</code> 命令</p>
<p>下面示例如何使用 <code>docker attach</code> 命令。</p>
<pre><code>$ docker run -dit ubuntu
243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia

$ docker attach 243c
root@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中exit回到host端，会导致容器的停止。</p>
<p><code>exec</code> 命令</p>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -dit ubuntu
69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles

$ docker exec -i 69d1 bash
ls
bin
boot
dev
...

$ docker exec -it 69d1 bash
root@69d137adef7a:/#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果从这个 stdin 中 exit回到host端，但不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p><strong>attach和exec的区别</strong></p>
<p>attach和exec的区别： （1）attach直接进入容器启动命令的终端，不会启动新的进程； （2）exec则是在容器中打开新的终端，并且可以启动新的进程； （3）如果想直接在终端中查看命令的输出，用attach，其他情况使用exec；</p>
<p><strong>暂停容器</strong></p>
<p>有时我们只是希望让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者docker host需要使用CPU，可以执行:docker pause CONTAINER [CONTAINER…]</p>
<p><strong>删除容器</strong></p>
<p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p>
<pre><code>$ docker container rm trusting_newton
trusting_newton</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<p><strong>清理所有处于终止状态的容器</strong></p>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<pre><code>$ docker container prune</code></pre><p>####批量删除所有已经退出的容器</p>
<pre><code>$ docker rm -v $(docker ps -aq -f status=exited)</code></pre><p><strong>导出容器</strong></p>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test
$ docker export 7691a814370e > ubuntu.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样将导出容器快照到本地文件。</p>
<p><strong>导入容器</strong></p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>cmd试一下用type替代，不行，直接导入，成功</p>
</blockquote>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker import http://example.com/exampleimage.tgz example/imagerepo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h3 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h3><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS (UNIX File System) ，可以提供很多有用的特性：</p>
<blockquote>
<p>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<p><strong>创建数据卷</strong></p>
<pre><code>$ docker volume create datawhale</code></pre><p>查看所有的数据卷</p>
<pre><code>$ docker volume ls</code></pre><p>在主机里使用以下命令可以查看指定数据卷的信息</p>
<pre><code>$ docker volume inspect datawhale</code></pre><p><strong>启动一个挂载数据卷的容器</strong></p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将数据卷挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个数据卷到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<pre><code>$ docker run -d -P \
    --name web \
    --mount source=datawhale,target=/usr/share/nginx/html \
    nginx:alpine</code></pre><blockquote>
<p>–-mount参数说明：<br>source ：数据卷<br>target ：是容器内文件系统挂载点</p>
</blockquote>
<blockquote>
<p>注意，可以不需要提前创建好数据卷，直接在运行容器的时候mount 这时如果不存在指定的数据卷，docker会自动创建，自动生成。</p>
</blockquote>
<p><strong>查看数据卷的具体信息</strong></p>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<pre><code>$ docker inspect web</code></pre><p><strong>删除数据卷</strong></p>
<pre><code>$ docker volume rm datawhale  #datawhale为卷名</code></pre><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<pre><code>$ docker volume prune</code></pre><h4 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h4><p><strong>挂载一个主机目录作为数据卷</strong></p>
<p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -d -P \
    --name web \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \
    nginx:alpine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<blockquote>
<p>注意： 如果挂载的目录不存在，创建容器时，docker 不会自动创建，此时会报错</p>
</blockquote>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -d -P \
    --name web \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \
    nginx:alpine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>源路径不存在，source是本地路径，然后前面启动了一个叫web的容器了，不能再启动</p>
</blockquote>
<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">/usr/share/nginx/html # touch new.txt
touch: new.txt: Read-only file system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>查看数据卷的具体信息</strong></p>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<pre><code>$ docker inspect web</code></pre><p><strong>挂载一个本地主机文件作为数据卷</strong></p>
<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run --rm -it \
   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \
   ubuntu:18.04 \
   bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><h4 id="Docker-基础网络介绍"><a href="#Docker-基础网络介绍" class="headerlink" title="Docker 基础网络介绍"></a>Docker 基础网络介绍</h4><h5 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a><strong>外部访问容器</strong></h5><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过<code>-P</code>或<code>-p</code>参数来指定端口映射。</p>
<p>当使用<code>-P</code>标记时，<code>Docker</code>会随机映射一个端口到内部容器开放的网络端口。 使用<code>docker container ls</code>可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p>
<p>同样的，可以通过<code>docker logs</code>命令来查看访问记录。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker logs [container name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-cmd"><code class="language-cmd">D:\mynginx>docker logs 64a2
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210417091738256.png" alt="成功"></p>
<p><code>-p</code>则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>.</p>
<p><strong>映射所有接口地址</strong></p>
<p>使用<code>hostPort:containerPort</code>格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<pre><code>$ docker run -d -p 80:80 nginx:alpine</code></pre><p>此时默认会绑定本地所有接口上的所有地址。</p>
<p><strong>映射到指定地址的指定端口</strong></p>
<p>可以使用<code>ip:hostPort:containerPort</code>格式指定映射使用一个特定地址，比如<code>localhost</code>地址127.0.0.1</p>
<pre><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code></pre><p><strong>映射到指定地址的任意端口</strong></p>
<p>使用<code>ip::containerPort</code>绑定<code>localhost</code>的任意端口到容器的80端口，本地主机会自动分配一个端口。</p>
<pre><code>$ docker run -d -p 127.0.0.1::80 nginx:alpine</code></pre><p>还可以使用<code>udp</code>标记来指定<code>udp</code>端口</p>
<pre><code>$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</code></pre><p><strong>查看映射端口配置</strong></p>
<p>使用<code>docker port</code>来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre><code>$ docker port fa 80
0.0.0.0:32768</code></pre><p><strong>注意：</strong> 容器有自己的内部网络和 ip 地址（使用<code>docker inspect</code>查看，<code>Docker</code>还可以有一个可变的网络配置。） <code>-p</code>标记可以多次使用来绑定多个端口</p>
<p>例如</p>
<pre><code>$ docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine</code></pre><h5 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a><strong>容器互联</strong></h5><p><strong>新建网络</strong></p>
<p>下面先创建一个新的 <code>Docker</code>网络。</p>
<pre><code>$ docker network create -d bridge my-net</code></pre><p><code>-d</code>参数指定<code>Docker</code>网络类型，有<code>bridge overlay</code>,其中<code>overlay</code>网络类型用于<code>Swarm mode</code>，在本小节中你可以忽略它。</p>
<p><strong>连接容器</strong></p>
<p>运行一个容器并连接到新建的<code>my-net</code>网络</p>
<pre><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code></pre><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code>网络</p>
<pre><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh</code></pre><blockquote>
<p>-rm是退出后删除了容器，所以我要开两个终端</p>
</blockquote>
<p>再打开一个新的终端查看容器信息</p>
<pre><code>$ docker container ls

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox2
8720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</code></pre><blockquote>
<p>能互相ping通证明，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
</blockquote>
<p><code>Docker Compose</code> 如果你有多个容器之间需要互相连接，推荐使用<code>Docker</code>Compose。</p>
<h5 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h5><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是<code>Docker</code>利用<strong>虚拟文件</strong>来挂载容器的 3个相关配置文件。</p>
<p><strong>在容器中</strong>使用 <code>mount</code>命令可以看到挂载信息：</p>
<pre><code>$ mount
/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...
/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...
tmpfs on /etc/resolv.conf type tmpfs ...</code></pre><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有<code>Docker</code>容器的 DNS 配置通过 <code>/etc/resolv.conf</code>文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p>
<pre><code>{
  &quot;dns&quot; : [
    &quot;114.114.114.114&quot;,
    &quot;8.8.8.8&quot;
  ]
}</code></pre><p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和8.8.8.8。使用以下命令来证明其已经生效。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.conf

nameserver 114.114.114.114
nameserver 8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>cat是Linux连接文件并打印到标准输出设备上的命令，win上可以好像用type命令</p>
</blockquote>
<p>如果用户想要<strong>手动指定容器的配置</strong>，可以在使用<code>docker run</code>命令启动容器时加入如下参数： <code>-h HOSTNAME</code>或者<code>--hostname=HOSTNAME</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname 和 /etc/hosts</code>。但它在容器外部看不到，既不会在<code>docker container ls</code>中显示，也不会在其他的容器的<code>/etc/hosts</code>看到。</p>
<p><code>--dns=IP_ADDRESS</code>添加 DNS 服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code>中的主机名。</p>
<p><code>--dns-search=DOMAIN</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS 不仅搜索 <code>host</code>，还会搜索<code>host.example.com</code>。</p>
<blockquote>
<p>关于DNS还有一些不明白</p>
</blockquote>
<p><strong>注意：</strong>如果在容器启动时没有指定最后两个参数，<code>Docker</code>会默认用主机上的<code>/etc/resolv.conf</code>来配置容器。</p>
<h4 id="Docker的网络模式"><a href="#Docker的网络模式" class="headerlink" title="Docker的网络模式"></a>Docker的网络模式</h4><p>可以通过<code>docker network ls</code>查看网络</p>
<p>常见网络的含义：</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>Bridge</td>
<td>为每一个容器分配、设置 IP 等，并将容器连接到一个 <code>docker0</code> 虚拟网桥，默认为该模式。</td>
</tr>
<tr>
<td>Host</td>
<td>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</td>
</tr>
<tr>
<td>None</td>
<td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。</td>
</tr>
<tr>
<td>Container</td>
<td>新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</td>
</tr>
</tbody></table>
<blockquote>
<p>上学期机组课上虚拟机间通网老师让我们看过各种桥接模式，当时没看懂，之后要好好看看计算机网络了，现在先把看不懂的名词记下来</p>
</blockquote>
<p>Bridge 模式</p>
<p>虚拟网桥是什么？网卡？</p>
<p>二层网络？子网分配ip？虚拟网卡两端放在容器和主机？</p>
<p>守护进程？</p>
<p>对于每个容器的 IP 地址和 Gateway 信息，可以通过 <code>docker inspect 容器名称|ID</code> 进行查看</p>
<p>可以通过 <code>docker network inspect bridge</code> 查看所有 <code>bridge</code> 网络模式下的容器，在 <code>Containers</code> 节点中可以看到容器名称</p>
<p>关于 <code>bridge</code> 网络模式的使用，只需要在创建容器时通过参数 <code>--net bridge</code> 或者 <code>--network bridge</code> 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。</p>
<p><code>iptables</code>做了<code>DNAT</code>规则，实现端口转发功能？</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">以使用iptables -t nat -vnL查看。演示：

$ docker run -tid --net=bridge --name docker_bri1 \
            ubuntu-base:v3
            docker run -tid --net=bridge --name docker_bri2 \
            ubuntu-base:v3 

$ brctl show
$ docker exec -ti docker_bri1 /bin/bash
$ ifconfig –a
$ route –n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>还有一些细节不明白，命令完全不明白在干嘛,暂时用不上所以先放放</p>
</blockquote>
<hr>
<p>Host 模式</p>
<p>通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定</p>
<p>可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；</p>
<blockquote>
<p>是不是说我把container扔到服务器上去就可以直接用服务器ip的意思？</p>
</blockquote>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/host.png" alt="看不明白"></p>
<p>不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个<code>Network Namespace</code></p>
<p>None 模式</p>
<p>通过参数 <code>--net none</code> 或者 <code>--network none</code> 指定；</p>
<p>只有 lo 接口 local 的简写，代表 127.0.0.1</p>
<p>localhost 本地环回接口？loopback 网络设备？</p>
<p>需要自己为 <code>Docker</code> 容器添加网卡、配置 IP 等</p>
<p><strong>“少即是多”</strong></p>
<hr>
<p>Container 模式</p>
<p>在创建容器时通过参数 <code>--net container:已运行的容器名称|ID</code> 或者 <code>--network container:已运行的容器名称|ID</code> 指定；</p>
<p>共享一个网络栈？</p>
<p>这样两个容器之间可以使用 localhost 高效快速通信。</p>
<p><strong>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等</strong>。</p>
<h4 id="Docker高级网络配置"><a href="#Docker高级网络配置" class="headerlink" title="Docker高级网络配置"></a>Docker高级网络配置</h4><p><strong>快速配置指南</strong></p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code>定制 <code>docker0</code> 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET... Docker</code> 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 Docker 添加 <code>iptables</code> 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 <code>MTU</code></li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 –publish=SPEC` 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
<p><strong>容器访问控制</strong></p>
<p><code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。机组课上用过。</p>
<p>容器要想<strong>访问外部网络</strong>，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<pre><code>$sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1</code></pre><p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<pre><code>$sysctl -w net.ipv4.ip_forward=1</code></pre><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<p><strong>容器之间相互访问</strong>，需要两方面的支持。</p>
<ul>
<li>容器的<strong>网络拓扑</strong>是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 <code>-- iptables</code> 是否允许通过。</li>
</ul>
<p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条<strong>转发策略</strong>到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p>
<p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来<strong>访问容器的开放端口</strong>。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p>
<p><strong>端口映射实现</strong></p>
<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo iptables -t nat -nL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态<strong>伪装</strong>为从系统网卡发出</p>
<p><strong>端口映射实现</strong></p>
<p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<blockquote>
<p>开放端口</p>
</blockquote>
<p>其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<ul>
<li>永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</li>
</ul>
<pre><code>{
  &quot;ip&quot;: &quot;0.0.0.0&quot;
}</code></pre><p><strong>配置docker0网桥</strong></p>
<p>它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</li>
<li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li>
</ul>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo brctl show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>注</strong>：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<p><strong>自定义网桥</strong></p>
<p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<pre><code>$ sudo systemctl stop docker
$ sudo ip link set dev docker0 down
$ sudo brctl delbr docker0</code></pre><blockquote>
<p>都没法在Windows上实现一遍了</p>
</blockquote>
<p>然后创建一个网桥 <code>bridge0</code>。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo brctl addbr bridge0
$ sudo ip addr add 192.168.5.1/24 dev bridge0
$ sudo ip link set dev bridge0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>查看确认网桥创建并启动。</p>
<p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<pre><code>{
  &quot;bridge&quot;: &quot;bridge0&quot;,
}</code></pre><p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
<hr>
<p><strong>工具和示例</strong></p>
<p>pipework，shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p>
<p>playground，一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p>
<p><strong>编辑网络配置文件</strong></p>
<p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p>
<p>实例：<strong>创建一个点到点连接</strong></p>
<p>首先启动 2 个容器：</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -i -t --rm --net=none base /bin/bash
root@1f1f4c1f931a:/#
$ docker run -i -t --rm --net=none base /bin/bash
root@12e343489d2f:/#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在两个终端启动吗？</p>
</blockquote>
<p>找到进程号，然后创建网络命名空间的<strong>跟踪文件</strong>。</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ docker inspect -f '{{.State.Pid}}' 1f1f4c1f931a
2989
$ docker inspect -f '{{.State.Pid}}' 12e343489d2f
3004
$ sudo mkdir -p /var/run/netns
$ sudo ln -s /proc/2989/ns/net /var/run/netns/2989
$ sudo ln -s /proc/3004/ns/net /var/run/netns/3004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>绿色的是端口号？ln用于硬连接 ln -s软连接？什么是创建接口？</p>
</blockquote>
<p>创建一对 <code>peer</code> 接口，然后配置路由</p>
<pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo ip link add A type veth peer name B

$ sudo ip link set A netns 2989
$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A
$ sudo ip netns exec 2989 ip link set A up
$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A

$ sudo ip link set B netns 3004
$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B
$ sudo ip netns exec 3004 ip link set B up
$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p>
<blockquote>
<p>后面完全是因为基本功没到位看不懂了</p>
</blockquote>
<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>先手资料</p>
<hr>
<p><a href="https://vuepress.mirror.docker-practice.com/compose/install/" target="_blank" rel="noopener">docker compose安装与卸载</a></p>
<p><strong><a href="https://github.com/docker/awesome-compose" target="_blank" rel="noopener">awesome-compose</a></strong>这个项目也非常推荐。</p>
<blockquote>
<p>推荐大家多看看一些项目的docker-compose.yml文件是怎么写的，慢慢模仿着去写很多就越来越熟练清晰了。</p>
</blockquote>
<p><strong>什么是</strong>docker compose</p>
<p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p>
<p><strong>如何使用</strong>docker compose</p>
<p>在<code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个<strong>应用的容器</strong>，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个<strong>完整业务单元</strong>，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><strong>web应用</strong></p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><strong>启动服务</strong></p>
<pre><code>docker-compose up</code></pre><p>命令后会自动接一个默认值<code>-f docker-compose.yml</code>，也就是默认是使用docker-compose.yml文件的。我们也可以给文件起名为<code>docke-test.yml</code>，这样在使用时指定文件名，但是为了符合规范，还是统一为<code>docker-compose.yml</code>。</p>
<pre><code>docker-compose up -f docer-test.yml</code></pre><p>-d参数让启动时的输出不会打印到终端</p>
<p><strong>查看服务状态</strong></p>
<pre><code>docker-compose ps</code></pre><p>要是想要查看所有service的状态可以使用-a参数</p>
<p><strong>停止或删除服务</strong></p>
<pre><code>docker-compose stop
docker-compose down</code></pre><p>其中stop是直接停止services，而down则会停止并删除创建的service，volume和network。</p>
<p><strong>进入服务</strong></p>
<pre><code>docker-compose exec mysql bash</code></pre><p><strong>查看服务输出日志</strong></p>
<pre><code>docker-compose logs</code></pre><hr>
<p>Compose<strong>模板文件</strong></p>
<p><em><a href="https://vuepress.mirror.docker-practice.com/compose/compose_file/#cap-add-cap-drop" target="_blank" rel="noopener">Compose模板文件</a></em></p>
<p>文件格式为 YAML 格式。</p>
<pre class="line-numbers language-yml"><code class="language-yml">version: "3"

services:
  webapp:
    image: examples/web
    ports:
      - "80:80"
    volumes:
      - "/data"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p><strong>build</strong></p>
<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<p><code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<p>使用 <code>cache_from</code> 指定构建镜像的缓存。</p>
<p><strong>depends_on</strong></p>
<p>解决容器的依赖、启动先后的问题。</p>
<p><strong>environment</strong></p>
<p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔 (opens new window)</a>含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<pre><code>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</code></pre><p><strong>expose</strong></p>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数</p>
<p><strong>ports</strong></p>
<p>暴露端口信息。使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<p><strong>secrets</strong>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<p><strong>image</strong>指定为镜像名称或镜像 ID。</p>
<p><strong>labels</strong>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<p><strong>network_mode</strong>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<p><strong>networks</strong>配置容器连接的网络。</p>
<p><strong>volumes</strong></p>
<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。该指令中路径支持相对路径。</p>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<hr>
<p>Compose<strong>命令</strong></p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<pre><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre><ul>
<li><code>f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td>build</td>
<td align="center">格式为 <code>docker-compose build [options] [SERVICE...]</code>。构建（重新构建）项目中的服务容器。</td>
</tr>
<tr>
<td>config</td>
<td align="center">验证 Compose 文件格式是否正确</td>
</tr>
<tr>
<td>down</td>
<td align="center">此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</td>
</tr>
<tr>
<td>exec</td>
<td align="center">进入指定的容器。</td>
</tr>
<tr>
<td>help</td>
<td align="center">帮助</td>
</tr>
<tr>
<td>image</td>
<td align="center">列出 Compose 文件中包含的镜像</td>
</tr>
<tr>
<td>kill</td>
<td align="center">格式为 <code>docker-compose kill [options] [SERVICE...]</code>。通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。支持通过 <code>-s</code> 参数来指定发送的信号</td>
</tr>
<tr>
<td>logs</td>
<td align="center">查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。该命令在调试问题的时候十分有用。</td>
</tr>
<tr>
<td>pause</td>
<td align="center">暂停一个服务容器。</td>
</tr>
<tr>
<td>port</td>
<td align="center">打印某个容器端口所映射的公共端口。</td>
</tr>
<tr>
<td>ps</td>
<td align="center">列出项目中目前的所有容器。</td>
</tr>
<tr>
<td>pull</td>
<td align="center">拉取服务依赖的镜像。–ignore-pull-failures忽略拉取镜像过程中的错误。</td>
</tr>
<tr>
<td>push</td>
<td align="center">推送服务</td>
</tr>
<tr>
<td>restart</td>
<td align="center">重启项目中的服务。</td>
</tr>
<tr>
<td>rm</td>
<td align="center">删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。<code>-f, --force</code> 强制直接删除 -v删除容器所挂载的数据卷</td>
</tr>
<tr>
<td>start</td>
<td align="center">启动</td>
</tr>
<tr>
<td>stop</td>
<td align="center">停止已经处于运行状态的容器，但不删除它</td>
</tr>
<tr>
<td>top</td>
<td align="center">查看各个服务容器内运行的进程</td>
</tr>
<tr>
<td>unpause</td>
<td align="center">恢复处于暂停状态中的服务</td>
</tr>
<tr>
<td>up</td>
<td align="center">尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。<code>-d</code>，将会在后台启动并运行所有的容器</td>
</tr>
</tbody></table>
<p>up选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<hr>
<p><strong>扩缩容</strong></p>
<pre><code>docker-compose up --scale web=3 -d</code></pre><blockquote>
<p>理想情况下这三个web会同时对外提供服务，以减轻访问单个容器的压力。但是我们在上面也看到了因为大家都是绑定的5000端口，这样端口就冲突了，导致新创建的两个web服务都是Exit的状态，对于这个问题我们可以通过HAProxy来解决。</p>
</blockquote>
<p>HAProxy？等我学完网络再来看能不能PR好了</p>
<h3 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a>综合实践</h3><h4 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h4><p>看github上的教程没搞懂这次打卡具体要做什么，如果自己写dockfile估计时间不够了，所以参照阮一峰的docker实战尝试在服务器上做点东西出来好了。</p>
<p>在服务器上装docker，见参考资料</p>
<p>首先还要更新一下yum，遇到点小问题，csdn解决。</p>
<p><a href="https://blog.csdn.net/haohaoxuexiyai/article/details/111027692" target="_blank" rel="noopener">yum更新失败：rpmdb: BDB0113 Thread/process 2673/140126198814528 failed: BDB1507 Thread died…</a></p>
<p>服务器一边还在进行一些其他任务，所以在本地同时开工。</p>
<p>由于时间关系这次就不自建WordPress容器了，直接采取最简单的方法，使用官方提供的容器。</p>
<p>首先，新建并启动 MySQL 容器。</p>
<blockquote>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container run \
  -d \
  --rm \
  --name wordpressdb \
  --env MYSQL_ROOT_PASSWORD<span class="token operator">=</span>123456 \
  --env MYSQL_DATABASE<span class="token operator">=</span>wordpress \
  mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p>
<blockquote>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container run \
  -d \
  --rm \
  --name wordpress \
  --env WORDPRESS_DB_PASSWORD<span class="token operator">=</span>123456 \
  --link wordpressdb:mysql \
  wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p>
<p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p>
<blockquote>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container inspect wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。</p>
<p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p>
<p>然而我打不开<code>172.17.0.3</code>，不知道是不是打开方式不对。</p>
<p>到了上一步，官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p>
<blockquote>
<ul>
<li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li>
<li>WordPress 安装在容器里面，本地无法修改文件。</li>
</ul>
</blockquote>
<p>解决这两个问题很容易，只要新建容器的时候，加两个命令行参数就可以了。</p>
<p>先把刚才启动的 WordPress 容器终止（容器文件会自动删除）。</p>
<blockquote>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<p>然后，使用下面的命令新建并启动 WordPress 容器。</p>
<blockquote>
<pre class="line-numbers language-bash"><code class="language-bash"> $ docker container run \
  -d \
  -p 127.0.0.2:8080:80 \
  --rm \
  --name wordpress \
  --env WORDPRESS_DB_PASSWORD<span class="token operator">=</span>123456 \
  --link wordpressdb:mysql \
  --volume <span class="token string">"<span class="token variable">$PWD</span>/wordpress"</span>:/var/www/html \
  wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>上面的命令跟前面相比，命令行参数只多出了两个。</p>
<blockquote>
<ul>
<li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li>
<li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li>
</ul>
</blockquote>
<p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p>
<p>最后，终止这两个容器（容器文件会自动删除）。</p>
<blockquote>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop wordpress wordpressdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<h4 id="第一次实际实用docker"><a href="#第一次实际实用docker" class="headerlink" title="第一次实际实用docker"></a><strong>第一次实际实用docker</strong></h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/1836012?qq-pf-to=pcqq.group" target="_blank" rel="noopener">教你用AI Studio+wechaty+阿里云白嫖一个智能微信机器人</a></p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰的docker教程</a></p>
<p><a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener">Docker 从入门到实践</a></p>
<p><a href="https://github.com/datawhalechina/team-learning-program/tree/master/Docker" target="_blank" rel="noopener">github组队学习</a></p>
<p><a href="https://blog.csdn.net/zzq060143/article/details/91050272?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">Windows上docker使用教程</a></p>
<p><a href="https://www.cnblogs.com/linjj/p/5606911.html" target="_blank" rel="noopener">Windows创建自己的镜像</a></p>
<p>关于安装问题</p>
<p><a href="https://blog.csdn.net/LFxiaosu/article/details/112214780" target="_blank" rel="noopener">docker的安装及卸载不干净造成的问题</a></p>
<p><a href="https://blog.csdn.net/lazy_ting/article/details/106375737" target="_blank" rel="noopener">乌班图配网</a></p>
<p>关于服务器装docker</p>
<p><a href="https://cloud.tencent.com/document/product/213/46000#.E5.AE.89.E8.A3.85-docker" target="_blank" rel="noopener">我用的腾讯云centos7</a></p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《docker2021》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/04/17/docker2021/" property="cc:attributionName"
               rel="cc:attributionURL">
                Henry-Avery
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'bcac118c07efd37bb7c3',
        clientSecret: '59ace8a6f5bc3daffc7aa090f2f8e93c971668e8',
        repo: 'Blogtalk',
        owner: 'henry-avery',
        admin: "henry-avery",
        id: '2021/04/17/docker2021/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/04/17/deeplearning/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/28.jpg" class="responsive-img" alt="关于神经网络与深度学习">
                        
                        <span class="card-title">关于神经网络与深度学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            先开好坑，估摸着暑假前整完
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/学习笔记/" class="post-category" target="_blank">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/DL/" target="_blank">
                        <span class="chip bg-color">DL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/04/11/ying-yu-xue-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="英语学习">
                        
                        <span class="card-title">英语学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            2021的英语学习计划
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/外语学习/" class="post-category" target="_blank">
                                    外语学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/英语/" target="_blank">
                        <span class="chip bg-color">英语</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 小天爷的博客<br />'
            + '作者: Henry-Avery<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2020 Henry-Avery. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">113.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/henry-avery" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>







    <a href="http://wpa.qq.com/msgrd?v=3&uin=849095098&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 1;
        var uvcountOffset = 1;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 07, 30, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        /*document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
        document.getElementById("sitetime").innerHTML = "本站已运行 " +  diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>