<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="关于神经网络与深度学习, SHU19级小天爷( •̀ ω •́ )y">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="
小时候，每个人都会鼓励不断成长
变成一个心智成熟，不在耍小孩子脾气的人
但是，很少有人鼓励继续成长
变成一个怀疑和抵制社会错误潮流的人
——保罗•格雷厄姆《黑客与画家》

目录[TOC]
参考资料课程
b站[中英字幕]吴恩达机器学习系列课">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>关于神经网络与深度学习 | 小天爷的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小天爷的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小天爷的博客</div>
        <div class="logo-desc">
            
            商才士魂
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/25.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        关于神经网络与深度学习
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/DL/" target="_blank">
                            <span class="chip bg-color">DL</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/学习笔记/" class="post-category" target="_blank">
                            学习笔记
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-06-25
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    Henry-Avery
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    51k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    184 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>小时候，每个人都会鼓励不断成长</p>
<p>变成一个心智成熟，不在耍小孩子脾气的人</p>
<p>但是，<strong>很少有人鼓励继续成长</strong></p>
<p><strong>变成一个怀疑和抵制社会错误潮流的人</strong></p>
<p>——保罗•格雷厄姆《黑客与画家》</p>
</blockquote>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong>课程</strong></p>
<p><a href="https://www.bilibili.com/video/BV164411b7dx?p=1" target="_blank" rel="noopener">b站[中英字幕]吴恩达机器学习系列课程</a></p>
<p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习</a></p>
<p><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera深度学习</a></p>
<blockquote>
<p>主成分数据选择那里有一节课没有字幕，建议移步Coursera</p>
</blockquote>
<p><strong>黄海广笔记</strong></p>
<p><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener"><strong>Coursera深度学习教程中文笔记</strong></a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>斯坦福大学2014（吴恩达）机器学习教程中文笔记</strong></a></p>
<p><strong>其他</strong></p>
<p><a href="https://henryavery.cn/2021/01/25/ml/">我的机器学习笔记</a></p>
<p><a href="https://nndl.github.io/" target="_blank" rel="noopener">神经网络与深度学习邱席鹏</a></p>
<blockquote>
<p>27个小时，集中时间的话三天左右看完。估计分散在一周时间内吧。</p>
</blockquote>
<iframe src="//player.bilibili.com/player.html?aid=926316362&bvid=BV1FT4y1E74V&cid=216510190&page=183" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h1 id="第一门课-神经网络和深度学习-Neural-Networks-and-Deep-Learning"><a href="#第一门课-神经网络和深度学习-Neural-Networks-and-Deep-Learning" class="headerlink" title="第一门课 神经网络和深度学习(Neural Networks and Deep Learning)"></a>第一门课 神经网络和深度学习(Neural Networks and Deep Learning)</h1><h2 id="第一周：深度学习引言-Introduction-to-Deep-Learning"><a href="#第一周：深度学习引言-Introduction-to-Deep-Learning" class="headerlink" title="第一周：深度学习引言(Introduction to Deep Learning)"></a><strong>第一周：深度学习引言(Introduction to Deep Learning)</strong></h2><h2 id="第二周：神经网络的编程基础-Basics-of-Neural-Network-programming"><a href="#第二周：神经网络的编程基础-Basics-of-Neural-Network-programming" class="headerlink" title="第二周：神经网络的编程基础(Basics of Neural Network programming)"></a>第二周：神经网络的编程基础(Basics of Neural Network programming)</h2><h3 id="2-1-二分类-Binary-Classification"><a href="#2-1-二分类-Binary-Classification" class="headerlink" title="2.1 二分类(Binary Classification)"></a><strong>2.1 二分类(Binary Classification)</strong></h3><h3 id="2-2-逻辑回归-Logistic-Regression"><a href="#2-2-逻辑回归-Logistic-Regression" class="headerlink" title="2.2 逻辑回归(Logistic Regression)"></a><strong>2.2 逻辑回归(Logistic Regression)</strong></h3><h3 id="2-3-逻辑回归的代价函数（Logistic-Regress）"><a href="#2-3-逻辑回归的代价函数（Logistic-Regress）" class="headerlink" title="2.3 逻辑回归的代价函数（Logistic Regress）"></a><strong>2.3 逻辑回归的代价函数（Logistic Regress）</strong></h3><p>损失函数又叫做误差函数，用来衡量算法的运行情况，Loss function</p>
<p>练样本中表现如何，为了衡量算法在全部训练样本上的表现如何，我们需要定义一个算法的代价函数cost function</p>
<h3 id="2-4-梯度下降法（Gradient-Descent）"><a href="#2-4-梯度下降法（Gradient-Descent）" class="headerlink" title="2.4 梯度下降法（Gradient Descent）"></a><strong>2.4 梯度下降法（Gradient Descent）</strong></h3><h3 id="2-9-逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）"><a href="#2-9-逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）" class="headerlink" title="2.9 逻辑回归中的梯度下降（Logistic Regression Gradient Descent）"></a><strong>2.9 逻辑回归中的梯度下降（Logistic Regression Gradient Descent）</strong></h3><h3 id="2-10-m-个样本的梯度下降-Gradient-Descent-on-m-Examples"><a href="#2-10-m-个样本的梯度下降-Gradient-Descent-on-m-Examples" class="headerlink" title="2.10  m 个样本的梯度下降(Gradient Descent on m Examples)"></a><strong>2.10  m 个样本的梯度下降(Gradient Descent on m Examples)</strong></h3><h3 id="2-11-向量化-Vectorization"><a href="#2-11-向量化-Vectorization" class="headerlink" title="2.11 向量化(Vectorization)"></a><strong>2.11 向量化(Vectorization)</strong></h3><h3 id="2-13-向量化逻辑回归-Vectorizing-Logistic-Regression"><a href="#2-13-向量化逻辑回归-Vectorizing-Logistic-Regression" class="headerlink" title="2.13 向量化逻辑回归(Vectorizing Logistic Regression)"></a><strong>2.13 向量化逻辑回归(Vectorizing Logistic Regression)</strong></h3><h3 id="2-14-向量化-logistic-回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）"><a href="#2-14-向量化-logistic-回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）" class="headerlink" title="2.14 向量化 logistic 回归的梯度输出（Vectorizing Logistic Regression’s Gradient）"></a><strong>2.14 向量化 logistic 回归的梯度输出（Vectorizing Logistic Regression’s Gradient）</strong></h3><h2 id="第三周：浅层神经网络-Shallow-neural-networks"><a href="#第三周：浅层神经网络-Shallow-neural-networks" class="headerlink" title="第三周：浅层神经网络(Shallow neural networks)"></a>第三周：浅层神经网络(Shallow neural networks)</h2><h3 id="3-1-神经网络概述（Neural-Network-Overview）"><a href="#3-1-神经网络概述（Neural-Network-Overview）" class="headerlink" title="3.1 神经网络概述（Neural Network Overview）"></a><strong>3.1 神经网络概述（Neural Network Overview）</strong></h3><h3 id="3-2-神经网络的表示（Neural-Network-Representation）"><a href="#3-2-神经网络的表示（Neural-Network-Representation）" class="headerlink" title="3.2 神经网络的表示（Neural Network Representation）"></a><strong>3.2 神经网络的表示（Neural Network Representation）</strong></h3><h3 id="3-3-计算一个神经网络的输出（Computing-a-Neural-Network’s-output）"><a href="#3-3-计算一个神经网络的输出（Computing-a-Neural-Network’s-output）" class="headerlink" title="3.3 计算一个神经网络的输出（Computing a Neural Network’s output）"></a><strong>3.3 计算一个神经网络的输出（Computing a Neural Network’s output）</strong></h3><h3 id="3-4-多样本向量化（Vectorizing-across-multiple-examples）"><a href="#3-4-多样本向量化（Vectorizing-across-multiple-examples）" class="headerlink" title="3.4 多样本向量化（Vectorizing across multiple examples）"></a><strong>3.4 多样本向量化（Vectorizing across multiple examples）</strong></h3><h3 id="3-5-向量化实现的解释（Justification-for-vectorized-implementation）"><a href="#3-5-向量化实现的解释（Justification-for-vectorized-implementation）" class="headerlink" title="3.5 向量化实现的解释（Justification for vectorized implementation）"></a><strong>3.5 向量化实现的解释（Justification for vectorized implementation）</strong></h3><h3 id="3-6-激活函数（Activation-functions）"><a href="#3-6-激活函数（Activation-functions）" class="headerlink" title="3.6 激活函数（Activation functions）"></a><strong>3.6 激活函数（Activation functions）</strong></h3><p><strong>tanh</strong>函数或者双曲正切函数是总体上都优于<strong>sigmoid</strong>函数的激活函数。</p>
<p><strong>sigmoid</strong>函数和<strong>tanh</strong>函数两者共同的缺点是，在$z$特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于0，导致降低梯度下降的速度。</p>
<p>在机器学习另一个很流行的函数是：修正线性单元的函数（<strong>ReLu</strong>）</p>
<p>如果输出是0、1值（二分类问题），则输出层选择<strong>sigmoid</strong>函数，然后其它的所有单元都选择<strong>Relu</strong>函数。</p>
<p>这是很多激活函数的默认选择，如果在隐藏层上不确定使用哪个激活函数，那么通常会使用<strong>Relu</strong>激活函数。有时，也会使用<strong>tanh</strong>激活函数，但<strong>Relu</strong>的一个优点是：当$z$是负值的时候，导数等于0。</p>
<p>这里也有另一个版本的<strong>Relu</strong>被称为<strong>Leaky Relu</strong>。</p>
<p>当$z$是负值时，这个函数的值不是等于0，而是轻微的倾斜。</p>
<p>如图。（图在心中）</p>
<p>两者的优点是：</p>
<p>第一，在$z$的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个<strong>if-else</strong>语句，而<strong>sigmoid</strong>函数需要进行浮点四则运算，在实践中，使用<strong>ReLu</strong>激活函数神经网络通常会比使用<strong>sigmoid</strong>或者<strong>tanh</strong>激活函数学习的更快。</p>
<p>第二，<strong>sigmoid</strong>和<strong>tanh</strong>函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而<strong>Relu</strong>和<strong>Leaky ReLu</strong>函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，<strong>Relu</strong>进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而<strong>Leaky ReLu</strong>不会有这问题)</p>
<p>$z$在<strong>ReLu</strong>的梯度一半都是0，但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。</p>
<p>快速概括一下不同激活函数的过程和结论。</p>
<p><strong>sigmoid</strong>激活函数：除了输出层是一个二分类问题基本不会用它。</p>
<p><strong>tanh</strong>激活函数：<strong>tanh</strong>是非常优秀的，几乎适合所有场合。</p>
<p><strong>ReLu</strong>激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用<strong>ReLu</strong>或者<strong>Leaky ReLu</strong>。</p>
<h3 id="3-7-为什么需要非线性激活函数？（why-need-a-nonlinear-activation-function-）"><a href="#3-7-为什么需要非线性激活函数？（why-need-a-nonlinear-activation-function-）" class="headerlink" title="3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?）"></a><strong>3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?）</strong></h3><h3 id="3-8-激活函数的导数（Derivatives-of-activation-functions）"><a href="#3-8-激活函数的导数（Derivatives-of-activation-functions）" class="headerlink" title="3.8 激活函数的导数（Derivatives of activation functions）"></a><strong>3.8 激活函数的导数（Derivatives of activation functions）</strong></h3><h3 id="3-9-神经网络的梯度下降（Gradient-descent-for-neural-networks）"><a href="#3-9-神经网络的梯度下降（Gradient-descent-for-neural-networks）" class="headerlink" title="3.9 神经网络的梯度下降（Gradient descent for neural networks）"></a><strong>3.9 神经网络的梯度下降（Gradient descent for neural networks）</strong></h3><h3 id="3-10（选修）直观理解反向传播（Backpropagation-intuition）"><a href="#3-10（选修）直观理解反向传播（Backpropagation-intuition）" class="headerlink" title="3.10（选修）直观理解反向传播（Backpropagation intuition）"></a><strong>3.10（选修）直观理解反向传播（Backpropagation intuition）</strong></h3><p>看懂逻辑回归就清楚了，主要是梯度下降用到loss function对某参数的导数来更新，求导就是链式法则，神经网络就是矩阵求导。</p>
<h3 id="3-11-随机初始化（Random-Initialization）"><a href="#3-11-随机初始化（Random-Initialization）" class="headerlink" title="3.11 随机初始化（Random+Initialization）"></a><strong>3.11 随机初始化（Random+Initialization）</strong></h3><p>如果$W$很大，$z$就会很大或者很小，因此这种情况下你很可能停在<strong>tanh</strong>/<strong>sigmoid</strong>函数的平坦的地方(见图3.8.2)，这些地方梯度很小也就意味着梯度下降会很慢，因此学习也就很慢。</p>
<p>事实上有时有比0.01更好的常数，当你训练一个只有一层隐藏层的网络时（这是相对浅的神经网络，没有太多的隐藏层），设为0.01可能也可以。但当你训练一个非常非常深的神经网络，你可能要试试0.01以外的常数。下一节课我们会讨论怎么并且何时去选择一个不同于0.01的常数，但是无论如何它通常都会是个相对小的数。</p>
<h2 id="第四周：深层神经网络-Deep-Neural-Networks"><a href="#第四周：深层神经网络-Deep-Neural-Networks" class="headerlink" title="第四周：深层神经网络(Deep Neural Networks)"></a>第四周：深层神经网络(Deep Neural Networks)</h2><h3 id="4-1-深层神经网络（Deep-L-layer-neural-network）"><a href="#4-1-深层神经网络（Deep-L-layer-neural-network）" class="headerlink" title="4.1 深层神经网络（Deep L-layer neural network）"></a>4.1 深层神经网络（Deep L-layer neural network）</h3><h3 id="4-2-前向传播和反向传播（Forward-and-backward-propagation）"><a href="#4-2-前向传播和反向传播（Forward-and-backward-propagation）" class="headerlink" title="4.2 前向传播和反向传播（Forward and backward propagation）"></a>4.2 前向传播和反向传播（Forward and backward propagation）</h3><h3 id="4-3-深层网络中的前向传播（Forward-propagation-in-a-Deep-Network）"><a href="#4-3-深层网络中的前向传播（Forward-propagation-in-a-Deep-Network）" class="headerlink" title="4.3 深层网络中的前向传播（Forward propagation in a Deep Network）"></a>4.3 深层网络中的前向传播（Forward propagation in a Deep Network）</h3><h3 id="4-4-核对矩阵的维数（Getting-your-matrix-dimensions-right）"><a href="#4-4-核对矩阵的维数（Getting-your-matrix-dimensions-right）" class="headerlink" title="4.4 核对矩阵的维数（Getting your matrix dimensions right）"></a>4.4 核对矩阵的维数（Getting your matrix dimensions right）</h3><h3 id="4-5-为什么使用深层表示？（Why-deep-representations-）"><a href="#4-5-为什么使用深层表示？（Why-deep-representations-）" class="headerlink" title="4.5 为什么使用深层表示？（Why deep representations?）"></a>4.5 为什么使用深层表示？（Why deep representations?）</h3><h3 id="4-6-搭建神经网络块（Building-blocks-of-deep-neural-networks）"><a href="#4-6-搭建神经网络块（Building-blocks-of-deep-neural-networks）" class="headerlink" title="4.6 搭建神经网络块（Building blocks of deep neural networks）"></a>4.6 搭建神经网络块（Building blocks of deep neural networks）</h3><h3 id="4-7-参数VS超参数（Parameters-vs-Hyperparameters）"><a href="#4-7-参数VS超参数（Parameters-vs-Hyperparameters）" class="headerlink" title="4.7 参数VS超参数（Parameters vs Hyperparameters）"></a>4.7 参数VS超参数（Parameters vs Hyperparameters）</h3><h3 id="4-8-深度学习和大脑的关联性（What-does-this-have-to-do-with-the-brain-）"><a href="#4-8-深度学习和大脑的关联性（What-does-this-have-to-do-with-the-brain-）" class="headerlink" title="4.8 深度学习和大脑的关联性（What does this have to do with the brain?）"></a>4.8 深度学习和大脑的关联性（What does this have to do with the brain?）</h3><h1 id="第二门课-改善深层神经网络：超参数调试、正则化以及优化-Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization"><a href="#第二门课-改善深层神经网络：超参数调试、正则化以及优化-Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization" class="headerlink" title="第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)"></a>第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)</h1><h2 id="第一周：深度学习的实践层面-Practical-aspects-of-Deep-Learning"><a href="#第一周：深度学习的实践层面-Practical-aspects-of-Deep-Learning" class="headerlink" title="第一周：深度学习的实践层面(Practical aspects of Deep Learning)"></a>第一周：深度学习的实践层面(Practical aspects of Deep Learning)</h2><h3 id="1-1-训练，验证，测试集（Train-Dev-Test-sets）"><a href="#1-1-训练，验证，测试集（Train-Dev-Test-sets）" class="headerlink" title="1.1 训练，验证，测试集（Train / Dev / Test sets）"></a>1.1 训练，验证，测试集（Train / Dev / Test sets）</h3><p>比如我们有100万条数据，那么取1万条数据便足以进行评估，找出其中表现最好的1-2种算法。同样地，根据最终选择的分类器，测试集的主要目的是正确评估分类器的性能，所以，如果拥有百万数据，我们只需要1000条数据，便足以评估单个分类器，并且准确评估该分类器的性能。假设我们有100万条数据，其中1万条作为验证集，1万条作为测试集，100万里取1万，比例是1%，即：训练集占98%，验证集和测试集各占1%。对于数据量过百万的应用，训练集可以占到99.5%，验证和测试集各占0.25%，或者验证集占0.4%，测试集占0.1%。</p>
<p>根据经验，我建议大家要确保验证集和测试集的数据来自<strong>同一分布</strong>，关于这个问题我也会多讲一些。因为你们要用验证集来评估不同的模型，尽可能地优化性能。如果验证集和测试集来自同一个分布就会很好。</p>
<h3 id="1-2-偏差，方差（Bias-Variance）"><a href="#1-2-偏差，方差（Bias-Variance）" class="headerlink" title="1.2 偏差，方差（Bias /Variance）"></a>1.2 偏差，方差（Bias /Variance）</h3><p>高偏差（<strong>high bias</strong>）的情况，我们称为“欠拟合”（<strong>underfitting</strong>）。</p>
<p>方差较高（<strong>high variance</strong>），数据过度拟合（<strong>overfitting</strong>）。</p>
<p>理解偏差和方差的两个关键数据是训练集误差（<strong>Train set error</strong>）和验证集误差（<strong>Dev set error</strong>）</p>
<p>假定训练集误差是1%，为了方便论证，假定验证集误差是11%，可以看出训练集设置得非常好，而验证集设置相对较差，我们可能过度拟合了训练集，在某种程度上，验证集并没有充分利用交叉验证集的作用，像这种情况，我们称之为“高方差”。</p>
<p>通过查看训练集误差和验证集误差，我们便可以诊断算法是否具有高方差。也就是说衡量训练集和验证集误差就可以得出不同结论。</p>
<p>假设训练集误差是15%，我们把训练集误差写在首行，验证集误差是16%，假设该案例中人的错误率几乎为0%，人们浏览这些图片，分辨出是不是猫。算法并没有在训练集中得到很好训练，如果训练数据的拟合度不高，就是数据欠拟合，就可以说这种算法偏差比较高。相反，它对于验证集产生的结果却是合理的，验证集中的错误率只比训练集的多了1%，所以这种算法偏差高，因为它甚至不能拟合训练集</p>
<p>再举一个例子，训练集误差是15%，偏差相当高，但是，验证集的评估结果更糟糕，错误率达到30%，在这种情况下，我会认为这种算法偏差高，因为它在训练集上结果不理想，而且方差也很高，这是方差偏差都很糟糕的情况。</p>
<h3 id="1-3-机器学习基础（Basic-Recipe-for-Machine-Learning）"><a href="#1-3-机器学习基础（Basic-Recipe-for-Machine-Learning）" class="headerlink" title="1.3 机器学习基础（Basic Recipe for Machine Learning）"></a>1.3 机器学习基础（Basic Recipe for Machine Learning）</h3><h3 id="1-4-正则化（Regularization）"><a href="#1-4-正则化（Regularization）" class="headerlink" title="1.4 正则化（Regularization）"></a>1.4 正则化（Regularization）</h3><p>深度学习可能存在过拟合问题——高方差，有两个解决方法，<strong>一个是正则化，另一个是准备更多的数据</strong>，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。</p>
<blockquote>
<p>今天上午起晚了，进度拖慢了，然后又改了一手cnn模型的代码。明天上午再看。今天晚上休息一会。</p>
</blockquote>
<h3 id="1-5-为什么正则化有利于预防过拟合呢？（Why-regularization-reduces-overfitting-）"><a href="#1-5-为什么正则化有利于预防过拟合呢？（Why-regularization-reduces-overfitting-）" class="headerlink" title="1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）"></a>1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）</h3><h3 id="1-6-dropout-正则化（Dropout-Regularization）"><a href="#1-6-dropout-正则化（Dropout-Regularization）" class="headerlink" title="1.6 dropout 正则化（Dropout Regularization）"></a>1.6 dropout 正则化（Dropout Regularization）</h3><p>除了$L2$正则化，还有一个非常实用的正则化方法——“<strong>Dropout</strong>（随机失活）”</p>
<h3 id="1-7-理解-dropout（Understanding-Dropout）"><a href="#1-7-理解-dropout（Understanding-Dropout）" class="headerlink" title="1.7 理解 dropout（Understanding Dropout）"></a>1.7 理解 dropout（Understanding Dropout）</h3><p><strong>Dropout</strong>可以随机删除网络中的神经单元，他为什么可以通过正则化发挥如此大的作用呢？</p>
<p>直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，通过传播所有权重，<strong>dropout</strong>将产生收缩权重的平方范数的效果，和之前讲的$L2$正则化类似；实施<strong>dropout</strong>的结果实它会压缩权重，并完成一些预防过拟合的外层正则化；$L2$对不同权重的衰减是不同的，它取决于激活函数倍增的大小。</p>
<h3 id="1-8-其他正则化方法（Other-regularization-methods）"><a href="#1-8-其他正则化方法（Other-regularization-methods）" class="headerlink" title="1.8 其他正则化方法（Other regularization methods）"></a>1.8 其他正则化方法（Other regularization methods）</h3><h3 id="1-9-归一化输入（Normalizing-inputs）"><a href="#1-9-归一化输入（Normalizing-inputs）" class="headerlink" title="1.9 归一化输入（Normalizing inputs）"></a>1.9 归一化输入（Normalizing inputs）</h3><h3 id="1-10-梯度消失-梯度爆炸（Vanishing-Exploding-gradients）"><a href="#1-10-梯度消失-梯度爆炸（Vanishing-Exploding-gradients）" class="headerlink" title="1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）"></a>1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）</h3><h3 id="1-11-神经网络的权重初始化（Weight-Initialization-for-Deep-NetworksVanishing-Exploding-gradients）"><a href="#1-11-神经网络的权重初始化（Weight-Initialization-for-Deep-NetworksVanishing-Exploding-gradients）" class="headerlink" title="1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing / Exploding gradients）"></a>1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing / Exploding gradients）</h3><h3 id="1-12-梯度的数值逼近（Numerical-approximation-of-gradients）"><a href="#1-12-梯度的数值逼近（Numerical-approximation-of-gradients）" class="headerlink" title="1.12 梯度的数值逼近（Numerical approximation of gradients）"></a>1.12 梯度的数值逼近（Numerical approximation of gradients）</h3><h3 id="1-13-梯度检验（Gradient-checking）"><a href="#1-13-梯度检验（Gradient-checking）" class="headerlink" title="1.13 梯度检验（Gradient checking）"></a>1.13 梯度检验（Gradient checking）</h3><h3 id="1-14-梯度检验应用的注意事项（Gradient-Checking-Implementation-Notes）"><a href="#1-14-梯度检验应用的注意事项（Gradient-Checking-Implementation-Notes）" class="headerlink" title="1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes）"></a>1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes）</h3><h2 id="第二周：优化算法-Optimization-algorithms"><a href="#第二周：优化算法-Optimization-algorithms" class="headerlink" title="第二周：优化算法 (Optimization algorithms)"></a>第二周：优化算法 (Optimization algorithms)</h2><h3 id="2-1-Mini-batch-梯度下降（Mini-batch-gradient-descent）"><a href="#2-1-Mini-batch-梯度下降（Mini-batch-gradient-descent）" class="headerlink" title="2.1 Mini-batch 梯度下降（Mini-batch gradient descent）"></a>2.1 Mini-batch 梯度下降（Mini-batch gradient descent）</h3><p>首先，如果训练集较小，直接使用<strong>batch</strong>梯度下降法，样本集较小就没必要使用<strong>mini-batch</strong>梯度下降法，你可以快速处理整个训练集，所以使用<strong>batch</strong>梯度下降法也很好，这里的少是说小于2000个样本，这样比较适合使用<strong>batch</strong>梯度下降法。不然，样本数目较大的话，一般的<strong>mini-batch</strong>大小为64到512，考虑到电脑内存设置和使用的方式，如果<strong>mini-batch</strong>大小是2的$n$次方，代码会运行地快一些，64就是2的6次方，以此类推，128是2的7次方，256是2的8次方，512是2的9次方。所以我经常把<strong>mini-batch</strong>大小设成2的次方。</p>
<p><strong>mini-batch</strong>梯度下降法比<strong>batch</strong>梯度下降法运行地更快。</p>
<h3 id="2-2-理解mini-batch梯度下降法（Understanding-mini-batch-gradient-descent）"><a href="#2-2-理解mini-batch梯度下降法（Understanding-mini-batch-gradient-descent）" class="headerlink" title="2.2 理解mini-batch梯度下降法（Understanding mini-batch gradient descent）"></a>2.2 理解mini-batch梯度下降法（Understanding mini-batch gradient descent）</h3><p>使用<strong>batch</strong>梯度下降法时，每次迭代你都需要历遍整个训练集，可以预期每次迭代成本都会下降，所以如果成本函数$J$是迭代次数的一个函数，它应该会随着每次迭代而减少，如果$J$在某次迭代中增加了，那肯定出了问题，也许你的学习率太大。</p>
<p>使用<strong>mini-batch</strong>梯度下降法，如果你作出成本函数在整个过程中的图，则并不是每次迭代都是下降的</p>
<p>另一个极端情况，假设<strong>mini-batch</strong>大小为1，就有了新的算法，叫做随机梯度下降法，每个样本都是独立的<strong>mini-batch</strong></p>
<h3 id="2-3-指数加权平均数（Exponentially-weighted-averages）"><a href="#2-3-指数加权平均数（Exponentially-weighted-averages）" class="headerlink" title="2.3 指数加权平均数（Exponentially weighted averages）"></a>2.3 指数加权平均数（Exponentially weighted averages）</h3><p>指数加权平均数经常被使用，再说一次，它在统计学中被称为指数加权移动平均值，我们就简称为指数加权平均数。通过调整这个参数（$\beta$），或者说后面的算法学习，你会发现这是一个很重要的参数，可以取得稍微不同的效果，往往中间有某个值效果最好</p>
<h3 id="2-4-理解指数加权平均数（Understanding-exponentially-weighted-averages）"><a href="#2-4-理解指数加权平均数（Understanding-exponentially-weighted-averages）" class="headerlink" title="2.4 理解指数加权平均数（Understanding exponentially weighted averages）"></a>2.4 理解指数加权平均数（Understanding exponentially weighted averages）</h3><p>指数加权平均数公式的好处之一在于，它占用极少内存，电脑内存中只占用一行数字而已，然后把最新数据代入公式，不断覆盖就可以了，正因为这个原因，其效率，它基本上只占用一行代码，计算指数加权平均数也只占用单行数字的存储和内存，当然它并不是最好的，也不是最精准的计算平均数的方法。如果你要计算移动窗，你直接算出过去10天的总和，过去50天的总和，除以10和50就好，如此往往会得到更好的估测。但缺点是，如果保存所有最近的温度数据，和过去10天的总和，必须占用更多的内存，执行更加复杂，计算成本也更加高昂。</p>
<h3 id="2-5-指数加权平均的偏差修正（Bias-correction-in-exponentially-weighted-averages）"><a href="#2-5-指数加权平均的偏差修正（Bias-correction-in-exponentially-weighted-averages）" class="headerlink" title="2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages）"></a>2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages）</h3><p>有个办法可以修改这一估测，让估测变得更好，更准确，特别是在估测初期，也就是不用$v_{t}$，而是用$\frac{v_{t}}{1- \beta^{t}}$，t就是现在的天数。</p>
<p>在机器学习中，在计算指数加权平均数的大部分时候，大家不在乎执行偏差修正，因为大部分人宁愿熬过初始时期，拿到具有偏差的估测，然后继续计算下去。如果你关心初始时期的偏差，在刚开始计算指数加权移动平均数的时候，偏差修正能帮助你在早期获取更好的估测。</p>
<h3 id="2-6-动量梯度下降法（Gradient-descent-with-Momentum）"><a href="#2-6-动量梯度下降法（Gradient-descent-with-Momentum）" class="headerlink" title="2.6 动量梯度下降法（Gradient descent with Momentum）"></a>2.6 动量梯度下降法（Gradient descent with Momentum）</h3><p>还有一种算法叫做<strong>Momentum</strong>，或者叫做动量梯度下降法，运行速度几乎总是快于标准的梯度下降算法，简而言之，基本的想法就是计算梯度的指数加权平均数，并利用该梯度更新你的权重</p>
<p>另一个看待问题的角度是，在纵轴上，你希望学习慢一点，因为你不想要这些摆动，但是在横轴上，你希望加快学习，你希望快速从左向右移，移向最小值，移向红点。</p>
<p>想象你有一个碗，你拿一个球，微分项给了这个球一个加速度，此时球正向山下滚，球因为加速度越滚越快，而因为$\beta$ 稍小于1，表现出一些摩擦力，所以球不会无限加速下去，所以不像梯度下降法，每一步都独立于之前的步骤，你的球可以向下滚，获得动量，可以从碗向下加速获得动量。我发现这个球从碗滚下的比喻，物理能力强的人接受得比较好，但不是所有人都能接受，如果球从碗中滚下这个比喻，你理解不了，别担心。</p>
<p>最后我们来看具体如何计算，算法在此。</p>
<p>你有两个超参数，学习率$a$以及参数$\beta$，$\beta$控制着指数加权平均数。$\beta$最常用的值是0.9，我们之前平均了过去十天的温度，所以现在平均了前十次迭代的梯度。实际上$\beta$为0.9时，效果不错，你可以尝试不同的值，可以做一些超参数的研究，不过0.9是很棒的鲁棒数。</p>
<h3 id="2-7-RMSprop"><a href="#2-7-RMSprop" class="headerlink" title="2.7 RMSprop"></a>2.7 RMSprop</h3><p>你们知道了动量（<strong>Momentum</strong>）可以加快梯度下降，还有一个叫做<strong>RMSprop</strong>的算法，全称是<strong>root mean square prop</strong>算法，它也可以加速梯度下降，我们来看看它是如何运作的。</p>
<p>该算法会照常计算当下<strong>mini-batch</strong>的微分$dW$，$db$，所以我会保留这个指数加权平均数，我们用到新符号$S_{dW}$，而不是$v_{dW}$，因此$S_{dW}= \beta S_{dW} + (1 -\beta) {dW}^{2}$，澄清一下，这个平方的操作是针对这一整个符号的，这样做能够保留微分平方的加权平均数，同样$S_{db}= \beta S_{db} + (1 - \beta){db}^{2}$，再说一次，平方是针对整个符号的操作。</p>
<p>接着<strong>RMSprop</strong>会这样更新参数值，$W:= W -a\frac{dW}{\sqrt{S_{dW}}}$，$b:=b -\alpha\frac{db}{\sqrt{S_{db}}}$，我们来理解一下其原理。记得在横轴方向或者在例子中的$W$方向，我们希望学习速度快，而在垂直方向，也就是例子中的$b$方向，我们希望减缓纵轴上的摆动，所以有了$S_{dW}$和$S_{db}$，我们希望$S_{dW}$会相对较小，所以我们要除以一个较小的数，而希望$S_{db}$又较大，所以这里我们要除以较大的数字，这样就可以减缓纵轴上的变化。你看这些微分，垂直方向的要比水平方向的大得多，所以斜率在$b$方向特别大，所以这些微分中，$db$较大，$dW$较小，因为函数的倾斜程度，在纵轴上，也就是b方向上要大于在横轴上，也就是$W$方向上。$db$的平方较大，所以$S_{db}$也会较大，而相比之下，$dW$会小一些，亦或$dW$平方会小一些，因此$S_{dW}$会小一些，结果就是纵轴上的更新要被一个较大的数相除，就能消除摆动，而水平方向的更新则被较小的数相除。</p>
<p>所以<strong>RMSprop</strong>跟<strong>Momentum</strong>有很相似的一点，可以消除梯度下降中的摆动，包括<strong>mini-batch</strong>梯度下降，并允许你使用一个更大的学习率$a$，从而加快你的算法学习速度。</p>
<h3 id="2-8-Adam-优化算法-Adam-optimization-algorithm"><a href="#2-8-Adam-优化算法-Adam-optimization-algorithm" class="headerlink" title="2.8 Adam 优化算法(Adam optimization algorithm)"></a>2.8 Adam 优化算法(Adam optimization algorithm)</h3><p>在深度学习的历史上，包括许多知名研究者在内，提出了优化算法，并很好地解决了一些问题，但随后这些优化算法被指出并不能一般化，并不适用于多种神经网络，时间久了，深度学习圈子里的人开始多少有些质疑全新的优化算法，很多人都觉得动量（<strong>Momentum</strong>）梯度下降法很好用，很难再想出更好的优化算法。所以<strong>RMSprop</strong>以及<strong>Adam</strong>优化算法（<strong>Adam</strong>优化算法也是本视频的内容），就是少有的经受住人们考验的两种算法，已被证明适用于不同的深度学习结构，这个算法我会毫不犹豫地推荐给你，因为很多人都试过，并且用它很好地解决了许多问题。</p>
<h3 id="2-9-学习率衰减-Learning-rate-decay"><a href="#2-9-学习率衰减-Learning-rate-decay" class="headerlink" title="2.9 学习率衰减(Learning rate decay)"></a>2.9 学习率衰减(Learning rate decay)</h3><h3 id="2-10-局部最优的问题-The-problem-of-local-optima"><a href="#2-10-局部最优的问题-The-problem-of-local-optima" class="headerlink" title="2.10 局部最优的问题(The problem of local optima)"></a>2.10 局部最优的问题(The problem of local optima)</h3><p>首先，你不太可能困在极差的局部最优中，条件是你在训练较大的神经网络，存在大量参数，并且成本函数$J$被定义在较高的维度空间。</p>
<p>第二点，平稳段是一个问题，这样使得学习十分缓慢，这也是像<strong>Momentum</strong>或是<strong>RMSprop</strong>，<strong>Adam</strong>这样的算法，能够加速学习算法的地方。在这些情况下，更成熟的优化算法，如<strong>Adam</strong>算法，能够加快速度，让你尽早往下走出平稳段。</p>
<h2 id="第三周-超参数调试、Batch正则化和程序框架（Hyperparameter-tuning）"><a href="#第三周-超参数调试、Batch正则化和程序框架（Hyperparameter-tuning）" class="headerlink" title="第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）"></a>第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）</h2><h3 id="3-1-调试处理（Tuning-process）"><a href="#3-1-调试处理（Tuning-process）" class="headerlink" title="3.1 调试处理（Tuning process）"></a>3.1 调试处理（Tuning process）</h3><h3 id="3-2-为超参数选择合适的范围（Using-an-appropriate-scale-to-pick-hyperparameters）"><a href="#3-2-为超参数选择合适的范围（Using-an-appropriate-scale-to-pick-hyperparameters）" class="headerlink" title="3.2 为超参数选择合适的范围（Using an appropriate scale to pick hyperparameters）"></a>3.2 为超参数选择合适的范围（Using an appropriate scale to pick hyperparameters）</h3><h3 id="3-3-超参数调试的实践：Pandas-VS-Caviar（Hyperparameters-tuning-in-practice-Pandas-vs-Caviar）"><a href="#3-3-超参数调试的实践：Pandas-VS-Caviar（Hyperparameters-tuning-in-practice-Pandas-vs-Caviar）" class="headerlink" title="3.3 超参数调试的实践：Pandas VS Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar）"></a>3.3 超参数调试的实践：Pandas VS Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar）</h3><h3 id="3-4-归一化网络的激活函数（Normalizing-activations-in-a-network）"><a href="#3-4-归一化网络的激活函数（Normalizing-activations-in-a-network）" class="headerlink" title="3.4 归一化网络的激活函数（Normalizing activations in a network）"></a>3.4 归一化网络的激活函数（Normalizing activations in a network）</h3><h3 id="3-5-将-Batch-Norm-拟合进神经网络（Fitting-Batch-Norm-into-a-neural-network）"><a href="#3-5-将-Batch-Norm-拟合进神经网络（Fitting-Batch-Norm-into-a-neural-network）" class="headerlink" title="3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）"></a>3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）</h3><h3 id="3-6-Batch-Norm-为什么奏效（Why-does-Batch-Norm-work-）"><a href="#3-6-Batch-Norm-为什么奏效（Why-does-Batch-Norm-work-）" class="headerlink" title="3.6 Batch Norm 为什么奏效（Why does Batch Norm work?）"></a>3.6 Batch Norm 为什么奏效（Why does Batch Norm work?）</h3><h3 id="3-7-测试时的-Batch-Norm（Batch-Norm-at-test-time）"><a href="#3-7-测试时的-Batch-Norm（Batch-Norm-at-test-time）" class="headerlink" title="3.7 测试时的 Batch Norm（Batch Norm at test time）"></a>3.7 测试时的 Batch Norm（Batch Norm at test time）</h3><h3 id="3-8-Softmax-回归（Softmax-regression）"><a href="#3-8-Softmax-回归（Softmax-regression）" class="headerlink" title="3.8 Softmax 回归（Softmax regression）"></a>3.8 Softmax 回归（Softmax regression）</h3><h3 id="3-9-训练一个-Softmax-分类器（Training-a-Softmax-classifier）"><a href="#3-9-训练一个-Softmax-分类器（Training-a-Softmax-classifier）" class="headerlink" title="3.9 训练一个 Softmax 分类器（Training a Softmax classifier）"></a>3.9 训练一个 Softmax 分类器（Training a Softmax classifier）</h3><h3 id="3-10-深度学习框架（Deep-Learning-frameworks）"><a href="#3-10-深度学习框架（Deep-Learning-frameworks）" class="headerlink" title="3.10 深度学习框架（Deep Learning frameworks）"></a>3.10 深度学习框架（Deep Learning frameworks）</h3><h3 id="3-11-TensorFlow"><a href="#3-11-TensorFlow" class="headerlink" title="3.11 TensorFlow"></a>3.11 TensorFlow</h3><blockquote>
<p>今天晚上多花了点时间，把进度提前推一点，BN是重点，明天回过头来再看看。明天再刷一天就进入cv了。</p>
</blockquote>
<h1 id="第三门课-结构化机器学习项目（Structuring-Machine-Learning-Projects）"><a href="#第三门课-结构化机器学习项目（Structuring-Machine-Learning-Projects）" class="headerlink" title="第三门课 结构化机器学习项目（Structuring Machine Learning Projects）"></a>第三门课 结构化机器学习项目（Structuring Machine Learning Projects）</h1><h2 id="第一周-机器学习（ML）策略（1）（ML-strategy（1））"><a href="#第一周-机器学习（ML）策略（1）（ML-strategy（1））" class="headerlink" title="第一周 机器学习（ML）策略（1）（ML strategy（1））"></a>第一周 机器学习（ML）策略（1）（ML strategy（1））</h2><h3 id="1-1-为什么是ML策略？（Why-ML-Strategy-）"><a href="#1-1-为什么是ML策略？（Why-ML-Strategy-）" class="headerlink" title="1.1 为什么是ML策略？（Why ML Strategy?）"></a>1.1 为什么是ML策略？（Why ML Strategy?）</h3><h3 id="1-2-正交化（Orthogonalization）"><a href="#1-2-正交化（Orthogonalization）" class="headerlink" title="1.2 正交化（Orthogonalization）"></a>1.2 正交化（Orthogonalization）</h3><p>所以正交化的概念是指，你可以想出一个维度，这个维度你想做的是控制转向角，还有另一个维度来控制你的速度，那么你就需要一个旋钮尽量只控制转向角，另一个旋钮，在这个开车的例子里其实是油门和刹车控制了你的速度。但如果你有一个控制旋钮将两者混在一起，比如说这样一个控制装置同时影响你的转向角和速度，同时改变了两个性质，那么就很难令你的车子以想要的速度和角度前进。然而正交化之后，正交意味着互成90度。设计出正交化的控制装置，最理想的情况是和你实际想控制的性质一致，这样你调整参数时就容易得多。可以单独调整转向角，还有你的油门和刹车，令车子以你想要的方式运动。</p>
<h3 id="1-3-单一数字评估指标（Single-number-evaluation-metric）"><a href="#1-3-单一数字评估指标（Single-number-evaluation-metric）" class="headerlink" title="1.3 单一数字评估指标（Single number evaluation metric）"></a>1.3 单一数字评估指标（Single number evaluation metric）</h3><h3 id="1-4-满足和优化指标（Satisficing-and-optimizing-metrics）"><a href="#1-4-满足和优化指标（Satisficing-and-optimizing-metrics）" class="headerlink" title="1.4 满足和优化指标（Satisficing and optimizing metrics）"></a>1.4 满足和优化指标（Satisficing and optimizing metrics）</h3><p>总结一下，如果你需要顾及多个指标，比如说，有一个优化指标，你想尽可能优化的，然后还有一个或多个满足指标，需要满足的，需要达到一定的门槛。现在你就有一个全自动的方法，在观察多个成本大小时，选出”最好的”那个。现在这些评估指标必须是在训练集或开发集或测试集上计算或求出来的。所以你还需要做一件事，就是设立训练集、开发集，还有测试集。</p>
<h3 id="1-5-训练-开发-测试集划分（Train-dev-test-distributions）"><a href="#1-5-训练-开发-测试集划分（Train-dev-test-distributions）" class="headerlink" title="1.5 训练/开发/测试集划分（Train/dev/test distributions）"></a>1.5 训练/开发/测试集划分（Train/dev/test distributions）</h3><h3 id="1-6-开发集和测试集的大小（Size-of-dev-and-test-sets）"><a href="#1-6-开发集和测试集的大小（Size-of-dev-and-test-sets）" class="headerlink" title="1.6 开发集和测试集的大小（Size of dev and test sets）"></a>1.6 开发集和测试集的大小（Size of dev and test sets）</h3><h3 id="1-7-什么时候该改变开发-测试集和指标？（When-to-change-dev-test-sets-and-metrics）"><a href="#1-7-什么时候该改变开发-测试集和指标？（When-to-change-dev-test-sets-and-metrics）" class="headerlink" title="1.7 什么时候该改变开发/测试集和指标？（When to change dev/test sets and metrics）"></a>1.7 什么时候该改变开发/测试集和指标？（When to change dev/test sets and metrics）</h3><p>所以方针是，如果你在指标上表现很好，在当前开发集或者开发集和测试集分布中表现很好，但你的实际应用程序，你真正关注的地方表现不好，那么就需要修改指标或者你的开发测试集。换句话说，如果你发现你的开发测试集都是这些高质量图像，但在开发测试集上做的评估无法预测你的应用实际的表现。因为你的应用处理的是低质量图像，那么就应该改变你的开发测试集，让你的数据更能反映你实际需要处理好的数据。</p>
<p>但总体方针就是，如果你当前的指标和当前用来评估的数据和你真正关心必须做好的事情关系不大，那就应该更改你的指标或者你的开发测试集，让它们能更够好地反映你的算法需要处理好的数据。</p>
<h3 id="1-8-为什么是人的表现？（Why-human-level-performance-）"><a href="#1-8-为什么是人的表现？（Why-human-level-performance-）" class="headerlink" title="1.8 为什么是人的表现？（Why human-level performance?）"></a>1.8 为什么是人的表现？（Why human-level performance?）</h3><h3 id="1-9-可避免偏差（Avoidable-bias）"><a href="#1-9-可避免偏差（Avoidable-bias）" class="headerlink" title="1.9 可避免偏差（Avoidable bias）"></a>1.9 可避免偏差（Avoidable bias）</h3><p>这个差值，贝叶斯错误率或者对贝叶斯错误率的估计和训练错误率之间的差值称为可避免偏差，你可能希望一直提高训练集表现，直到你接近贝叶斯错误率，但实际上你也不希望做到比贝叶斯错误率更好，这理论上是不可能超过贝叶斯错误率的，除非过拟合。而这个训练错误率和开发错误率之前的差值，就大概说明你的算法在方差问题上还有多少改善空间。</p>
<h3 id="1-10-理解人的表现（Understanding-human-level-performance）"><a href="#1-10-理解人的表现（Understanding-human-level-performance）" class="headerlink" title="1.10 理解人的表现（Understanding human-level performance）"></a>1.10 理解人的表现（Understanding human-level performance）</h3><h3 id="1-11-超过人的表现（Surpassing-human-level-performance）"><a href="#1-11-超过人的表现（Surpassing-human-level-performance）" class="headerlink" title="1.11 超过人的表现（Surpassing human- level performance）"></a>1.11 超过人的表现（Surpassing human- level performance）</h3><h3 id="1-12-改善你的模型的表现（Improving-your-model-performance）"><a href="#1-12-改善你的模型的表现（Improving-your-model-performance）" class="headerlink" title="1.12 改善你的模型的表现（Improving your model performance）"></a>1.12 改善你的模型的表现（Improving your model performance）</h3><p>所以我想要让一个监督学习算法达到实用，基本上希望或者假设你可以完成两件事情。首先，你的算法对训练集的拟合很好，这可以看成是你能做到可避免偏差很低。还有第二件事你可以做好的是，在训练集中做得很好，然后推广到开发集和测试集也很好，这就是说方差不是太大。</p>
<p>可以修正可避免偏差问题，比如训练更大的网络或者训练更久。还有一套独立的技巧可以用来处理方差问题，比如正则化或者收集更多训练数据。</p>
<p>总结一下前几段视频我们见到的步骤，如果你想提升机器学习系统的性能，我建议你们看看训练错误率和贝叶斯错误率估计值之间的距离，让你知道可避免偏差有多大。换句话说，就是你觉得还能做多好，你对训练集的优化还有多少空间。然后看看你的开发错误率和训练错误率之间的距离，就知道你的方差问题有多大。换句话说，你应该做多少努力让你的算法表现能够从训练集推广到开发集，算法是没有在开发集上训练的。</p>
<p>如果你想用尽一切办法减少可避免偏差，我建议试试这样的策略：比如使用规模更大的模型，这样算法在训练集上的表现会更好，或者训练更久。使用更好的优化算法，比如说加入<strong>momentum</strong>或者<strong>RMSprop</strong>，或者使用更好的算法，比如<strong>Adam</strong>。你还可以试试寻找更好的新神经网络架构，或者说更好的超参数。这些手段包罗万有，你可以改变激活函数，改变层数或者隐藏单位数，虽然你这么做可能会让模型规模变大。或者试用其他模型，其他架构，如循环神经网络和卷积神经网络。在之后的课程里我们会详细介绍的，新的神经网络架构能否更好地拟合你的训练集，有时也很难预先判断，但有时换架构可能会得到好得多的结果。</p>
<p>另外当你发现方差是个问题时，你可以试用很多技巧，包括以下这些：你可以收集更多数据，因为收集更多数据去训练可以帮你更好地推广到系统看不到的开发集数据。你可以尝试正则化，包括$L2$正则化，<strong>dropout</strong>正则化或者我们在之前课程中提到的数据增强。同时你也可以试用不同的神经网络架构，超参数搜索，看看能不能帮助你，找到一个更适合你的问题的神经网络架构。</p>
<h2 id="第二周：机器学习策略（2）-ML-Strategy-2"><a href="#第二周：机器学习策略（2）-ML-Strategy-2" class="headerlink" title="第二周：机器学习策略（2）(ML Strategy (2))"></a>第二周：机器学习策略（2）(ML Strategy (2))</h2><h3 id="2-1-进行误差分析（Carrying-out-error-analysis）"><a href="#2-1-进行误差分析（Carrying-out-error-analysis）" class="headerlink" title="2.1 进行误差分析（Carrying out error analysis）"></a>2.1 进行误差分析（Carrying out error analysis）</h3><p>总结一下，进行错误分析，你应该找一组错误样本，可能在你的开发集里或者测试集里，观察错误标记的样本，看看假阳性（<strong>false positives</strong>）和假阴性（<strong>false negatives</strong>），统计属于不同错误类型的错误数量。在这个过程中，你可能会得到启发，归纳出新的错误类型，就像我们看到的那样。如果你过了一遍错误样本，然后说，天，有这么多<strong>Instagram</strong>滤镜或<strong>Snapchat</strong>滤镜，这些滤镜干扰了我的分类器，你就可以在途中新建一个错误类型。总之，通过统计不同错误标记类型占总数的百分比，可以帮你发现哪些问题需要优先解决，或者给你构思新优化方向的灵感。在做错误分析的时候，有时你会注意到开发集里有些样本被错误标记了，这时应该怎么做呢？</p>
<h3 id="2-2-清除标注错误的数据（Cleaning-up-Incorrectly-labeled-data）"><a href="#2-2-清除标注错误的数据（Cleaning-up-Incorrectly-labeled-data）" class="headerlink" title="2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）"></a>2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）</h3><p>如果你还记得设立开发集的目标的话，开发集的主要目的是，你希望用它来从两个分类器$A$和$B$中选择一个。所以当你测试两个分类器$A$和$B$时，在开发集上一个有2.1%错误率，另一个有1.9%错误率，但是你不能再信任开发集了，因为它无法告诉你这个分类器是否比这个好，因为0.6%的错误率是标记出错导致的。那么现在你就有很好的理由去修正开发集里的错误标签，因为在右边这个样本中，标记出错对算法错误的整体评估标准有严重的影响。而左边的样本中，标记出错对你算法影响的百分比还是相对较小的。</p>
<p>现在如果你决定要去修正开发集数据，手动重新检查标签，并尝试修正一些标签，这里还有一些额外的方针和原则需要考虑。首先，我鼓励你不管用什么修正手段，都要同时作用到开发集和测试集上，我们之前讨论过为什么，开发和测试集必须来自相同的分布。开发集确定了你的目标，当你击中目标后，你希望算法能够推广到测试集上，这样你的团队能够更高效的在来自同一分布的开发集和测试集上迭代。如果你打算修正开发集上的部分数据，那么最好也对测试集做同样的修正以确保它们继续来自相同的分布。所以我们雇佣了一个人来仔细检查这些标签，但必须同时检查开发集和测试集。</p>
<h3 id="2-3-快速搭建你的第一个系统，并进行迭代（Build-your-first-system-quickly-then-iterate）"><a href="#2-3-快速搭建你的第一个系统，并进行迭代（Build-your-first-system-quickly-then-iterate）" class="headerlink" title="2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）"></a>2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）</h3><p>如果你想搭建全新的机器学习程序，就是快速搭好你的第一个系统，然后开始迭代。我的意思是我建议你快速设立开发集和测试集还有指标，这样就决定了你的目标所在，如果你的目标定错了，之后改也是可以的。但一定要设立某个目标，然后我建议你马上搭好一个机器学习系统原型，然后找到训练集，训练一下，看看效果，开始理解你的算法表现如何，在开发集测试集，你的评估指标上表现如何。当你建立第一个系统后，你就可以马上用到之前说的偏差方差分析</p>
<p>建立这个初始系统的所有意义在于，它可以是一个快速和粗糙的实现（<strong>quick and dirty implementation</strong>），你知道的，别想太多。初始系统的全部意义在于，有一个学习过的系统，有一个训练过的系统，让你确定偏差方差的范围，就可以知道下一步应该优先做什么，让你能够进行错误分析，可以观察一些错误，然后想出所有能走的方向，哪些是实际上最有希望的方向。</p>
<p>你的主要目标是弄出能用的系统，你的主要目标并不是发明全新的机器学习算法，这是完全不同的目标，那时你的目标应该是想出某种效果非常好的算法。</p>
<h3 id="2-4-使用来自不同分布的数据，进行训练和测试（Training-and-testing-on-different-distributions）"><a href="#2-4-使用来自不同分布的数据，进行训练和测试（Training-and-testing-on-different-distributions）" class="headerlink" title="2.4 使用来自不同分布的数据，进行训练和测试（Training and testing on different distributions）"></a>2.4 使用来自不同分布的数据，进行训练和测试（Training and testing on different distributions）</h3><p>将两组数据合并在一起，这样你就有21万张照片，你可以把这21万张照片随机分配到训练、开发和测试集中。</p>
<h3 id="2-5-数据分布不匹配时，偏差与方差的分析（Bias-and-Variance-with-mismatched-data-distributions）"><a href="#2-5-数据分布不匹配时，偏差与方差的分析（Bias-and-Variance-with-mismatched-data-distributions）" class="headerlink" title="2.5 数据分布不匹配时，偏差与方差的分析（Bias and Variance with mismatched data distributions）"></a>2.5 数据分布不匹配时，偏差与方差的分析（Bias and Variance with mismatched data distributions）</h3><p>我们继续用猫分类器为例，我们说人类在这个任务上能做到几乎完美，所以贝叶斯错误率或者说贝叶斯最优错误率，我们知道这个问题里几乎是0%。所以要进行错误率分析，你通常需要看训练误差，也要看看开发集的误差。比如说，在这个样本中，你的训练集误差是1%，你的开发集误差是10%，如果你的开发集来自和训练集一样的分布，你可能会说，这里存在很大的方差问题，你的算法不能很好的从训练集出发泛化，它处理训练集很好，但处理开发集就突然间效果很差了。</p>
<p>但如果你的训练数据和开发数据来自不同的分布，你就不能再放心下这个结论了。特别是，也许算法在开发集上做得不错，可能因为训练集很容易识别，因为训练集都是高分辨率图片，很清晰的图像，但开发集要难以识别得多。所以也许软件没有方差问题，这只不过反映了开发集包含更难准确分类的图片。所以这个分析的问题在于，当你看训练误差，再看开发误差，有两件事变了。首先算法只见过训练集数据，没见过开发集数据。第二，开发集数据来自不同的分布。而且因为你同时改变了两件事情，很难确认这增加的9%误差率有多少是因为算法没看到开发集中的数据导致的，这是问题方差的部分，有多少是因为开发集数据就是不一样。</p>
<p>为了弄清楚哪个因素影响更大，如果你完全不懂这两种影响到底是什么，别担心我们马上会再讲一遍。但为了分辨清楚两个因素的影响，定义一组新的数据是有意义的，我们称之为训练-开发集，所以这是一个新的数据子集。我们应该从训练集的分布里挖出来，但你不会用来训练你的网络。</p>
<p>我们说人类水平错误率是4%的话，你的训练错误率是7%，而你的训练-开发错误率是10%，而开发错误率是12%，这样你就大概知道可避免偏差有多大。因为你知道，你希望你的算法至少要在训练集上的表现接近人类。而这大概表明了方差大小，所以你从训练集泛化推广到训练-开发集时效果如何？而这告诉你数据不匹配的问题大概有多大。技术上你还可以再加入一个数字，就是测试集表现，我们写成测试集错误率，你不应该在测试集上开发，因为你不希望对测试集过拟合。但如果你看看这个，那么这里的差距就说明你对开发集过拟合的程度。所以如果开发集表现和测试集表现有很大差距，那么你可能对开发集过拟合了，所以也许你需要一个更大的开发集，对吧？要记住，你的开发集和测试集来自同一分布，所以这里存在很大差距的话。如果算法在开发集上做的很好，比测试集好得多，那么你就可能对开发集过拟合了。如果是这种情况，那么你可能要往回退一步，然后收集更多开发集数据。</p>
<h3 id="2-6-处理数据不匹配问题（Addressing-data-mismatch）"><a href="#2-6-处理数据不匹配问题（Addressing-data-mismatch）" class="headerlink" title="2.6 处理数据不匹配问题（Addressing data mismatch）"></a>2.6 处理数据不匹配问题（Addressing data mismatch）</h3><p>如果您的训练集来自和开发测试集不同的分布，如果错误分析显示你有一个数据不匹配的问题该怎么办？这个问题没有完全系统的解决方案，但我们可以看看一些可以尝试的事情。如果我发现有严重的数据不匹配问题，我通常会亲自做错误分析，尝试了解训练集和开发测试集的具体差异。技术上，为了避免对测试集过拟合，要做错误分析，你应该人工去看开发集而不是测试集。</p>
<p>通过人工数据合成，你可以快速制造更多的训练数据，就像真的在车里录的那样，那就不需要花时间实际出去收集数据，比如说在实际行驶中的车子，录下上万小时的音频。所以，如果错误分析显示你应该尝试让你的数据听起来更像在车里录的，那么人工合成那种音频，然后喂给你的机器学习算法，这样做是合理的。</p>
<p>我们谈到其中一种办法是人工数据合成，人工数据合成确实有效。在语音识别中。我已经看到人工数据合成显著提升了已经非常好的语音识别系统的表现，所以这是可行的。但当你使用人工数据合成时，一定要谨慎，要记住你有可能从所有可能性的空间只选了很小一部分去模拟数据。</p>
<h3 id="2-7-迁移学习（Transfer-learning）"><a href="#2-7-迁移学习（Transfer-learning）" class="headerlink" title="2.7 迁移学习（Transfer learning）"></a>2.7 迁移学习（Transfer learning）</h3><p>深度学习中，最强大的理念之一就是，有的时候神经网络可以从一个任务中习得知识，并将这些知识应用到另一个独立的任务中。所以例如，也许你已经训练好一个神经网络，能够识别像猫这样的对象，然后使用那些知识，或者部分习得的知识去帮助您更好地阅读x射线扫描图，这就是所谓的迁移学习。</p>
<p>那么迁移学习什么时候是有意义的呢？迁移学习起作用的场合是，在迁移来源问题中你有很多数据，但迁移目标问题你没有那么多数据。例如，假设图像识别任务中你有1百万个样本，所以这里数据相当多。可以学习低层次特征，可以在神经网络的前面几层学到如何识别很多有用的特征。但是对于放射科任务，也许你只有一百个样本，所以你的放射学诊断问题数据很少，也许只有100次$X$射线扫描，所以你从图像识别训练中学到的很多知识可以迁移，并且真正帮你加强放射科识别任务的性能，即使你的放射科数据很少。</p>
<h3 id="2-8-多任务学习（Multi-task-learning）"><a href="#2-8-多任务学习（Multi-task-learning）" class="headerlink" title="2.8 多任务学习（Multi-task learning）"></a>2.8 多任务学习（Multi-task learning）</h3><p>最后多任务学习往往在以下场合更有意义，当你可以训练一个足够大的神经网络，同时做好所有的工作，所以多任务学习的替代方法是为每个任务训练一个单独的神经网络。所以不是训练单个神经网络同时处理行人、汽车、停车标志和交通灯检测。你可以训练一个用于行人检测的神经网络，一个用于汽车检测的神经网络，一个用于停车标志检测的神经网络和一个用于交通信号灯检测的神经网络。那么研究员<strong>Rich Carona</strong>几年前发现的是什么呢？多任务学习会降低性能的唯一情况，和训练单个神经网络相比性能更低的情况就是你的神经网络还不够大。但如果你可以训练一个足够大的神经网络，那么多任务学习肯定不会或者很少会降低性能，我们都希望它可以提升性能，比单独训练神经网络来单独完成各个任务性能要更好。</p>
<h3 id="2-9-什么是端到端的深度学习-（What-is-end-to-end-deep-learning-）"><a href="#2-9-什么是端到端的深度学习-（What-is-end-to-end-deep-learning-）" class="headerlink" title="2.9 什么是端到端的深度学习?（What is end-to-end deep learning?）"></a>2.9 什么是端到端的深度学习?（What is end-to-end deep learning?）</h3><p>研究人员发现，比起一步到位，一步学习，把这个问题分解成两个更简单的步骤。首先，是弄清楚脸在哪里。第二步是看着脸，弄清楚这是谁。这第二种方法让学习算法，或者说两个学习算法分别解决两个更简单的任务，并在整体上得到更好的表现。</p>
<p>为什么两步法更好呢？实际上有两个原因。一是，你解决的两个问题，每个问题实际上要简单得多。但第二，两个子任务的训练数据都很多。具体来说，有很多数据可以用于人脸识别训练，对于这里的任务1来说，任务就是观察一张图，找出人脸所在的位置，把人脸图像框出来，所以有很多数据，有很多标签数据$(x,y)$，其中$x$是图片，$y$是表示人脸的位置，你可以建立一个神经网络，可以很好地处理任务1。然后任务2，也有很多数据可用，今天，业界领先的公司拥有，比如说数百万张人脸照片，所以输入一张裁剪得很紧凑的照片，比如这张红色照片，下面这个，今天业界领先的人脸识别团队有至少数亿的图像，他们可以用来观察两张图片，并试图判断照片里人的身份，确定是否同一个人，所以任务2还有很多数据。相比之下，如果你想一步到位，这样$(x,y)$的数据对就少得多，其中$x$是门禁系统拍摄的图像，$y$是那人的身份，因为你没有足够多的数据去解决这个端到端学习问题，但你却有足够多的数据来解决子问题1和子问题2。</p>
<p>实际上，把这个分成两个子问题，比纯粹的端到端深度学习方法，达到更好的表现。不过如果你有足够多的数据来做端到端学习，也许端到端方法效果更好。但在今天的实践中，并不是最好的方法。</p>
<h3 id="2-10-是否要使用端到端的深度学习-（Whether-to-use-end-to-end-learning-）"><a href="#2-10-是否要使用端到端的深度学习-（Whether-to-use-end-to-end-learning-）" class="headerlink" title="2.10 是否要使用端到端的深度学习?（Whether to use end-to-end learning?）"></a>2.10 是否要使用端到端的深度学习?（Whether to use end-to-end learning?）</h3><p>这里是应用端到端学习的一些好处，首先端到端学习真的只是让数据说话。所以如果你有足够多的$(x,y)$数据，那么不管从$x$到$y$最适合的函数映射是什么，如果你训练一个足够大的神经网络，希望这个神经网络能自己搞清楚，而使用纯机器学习方法，直接从$x$到$y$输入去训练的神经网络，可能更能够捕获数据中的任何统计信息，而不是被迫引入人类的成见。</p>
<p>端到端深度学习的第二个好处就是这样，所需手工设计的组件更少，所以这也许能够简化你的设计工作流程，你不需要花太多时间去手工设计功能，手工设计这些中间表示方式。</p>
<p>那么缺点呢？这里有一些缺点，首先，它可能需要大量的数据。要直接学到这个$x$到$y$的映射，你可能需要大量$(x,y)$数据。我们在以前的视频里看过一个例子，其中你可以收集大量子任务数据，比如人脸识别，我们可以收集很多数据用来分辨图像中的人脸，当你找到一张脸后，也可以找得到很多人脸识别数据。但是对于整个端到端任务，可能只有更少的数据可用。所以$x$这是端到端学习的输入端，$y$是输出端，所以你需要很多这样的$(x,y)$数据，在输入端和输出端都有数据，这样可以训练这些系统。这就是为什么我们称之为端到端学习，因为你直接学习出从系统的一端到系统的另一端。</p>
<p>另一个缺点是，它排除了可能有用的手工设计组件。机器学习研究人员一般都很鄙视手工设计的东西，但如果你没有很多数据，你的学习算法就没办法从很小的训练集数据中获得洞察力。所以手工设计组件在这种情况，可能是把人类知识直接注入算法的途径，这总不是一件坏事。我觉得学习算法有两个主要的知识来源，一个是数据，另一个是你手工设计的任何东西，可能是组件，功能，或者其他东西。所以当你有大量数据时，手工设计的东西就不太重要了，但是当你没有太多的数据时，构造一个精心设计的系统，实际上可以将人类对这个问题的很多认识直接注入到问题里，进入算法里应该挺有帮助的。</p>
<p>如果你在构建一个新的机器学习系统，而你在尝试决定是否使用端到端深度学习，我认为关键的问题是，你有足够的数据能够直接学到从$x$映射到$y$足够复杂的函数吗？我还没有正式定义过这个词“必要复杂度（<strong>complexity needed</strong>）”。但直觉上，如果你想从$x$到$y$的数据学习出一个函数，就是看着这样的图像识别出图像中所有骨头的位置，那么也许这像是识别图中骨头这样相对简单的问题，也许系统不需要那么多数据来学会处理这个任务。或给出一张人物照片，也许在图中把人脸找出来不是什么难事，所以你也许不需要太多数据去找到人脸，或者至少你可以找到足够数据去解决这个问题。相对来说，把手的X射线照片直接映射到孩子的年龄，直接去找这种函数，直觉上似乎是更为复杂的问题。如果你用纯端到端方法，需要很多数据去学习。</p>
<p>所以这个例子就表明了，如果你想使用机器学习或者深度学习来学习某些单独的组件，那么当你应用监督学习时，你应该仔细选择要学习的$x$到$y$映射类型，<strong>这取决于那些任务你可以收集数据。</strong></p>
<blockquote>
<p>6.25 刚好到周五结束前三门课程，周末可以再把后续的cv的CNN模型和nlp序列模型看完，然后就可以马上自己动手实践了。其实这样看一遍只相当于是简单预习，完全谈不上学完，只有自己一边实践一边学才能真正学会。后两门才是重头，前面都是机器学习课程里曾经涉及过的或者相关的基础内容，这样复习一边前面知识一边继续前进，这个进度很舒服。</p>
</blockquote>
<h1 id="第四门课-卷积神经网络（Convolutional-Neural-Networks）"><a href="#第四门课-卷积神经网络（Convolutional-Neural-Networks）" class="headerlink" title="第四门课 卷积神经网络（Convolutional Neural Networks）"></a>第四门课 卷积神经网络（Convolutional Neural Networks）</h1><blockquote>
<p>起晚了。</p>
</blockquote>
<h2 id="第一周-卷积神经网络（Foundations-of-Convolutional-Neural-Networks）"><a href="#第一周-卷积神经网络（Foundations-of-Convolutional-Neural-Networks）" class="headerlink" title="第一周 卷积神经网络（Foundations of Convolutional Neural Networks）"></a>第一周 卷积神经网络（Foundations of Convolutional Neural Networks）</h2><h3 id="1-2-边缘检测示例（Edge-detection-example）"><a href="#1-2-边缘检测示例（Edge-detection-example）" class="headerlink" title="1.2 边缘检测示例（Edge detection example）"></a>1.2 边缘检测示例（Edge detection example）</h3><p>卷积运算是卷积神经网络最基本的组成部分，使用边缘检测作为入门样例。</p>
<p>在编程练习中，你会使用一个叫<strong>conv_forward</strong>的函数。如果在<strong>tensorflow</strong>下，这个函数叫<strong>tf.conv2d</strong>。在其他深度学习框架中，在后面的课程中，你将会看到<strong>Keras</strong>这个框架，在这个框架下用<strong>Conv2D</strong>实现卷积运算。所有的编程框架都有一些函数来实现卷积运算。</p>
<h3 id="1-3-更多边缘检测内容（More-edge-detection）"><a href="#1-3-更多边缘检测内容（More-edge-detection）" class="headerlink" title="1.3 更多边缘检测内容（More edge detection）"></a>1.3 更多边缘检测内容（More edge detection）</h3><p>你已经见识到用卷积运算实现垂直边缘检测，在本视频中，你将学习如何区分正边和负边，这实际就是由亮到暗与由暗到亮的区别，也就是边缘的过渡。你还能了解到其他类型的边缘检测以及如何去实现这些算法，而不要总想着去自己编写一个边缘检测程序，让我们开始吧。</p>
<h3 id="1-4-Padding"><a href="#1-4-Padding" class="headerlink" title="1.4 Padding"></a>1.4 Padding</h3><p>为了构建深度神经网络，你需要学会使用的一个基本的卷积操作就是<strong>padding</strong>，让我们来看看它是如何工作的。</p>
<p>第一个缺点是每次做卷积操作，你的图像就会缩小，从6×6缩小到4×4，你可能做了几次之后，你的图像就会变得很小了，可能会缩小到只有1×1的大小。你可不想让你的图像在每次识别边缘或其他特征时都缩小，这就是第一个缺点。</p>
<p>第二个缺点时，如果你注意角落边缘的像素，这个像素点（绿色阴影标记）只被一个输出所触碰或者使用，因为它位于这个3×3的区域的一角。但如果是在中间的像素点，比如这个（红色方框标记），就会有许多3×3的区域与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着你丢掉了图像边缘位置的许多信息。</p>
<p>为了解决这些问题，你可以在卷积操作之前填充这幅图像。在这个案例中，你可以沿着图像边缘再填充一层像素。如果你这样操作了，那么6×6的图像就被你填充成了一个8×8的图像。</p>
<p>至于选择填充多少像素，通常有两个选择，分别叫做<strong>Valid</strong>卷积和<strong>Same</strong>卷积。</p>
<p>因此如果你有一个$n×n$的图像，用$p$个像素填充边缘，输出的大小就是这样的$(n+2p-f+1)×(n+2p-f+1)$。如果你想让$n+2p-f+1=n$的话，使得输出和输入大小相等，如果你用这个等式求解$p$，那么$p=(f-1)/2$。所以当$f$是一个奇数的时候，只要选择相应的填充尺寸，你就能确保得到和输入相同尺寸的输出。</p>
<h3 id="1-5-卷积步长（Strided-convolutions）"><a href="#1-5-卷积步长（Strided-convolutions）" class="headerlink" title="1.5 卷积步长（Strided convolutions）"></a>1.5 卷积步长（Strided convolutions）</h3><p>卷积中的步幅是另一个构建卷积神经网络的基本操作，让我向你展示一个例子。</p>
<p>输入和输出的维度是由下面的公式决定的。如果你用一个$f×f$的过滤器卷积一个$n×n$的图像，你的<strong>padding</strong>为$p$，步幅为$s$，在这个例子中$s=2$，你会得到一个输出，因为现在你不是一次移动一个步子，而是一次移动$s$个步子，输出于是变为$\frac{n+2p - f}{s} + 1 \times \frac{n+2p - f}{s} + 1$</p>
<p>现在只剩下最后的一个细节了，如果商不是一个整数怎么办？在这种情况下，我们向下取整。$⌊ ⌋$这是向下取整的符号，这也叫做对$z$进行地板除(<strong>floor</strong>)，这意味着$z$向下取整到最近的整数。这个原则实现的方式是，你只在蓝框完全包括在图像或填充完的图像内部时，才对它进行运算。如果有任意一个蓝框移动到了外面，那你就不要进行相乘操作，这是一个惯例。你的3×3的过滤器必须完全处于图像中或者填充之后的图像区域内才输出相应结果，这就是惯例。因此正确计算输出维度的方法是向下取整，以免$\frac{n + 2p - f}{s}$不是整数。</p>
<h3 id="1-6-三维卷积（Convolutions-over-volumes）"><a href="#1-6-三维卷积（Convolutions-over-volumes）" class="headerlink" title="1.6 三维卷积（Convolutions over volumes）"></a>1.6 三维卷积（Convolutions over volumes）</h3><p>你已经知道如何对二维图像做卷积了，现在看看如何执行卷积不仅仅在二维图像上，而是三维立体上。</p>
<h3 id="1-7-单层卷积网络（One-layer-of-a-convolutional-network）"><a href="#1-7-单层卷积网络（One-layer-of-a-convolutional-network）" class="headerlink" title="1.7 单层卷积网络（One layer of a convolutional network）"></a>1.7 单层卷积网络（One layer of a convolutional network）</h3><p>今天我们要讲的是如何构建卷积神经网络的卷积层，下面来看个例子。</p>
<h3 id="1-8-简单卷积网络示例（A-simple-convolution-network-example）"><a href="#1-8-简单卷积网络示例（A-simple-convolution-network-example）" class="headerlink" title="1.8 简单卷积网络示例（A simple convolution network example）"></a>1.8 简单卷积网络示例（A simple convolution network example）</h3><p>上节课，我们讲了如何为卷积网络构建一个卷积层。今天我们看一个深度卷积神经网络的具体示例，顺便练习一下我们上节课所学的标记法。</p>
<h3 id="1-9-池化层（Pooling-layers）"><a href="#1-9-池化层（Pooling-layers）" class="headerlink" title="1.9 池化层（Pooling layers）"></a>1.9 池化层（Pooling layers）</h3><p>除了卷积层，卷积网络也经常使用池化层来缩减模型的大小，提高计算速度，同时提高所提取特征的鲁棒性，我们来看一下。</p>
<p>最大池化算法。</p>
<p>另外还有一种类型的池化，平均池化，它不太常用。目前来说，最大池化比平均池化更常用。但也有例外，就是深度很深的神经网络，你可以用平均池化来分解规模为7×7×1000的网络的表示层，在整个空间内求平均值，得到1×1×1000，一会我们看个例子。但在神经网络中，最大池化要比平均池化用得更多。</p>
<p>总结一下，池化的超级参数包括过滤器大小$f$和步幅$s$，常用的参数值为$f=2$，$s=2$，应用频率非常高，其效果相当于高度和宽度缩减一半。也有使用$f=3$，$s=2$的情况。至于其它超级参数就要看你用的是最大池化还是平均池化了。你也可以根据自己意愿增加表示<strong>padding</strong>的其他超级参数，虽然很少这么用。最大池化时，往往很少用到超参数<strong>padding</strong>，当然也有例外的情况，我们下周会讲。大部分情况下，最大池化很少用<strong>padding</strong>。目前$p$最常用的值是0，即$p=0$。最大池化的输入就是$n_{H} \times n_{W} \times n_{c}$，假设没有<strong>padding</strong>，则输出$\lfloor\frac{n_{H} - f}{s} +1\rfloor \times \lfloor\frac{n_{w} - f}{s} + 1\rfloor \times n_{c}$。输入通道与输出通道个数相同，因为我们对每个通道都做了池化。需要注意的一点是，池化过程中没有需要学习的参数。执行反向传播时，反向传播没有参数适用于最大池化。只有这些设置过的超参数，可能是手动设置的，也可能是通过交叉验证设置的。</p>
<h3 id="1-10-卷积神经网络示例（Convolutional-neural-network-example）"><a href="#1-10-卷积神经网络示例（Convolutional-neural-network-example）" class="headerlink" title="1.10 卷积神经网络示例（Convolutional neural network example）"></a>1.10 卷积神经网络示例（Convolutional neural network example）</h3><p>构建全卷积神经网络的构造模块我们已经掌握得差不多了，下面来看个例子。</p>
<p>人们发现在卷积神经网络文献中，卷积有两种分类，这与所谓层的划分存在一致性。一类卷积是一个卷积层和一个池化层一起作为一层，这就是神经网络的<strong>Layer1</strong>。另一类卷积是把卷积层作为一层，而池化层单独作为一层。人们在计算神经网络有多少层时，通常只统计具有权重和参数的层。因为池化层没有权重和参数，只有一些超参数。这里，我们把<strong>CONV1</strong>和<strong>POOL1</strong>共同作为一个卷积，并标记为<strong>Layer1</strong>。虽然你在阅读网络文章或研究报告时，你可能会看到卷积层和池化层各为一层的情况，这只是两种不同的标记术语。一般我在统计网络层数时，只计算具有权重的层，也就是把<strong>CONV1</strong>和<strong>POOL1</strong>作为<strong>Layer1</strong>。这里我们用<strong>CONV1</strong>和<strong>POOL1</strong>来标记，两者都是神经网络<strong>Layer1</strong>的一部分，<strong>POOL1</strong>也被划分在<strong>Layer1</strong>中，因为它没有权重</p>
<h3 id="1-11-为什么使用卷积？（Why-convolutions-）"><a href="#1-11-为什么使用卷积？（Why-convolutions-）" class="headerlink" title="1.11 为什么使用卷积？（Why convolutions?）"></a>1.11 为什么使用卷积？（Why convolutions?）</h3><p>这是本周最后一节课，我们来分析一下卷积在神经网络中如此受用的原因，然后对如何整合这些卷积，如何通过一个标注过的训练集训练卷积神经网络做个简单概括。<strong>和只用全连接层相比，卷积层的两个主要优势在于参数共享和稀疏连接</strong>，举例说明一下。</p>
<h2 id="第二周-深度卷积网络：实例探究（Deep-convolutional-models-case-studies）"><a href="#第二周-深度卷积网络：实例探究（Deep-convolutional-models-case-studies）" class="headerlink" title="第二周 深度卷积网络：实例探究（Deep convolutional models: case studies）"></a>第二周 深度卷积网络：实例探究（Deep convolutional models: case studies）</h2><h3 id="2-1-为什么要进行实例探究？（Why-look-at-case-studies-）"><a href="#2-1-为什么要进行实例探究？（Why-look-at-case-studies-）" class="headerlink" title="2.1 为什么要进行实例探究？（Why look at case studies?）"></a>2.1 为什么要进行实例探究？（Why look at case studies?）</h3><h3 id="2-2-经典网络（Classic-networks）"><a href="#2-2-经典网络（Classic-networks）" class="headerlink" title="2.2 经典网络（Classic networks）"></a>2.2 经典网络（Classic networks）</h3><p>这节课，我们来学习几个经典的神经网络结构，分别是<strong>LeNet-5</strong>、<strong>AlexNet</strong>和<strong>VGGNet</strong></p>
<h3 id="2-3-残差网络-ResNets-（Residual-Networks-ResNets-）"><a href="#2-3-残差网络-ResNets-（Residual-Networks-ResNets-）" class="headerlink" title="2.3 残差网络(ResNets)（Residual Networks (ResNets)）"></a>2.3 残差网络(ResNets)（Residual Networks (ResNets)）</h3><h3 id="2-4-残差网络为什么有用？（Why-ResNets-work-）"><a href="#2-4-残差网络为什么有用？（Why-ResNets-work-）" class="headerlink" title="2.4 残差网络为什么有用？（Why ResNets work?）"></a>2.4 残差网络为什么有用？（Why ResNets work?）</h3><p>之所以能实现跳跃连接是因为<strong>same</strong>卷积保留了维度，所以很容易得出这个捷径连接，并输出这两个相同维度的向量。</p>
<p>结果表明，残差块学习这个恒等式函数并不难，跳跃连接使我们很容易得出$ a^{\left\lbrack l + 2 \right\rbrack} = a^{\left\lbrack l\right\rbrack}$。这意味着，即使给神经网络增加了这两层，它的效率也并不逊色于更简单的神经网络，因为学习恒等函数对它来说很简单。尽管它多了两层，也只把$a^{[l]}$的值赋值给$a^{\left\lbrack l + 2 \right\rbrack}$。所以给大型神经网络增加两层，不论是把残差块添加到神经网络的中间还是末端位置，都不会影响网络的表现。</p>
<p>残差网络起作用的主要原因就是这些残差块学习恒等函数非常容易，你能确定网络性能不会受到影响，很多时候甚至可以提高效率，或者说至少不会降低网络的效率，因此创建类似残差网络可以提升网络性能。</p>
<h3 id="2-5-网络中的网络以及-1×1-卷积（Network-in-Network-and-1×1-convolutions）"><a href="#2-5-网络中的网络以及-1×1-卷积（Network-in-Network-and-1×1-convolutions）" class="headerlink" title="2.5 网络中的网络以及 1×1 卷积（Network in Network and 1×1 convolutions）"></a>2.5 网络中的网络以及 1×1 卷积（Network in Network and 1×1 convolutions）</h3><h3 id="2-6-谷歌-Inception-网络简介（Inception-network-motivation）"><a href="#2-6-谷歌-Inception-网络简介（Inception-network-motivation）" class="headerlink" title="2.6 谷歌 Inception 网络简介（Inception network motivation）"></a>2.6 谷歌 Inception 网络简介（Inception network motivation）</h3><h3 id="2-7-Inception-网络（Inception-network）"><a href="#2-7-Inception-网络（Inception-network）" class="headerlink" title="2.7 Inception 网络（Inception network）"></a>2.7 Inception 网络（Inception network）</h3><h3 id="2-8-使用开源的实现方案（Using-open-source-implementations）"><a href="#2-8-使用开源的实现方案（Using-open-source-implementations）" class="headerlink" title="2.8 使用开源的实现方案（Using open-source implementations）"></a>2.8 使用开源的实现方案（Using open-source implementations）</h3><h3 id="2-9-迁移学习（Transfer-Learning）"><a href="#2-9-迁移学习（Transfer-Learning）" class="headerlink" title="2.9 迁移学习（Transfer Learning）"></a>2.9 迁移学习（Transfer Learning）</h3><h3 id="2-10-数据增强（Data-augmentation）"><a href="#2-10-数据增强（Data-augmentation）" class="headerlink" title="2.10 数据增强（Data augmentation）"></a>2.10 数据增强（Data augmentation）</h3><p>常用的实现数据扩充的方法是使用一个线程或者是多线程，这些可以用来加载数据，实现变形失真，然后传给其他的线程或者其他进程，来训练这个（编号2）和这个（编号1），可以并行实现。</p>
<p>这就是数据扩充，与训练深度神经网络的其他部分类似，在数据扩充过程中也有一些超参数，比如说颜色变化了多少，以及随机裁剪的时候使用的参数。与计算机视觉其他部分类似，一个好的开始可能是使用别人的开源实现，了解他们如何实现数据扩充。当然如果你想获得更多的不变特性，而其他人的开源实现并没有实现这个，你也可以去调整这些参数。因此，我希望你们可以使用数据扩充使你的计算机视觉应用效果更好。</p>
<h3 id="2-11-计算机视觉现状（The-state-of-computer-vision）"><a href="#2-11-计算机视觉现状（The-state-of-computer-vision）" class="headerlink" title="2.11 计算机视觉现状（The state of computer vision）"></a>2.11 计算机视觉现状（The state of computer vision）</h3><p>下面是一些有助于在基准测试中表现出色的小技巧</p>
<p>其中一个是集成，这就意味着在你想好了你想要的神经网络之后，可以独立训练几个神经网络，并平均它们的输出。比如说随机初始化三个、五个或者七个神经网络，然后训练所有这些网络，然后平均它们的输出。另外对他们的输出$\hat y$进行平均计算是很重要的，不要平均他们的权重，这是行不通的。看看你的7个神经网络，它们有7个不同的预测，然后平均他们，这可能会让你在基准上提高1%，2%或者更好。这会让你做得更好，也许有时会达到1%或2%，这真的能帮助你赢得比赛。但因为集成意味着要对每张图片进行测试，你可能需要在从3到15个不同的网络中运行一个图像，这是很典型的，因为这3到15个网络可能会让你的运行时间变慢，甚至更多时间，所以技巧之一的集成是人们在基准测试中表现出色和赢得比赛的利器，但我认为这几乎不用于生产服务于客户的，我想除非你有一个巨大的计算预算而且不介意在每个用户图像数据上花费大量的计算。</p>
<p>你在论文中可以看到在测试时，对进准测试有帮助的另一个技巧就是<strong>Multi-crop at test time</strong>，我的意思是你已经看到了如何进行数据扩充，<strong>Multi-crop</strong>是一种将数据扩充应用到你的测试图像中的一种形式。</p>
<p>集成的一个大问题是你需要保持所有这些不同的神经网络，这就占用了更多的计算机内存。对于<strong>multi-crop</strong>，我想你只保留一个网络，所以它不会占用太多的内存，但它仍然会让你的运行时间变慢。</p>
<p>这些是你看到的小技巧，研究论文也可以参考这些，但我个人并不倾向于在构建生产系统时使用这些方法，尽管它们在基准测试和竞赛上做得很好。</p>
<blockquote>
<p>不知道什么时候会用到机器视觉</p>
</blockquote>
<h2 id="第三周-目标检测（Object-detection）"><a href="#第三周-目标检测（Object-detection）" class="headerlink" title="第三周 目标检测（Object detection）"></a>第三周 目标检测（Object detection）</h2><h3 id="3-1-目标定位（Object-localization）"><a href="#3-1-目标定位（Object-localization）" class="headerlink" title="3.1 目标定位（Object localization）"></a>3.1 目标定位（Object localization）</h3><h3 id="3-2-特征点检测（Landmark-detection）"><a href="#3-2-特征点检测（Landmark-detection）" class="headerlink" title="3.2 特征点检测（Landmark detection）"></a>3.2 特征点检测（Landmark detection）</h3><h3 id="3-3-目标检测（Object-detection）"><a href="#3-3-目标检测（Object-detection）" class="headerlink" title="3.3 目标检测（Object detection）"></a>3.3 目标检测（Object detection）</h3><h3 id="3-4-滑动窗口的卷积实现（Convolutional-implementation-of-sliding-windows）"><a href="#3-4-滑动窗口的卷积实现（Convolutional-implementation-of-sliding-windows）" class="headerlink" title="3.4 滑动窗口的卷积实现（Convolutional implementation of sliding windows）"></a>3.4 滑动窗口的卷积实现（Convolutional implementation of sliding windows）</h3><p>为了构建滑动窗口的卷积应用，首先要知道如何把神经网络的全连接层转化成卷积层。</p>
<h3 id="3-5-Bounding-Box预测（Bounding-box-predictions）"><a href="#3-5-Bounding-Box预测（Bounding-box-predictions）" class="headerlink" title="3.5 Bounding Box预测（Bounding box predictions）"></a>3.5 Bounding Box预测（Bounding box predictions）</h3><p>在上一个视频中，你们学到了滑动窗口法的卷积实现，这个算法效率更高，但仍然存在问题，不能输出最精准的边界框。在这个视频中，我们看看如何得到更精准的边界框。</p>
<p>其中一个能得到更精准边界框的算法是<strong>YOLO</strong>算法，<strong>YOLO</strong>(<strong>You only look once</strong>)意思是你只看一次，这是由<strong>Joseph Redmon</strong>，<strong>Santosh Divvala</strong>，<strong>Ross Girshick</strong>和<strong>Ali Farhadi</strong>提出的算法。</p>
<p>是这么做的，比如你的输入图像是100×100的，然后在图像上放一个网格。为了介绍起来简单一些，我用3×3网格，实际实现时会用更精细的网格，可能是19×19。基本思路是使用图像分类和定位算法，前几个视频介绍过的，然后将算法应用到9个格子上。（基本思路是，采用图像分类和定位算法，本周第一个视频中介绍过的，逐一应用在图像的9个格子中。）更具体一点，你需要这样定义训练标签，所以对于9个格子中的每一个指定一个标签$y$，$y$是8维的，和你之前看到的一样，$y= \ \begin{bmatrix} p_{c} \\ b_{x} \\ b_{y} \\ b_{h} \\ b_{w} \\ c_{1} \\ c_{2}\\ c_{3} \\\end{bmatrix}$，$p_{c}$等于0或1取决于这个绿色格子中是否有图像。然后$b_{x}$、$b_{y}$、$b_{h}$和$b_{w}$作用就是，如果那个格子里有对象，那么就给出边界框坐标。然后$c_{1}$、$c_{2}$和$c_{3}$就是你想要识别的三个类别，背景类别不算，所以你尝试在背景类别中识别行人、汽车和摩托车，那么$c_{1}$、$c_{2}$和$c_{3}$可以是行人、汽车和摩托车类别。这张图里有9个格子，所以对于每个格子都有这么一个向量。</p>
<p>事实上<strong>YOLO</strong>算法有一个好处，也是它受欢迎的原因，因为这是一个卷积实现，实际上它的运行速度非常快，可以达到实时识别。</p>
<h3 id="3-6-交并比（Intersection-over-union）"><a href="#3-6-交并比（Intersection-over-union）" class="headerlink" title="3.6 交并比（Intersection over union）"></a>3.6 交并比（Intersection over union）</h3><p>在对象检测任务中，你希望能够同时定位对象，所以如果实际边界框是这样的，你的算法给出这个紫色的边界框，那么这个结果是好还是坏？所以交并比（<strong>loU</strong>）函数做的是计算两个边界框交集和并集之比。两个边界框的并集是这个区域，就是属于包含两个边界框区域（绿色阴影表示区域），而交集就是这个比较小的区域（橙色阴影表示区域），那么交并比就是交集的大小，这个橙色阴影面积，然后除以绿色阴影的并集面积。</p>
<p>一般约定，在计算机检测任务中，如果$loU≥0.5$，就说检测正确，如果预测器和实际边界框完美重叠，<strong>loU</strong>就是1，因为交集就等于并集。但一般来说只要$loU≥0.5$，那么结果是可以接受的，看起来还可以。一般约定，0.5是阈值，用来判断预测的边界框是否正确。一般是这么约定，但如果你希望更严格一点，你可以将<strong>loU</strong>定得更高，比如说大于0.6或者更大的数字，但<strong>loU</strong>越高，边界框越精确。</p>
<p>所以这是衡量定位精确度的一种方式，你只需要统计算法正确检测和定位对象的次数，你就可以用这样的定义判断对象定位是否准确。再次，0.5是人为约定，没有特别深的理论依据，如果你想更严格一点，可以把阈值定为0.6。有时我看到更严格的标准，比如0.6甚至0.7，但很少见到有人将阈值降到0.5以下。</p>
<p>人们定义<strong>loU</strong>这个概念是为了评价你的对象定位算法是否精准，但更一般地说，<strong>loU</strong>衡量了两个边界框重叠地相对大小。如果你有两个边界框，你可以计算交集，计算并集，然后求两个数值的比值，所以这也可以判断两个边界框是否相似，我们将在下一个视频中再次用到这个函数，当我们讨论非最大值抑制时再次用到。</p>
<h3 id="3-7-非极大值抑制（Non-max-suppression）"><a href="#3-7-非极大值抑制（Non-max-suppression）" class="headerlink" title="3.7 非极大值抑制（Non-max suppression）"></a>3.7 非极大值抑制（Non-max suppression）</h3><p>到目前为止你们学到的对象检测中的一个问题是，你的算法可能对同一个对象做出多次检测，所以算法不是对某个对象检测出一次，而是检测出多次。非极大值抑制这个方法可以确保你的算法对每个对象只检测一次</p>
<p>所以这就是非极大值抑制，非最大值意味着你只输出概率最大的分类结果，但抑制很接近，但不是最大的其他预测结果，所以这方法叫做非极大值抑制。</p>
<h3 id="3-8-Anchor-Boxes"><a href="#3-8-Anchor-Boxes" class="headerlink" title="3.8 Anchor Boxes"></a>3.8 Anchor Boxes</h3><p>到目前为止，对象检测中存在的一个问题是每个格子只能检测出一个对象，如果你想让一个格子检测出多个对象，你可以这么做，就是使用<strong>anchor box</strong>这个概念</p>
<p>这就是<strong>anchor box</strong>的概念，我们建立<strong>anchor box</strong>这个概念，是为了处理两个对象出现在同一个格子的情况，实践中这种情况很少发生，特别是如果你用的是19×19网格而不是3×3的网格，两个对象中点处于361个格子中同一个格子的概率很低，确实会出现，但出现频率不高。也许设立<strong>anchor box</strong>的好处在于<strong>anchor box</strong>能让你的学习算法能够更有征对性，特别是如果你的数据集有一些很高很瘦的对象，比如说行人，还有像汽车这样很宽的对象，这样你的算法就能更有针对性的处理，这样有一些输出单元可以针对检测很宽很胖的对象，比如说车子，然后输出一些单元，可以针对检测很高很瘦的对象，比如说行人。</p>
<p>最后，你应该怎么选择<strong>anchor box</strong>呢？人们一般手工指定<strong>anchor box</strong>形状，你可以选择5到10个<strong>anchor box</strong>形状，覆盖到多种不同的形状，可以涵盖你想要检测的对象的各种形状。还有一个更高级的版本，我就简单说一句，你们如果接触过一些机器学习，可能知道后期<strong>YOLO</strong>论文中有更好的做法，就是所谓的<strong>k-平均算法</strong>，可以将两类对象形状聚类，如果我们用它来选择一组<strong>anchor box</strong>，选择最具有代表性的一组<strong>anchor box</strong>，可以代表你试图检测的十几个对象类别，但这其实是自动选择<strong>anchor box</strong>的高级方法。如果你就人工选择一些形状，合理的考虑到所有对象的形状，你预计会检测的很高很瘦或者很宽很胖的对象，这应该也不难做。</p>
<h3 id="3-9-YOLO-算法（Putting-it-together-YOLO-algorithm）"><a href="#3-9-YOLO-算法（Putting-it-together-YOLO-algorithm）" class="headerlink" title="3.9 YOLO 算法（Putting it together: YOLO algorithm）"></a>3.9 YOLO 算法（Putting it together: YOLO algorithm）</h3><p>你们已经学到对象检测算法的大部分组件了，在这个视频里，我们会把所有组件组装在一起构成<strong>YOLO</strong>对象检测算法。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103420.png" alt></p>
<p>我们先看看如何构造你的训练集，假设你要训练一个算法去检测三种对象，行人、汽车和摩托车，你还需要显式指定完整的背景类别。这里有3个类别标签，如果你要用两个<strong>anchor box</strong>，那么输出 $y$ 就是3×3×2×8，其中3×3表示3×3个网格，2是<strong>anchor box</strong>的数量，8是向量维度，8实际上先是5（$p_{c},b_{x},b_{y},b_{h},b_{w}$）再加上类别的数量（$c_{1},c_{2},c_{3}$）。你可以将它看成是3×3×2×8，或者3×3×16。要构造训练集，你需要遍历9个格子，然后构成对应的目标向量$y$。</p>
<p><img src="../../../%E6%9A%82%E5%AD%98/%E5%90%B4%E6%81%A9%E8%BE%BE/images/36ff927836cfcd7fee9413e2d34757d8.png" alt></p>
<p>所以先看看第一个格子（编号1），里面没什么有价值的东西，行人、车子和摩托车，三个类别都没有出现在左上格子中，所以对应那个格子目标$y$就是这样的，$y= \begin{bmatrix} 0 &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; 0 &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ?\\ \end{bmatrix}^{T}$，第一个<strong>anchor box</strong>的 $p_{c}$ 是0，因为没什么和第一个<strong>anchor box</strong>有关的，第二个<strong>anchor box</strong>的 $p_{c}$ 也是0，剩下这些值是<strong>don’t care-s</strong>。</p>
<p>现在网格中大多数格子都是空的，但那里的格子（编号2）会有这个目标向量$y$，$y =\begin{bmatrix} 0 &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; 1 &amp; b_{x} &amp; b_{y} &amp; b_{h} &amp;b_{w} &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}^{T}$，所以假设你的训练集中，对于车子有这样一个边界框（编号3），水平方向更长一点。所以如果这是你的<strong>anchor box</strong>，这是<strong>anchor box 1</strong>（编号4），这是<strong>anchor box 2</strong>（编号5），然后红框和<strong>anchor box 2</strong>的交并比更高，那么车子就和向量的下半部分相关。要注意，这里和<strong>anchor box 1</strong>有关的 $p_{c}$ 是0，剩下这些分量都是<strong>don’t care-s</strong>，然后你的第二个 $p_{c} =1$，然后你要用这些（$b_{x},b_{y},b_{h},b_{w}$）来指定红边界框的位置，然后指定它的正确类别是2($c_{1}= 0 ,c_{2} = 1,c_{3} = 0$)，对吧，这是一辆汽车。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103426.png" alt></p>
<p>所以你这样遍历9个格子，遍历3×3网格的所有位置，你会得到这样一个向量，得到一个16维向量，所以最终输出尺寸就是3×3×16。和之前一样，简单起见，我在这里用的是3×3网格，实践中用的可能是19×19×16，或者需要用到更多的<strong>anchor box</strong>，可能是19×19×5×8，即19×19×40，用了5个<strong>anchor box</strong>。这就是训练集，然后你训练一个卷积网络，输入是图片，可能是100×100×3，然后你的卷积网络最后输出尺寸是，在我们例子中是3×3×16或者3×3×2×8。</p>
<p>接下来我们看看你的算法是怎样做出预测的，输入图像，你的神经网络的输出尺寸是这个3×3×2×8，对于9个格子，每个都有对应的向量。对于左上的格子（编号1），那里没有任何对象，那么我们希望你的神经网络在那里（第一个$p_{c}$）输出的是0，这里（第二个$p_{c}$）是0，然后我们输出一些值，你的神经网络不能输出问号，不能输出<strong>don’t care-s</strong>，剩下的我输入一些数字，但这些数字基本上会被忽略，因为神经网络告诉你，那里没有任何东西，所以输出是不是对应一个类别的边界框无关紧要，所以基本上是一组数字，多多少少都是噪音（输出 $y$ 如编号3所示）。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103430.png" alt></p>
<p>和这里的边界框不大一样，希望$y$的值，那个左下格子（编号2）的输出$y$（编号4所示），形式是，对于边界框1来说（$p_{c}$）是0，然后就是一组数字，就是噪音（<strong>anchor box 1</strong>对应行人，此格子中无行人，$p_{c} = 0,b_{x} = ?,b_{y} = ?,b_{h} = ?,b_{w} = ?,c_{1} = ?c_{2} = ?,c_{3} =?$）。希望你的算法能输出一些数字，可以对车子指定一个相当准确的边界框（<strong>anchor box 2</strong>对应汽车，此格子中有车，$ p_{c} = 1,b_{x},b_{y},b_{h},b_{w},c_{1} = 0,c_{2}= 1,c_{3} = 0$），这就是神经网络做出预测的过程。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103438.png" alt></p>
<p>最后你要运行一下这个非极大值抑制，为了让内容更有趣一些，我们看看一张新的测试图像，这就是运行非极大值抑制的过程。如果你使用两个<strong>anchor box</strong>，那么对于9个格子中任何一个都会有两个预测的边界框，其中一个的概率$p_{c}$很低。但9个格子中，每个都有两个预测的边界框，比如说我们得到的边界框是是这样的，注意有一些边界框可以超出所在格子的高度和宽度（编号1所示）。接下来你抛弃概率很低的预测，去掉这些连神经网络都说，这里很可能什么都没有，所以你需要抛弃这些（编号2所示）。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103446.png" alt></p>
<p>最后，如果你有三个对象检测类别，你希望检测行人，汽车和摩托车，那么你要做的是，对于每个类别单独运行非极大值抑制，处理预测结果所属类别的边界框，用非极大值抑制来处理行人类别，用非极大值抑制处理车子类别，然后对摩托车类别进行非极大值抑制，运行三次来得到最终的预测结果。所以算法的输出最好能够检测出图像里所有的车子，还有所有的行人（编号3所示）。</p>
<p>这就是<strong>YOLO</strong>对象检测算法，这实际上是最有效的对象检测算法之一，包含了整个计算机视觉对象检测领域文献中很多最精妙的思路。</p>
<h3 id="3-10-候选区域（选修）（Region-proposals-Optional-）"><a href="#3-10-候选区域（选修）（Region-proposals-Optional-）" class="headerlink" title="3.10 候选区域（选修）（Region proposals (Optional)）"></a>3.10 候选区域（选修）（Region proposals (Optional)）</h3><p>如果你们阅读一下对象检测的文献，可能会看到一组概念，所谓的候选区域，这在计算机视觉领域是非常有影响力的概念。我把这个视频定为可选视频是因为我用到候选区域这一系列算法的频率没有那么高，但当然了，这些工作是很有影响力的，你们在工作中也可能会碰到，我们来看看。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103551.png" alt></p>
<p>你们还记得滑动窗法吧，你使用训练过的分类器，在这些窗口中全部运行一遍，然后运行一个检测器，看看里面是否有车辆，行人和摩托车。现在你也可以运行一下卷积算法，这个算法的其中一个缺点是，它在显然没有任何对象的区域浪费时间，对吧。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103559.png" alt></p>
<p>所以这里这个矩形区域（编号1）基本是空的，显然没有什么需要分类的东西。也许算法会在这个矩形上（编号2）运行，而你知道上面没有什么有趣的东西。</p>
<p>[<strong>Girshick R, Donahue J, Darrell T, et al. Rich feature hierarchies for accurate object detection and semantic segmentation[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2014: 580-587.</strong>]</p>
<p>所以<strong>Ross Girshick</strong>，<strong>Jeff Donahue</strong>，<strong>Trevor Darrell</strong>，<strong>Jitendra Malik</strong>，在本幻灯片底部引用到的论文中提出一种叫做<strong>R-CNN</strong>的算法，意思是带区域的卷积网络，或者说带区域的<strong>CNN</strong>。这个算法尝试选出一些区域，在这些区域上运行卷积网络分类器是有意义的，所以这里不再针对每个滑动窗运行检测算法，而是只选择一些窗口，在少数窗口上运行卷积网络分类器。</p>
<p>选出候选区域的方法是运行图像分割算法，分割的结果是下边的图像，为了找出可能存在对象的区域。比如说，分割算法在这里得到一个色块，所以你可能会选择这样的边界框（编号1），然后在这个色块上运行分类器，就像这个绿色的东西（编号2），在这里找到一个色块，接下来我们还会在那个矩形上（编号2）运行一次分类器，看看有没有东西。在这种情况下，如果在蓝色色块上（编号3）运行分类器，希望你能检测出一个行人，如果你在青色色块(编号4)上运行算法，也许你可以发现一辆车，我也不确定。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103602.png" alt></p>
<p>所以这个细节就是所谓的分割算法，你先找出可能2000多个色块，然后在这2000个色块上放置边界框，然后在这2000个色块上运行分类器，这样需要处理的位置可能要少的多，可以减少卷积网络分类器运行时间，比在图像所有位置运行一遍分类器要快。特别是这种情况，现在不仅是在方形区域（编号5）中运行卷积网络，我们还会在高高瘦瘦（编号6）的区域运行，尝试检测出行人，然后我们在很宽很胖的区域（编号7）运行，尝试检测出车辆，同时在各种尺度运行分类器。</p>
<p>这就是<strong>R-CNN</strong>或者<strong>区域CNN</strong>的特色概念，现在看来<strong>R-CNN</strong>算法还是很慢的。所以有一系列的研究工作去改进这个算法，所以基本的<strong>R-CNN</strong>算法是使用某种算法求出候选区域，然后对每个候选区域运行一下分类器，每个区域会输出一个标签，有没有车子？有没有行人？有没有摩托车？并输出一个边界框，这样你就能在确实存在对象的区域得到一个精确的边界框。</p>
<p>澄清一下，<strong>R-CNN</strong>算法不会直接信任输入的边界框，它也会输出一个边界框$b_{x}$，$b_{y}$，$b_{h}$和$b_{w}$，这样得到的边界框比较精确，比单纯使用图像分割算法给出的色块边界要好，所以它可以得到相当精确的边界框。</p>
<p>现在<strong>R-CNN</strong>算法的一个缺点是太慢了，所以这些年来有一些对<strong>R-CNN</strong>算法的改进工作，<strong>Ross Girshik</strong>提出了快速的<strong>R-CNN</strong>算法，它基本上是<strong>R-CNN</strong>算法，不过用卷积实现了滑动窗法。最初的算法是逐一对区域分类的，所以快速<strong>R-CNN</strong>用的是滑动窗法的一个卷积实现，这和你在本周第四个视频（3.4 卷积的滑动窗口实现）中看到的大致相似，这显著提升了<strong>R-CNN</strong>的速度。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103607.png" alt></p>
<p>事实证明，<strong>Fast R-CNN</strong>算法的其中一个问题是得到候选区域的聚类步骤仍然非常缓慢，所以另一个研究组，<strong>任少卿</strong>（<strong>Shaoqing Ren</strong>）、<strong>何凯明</strong>（<strong>Kaiming He</strong>）、<strong>Ross Girshick</strong>和<strong>孙剑</strong>（<strong>Jiangxi Sun</strong>）提出了更快的<strong>R-CNN</strong>算法（<strong>Faster R-CNN</strong>），使用的是卷积神经网络，而不是更传统的分割算法来获得候选区域色块，结果比<strong>Fast R-CNN</strong>算法快得多。不过我认为大多数更快<strong>R-CNN</strong>的算法实现还是比<strong>YOLO</strong>算法慢很多。</p>
<p>候选区域的概念在计算机视觉领域的影响力相当大，所以我希望你们能了解一下这些算法，因为你可以看到还有人在用这些概念。对我个人来说，这是我的个人看法而不是整个计算机视觉研究界的看法，我觉得候选区域是一个有趣的想法，但这个方法需要两步，首先得到候选区域，然后再分类，相比之下，能够一步做完，类似于<strong>YOLO</strong>或者你只看一次（<strong>You only look once</strong>）这个算法，在我看来，是长远而言更有希望的方向。但这是我的个人看法，而不是整个计算机视觉研究界的看法，所以你们最好批判接受。但我想这个<strong>R-CNN</strong>概念，你可能会想到，或者碰到其他人在用，所以这也是值得了解的，这样你可以更好地理解别人的算法。</p>
<h2 id="第四周-特殊应用：人脸识别和神经风格转换（Special-applications-Face-recognition-amp-Neural-style-transfer）"><a href="#第四周-特殊应用：人脸识别和神经风格转换（Special-applications-Face-recognition-amp-Neural-style-transfer）" class="headerlink" title="第四周 特殊应用：人脸识别和神经风格转换（Special applications: Face recognition &amp;Neural style transfer）"></a>第四周 特殊应用：人脸识别和神经风格转换（Special applications: Face recognition &amp;Neural style transfer）</h2><h3 id="4-1-什么是人脸识别？"><a href="#4-1-什么是人脸识别？" class="headerlink" title="4.1 什么是人脸识别？"></a>4.1 什么是人脸识别？</h3><h3 id="4-2-One-Shot学习（One-shot-learning）"><a href="#4-2-One-Shot学习（One-shot-learning）" class="headerlink" title="4.2 One-Shot学习（One-shot learning）"></a>4.2 One-Shot学习（One-shot learning）</h3><p>所以要让人脸识别能够做到一次学习，为了能有更好的效果，你现在要做的应该是学习<strong>Similarity</strong>函数。详细地说，你想要神经网络学习这样一个用$d$表示的函数，$d(img1,img2) = degree\ of\ difference\ between\ images$，它以两张图片作为输入，然后输出这两张图片的差异值。如果你放进同一个人的两张照片，你希望它能输出一个很小的值，如果放进两个长相差别很大的人的照片，它就输出一个很大的值。所以在识别过程中，如果这两张图片的差异值小于某个阈值$\tau$，它是一个超参数，那么这时就能预测这两张图片是同一个人，如果差异值大于τ，就能预测这是不同的两个人，这就是解决人脸验证问题的一个可行办法。</p>
<h3 id="4-3-Siamese-网络（Siamese-network）"><a href="#4-3-Siamese-网络（Siamese-network）" class="headerlink" title="4.3 Siamese 网络（Siamese network）"></a>4.3 Siamese 网络（Siamese network）</h3><p>对于两个不同的输入，运行相同的卷积神经网络，然后比较它们，这一般叫做<strong>Siamese</strong>网络架构。这里提到的很多观点，都来自于<strong>Yaniv Taigman</strong>，<strong>Ming Yang</strong>，<strong>Marc’ Aurelio Ranzato</strong>，<strong>Lior Wolf</strong>的这篇论文，他们开发的系统叫做<strong>DeepFace</strong>。</p>
<p>怎么训练这个<strong>Siamese</strong>神经网络呢？不要忘了这两个网络有相同的参数，所以你实际要做的就是训练一个网络，它计算得到的编码可以用于函数$d$，它可以告诉你两张图片是否是同一个人。更准确地说，神经网络的参数定义了一个编码函数$f(x^{(i)})$，如果给定输入图像$x^{(i)}$，这个网络会输出$x^{(i)}$的128维的编码。你要做的就是学习参数，使得如果两个图片$x^{( i)}$和$x^{( j)}$是同一个人，那么你得到的两个编码的距离就小。前面几个幻灯片我都用的是$x^{(1)}$和$x^{( 2)}$，其实训练集里任意一对$x^{(i)}$和$x^{(j)}$都可以。相反，如果$x^{(i)}$和$x^{(j)}$是不同的人，那么你会想让它们之间的编码距离大一点。</p>
<h3 id="4-4-Triplet-损失"><a href="#4-4-Triplet-损失" class="headerlink" title="4.4 Triplet 损失"></a>4.4 Triplet 损失</h3><p>想通过学习神经网络的参数来得到优质的人脸图片编码，方法之一就是定义三元组损失函数然后应用梯度下降。</p>
<p>用三元组损失的术语来说，你要做的通常是看一个 <strong>Anchor</strong> 图片，你想让<strong>Anchor</strong>图片和<strong>Positive</strong>图片（<strong>Positive</strong>意味着是同一个人）的距离很接近。然而，当<strong>Anchor</strong>图片与<strong>Negative</strong>图片（<strong>Negative</strong>意味着是非同一个人）对比时，你会想让他们的距离离得更远一点。</p>
<p>这就是为什么叫做三元组损失，它代表你通常会同时看三张图片，你需要看<strong>Anchor</strong>图片、<strong>Postive</strong>图片，还有<strong>Negative</strong>图片，我要把<strong>Anchor</strong>图片、<strong>Positive</strong>图片和<strong>Negative</strong>图片简写成$A$、$P$、$N$。</p>
<p>把这些写成公式的话，你想要的是网络的参数或者编码能够满足以下特性，也就是说你想要$|| f(A) - f(P) ||^{2}$，你希望这个数值很小，准确地说，你想让它小于等$f(A)$和$f(N)$之间的距离，或者说是它们的范数的平方（即：$|| f(A) - f(P)||^{2} \leq ||f(A) - f(N)||^{2}$）。（$|| f(A) - f(P) ||^{2}$）当然这就是$d(A,P)$，（$|| f(A) - f(N) ||^{2}$）这是$d(A,N)$，你可以把$d$ 看作是距离(<strong>distance</strong>)函数，这也是为什么我们把它命名为$d$。</p>
<p>现在如果我把方程右边项移到左边，最终就得到：</p>
<p>$|| f(A) - f(P)||^{2} \leq ||f(A) - f(N)||^{2}$</p>
<p>现在我要对这个表达式做一些小的改变，有一种情况满足这个表达式，但是没有用处，就是把所有的东西都学成0，如果$f$总是输出0，即0-0≤0，这就是0减去0还等于0，如果所有图像的$f$都是一个零向量，那么总能满足这个方程。所以为了确保网络对于所有的编码不会总是输出0，也为了确保它不会把所有的编码都设成互相相等的。另一种方法能让网络得到这种没用的输出，就是如果每个图片的编码和其他图片一样，这种情况，你还是得到0-0。</p>
<p>为了阻止网络出现这种情况，我们需要修改这个目标，也就是，这个不能是刚好小于等于0，应该是比0还要小，所以这个应该小于一个$-a$值（即$|| f(A) - f(P)||^{2} -||f(A) - f(N)||^{2} \leq -a$），这里的$a$是另一个超参数，这个就可以阻止网络输出无用的结果。按照惯例，我们习惯写$+a$（即$|| f(A) - f(P)||^{2} -||f(A) - f(N)||^{2} +a\leq0$），而不是把$-a$写在后面，它也叫做间隔(<strong>margin</strong>)，这个术语你会很熟悉，如果你看过关于支持向量机 (<strong>SVM</strong>)的文献，没看过也不用担心。我们可以把上面这个方程（$|| f(A) - f(P)||^{2}  -||f(A) - f(N)||^{2}$）也修改一下，加上这个间隔参数。</p>
<p>接下来我们定义损失函数，这个例子的损失函数，它的定义基于三元图片组，我先从前一张幻灯片复制过来一些式子，就是$|| f( A) - f( P)||^{2} -||f( A) - f( N)||^{2} +a \leq0$。所以为了定义这个损失函数，我们取这个和0的最大值：</p>
<p>$L( A,P,N) = max(|| f( A) - f( P)||^{2} -|| f( A) - f( N)||^{2} + a,0)$</p>
<p>这个$max$函数的作用就是，只要这个$|| f( A) - f( P)||^{2} -|| f( A) - f( N)||^{2} + a\leq0$，那么损失函数就是0。只要你能使画绿色下划线部分小于等于0，只要你能达到这个目标，那么这个例子的损失就是0。</p>
<p>另一方面如果这个$|| f( A) - f( P)||^{2} -|| f( A) - f( N)||^{2} + a\leq0$，然后你取它们的最大值，最终你会得到绿色下划线部分（即$|| f(A) - f( P)||^{2} -|| f( A) - f( N)||^{2} +a$）是最大值，这样你会得到一个正的损失值。通过最小化这个损失函数达到的效果就是使这部分$|| f( A) - f( P)||^{2} -||f( A) - f( N)||^{2} +a$成为0，或者小于等于0。只要这个损失函数小于等于0，网络不会关心它负值有多大。</p>
<p>这是一个三元组定义的损失，整个网络的代价函数应该是训练集中这些单个三元组损失的总和。假如你有一个10000个图片的训练集，里面是1000个不同的人的照片，你要做的就是取这10000个图片，然后生成这样的三元组，然后训练你的学习算法，对这种代价函数用梯度下降，这个代价函数就是定义在你数据集里的这样的三元组图片上。</p>
<p>注意，为了定义三元组的数据集你需要成对的$A$和$P$，即同一个人的成对的图片，为了训练你的系统你确实需要一个数据集，里面有同一个人的多个照片。这是为什么在这个例子中，我说假设你有1000个不同的人的10000张照片，也许是这1000个人平均每个人10张照片，组成了你整个数据集。如果你只有每个人一张照片，那么根本没法训练这个系统。当然，训练完这个系统之后，你可以应用到你的一次学习问题上，对于你的人脸识别系统，可能你只有想要识别的某个人的一张照片。但对于训练集，你需要确保有同一个人的多个图片，至少是你训练集里的一部分人，这样就有成对的<strong>Anchor</strong>和<strong>Positive</strong>图片了。</p>
<p>所以为了构建一个数据集，你要做的就是尽可能选择难训练的三元组$A$、$P$和$N$。具体而言，你想要所有的三元组都满足这个条件（$d(A,P) + a \leq d(A,N)$），难训练的三元组就是，你的$A$、$P$和$N$的选择使得$d(A,P)$很接近$d(A,N)$，即$d(A,P) \approx d(A,N)$，这样你的学习算法会竭尽全力使右边这个式子变大（$d(A,N)$），或者使左边这个式子（$d(A,P)$）变小，这样左右两边至少有一个$a$的间隔。并且选择这样的三元组还可以增加你的学习算法的计算效率，如果随机的选择这些三元组，其中有太多会很简单，梯度算法不会有什么效果，因为网络总是很轻松就能得到正确的结果，只有选择难的三元组梯度下降法才能发挥作用，使得这两边离得尽可能远。</p>
<h3 id="4-5-人脸验证与二分类（Face-verification-and-binary-classification）"><a href="#4-5-人脸验证与二分类（Face-verification-and-binary-classification）" class="headerlink" title="4.5 人脸验证与二分类（Face verification and binary classification）"></a>4.5 人脸验证与二分类（Face verification and binary classification）</h3><p>总结一下，把人脸验证当作一个监督学习，创建一个只有成对图片的训练集，不是三个一组，而是成对的图片，目标标签是1表示一对图片是一个人，目标标签是0表示图片中是不同的人。利用不同的成对图片，使用反向传播算法去训练神经网络，训练<strong>Siamese</strong>神经网络。</p>
<h3 id="4-6-什么是神经风格迁移？（What-is-neural-style-transfer-）"><a href="#4-6-什么是神经风格迁移？（What-is-neural-style-transfer-）" class="headerlink" title="4.6 什么是神经风格迁移？（What is neural style transfer?）"></a>4.6 什么是神经风格迁移？（What is neural style transfer?）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628104629.png" alt></p>
<h3 id="4-7-CNN特征可视化（What-are-deep-ConvNets-learning-）"><a href="#4-7-CNN特征可视化（What-are-deep-ConvNets-learning-）" class="headerlink" title="4.7 CNN特征可视化（What are deep ConvNets learning?）"></a>4.7 CNN特征可视化（What are deep ConvNets learning?）</h3><h3 id="4-8-代价函数（Cost-function）"><a href="#4-8-代价函数（Cost-function）" class="headerlink" title="4.8 代价函数（Cost function）"></a>4.8 代价函数（Cost function）</h3><p>记住我们的问题，给你一个内容图像$C$，给定一个风格图片$S$，而你的目标是生成一个新图片$G$。为了实现神经风格迁移，你要做的是定义一个关于$G$的代价函数$J$用来评判某个生成图像的好坏，我们将使用梯度下降法去最小化$J(G)$，以便于生成这个图像。</p>
<p>怎么判断生成图像的好坏呢？我们把这个代价函数定义为两个部分。</p>
<p>$J_{\text{content}}(C,G)$</p>
<p>第一部分被称作内容代价，这是一个关于内容图片和生成图片的函数，它是用来度量生成图片$G$的内容与内容图片$C$的内容有多相似。</p>
<p>$J_{\text{style}}(S,G)$</p>
<p>然后我们会把结果加上一个风格代价函数，也就是关于$S$和$G$的函数，用来度量图片$G$的风格和图片$S$的风格的相似度。</p>
<p>$J( G) = a J_{\text{content}}( C,G) + \beta J_{\text{style}}(S,G)$</p>
<p>最后我们用两个超参数$a$和$\beta$来来确定内容代价和风格代价，两者之间的权重用两个超参数来确定。两个代价的权重似乎是多余的，我觉得一个超参数似乎就够了，但提出神经风格迁移的原始作者使用了两个不同的超参数，我准备保持一致。</p>
<p>关于神经风格迁移算法我将在接下来几段视频中展示的，是基于<strong>Leon Gatys</strong>， <strong>Alexandra Ecker</strong>和<strong>Matthias Bethge</strong>的这篇论文。这篇论文并不是很难读懂，如果你愿意，看完这些视频，我也非常推荐你去看看他们的论文。</p>
<p><strong>Leon A. Gatys, Alexander S. Ecker, Matthias Bethge, (2015). A Neural Algorithm of Artistic Style</strong> (<a href="https://arxiv.org/abs/1508.06576" target="_blank" rel="noopener">https://arxiv.org/abs/1508.06576</a>)</p>
<h3 id="4-9-内容代价函数（Content-cost-function）"><a href="#4-9-内容代价函数（Content-cost-function）" class="headerlink" title="4.9 内容代价函数（Content cost function）"></a>4.9 内容代价函数（Content cost function）</h3><p>现在你需要衡量假如有一个内容图片和一个生成图片他们在内容上的相似度，我们令这个$a^{[l][C]}$和$a^{[l][G]}$，代表这两个图片$C$和$G$的$l$层的激活函数值。如果这两个激活值相似，那么就意味着两个图片的内容相似。</p>
<p>我们定义这个</p>
<p>$J_{\text{content}}( C,G) = \frac{1}{2}|| a^{[l][C]} - a^{[l][G]}||^{2}$</p>
<h3 id="4-10-风格代价函数（Style-cost-function）"><a href="#4-10-风格代价函数（Style-cost-function）" class="headerlink" title="4.10 风格代价函数（Style cost function）"></a>4.10 风格代价函数（Style cost function）</h3><p>比如你有这样一张图片，你可能已经对这个计算很熟悉了，它能算出这里是否含有不同隐藏层。现在你选择了某一层$l$（编号1），比如这一层去为图片的风格定义一个深度测量，现在我们要做的就是将图片的风格定义为$l$层中各个通道之间激活项的相关系数。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105250.png" alt></p>
<h3 id="4-11-一维到三维推广（1D-and-3D-generalizations-of-models）"><a href="#4-11-一维到三维推广（1D-and-3D-generalizations-of-models）" class="headerlink" title="4.11 一维到三维推广（1D and 3D generalizations of models）"></a>4.11 一维到三维推广（1D and 3D generalizations of models）</h3><blockquote>
<p>一下就快到了晚上十点了，晚安早点睡。</p>
</blockquote>
<h1 id="第五门课-序列模型-Sequence-Models"><a href="#第五门课-序列模型-Sequence-Models" class="headerlink" title="第五门课 序列模型(Sequence Models)"></a>第五门课 序列模型(Sequence Models)</h1><h2 id="第一周-循环序列模型（Recurrent-Neural-Networks）"><a href="#第一周-循环序列模型（Recurrent-Neural-Networks）" class="headerlink" title="第一周 循环序列模型（Recurrent Neural Networks）"></a>第一周 循环序列模型（Recurrent Neural Networks）</h2><h3 id="1-1-为什么选择序列模型？（Why-Sequence-Models-）"><a href="#1-1-为什么选择序列模型？（Why-Sequence-Models-）" class="headerlink" title="1.1 为什么选择序列模型？（Why Sequence Models?）"></a>1.1 为什么选择序列模型？（Why Sequence Models?）</h3><p>要想了解到这个模型学到了什么，一种非正式的方法就是进行一次新序列采样</p>
<h3 id="1-2-数学符号（Notation）"><a href="#1-2-数学符号（Notation）" class="headerlink" title="1.2 数学符号（Notation）"></a>1.2 数学符号（Notation）</h3><p>如果你遇到了一个不在你词表中的单词，答案就是创建一个新的标记，也就是一个叫做<strong>Unknow Word</strong>的伪造单词，用\&lt;<strong>UNK</strong>&gt;作为标记，来表示不在词表中的单词</p>
<h3 id="1-3-循环神经网络模型（Recurrent-Neural-Network-Model）"><a href="#1-3-循环神经网络模型（Recurrent-Neural-Network-Model）" class="headerlink" title="1.3 循环神经网络模型（Recurrent Neural Network Model）"></a>1.3 循环神经网络模型（Recurrent Neural Network Model）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105640.png" alt="140529e4d7531babb5ba21778cd88bc3"></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105707.png" alt></p>
<p>循环神经网络用的激活函数经常是<strong>tanh</strong>，不过有时候也会用<strong>ReLU</strong>，但是<strong>tanh</strong>是更通常的选择，我们有其他方法来避免梯度消失问题，我们将在之后进行讲述。选用哪个激活函数是取决于你的输出$y$，如果它是一个二分问题，那么我猜你会用<strong>sigmoid</strong>函数作为激活函数，如果是$k$类别分类问题的话，那么可以选用<strong>softmax</strong>作为激活函数。不过这里激活函数的类型取决于你有什么样类型的输出$y$，对于命名实体识别来说$y$只可能是0或者1，那我猜这里第二个激活函数$g$可以是<strong>sigmoid</strong>激活函数。</p>
<h3 id="1-4-通过时间的反向传播（Backpropagation-through-time）"><a href="#1-4-通过时间的反向传播（Backpropagation-through-time）" class="headerlink" title="1.4 通过时间的反向传播（Backpropagation through time）"></a>1.4 通过时间的反向传播（Backpropagation through time）</h3><p>在这个反向传播的过程中，最重要的信息传递或者说最重要的递归运算就是这个从右到左的运算，这也就是为什么这个算法有一个很别致的名字，叫做<strong>“通过（穿越）时间反向传播</strong>（<strong>backpropagation through time</strong>）”。取这个名字的原因是对于前向传播，你需要从左到右进行计算，在这个过程中，时刻$t$不断增加。而对于反向传播，你需要从右到左进行计算，就像时间倒流。“通过时间反向传播”，就像穿越时光，这种说法听起来就像是你需要一台时光机来实现这个算法一样。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105829.png" alt="nn_cell_backpro"></p>
<h3 id="1-5-不同类型的循环神经网络（Different-types-of-RNNs）"><a href="#1-5-不同类型的循环神经网络（Different-types-of-RNNs）" class="headerlink" title="1.5 不同类型的循环神经网络（Different types of RNNs）"></a>1.5 不同类型的循环神经网络（Different types of <strong>RNN</strong>s）</h3><p>这个视频的内容参考了<strong>Andrej Karpathy</strong>的博客，一篇叫做《循环神经网络的非理性效果》（“<strong>The Unreasonable Effectiveness of Recurrent Neural Networks</strong>”）的文章，我们看一些例子。</p>
<p>“<strong>多对多</strong>”、“<strong>多对一</strong>”、“<strong>一对一</strong>”和“<strong>一对多</strong>”的结构</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105923.png" alt></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105923.png" alt></p>
<h3 id="1-6-语言模型和序列生成（Language-model-and-sequence-generation）"><a href="#1-6-语言模型和序列生成（Language-model-and-sequence-generation）" class="headerlink" title="1.6 语言模型和序列生成（Language model and sequence generation）"></a>1.6 语言模型和序列生成（Language model and sequence generation）</h3><p>所以语言模型所做的就是，它会告诉你某个特定的句子它出现的概率是多少，根据我所说的这个概率，假设你随机拿起一张报纸，打开任意邮件，或者任意网页或者听某人说下一句话，并且这个人是你的朋友，这个你即将从世界上的某个地方得到的句子会是某个特定句子的概率是多少，例如“<strong>the apple and pear salad</strong>”。它是两种系统的基本组成部分，一个刚才所说的语音识别系统，还有机器翻译系统，它要能正确输出最接近的句子。而语言模型做的最基本工作就是输入一个句子，准确地说是一个文本序列，$y^{&lt;1&gt;}$，$y^{&lt;2&gt;}$一直到$y^{&lt;T_{y}&gt;}$。对于语言模型来说，用$y$来表示这些序列比用$x$来表示要更好，然后语言模型会估计某个句子序列中各个单词出现的可能性。</p>
<p>那么如何建立一个语言模型呢？为了使用<strong>RNN</strong>建立出这样的模型，你首先需要一个训练集，包含一个很大的英文文本语料库（<strong>corpus</strong>）或者其它的语言，你想用于构建模型的语言的语料库。语料库是自然语言处理的一个专有名词，意思就是很长的或者说数量众多的英文句子组成的文本。</p>
<h3 id="1-7-对新序列采样（Sampling-novel-sequences）"><a href="#1-7-对新序列采样（Sampling-novel-sequences）" class="headerlink" title="1.7 对新序列采样（Sampling novel sequences）"></a>1.7 对新序列采样（Sampling novel sequences）</h3><p>这些就是基础的<strong>RNN</strong>结构和如何去建立一个语言模型并使用它，对于训练出的语言模型进行采样。在之后的视频中，我想探讨在训练<strong>RNN</strong>时一些更加深入的挑战以及如何适应这些挑战，特别是梯度消失问题来建立更加强大的<strong>RNN</strong>模型。下节课，我们将谈到梯度消失并且会开始谈到<strong>GRU</strong>，也就是门控循环单元和<strong>LSTM</strong>长期记忆网络模型。</p>
<h3 id="1-8-循环神经网络的梯度消失（Vanishing-gradients-with-RNNs）"><a href="#1-8-循环神经网络的梯度消失（Vanishing-gradients-with-RNNs）" class="headerlink" title="1.8 循环神经网络的梯度消失（Vanishing gradients with RNNs）"></a>1.8 循环神经网络的梯度消失（Vanishing gradients with <strong>RNN</strong>s）</h3><p>你应该还记得之前讨论的训练很深的网络，我们讨论了梯度消失的问题。比如说一个很深很深的网络（上图编号4所示），100层，甚至更深，对这个网络从左到右做前向传播然后再反向传播。我们知道如果这是个很深的神经网络，从输出$\hat y$得到的梯度很难传播回去，很难影响靠前层的权重，很难影响前面层（编号5所示的层）的计算。</p>
<p>对于有同样问题的<strong>RNN</strong>，首先从左到右前向传播，然后反向传播。但是反向传播会很困难，因为同样的梯度消失的问题，后面层的输出误差（上图编号6所示）很难影响前面层（上图编号7所示的层）的计算。这就意味着，实际上很难让一个神经网络能够意识到它要记住看到的是单数名词还是复数名词，然后在序列后面生成依赖单复数形式的<strong>was</strong>或者<strong>were</strong>。而且在英语里面，这中间的内容（上图编号8所示）可以任意长，对吧？所以你需要长时间记住单词是单数还是复数，这样后面的句子才能用到这些信息。也正是这个原因，所以基本的<strong>RNN</strong>模型会有很多局部影响，意味着这个输出$\hat y^{&lt;3&gt;}$（上图编号9所示）主要受$\hat y^{&lt;3&gt;}$附近的值（上图编号10所示）的影响，上图编号11所示的一个数值主要与附近的输入（上图编号12所示）有关，上图编号6所示的输出，基本上很难受到序列靠前的输入（上图编号10所示）的影响，这是因为不管输出是什么，不管是对的，还是错的，这个区域都很难反向传播到序列的前面部分，也因此网络很难调整序列前面的计算。这是基本的<strong>RNN</strong>算法的一个缺点，我们会在下几节视频里处理这个问题。如果不管的话，<strong>RNN</strong>会不擅长处理长期依赖的问题。</p>
<p>尽管我们一直在讨论梯度消失问题，但是，你应该记得我们在讲很深的神经网络时，我们也提到了梯度爆炸，我们在反向传播的时候，随着层数的增多，梯度不仅可能指数型的下降，也可能指数型的上升。事实上梯度消失在训练<strong>RNN</strong>时是首要的问题，尽管梯度爆炸也是会出现，但是梯度爆炸很明显，因为指数级大的梯度会让你的参数变得极其大，以至于你的网络参数崩溃。所以梯度爆炸很容易发现，因为参数会大到崩溃，你会看到很多<strong>NaN</strong>，或者不是数字的情况，这意味着你的网络计算出现了数值溢出。如果你发现了梯度爆炸的问题，一个解决方法就是用梯度修剪。梯度修剪的意思就是观察你的梯度向量，如果它大于某个阈值，缩放梯度向量，保证它不会太大，这就是通过一些最大值来修剪的方法。所以如果你遇到了梯度爆炸，如果导数值很大，或者出现了<strong>NaN</strong>，就用梯度修剪，这是相对比较鲁棒的，这是梯度爆炸的解决方法。然而梯度消失更难解决，这也是我们下几节视频的主题。</p>
<h3 id="1-9-GRU单元（Gated-Recurrent-Unit（GRU））"><a href="#1-9-GRU单元（Gated-Recurrent-Unit（GRU））" class="headerlink" title="1.9 GRU单元（Gated Recurrent Unit（GRU））"></a>1.9 <strong>GRU</strong>单元（Gated Recurrent Unit（<strong>GRU</strong>））</h3><p>许多<strong>GRU</strong>的想法都来分别自于<strong>Yu Young Chang, Kagawa，Gaza Hera, Chang Hung Chu</strong>和<br><strong>Jose Banjo</strong>的两篇论文。我再引用上个视频中你已经见过的这个句子，“<strong>The cat, which already ate……, was full.</strong>”，你需要记得猫是单数的，为了确保你已经理解了为什么这里是<strong>was</strong>而不是<strong>were</strong>，“<strong>The cat was full.</strong>”或者是“<strong>The cats were full</strong>”。当我们从左到右读这个句子，<strong>GRU</strong>单元将会有个新的变量称为$c$，代表细胞（<strong>cell</strong>），即记忆细胞（下图编号1所示）。记忆细胞的作用是提供了记忆的能力，比如说一只猫是单数还是复数，所以当它看到之后的句子的时候，它仍能够判断句子的主语是单数还是复数。于是在时间$t$处，有记忆细胞$c^{<t>}$，然后我们看的是，<strong>GRU</strong>实际上输出了激活值$a^{<t>}$，$c^{<t>} = a^{<t>}$（下图编号2所示）。于是我们想要使用不同的符号$c$和$a$来表示记忆细胞的值和输出的激活值，即使它们是一样的。我现在使用这个标记是因为当我们等会说到<strong>LSTMs</strong>的时候，这两个会是不同的值，但是现在对于<strong>GRU</strong>，$c^{<t>}$的值等于$a^{<t>}$的激活值。</t></t></t></t></t></t></p>
<p>所以这些等式表示了<strong>GRU</strong>单元的计算，在每个时间步，我们将用一个候选值重写记忆细胞，即${\tilde{c}}^{<t>}$的值，所以它就是个候选值，替代了$c^{<t>}$的值。然后我们用<strong>tanh</strong>激活函数来计算，${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$，所以${\tilde{c}}^{<t>}$的值就是个替代值，代替表示$c^{<t>}$的值（下图编号3所示）。</t></t></t></t-1></t></t></t></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110301.png" alt></p>
<p>重点来了，在<strong>GRU</strong>中真正重要的思想是我们有一个门，我先把这个门叫做$\Gamma_{u}$（上图编号4所示），这是个下标为$u$的大写希腊字母$\Gamma$，$u$代表更新门，这是一个0到1之间的值。为了让你直观思考<strong>GRU</strong>的工作机制，先思考$\Gamma_{u}$，这个一直在0到1之间的门值，实际上这个值是把这个式子带入<strong>sigmoid</strong>函数得到的，$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$。我们还记得<strong>sigmoid</strong>函数是上图编号5所示这样的，它的输出值总是在0到1之间，对于大多数可能的输入，<strong>sigmoid</strong>函数的输出总是非常接近0或者非常接近1。在这样的直觉下，可以想到$\Gamma_{u}$在大多数的情况下非常接近0或1。然后这个字母<strong>u</strong>表示“<strong>update</strong>”，我选了字母$\Gamma$是因为它看起来像门。还有希腊字母<strong>G</strong>，<strong>G</strong>是门的首字母，所以<strong>G</strong>表示门。</t></t-1></p>
<p>然后<strong>GRU</strong>的关键部分就是上图编号3所示的等式，我们刚才写出来的用$\tilde{c}$更新$c$的等式。然后门决定是否要真的更新它。于是我们这么看待它，记忆细胞$c^{<t>}$将被设定为0或者1，这取决于你考虑的单词在句子中是单数还是复数，因为这里是单数情况，所以我们先假定它被设为了1，或者如果是复数的情况我们就把它设为0。然后<strong>GRU</strong>单元将会一直记住$c^{<t>}$的值，直到上图编号7所示的位置，$c^{<t>}$的值还是1，这就告诉它，噢，这是单数，所以我们用<strong>was</strong>。于是门，即$\Gamma_{u}$的作用就是决定什么时候你会更新这个值，特别是当你看到词组<strong>the cat</strong>，即句子的主语猫，这就是一个好时机去更新这个值。然后当你使用完它的时候，“<strong>The cat, which already ate……, was full.</strong>”，然后你就知道，我不需要记住它了，我可以忘记它了。</t></t></t></p>
<p>所以我们接下来要给<strong>GRU</strong>用的式子就是$c^{<t>} = \Gamma_{u}<em>{\tilde{c}}^{<t>} +\left( 1- \Gamma_{u} \right)</t></em>c^{<t-1>}$（上图编号1所示）。你应该注意到了，如果这个更新值$\Gamma_{u} =1$，也就是说把这个新值，即$c^{<t>}$设为候选值（$\Gamma_{u} =1$时简化上式，$c^{<t>} = {\tilde{c}}^{<t>}$）。将门值设为1（上图编号2所示），然后往前再更新这个值。对于所有在这中间的值，你应该把门的值设为0，即$\Gamma_{u}= 0$，意思就是说不更新它，就用旧的值。因为如果$\Gamma_{u} = 0$，则$c^{<t>} =c^{<t-1>}$，$c^{<t>}$等于旧的值。甚至你从左到右扫描这个句子，当门值为0的时候（上图编号3所示，中间$\Gamma_{u}=0$一直为0，表示一直不更新），就是说不更新它的时候，不要更新它，就用旧的值，也不要忘记这个值是什么，这样即使你一直处理句子到上图编号4所示，$c^{<t>}$应该会一直等$c^{<t-1>}$，于是它仍然记得猫是单数的。</t-1></t></t></t-1></t></t></t></t></t-1></t></p>
<p>让我再画个图来（下图所示）解释一下<strong>GRU</strong>单元，顺便说一下，当你在看网络上的博客或者教科书或者教程之类的，这些图对于解释<strong>GRU</strong>和我们稍后会讲的<strong>LSTM</strong>是相当流行的，我个人感觉式子在图片中比较容易理解，那么即使看不懂图片也没关系，我就画画，万一能帮得上忙就最好了。</p>
<p><strong>GRU</strong>单元输入$c^{<t-1>}$（下图编号1所示），对于上一个时间步，先假设它正好等于$a^{<t-1>}$，所以把这个作为输入。然后$x^{<t>}$也作为输入（下图编号2所示），然后把这两个用合适权重结合在一起，再用<strong>tanh</strong>计算，算出${\tilde{c}}^{<t>}$，${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$，即$c^{<t>}$的替代值。</t></t></t-1></t></t></t></t-1></t-1></p>
<p>再用一个不同的参数集，通过<strong>sigmoid</strong>激活函数算出$\Gamma_{u}$，$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$，即更新门。最后所有的值通过另一个运算符结合，我并不会写出公式，但是我用紫色阴影标注的这个方框（下图编号5所示，其所代表的运算过程即下图编号13所示的等式），代表了这个式子。所以这就是紫色运算符所表示的是，它输入一个门值（下图编号6所示），新的候选值（下图编号7所示），这再有一个门值（下图编号8所示）和$c^{<t>}$的旧值（下图编号9所示），所以它把这个（下图编号1所示）、这个（下图编号3所示）和这个（下图编号4所示）作为输入一起产生记忆细胞的新值$c^{<t>}$，所以$c^{<t>}$等于$a^{<t>}$。如果你想，你也可以也把这个代入<strong>softmax</strong>或者其他预测$y^{<t>}$的东西。</t></t></t></t></t></t></t-1></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110350.png" alt></p>
<p>这就是<strong>GRU</strong>单元或者说是一个简化过的<strong>GRU</strong>单元，它的优点就是通过门决定，当你从左（上图编号10所示）到右扫描一个句子的时候，这个时机是要更新某个记忆细胞，还是不更新，不更新（上图编号11所示，中间$\Gamma_{u}=0$一直为0，表示一直不更新）直到你到你真的需要使用记忆细胞的时候（上图编号12所示），这可能在句子之前就决定了。因为sigmoid的值，现在因为门很容易取到0值，只要这个值是一个很大的负数，再由于数值上的四舍五入，上面这些门大体上就是0，或者说非常非常非常接近0。所以在这样的情况下，这个更新式子（上图编号13所示的等式）就会变成$c^{<t>} = c^{<t-1>}$，这非常有利于维持细胞的值。因为$\Gamma_{u}$很接近0，可能是0.000001或者更小，这就不会有梯度消失的问题了。因为$\Gamma_{u}$很接近0，这就是说$c^{<t>}$几乎就等于$c^{<t-1>}$，而且$c^{<t>}$的值也很好地被维持了，即使经过很多很多的时间步（上图编号14所示）。这就是缓解梯度消失问题的关键，因此允许神经网络运行在非常庞大的依赖词上，比如说<strong>cat</strong>和<strong>was</strong>单词即使被中间的很多单词分割开。</t></t-1></t></t-1></t></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110347.png" alt></p>
<p>现在我想说下一些实现的细节，在这个我写下的式子中$c^{<t>}$可以是一个向量（上图编号1所示），如果你有100维的隐藏的激活值，那么$c^{<t>}$也是100维的，${\tilde{c}}^{<t>}$也是相同的维度（${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$），$\Gamma_{u}$也是相同的维度（$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$），还有画在框中的其他值。这样的话“*”实际上就是元素对应的乘积（$c^{<t>} = \Gamma_{u}<em>{\tilde{c}}^{<t>} +\left( 1- \Gamma_{u} \right)</t></em>c^{<t-1>}$），所以这里的$\Gamma_{u}$：（$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$），即如果门是一个100维的向量，$\Gamma_{u}$也就100维的向量，里面的值几乎都是0或者1，就是说这100维的记忆细胞$c^{<t>}$（$c^{<t>}=a^{<t>}$上图编号1所示）就是你要更新的比特。</t></t></t></t></t-1></t-1></t></t></t-1></t></t-1></t></t></t></t></p>
<p>当然在实际应用中$\Gamma_{u}$不会真的等于0或者1，有时候它是0到1的一个中间值（上图编号5所示），但是这对于直观思考是很方便的，就把它当成确切的0，完全确切的0或者就是确切的1。元素对应的乘积做的就是告诉<strong>GRU</strong>单元哪个记忆细胞的向量维度在每个时间步要做更新，所以你可以选择保存一些比特不变，而去更新其他的比特。比如说你可能需要一个比特来记忆猫是单数还是复数，其他比特来理解你正在谈论食物，因为你在谈论吃饭或者食物，然后你稍后可能就会谈论“<strong>The cat was full.</strong>”，你可以每个时间点只改变一些比特。</p>
<p>你现在已经理解<strong>GRU</strong>最重要的思想了，幻灯片中展示的实际上只是简化过的<strong>GRU</strong>单元，现在来描述一下完整的<strong>GRU</strong>单元。</p>
<p>对于完整的<strong>GRU</strong>单元我要做的一个改变就是在我们计算的第一个式子中给记忆细胞的新候选值加上一个新的项，我要添加一个门$\Gamma_{r}$（下图编号1所示），你可以认为$r$代表相关性（<strong>relevance</strong>）。这个$\Gamma_{r}$门告诉你计算出的下一个$c^{<t>}$的候选值${\tilde{c}}^{<t>}$跟$c^{<t-1>}$有多大的相关性。计算这个门$\Gamma_{r}$需要参数，正如你看到的这个，一个新的参数矩阵$W_{r}$，$\Gamma_{r}= \sigma(W_{r}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack + b_{r})$。</t></t-1></t-1></t></t></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110359.png" alt></p>
<p>正如你所见，有很多方法可以来设计这些类型的神经网络，然后我们为什么有$\Gamma_{r}$？为什么不用上一张幻灯片里的简单的版本？这是因为多年来研究者们试验过很多很多不同可能的方法来设计这些单元，去尝试让神经网络有更深层的连接，去尝试产生更大范围的影响，还有解决梯度消失的问题，<strong>GRU</strong>就是其中一个研究者们最常使用的版本，也被发现在很多不同的问题上也是非常健壮和实用的。你可以尝试发明新版本的单元，只要你愿意。但是<strong>GRU</strong>是一个标准版本，也就是最常使用的。你可以想象到研究者们也尝试了很多其他版本，类似这样的但不完全是，比如我这里写的这个。然后另一个常用的版本被称为<strong>LSTM</strong>，表示长短时记忆网络，这个我们会在下节视频中讲到，但是<strong>GRU</strong>和<strong>LSTM</strong>是在神经网络结构中最常用的两个具体实例。</p>
<p>还有在符号上的一点，我尝试去定义固定的符号让这些概念容易理解，如果你看学术文章的话，你有的时候会看到有些人使用另一种符号$\tilde{x}$，$u$，$r$和$h$表示这些量。但我试着在<strong>GRU</strong>和<strong>LSTM</strong>之间用一种更固定的符号，比如使用更固定的符号$\Gamma$来表示门，所以希望这能让这些概念更好理解。</p>
<p>所以这就是<strong>GRU</strong>，即门控循环单元，这是<strong>RNN</strong>的其中之一。这个结构可以更好捕捉非常长范围的依赖，让<strong>RNN</strong>更加有效。然后我简单提一下其他常用的神经网络，比较经典的是这个叫做<strong>LSTM</strong>，即长短时记忆网络，我们在下节视频中讲解。</p>
<h3 id="1-10-长短期记忆（LSTM（long-short-term-memory）unit）"><a href="#1-10-长短期记忆（LSTM（long-short-term-memory）unit）" class="headerlink" title="1.10 长短期记忆（LSTM（long short term memory）unit）"></a>1.10 长短期记忆（<strong>LSTM</strong>（long short term memory）unit）</h3><p>在上一个视频中你已经学了<strong>GRU</strong>（门控循环单元）。它能够让你可以在序列中学习非常深的连接。其他类型的单元也可以让你做到这个，比如<strong>LSTM</strong>即长短时记忆网络，甚至比<strong>GRU</strong>更加有效，让我们看看。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110433.png" alt></p>
<p>这里是上个视频中的式子，对于<strong>GRU</strong>我们有$a^{&lt; t &gt;} = c^{<t>}$。</t></p>
<p>还有两个门:</p>
<p>更新门$\Gamma_{u}$（<strong>the update gate</strong>）</p>
<p>相关门$\Gamma_{r}$（<strong>the relevance gate</strong>）</p>
<p>${\tilde{c}}^{<t>}$，这是代替记忆细胞的候选值，然后我们使用更新门$\Gamma_{u}$来决定是否要用${\tilde{c}}^{<t>}$ 更新$c^{<t>}$。</t></t></t></p>
<p><strong>LSTM</strong>是一个比<strong>GRU</strong>更加强大和通用的版本，这多亏了 <strong>Sepp Hochreiter</strong>和 <strong>Jurgen Schmidhuber</strong>，感谢那篇开创性的论文，它在序列模型上有着巨大影响。我感觉这篇论文是挺难读懂的，虽然我认为这篇论文在深度学习社群有着重大的影响，它深入讨论了梯度消失的理论，我感觉大部分的人学到<strong>LSTM</strong>的细节是在其他的地方，而不是这篇论文。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110438.png" alt></p>
<p>这就是<strong>LSTM</strong>主要的式子（上图编号2所示），我们继续回到记忆细胞<strong>c</strong>上面来，使用${\tilde{c}}^{<t>} = tanh(W_{c}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{c}$来更新它的候选值${\tilde{c}}^{<t>}$（上图编号3所示）。注意了，在<strong>LSTM</strong>中我们不再有$a^{<t>} = c^{<t>}$的情况，这是现在我们用的是类似于左边这个式子（上图编号4所示），但是有一些改变，现在我们专门使用$a^{<t>}$或者$a^{<t-1>}$，而不是用$c^{<t-1>}$，我们也不用$\Gamma_{r}$，即相关门。虽然你可以使用<strong>LSTM</strong>的变体，然后把这些东西（左边所示的<strong>GRU</strong>公式）都放回来，但是在更加典型的<strong>LSTM</strong>里面，我们先不那样做。</t-1></t-1></t></t></t></t></t></t-1></t></p>
<p>我们像以前那样有一个更新门$\Gamma_{u}$和表示更新的参数$W_{u}$，$\Gamma_{u}= \sigma(W_{u}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{u})$（上图编号5所示）。一个<strong>LSTM</strong>的新特性是不只有一个更新门控制，这里的这两项（上图编号6，7所示），我们将用不同的项来代替它们，要用别的项来取代$\Gamma_{u}$和$1-\Gamma_{u}$，这里（上图编号6所示）我们用$\Gamma_{u}$。</t></t-1></p>
<p>然后这里（上图编号7所示）用遗忘门（<strong>the forget gate</strong>），我们叫它$\Gamma_{f}$，所以这个$\Gamma_{f} =\sigma(W_{f}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{f})$（上图编号8所示）；</t></t-1></p>
<p>然后我们有一个新的输出门，$\Gamma_{o} =\sigma(W_{o}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +&gt;b_{o})$（上图编号9所示）；</t></t-1></p>
<p>于是记忆细胞的更新值$c^{<t>} =\Gamma_{u}<em>{\tilde{c}}^{<t>} + \Gamma_{f}</t></em>c^{<t-1>}$（上图编号10所示）；</t-1></t></p>
<p>所以这给了记忆细胞选择权去维持旧的值$c^{<t-1>}$或者就加上新的值${\tilde{c}}^{<t>}$，所以这里用了单独的更新门$\Gamma_{u}$和遗忘门$\Gamma_{f}$，</t></t-1></p>
<p>然后这个表示更新门（$\Gamma_{u}= \sigma(W_{u}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{u})$上图编号5所示）；</t></t-1></p>
<p>遗忘门（$\Gamma_{f} =\sigma(W_{f}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{f})$上图编号8所示）和输出门（上图编号9所示）。</t></t-1></p>
<p>最后$a^{<t>} = c^{<t>}$的式子会变成$a^{<t>} = \Gamma_{o}<em>c^{<t>}$。这就是<em>*LSTM</em></t></em>主要的式子了，然后这里（上图编号11所示）有三个门而不是两个，这有点复杂，它把门放到了和之前有点不同的地方。</t></t></t></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110444.png" alt></p>
<p>再提一下，这些式子就是控制<strong>LSTM</strong>行为的主要的式子了（上图编号1所示）。像之前一样用图片稍微解释一下，先让我把图画在这里（上图编号2所示）。如果图片过于复杂，别担心，我个人感觉式子比图片好理解，但是我画图只是因为它比较直观。这个右上角的图的灵感来自于<strong>Chris Ola</strong>的一篇博客，标题是《理解<strong>LSTM</strong>网络》（<strong>Understanding LSTM Network</strong>），这里的这张图跟他博客上的图是很相似的，但关键的不同可能是这里的这张图用了$a^{<t-1>}$和$x^{<t>}$来计算所有门值（上图编号3，4所示），在这张图里是用$a^{<t-1>}$， $x^{<t>}$一起来计算遗忘门$\Gamma_{f}$的值，还有更新门$\Gamma_{u}$以及输出门$\Gamma_{o}$（上图编号4所示）。然后它们也经过<strong>tanh</strong>函数来计算${\tilde{c}}^{<t>}$（上图编号5所示），这些值被用复杂的方式组合在一起，比如说元素对应的乘积或者其他的方式来从之前的$c^{<t-1>}$（上图编号6所示）中获得$c^{<t>}$（上图编号7所示）。</t></t-1></t></t></t-1></t></t-1></p>
<p>这里其中一个元素很有意思，如你在这一堆图（上图编号8所示的一系列图片）中看到的，这是其中一个，再把他们连起来，就是把它们按时间次序连起来，这里（上图编号9所示）输入$x^{&lt;1&gt;}$，然后$x^{&lt;2&gt;}$，$x^{&lt;3&gt;}$，然后你可以把这些单元依次连起来，这里输出了上一个时间的$a$，$a$会作为下一个时间步的输入，$c$同理。在下面这一块，我把图简化了一下（相对上图编号2所示的图有所简化）。然后这有个有意思的事情，你会注意到上面这里有条线（上图编号10所示的线），这条线显示了只要你正确地设置了遗忘门和更新门，<strong>LSTM</strong>是相当容易把$c^{&lt;0&gt;}$的值（上图编号11所示）一直往下传递到右边，比如$c^{&lt;3&gt;} = c^{&lt;0&gt;}$（上图编号12所示）。这就是为什么<strong>LSTM</strong>和<strong>GRU</strong>非常擅长于长时间记忆某个值，对于存在记忆细胞中的某个值，即使经过很长很长的时间步。</p>
<p>这就是<strong>LSTM</strong>，你可能会想到这里和一般使用的版本会有些不同，最常用的版本可能是门值不仅取决于$a^{<t-1>}$和$x^{<t>}$，有时候也可以偷窥一下$c^{<t-1>}$的值（上图编号13所示），这叫做“窥视孔连接”（<strong>peephole connection</strong>）。虽然不是个好听的名字，但是你想，“<strong>偷窥孔连接</strong>”其实意思就是门值不仅取决于$a^{<t-1>}$和$x^{<t>}$，也取决于上一个记忆细胞的值（$c^{<t-1>}$），然后“偷窥孔连接”就可以结合这三个门（$\Gamma_{u}$、$\Gamma_{f}$、$\Gamma_{o}$）来计算了。</t-1></t></t-1></t-1></t></t-1></p>
<p>如你所见<strong>LSTM</strong>主要的区别在于一个技术上的细节，比如这（上图编号13所示）有一个100维的向量，你有一个100维的隐藏的记忆细胞单元，然后比如第50个$c^{<t-1>}$的元素只会影响第50个元素对应的那个门，所以关系是一对一的，于是并不是任意这100维的$c^{<t-1>}$可以影响所有的门元素。相反的，第一个$c^{<t-1>}$的元素只能影响门的第一个元素，第二个元素影响对应的第二个元素，如此类推。但如果你读过论文，见人讨论“<strong>偷窥孔连接</strong>”，那就是在说$c^{<t-1>}$也能影响门值。</t-1></t-1></t-1></t-1></p>
<p><strong>LSTM</strong>前向传播图：</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110500.png" alt="ST"></p>
<p><img src="../../../%E6%9A%82%E5%AD%98/%E5%90%B4%E6%81%A9%E8%BE%BE/images/LSTM_rnn.png" alt="STM_rn"></p>
<p><strong>LSTM</strong>反向传播计算：</p>
<p><strong>门求偏导：</strong></p>
<p>$d \Gamma_o^{\langle t \rangle} = da_{next}<em>\tanh(c_{next}) </em> \Gamma_o^{\langle t \rangle}*(1-\Gamma_o^{\langle t \rangle})\tag{1}$</p>
<p>$d\tilde c^{\langle t \rangle} = dc_{next}<em>\Gamma_i^{\langle t \rangle}+ \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> i_t <em> da_{next} </em> \tilde c^{\langle t \rangle} * (1-\tanh(\tilde c)^2) \tag{2}$</p>
<p>$d\Gamma_u^{\langle t \rangle} = dc_{next}<em>\tilde c^{\langle t \rangle} + \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> \tilde c^{\langle t \rangle} <em> da_{next}</em>\Gamma_u^{\langle t \rangle}*(1-\Gamma_u^{\langle t \rangle})\tag{3}$</p>
<p>$d\Gamma_f^{\langle t \rangle} = dc_{next}<em>\tilde c_{prev} + \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> c_{prev} <em> da_{next}</em>\Gamma_f^{\langle t \rangle}*(1-\Gamma_f^{\langle t \rangle})\tag{4}$</p>
<p><strong>参数求偏导 ：</strong></p>
<p>$ dW_f = d\Gamma_f^{\langle t \rangle} <em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{5} $<br>$ dW_u = d\Gamma_u^{\langle t \rangle} </em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{6} $<br> $ dW_c = d\tilde c^{\langle t \rangle} <em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{7} $<br>$ dW_o = d\Gamma_o^{\langle t \rangle} </em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{8}$</p>
<p>为了计算$db_f, db_u, db_c, db_o$ 需要各自对$d\Gamma_f^{\langle t \rangle}, d\Gamma_u^{\langle t \rangle}, d\tilde c^{\langle t \rangle}, d\Gamma_o^{\langle t \rangle}$ 求和。</p>
<p>最后，计算隐藏状态、记忆状态和输入的偏导数：</p>
<p>$ da_{prev} = W_f^T<em>d\Gamma_f^{\langle t \rangle} + W_u^T </em> d\Gamma_u^{\langle t \rangle}+ W_c^T <em> d\tilde c^{\langle t \rangle} + W_o^T </em> d\Gamma_o^{\langle t \rangle} \tag{9}$</p>
<p>$ dc_{prev} = dc_{next}\Gamma_f^{\langle t \rangle} + \Gamma_o^{\langle t \rangle} <em> (1- \tanh(c_{next})^2)</em>\Gamma_f^{\langle t \rangle}<em>da_{next} \tag{10}$<br>$ dx^{\langle t \rangle} = W_f^T</em>d\Gamma_f^{\langle t \rangle} + W_u^T <em> d\Gamma_u^{\langle t \rangle}+ W_c^T </em> d\tilde c_t + W_o^T * d\Gamma_o^{\langle t \rangle}\tag{11} $</p>
<p>这就是<strong>LSTM</strong>，我们什么时候应该用<strong>GRU</strong>？什么时候用<strong>LSTM</strong>？这里没有统一的准则。而且即使我先讲解了<strong>GRU</strong>，在深度学习的历史上，<strong>LSTM</strong>也是更早出现的，而<strong>GRU</strong>是最近才发明出来的，它可能源于<strong>Pavia</strong>在更加复杂的<strong>LSTM</strong>模型中做出的简化。研究者们在很多不同问题上尝试了这两种模型，看看在不同的问题不同的算法中哪个模型更好，所以这不是个学术和高深的算法，我才想要把这两个模型展示给你。</p>
<p><strong>GRU</strong>的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。</p>
<p>但是<strong>LSTM</strong>更加强大和灵活，因为它有三个门而不是两个。如果你想选一个使用，我认为<strong>LSTM</strong>在历史进程上是个更优先的选择，所以如果你必须选一个，我感觉今天大部分的人还是会把<strong>LSTM</strong>作为默认的选择来尝试。虽然我认为最近几年<strong>GRU</strong>获得了很多支持，而且我感觉越来越多的团队也正在使用<strong>GRU</strong>，因为它更加简单，而且还效果还不错，它更容易适应规模更加大的问题。</p>
<p>所以这就是<strong>LSTM</strong>，无论是<strong>GRU</strong>还是<strong>LSTM</strong>，你都可以用它们来构建捕获更加深层连接的神经网络。</p>
<p>（<strong>Hochreiter S, Schmidhuber J. Long Short-Term Memory[J]. Neural Computation, 1997, 9(8):1735-1780.</strong>）</p>
<h3 id="1-11-双向循环神经网络（Bidirectional-RNN）"><a href="#1-11-双向循环神经网络（Bidirectional-RNN）" class="headerlink" title="1.11 双向循环神经网络（Bidirectional RNN）"></a>1.11 双向循环神经网络（Bidirectional <strong>RNN</strong>）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110548.png" alt></p>
<h3 id="1-12-深层循环神经网络（Deep-RNNs）"><a href="#1-12-深层循环神经网络（Deep-RNNs）" class="headerlink" title="1.12 深层循环神经网络（Deep RNNs）"></a>1.12 深层循环神经网络（Deep <strong>RNN</strong>s）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110627.png" alt></p>
<p>对于像左边这样标准的神经网络，你可能见过很深的网络，甚至于100层深，而对于<strong>RNN</strong>来说，有三层就已经不少了。由于时间的维度，<strong>RNN</strong>网络会变得相当大，即使只有很少的几层，很少会看到这种网络堆叠到100层。但有一种会容易见到，就是在每一个上面堆叠循环层，把这里的输出去掉（上图编号1所示），然后换成一些深的层，这些层并不水平连接，只是一个深层的网络，然后用来预测$y^{&lt;1&gt;}$。同样这里（上图编号2所示）也加上一个深层网络，然后预测$y^{&lt;2&gt;}$。这种类型的网络结构用的会稍微多一点，这种结构有三个循环单元，在时间上连接，接着一个网络在后面接一个网络，当然$y^{&lt;3&gt;}$和$y^{&lt;4&gt;}$也一样，这是一个深层网络，但没有水平方向上的连接，所以这种类型的结构我们会见得多一点。通常这些单元（上图编号3所示）没必要非是标准的<strong>RNN</strong>，最简单的<strong>RNN</strong>模型，也可以是<strong>GRU</strong>单元或者<strong>LSTM</strong>单元，并且，你也可以构建深层的双向<strong>RNN</strong>网络。由于深层的<strong>RNN</strong>训练需要很多计算资源，需要很长的时间，尽管看起来没有多少循环层，这个也就是在时间上连接了三个深层的循环层，你看不到多少深层的循环层，不像卷积神经网络一样有大量的隐含层。</p>
<p>这就是深层<strong>RNN</strong>的内容，从基本的<strong>RNN</strong>网络，基本的循环单元到<strong>GRU</strong>，<strong>LSTM</strong>，再到双向<strong>RNN</strong>，还有深层版的模型。这节课后，你已经可以构建很不错的学习序列的模型了。</p>
<h2 id="第二周-自然语言处理与词嵌入（Natural-Language-Processing-and-Word-Embeddings）"><a href="#第二周-自然语言处理与词嵌入（Natural-Language-Processing-and-Word-Embeddings）" class="headerlink" title="第二周 自然语言处理与词嵌入（Natural Language Processing and Word Embeddings）"></a>第二周 自然语言处理与词嵌入（Natural Language Processing and Word Embeddings）</h2><h3 id="2-1-词汇表征（Word-Representation）"><a href="#2-1-词汇表征（Word-Representation）" class="headerlink" title="2.1 词汇表征（Word Representation）"></a>2.1 词汇表征（Word Representation）</h3><h3 id="2-2-使用词嵌入（Using-Word-Embeddings）"><a href="#2-2-使用词嵌入（Using-Word-Embeddings）" class="headerlink" title="2.2 使用词嵌入（Using Word Embeddings）"></a>2.2 使用词嵌入（Using Word Embeddings）</h3><p>尽管<strong>one-hot</strong>向量很快计算，而学到的用于词嵌入的300维的向量会更加紧凑。</p>
<h3 id="2-3-词嵌入的特性（Properties-of-Word-Embeddings）"><a href="#2-3-词嵌入的特性（Properties-of-Word-Embeddings）" class="headerlink" title="2.3 词嵌入的特性（Properties of Word Embeddings）"></a>2.3 词嵌入的特性（Properties of Word Embeddings）</h3><p>这是一系列你希望词嵌入可以捕捉的单词的特征表示，假如我提出一个问题，<strong>man</strong>如果对应<strong>woman</strong>，那么<strong>king</strong>应该对应什么？你们应该都能猜到<strong>king</strong>应该对应<strong>queen</strong>。能否有一种算法来自动推导出这种关系，下面就是实现的方法。</p>
<p>在之前我们谈到过用<strong>t-SNE</strong>算法来将单词可视化。<strong>t-SNE算法</strong>所做的就是把这些300维的数据用一种非线性的方式映射到2维平面上，可以得知<strong>t-SNE</strong>中这种映射很复杂而且很非线性。在进行<strong>t-SNE</strong>映射之后，你不能总是期望使等式成立的关系，会像左边那样成一个平行四边形，尽管在这个例子最初的300维的空间内你可以依赖这种平行四边形的关系来找到使等式成立的一对类比，通过<strong>t-SNE算法</strong>映射出的图像可能是正确的。但在大多数情况下，由于<strong>t-SNE</strong>的非线性映射，你就没法再指望这种平行四边形了，很多这种平行四边形的类比关系在<strong>t-SNE</strong>映射中都会失去原貌。</p>
<p>现在，再继续之前，我想再快速地列举一个最常用的相似度函数，这个最常用的相似度函数叫做余弦相似度。这是我们上个幻灯片所得到的等式（下图编号1所示），在余弦相似度中，假如在向量$u$和$v$之间定义相似度</p>
<p>在本节视频中，你见到了词嵌入是如何被用于类比推理的，可能你不会自己动手构建一个类比推理系统作为一项应用，不过希望在这些可学习的类特征的表示方式能够给你一些直观的感受。你还看知道了余弦相似度可以作为一种衡量两个词嵌入向量间相似度的办法，我们谈了许多有关这些嵌入的特性，以及如何使用它们。下节视频中，我们来讨论如何真正的学习这些词嵌入。</p>
<h3 id="2-4-嵌入矩阵（Embedding-Matrix）"><a href="#2-4-嵌入矩阵（Embedding-Matrix）" class="headerlink" title="2.4 嵌入矩阵（Embedding Matrix）"></a>2.4 嵌入矩阵（Embedding Matrix）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110855.png" alt></p>
<p>，要记住的一件事就是我们的目标是学习一个嵌入矩阵$E$。在下节视频中你将会随机地初始化矩阵$E$，然后使用梯度下降法来学习这个300×10,000的矩阵中的各个参数，$E$乘以这个<strong>one-hot</strong>向量（上图编号1所示）会得到嵌入向量。再多说一点，当我们写这个等式（上图编号2所示）的时候，写出这些符号是很方便的，代表用矩阵$E$乘以<strong>one-hot</strong>向量$O_{j}$。但当你动手实现时，用大量的矩阵和向量相乘来计算它，效率是很低下的，因为<strong>one-hot</strong>向量是一个维度非常高的向量，并且几乎所有元素都是0，所以矩阵向量相乘效率太低，因为我们要乘以一大堆的0。所以在实践中你会使用一个专门的函数来单独查找矩阵$E$的某列，而不是用通常的矩阵乘法来做，但是在画示意图时（上图所示，即矩阵$E$乘以<strong>one-hot</strong>向量示意图），这样写比较方便。但是例如在<strong>Keras</strong>中就有一个嵌入层，然后我们用这个嵌入层更有效地从嵌入矩阵中提取出你需要的列，而不是对矩阵进行很慢很复杂的乘法运算。</p>
<h3 id="2-5-学习词嵌入（Learning-Word-Embeddings）"><a href="#2-5-学习词嵌入（Learning-Word-Embeddings）" class="headerlink" title="2.5 学习词嵌入（Learning Word Embeddings）"></a>2.5 学习词嵌入（Learning Word Embeddings）</h3><p>研究者发现，如果你真想建立一个语言模型，用目标词的前几个单词作为上下文是常见做法（上图编号9所示）。但如果你的目标是学习词嵌入，那么你就可以用这些其他类型的上下文（上图编号10所示），它们也能得到很好的词嵌入。</p>
<h3 id="2-6-Word2Vec"><a href="#2-6-Word2Vec" class="headerlink" title="2.6 Word2Vec"></a>2.6 Word2Vec</h3><p>在本视频中你会见到 <strong>Word2Vec</strong>算法，这是一种简单而且计算时更加高效的方式来学习这种类型的嵌入，让我们来看看。</p>
<p>本视频中的大多数的想法来源于<strong>Tomas Mikolov</strong>，<strong>Kai Chen</strong>，<strong>Greg Corrado</strong> 和 <strong>Jeff Dean</strong>。</p>
<p>（<strong>Mikolov T, Chen K, Corrado G, et al. Efficient Estimation of Word Representations in Vector Space[J]. Computer Science, 2013.</strong>）</p>
<p>假设在训练集中给定了一个这样的句子：“<strong>I want a glass of orange juice to go along with my cereal.</strong>”，在<strong>Skip-Gram</strong>模型中，我们要做的是抽取上下文和目标词配对，来构造一个监督学习问题。上下文不一定总是目标单词之前离得最近的四个单词，或最近的$n$个单词。我们要的做的是随机选一个词作为上下文词，比如选<strong>orange</strong>这个词，然后我们要做的是随机在一定词距内选另一个词，比如在上下文词前后5个词内或者前后10个词内，我们就在这个范围内选择目标词。可能你正好选到了<strong>juice</strong>作为目标词，正好是下一个词（表示<strong>orange</strong>的下一个词），也有可能你选到了前面第二个词，所以另一种配对目标词可以是<strong>glass</strong>，还可能正好选到了单词<strong>my</strong>作为目标词。</p>
<p>于是我们将构造一个监督学习问题，它给定上下文词，要求你预测在这个词正负10个词距或者正负5个词距内随机选择的某个目标词。显然，这不是个非常简单的学习问题，因为在单词<strong>orange</strong>的正负10个词距之间，可能会有很多不同的单词。但是构造这个监督学习问题的目标并不是想要解决这个监督学习问题本身，而是想要使用这个学习问题来学到一个好的词嵌入模型。</p>
<p>接下来说说模型的细节，我们继续假设使用一个10,000词的词汇表，有时训练使用的词汇表会超过一百万词。但我们要解决的基本的监督学习问题是学习一种映射关系，从上下文<strong>c</strong>，比如单词<strong>orange</strong>，到某个目标词，记为<strong>t</strong>，可能是单词<strong>juice</strong>或者单词<strong>glass</strong>或者单词<strong>my</strong>。延续上一张幻灯片的例子，在我们的词汇表中，<strong>orange</strong>是第6257个单词，<strong>juice</strong>是10,000个单词中的第4834个，这就是你想要的映射到输出$y$的输入$x$。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111137.png" alt></p>
<p>为了表示输入，比如单词<strong>orange</strong>，你可以先从<strong>one-hot</strong>向量开始，我们将其写作$O_{c}$，这就是上下文词的<strong>one-hot</strong>向量（上图编号1所示）。然后和你在上节视频中看到的类似，你可以拿嵌入矩阵$E$乘以向量$O_{c}$，然后得到了输入的上下文词的嵌入向量，于是这里$e_{c}=EO_{c}$。在这个神经网络中（上图编号2所示），我们将把向量$e_{c}$喂入一个<strong>softmax</strong>单元。我通常把<strong>softmax</strong>单元画成神经网络中的一个节点（上图编号3所示），这不是字母<strong>O</strong>，而是<strong>softmax</strong>单元，<strong>softmax</strong>单元要做的就是输出$\hat y$。然后我们再写出模型的细节，这是<strong>softmax</strong>模型（上图编号4所示），预测不同目标词的概率：</p>
<p>$Softmax:p\left( t \middle| c \right) = \frac{e^{\theta_{t}^{T}e_{c}}}{\sum_{j = 1}^{10,000}e^{\theta_{j}^{T}e_{c}}}$</p>
<p>这里$\theta_{t}$是一个与输出$t$有关的参数，即某个词$t$和标签相符的概率是多少。我省略了<strong>softmax</strong>中的偏差项，想要加上的话也可以加上。</p>
<p>最终<strong>softmax</strong>的损失函数就会像之前一样，我们用$y$表示目标词，我们这里用的$y$和$\hat y$都是用<strong>one-hot</strong>表示的，于是损失函数就会是：</p>
<p>$L\left( \hat y,y \right) = - \sum_{i = 1}^{10,000}{y_{i}\log \hat y_{i}}$</p>
<p>这是常用的<strong>softmax</strong>损失函数，$y$ 就是只有一个1其他都是0的<strong>one-hot</strong>向量，如果目标词是<strong>juice</strong>，那么第4834个元素就是1，其余是0（上图编号5所示）。类似的$\hat y$是一个从<strong>softmax</strong>单元输出的10,000维的向量，这个向量是所有可能目标词的概率。</p>
<p>总结一下，这大体上就是一个可以找到词嵌入的简化模型和神经网络（上图编号2所示），其实就是个<strong>softmax</strong>单元。矩阵$E$将会有很多参数，所以矩阵$E$有对应所有嵌入向量$e_{c}$的参数（上图编号6所示），<strong>softmax</strong>单元也有$\theta_{t}$的参数（上图编号3所示）。如果优化这个关于所有这些参数的损失函数，你就会得到一个较好的嵌入向量集，这个就叫做<strong>Skip-Gram</strong>模型。它把一个像<strong>orange</strong>这样的词作为输入，并预测这个输入词，从左数或从右数的某个词，预测上下文词的前面一些或者后面一些是什么词。</p>
<p>实际上使用这个算法会遇到一些问题，首要的问题就是计算速度。尤其是在<strong>softmax</strong>模型中，每次你想要计算这个概率，你需要对你词汇表中的所有10,000个词做求和计算，可能10,000个词的情况还不算太差。如果你用了一个大小为100,000或1,000,000的词汇表，那么这个分母的求和操作是相当慢的，实际上10,000已经是相当慢的了，所以扩大词汇表就更加困难了。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111141.png" alt></p>
<p>这里有一些解决方案，如分级（<strong>hierarchical</strong>）的<strong>softmax</strong>分类器和<strong>负采样</strong>（<strong>Negative Sampling</strong>）。</p>
<p>在文献中你会看到的方法是使用一个分级（<strong>hierarchical</strong>）的<strong>softmax</strong>分类器，意思就是说不是一下子就确定到底是属于10,000类中的哪一类。想象如果你有一个分类器（上图编号1所示），它告诉你目标词是在词汇表的前5000个中还是在词汇表的后5000个词中，假如这个二分类器告诉你这个词在前5000个词中（上图编号2所示），然后第二个分类器会告诉你这个词在词汇表的前2500个词中，或者在词汇表的第二组2500个词中，诸如此类，直到最终你找到一个词准确所在的分类器（上图编号3所示），那么就是这棵树的一个叶子节点。像这样有一个树形的分类器，意味着树上内部的每一个节点都可以是一个二分类器，比如逻辑回归分类器，所以你不需要再为单次分类，对词汇表中所有的10,000个词求和了。实际上用这样的分类树，计算成本与词汇表大小的对数成正比（上图编号4所示），而不是词汇表大小的线性函数，这个就叫做分级<strong>softmax</strong>分类器。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111144.png" alt></p>
<p>我要提一下，在实践中分级<strong>softmax</strong>分类器不会使用一棵完美平衡的分类树或者说一棵左边和右边分支的词数相同的对称树（上图编号1所示的分类树）。实际上，分级的<strong>softmax</strong>分类器会被构造成常用词在顶部，然而不常用的词像<strong>durian</strong>会在树的更深处（上图编号2所示的分类树），因为你想更常见的词会更频繁，所以你可能只需要少量检索就可以获得常用单词像<strong>the</strong>和<strong>of</strong>。然而你更少见到的词比如<strong>durian</strong>就更合适在树的较深处，因为你一般不需要到那样的深处，所以有不同的经验法则可以帮助构造分类树形成分级<strong>softmax</strong>分类器。所以这是你能在文献中见到的一个加速<strong>softmax</strong>分类的方法，但是我不会再花太多时间在这上面了，你可以从我在第一张幻灯片中提到的<strong>Tomas Mikolov</strong>等人的论文中参阅更多的细节，所以我不会再花更多时间讲这个了。因为在下个视频中，我们会讲到另一个方法叫做负采样，我感觉这个会更简单一点，对于加速<strong>softmax</strong>和解决需要在分母中对整个词汇表求和的问题也很有作用，下个视频中你会看到更多的细节。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111148.png" alt></p>
<p>但是在进入下个视频前，我想要你理解一个东西，那就是怎么对上下文<strong>c</strong>进行采样，一旦你对上下文<strong>c</strong>进行采样，那么目标词<strong>t</strong>就会在上下文<strong>c</strong>的正负10个词距内进行采样。但是你要如何选择上下文<strong>c</strong>？一种选择是你可以就对语料库均匀且随机地采样，如果你那么做，你会发现有一些词，像<strong>the</strong>、<strong>of</strong>、<strong>a</strong>、<strong>and</strong>、<strong>to</strong>诸如此类是出现得相当频繁的，于是你那么做的话，你会发现你的上下文到目标词的映射会相当频繁地得到这些种类的词，但是其他词，像<strong>orange</strong>、<strong>apple</strong>或<strong>durian</strong>就不会那么频繁地出现了。你可能不会想要你的训练集都是这些出现得很频繁的词，因为这会导致你花大部分的力气来更新这些频繁出现的单词的$e_{c}$（上图编号1所示），但你想要的是花时间来更新像<strong>durian</strong>这些更少出现的词的嵌入，即$e_{\text{durian}}$。实际上词$p(c)$的分布并不是单纯的在训练集语料库上均匀且随机的采样得到的，而是采用了不同的分级来平衡更常见的词和不那么常见的词。</p>
<p>这就是<strong>Word2Vec</strong>的<strong>Skip-Gram</strong>模型，如果你读过我之前提到的论文原文，你会发现那篇论文实际上有两个不同版本的<strong>Word2Vec</strong>模型，<strong>Skip-Gram</strong>只是其中的一个，另一个叫做<strong>CBOW</strong>，即连续词袋模型（<strong>Continuous</strong><br><strong>Bag-Of-Words Model</strong>），它获得中间词两边的的上下文，然后用周围的词去预测中间的词，这个模型也很有效，也有一些优点和缺点。</p>
<p>总结下：<strong>CBOW</strong>是从原始语句推测目标字词；而<strong>Skip-Gram</strong>正好相反，是从目标字词推测出原始语句。<strong>CBOW</strong>对小型数据库比较合适，而<strong>Skip-Gram</strong>在大型语料中表现更好。 （下图左边为<strong>CBOW</strong>，右边为<strong>Skip-Gram</strong>）</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111151.jpg" alt="bo">                                  <img src="../../../%E6%9A%82%E5%AD%98/%E5%90%B4%E6%81%A9%E8%BE%BE/images/skipgram.jpg" alt="kipgra"></p>
<p>而刚才讲的<strong>Skip-Gram</strong>模型，关键问题在于<strong>softmax</strong>这个步骤的计算成本非常昂贵，因为它需要在分母里对词汇表中所有词求和。通常情况下，<strong>Skip-Gram</strong>模型用到更多点。在下个视频中，我会展示给你一个算法，它修改了训练目标使其可以运行得更有效，因此它可以让你应用在一个更大的训练集上面，也可以学到更好的词嵌入。</p>
<h3 id="2-7-负采样（Negative-Sampling）"><a href="#2-7-负采样（Negative-Sampling）" class="headerlink" title="2.7 负采样（Negative Sampling）"></a>2.7 负采样（Negative Sampling）</h3><p>在上个视频中，你见到了<strong>Skip-Gram</strong>模型如何帮助你构造一个监督学习任务，把上下文映射到了目标词上，它如何让你学到一个实用的词嵌入。但是它的缺点就在于<strong>softmax</strong>计算起来很慢。在本视频中，你会看到一个改善过的学习问题叫做负采样，它能做到与你刚才看到的<strong>Skip-Gram</strong>模型相似的事情，但是用了一个更加有效的学习算法，让我们来看看这是怎么做到的。</p>
<p>我们在这个算法中要做的是构造一个新的监督学习问题，那么问题就是给定一对单词，比如<strong>orange</strong>和<strong>juice</strong>，我们要去预测这是否是一对上下文词-目标词（<strong>context-target</strong>）。</p>
<p>总结一下，生成这些数据的方式是我们选择一个上下文词（上图编号2所示），再选一个目标词（上图编号3所示），这（上图编号4所示）就是表的第一行，它给了一个正样本，上下文，目标词，并给定标签为1。然后我们要做的是给定几次，比如$K$次（上图编号5所示），我们将用相同的上下文词，再从字典中选取随机的词，<strong>king</strong>、<strong>book</strong>、<strong>the</strong>、<strong>of</strong>等，从词典中任意选取的词，并标记0，这些就会成为负样本（上图编号6所示）。出现以下情况也没关系，就是如果我们从字典中随机选到的词，正好出现在了词距内，比如说在上下文词<strong>orange</strong>正负10个词之内。</p>
<p>接下来我们将构造一个监督学习问题，其中学习算法输入$x$，输入这对词（上图编号7所示），要去预测目标的标签（上图编号8所示），即预测输出$y$。因此问题就是给定一对词，像<strong>orange</strong>和<strong>juice</strong>，你觉得它们会一起出现么？你觉得这两个词是通过对靠近的两个词采样获得的吗？或者你觉得我是分别在文本和字典中随机选取得到的？这个算法就是要分辨这两种不同的采样方式，这就是如何生成训练集的方法。</p>
<p>这个算法有一个重要的细节就是如何选取负样本，即在选取了上下文词<strong>orange</strong>之后，你如何对这些词进行采样生成负样本？一个办法是对中间的这些词进行采样，即候选的目标词，你可以根据其在语料中的经验频率进行采样，就是通过词出现的频率对其进行采样。但问题是这会导致你在<strong>like</strong>、<strong>the</strong>、<strong>of</strong>、<strong>and</strong>诸如此类的词上有很高的频率。另一个极端就是用1除以词汇表总词数，即$\frac{1}{\left|v\right|}$，均匀且随机地抽取负样本，这对于英文单词的分布是非常没有代表性的。所以论文的作者<strong>Mikolov</strong>等人根据经验，他们发现这个经验值的效果最好，它位于这两个极端的采样方法之间，既不用经验频率，也就是实际观察到的英文文本的分布，也不用均匀分布，他们采用以下方式：</p>
<p>$P\left( w_{i} \right) = \frac{f\left( w_{i} \right)^{\frac{3}{4}}}{\sum_{j = 1}^{10,000}{f\left( w_{j} \right)^{\frac{3}{4}}}}$</p>
<p>进行采样，所以如果$f(w_{i})$是观测到的在语料库中的某个英文词的词频，通过$\frac{3}{4}$次方的计算，使其处于完全独立的分布和训练集的观测分布两个极端之间。我并不确定这是否有理论证明，但是很多研究者现在使用这个方法，似乎也效果不错。</p>
<p>总结一下，你已经知道了在<strong>softmax</strong>分类器中如何学到词向量，但是计算成本很高。在这个视频中，你见到了如何通过将其转化为一系列二分类问题使你可以非常有效的学习词向量。如果你使用这个算法，你将可以学到相当好的词向量。当然和深度学习的其他领域一样，有很多开源的实现，当然也有预训练过的词向量，就是其他人训练过的然后授权许可发布在网上的，所以如果你想要在<strong>NLP</strong>问题上取得进展，去下载其他人的词向量是很好的方法，在此基础上改进。</p>
<h3 id="2-8-GloVe-词向量（GloVe-Word-Vectors）"><a href="#2-8-GloVe-词向量（GloVe-Word-Vectors）" class="headerlink" title="2.8 GloVe 词向量（GloVe Word Vectors）"></a>2.8 GloVe 词向量（GloVe Word Vectors）</h3><p><strong>GloVe</strong>代表用词表示的全局变量（<strong>global vectors for word representation</strong>）。在此之前，我们曾通过挑选语料库中位置相近的两个词，列举出词对，即上下文和目标词，<strong>GloVe</strong>算法做的就是使其关系开始明确化。假定$X_$是单词$i$在单词$j$上下文中出现的次数，那么这里$i$和$j$就和$t$和$c$的功能一样，所以你可以认为$X_$等同于$X_$。你也可以遍历你的训练集，然后数出单词$i$在不同单词$j$上下文中出现的个数，单词$t$在不同单词$c$的上下文中共出现多少次。根据上下文和目标词的定义，你大概会得出$X_$等于$X_{ji}$这个结论。事实上，如果你将上下文和目标词的范围定义为出现于左右各10词以内的话，那么就会有一种对称关系。如果你对上下文的选择是，上下文总是目标词前一个单词的话，那么$X_$和$X_{ji}$就不会像这样对称了。不过对于<strong>GloVe</strong>算法，我们可以定义上下文和目标词为任意两个位置相近的单词，假设是左右各10词的距离，那么$X_$就是一个能够获取单词$i$和单词$j$出现位置相近时或是彼此接近的频率的计数器。</p>
<p><strong>GloVe</strong>模型做的就是进行优化，我们将他们之间的差距进行最小化处理：</p>
<p>$\text{mini}\text{mize}\sum_{i = 1}^{10,000}{\sum_{j = 1}^{10,000}{f\left( X_ \right)\left( \theta_{i}^{T}e_{j} + b_{i} + b_{j}^{‘} - logX_ \right)^{2}}}$</p>
<p>其中$\theta_{i}^{T}e_{j}$，想一下$i$和$j$与$t$和$c$的功能一样，因此这就和你之前看的有些类似了，即$\theta_{t}^{T}e_{c}$。同时对于这个（$\theta_{t}^{T}e_{c}$，下图编号1所示）来说，你想要知道的是告诉你这两个单词之间有多少联系，$t$和$c$之间有多紧密，$i$和$j$之间联系程度如何，换句话说就是他们同时出现的频率是多少，这是由这个$X_$影响的。然后，我们要做的是解决参数$\theta$和$e$的问题，然后准备用梯度下降来最小化上面的公式，你只想要学习一些向量，这样他们的输出能够对这两个单词同时出现的频率进行良好的预测。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111610.png" alt></p>
<p>现在一些附加的细节是如果$X_$是等于0的话，那么$log0$就是未定义的，是负无穷大的，所以我们想要对$X_$为0时进行求和，因此要做的就是添加一个额外的加权项$f\left(X_\right)$（上图编号2所示）。如果$X_$等于0的话，同时我们会用一个约定，即$0log0= 0$，这个的意思是如果$X_ =0$，先不要进行求和，所以这个$log0$项就是不相关项。上面的求和公式表明，这个和仅是一个上下文和目标词关系里连续出现至少一次的词对的和。$f\left(X_\right)$的另一个作用是，有些词在英语里出现十分频繁，比如说<strong>this</strong>，<strong>is</strong>，<strong>of</strong>，<strong>a</strong>等等，有些情况，这叫做<strong>停止词</strong>，但是在频繁词和不常用词之间也会有一个连续统（<strong>continuum</strong>）。不过也有一些不常用的词，比如<strong>durion</strong>，你还是想将其考虑在内，但又不像那些常用词这样频繁。因此，这个加权因子$f\left(X_\right)$就可以是一个函数，即使是像<strong>durion</strong>这样不常用的词，它也能给予大量有意义的运算，同时也能够给像<strong>this</strong>，<strong>is</strong>，<strong>of</strong>，<strong>a</strong>这样在英语里出现更频繁的词更大但不至于过分的权重。因此有一些对加权函数f的选择有着启发性的原则，就是既不给这些词（<strong>this</strong>，<strong>is</strong>，<strong>of</strong>，<strong>a</strong>）过分的权重，也不给这些不常用词（<strong>durion</strong>）太小的权值。如果你想要知道f是怎么能够启发性地完成这个功能的话，你可以看一下我之前的幻灯片里引用的<strong>GloVe</strong>算法论文。</p>
<p>最后，一件有关这个算法有趣的事是$\theta$和$e$现在是完全对称的，所以那里的$\theta_{i}$和$e_{j}$就是对称的。如果你只看数学式的话，他们（$\theta_{i}$和$e_{j}$）的功能其实很相近，你可以将它们颠倒或者将它们进行排序，实际上他们都输出了最佳结果。因此一种训练算法的方法是一致地初始化$\theta$和$e$，然后使用梯度下降来最小化输出，当每个词都处理完之后取平均值，所以，给定一个词$w$，你就会有$e_{w}^{(final)}= \frac{e_{w} +\theta_{w}}{2}$。因为$\theta$和$e$在这个特定的公式里是对称的，而不像之前视频里我们了解的模型，$\theta$和$e$功能不一样，因此也不能像那样取平均。</p>
<p>这就是<strong>GloVe</strong>算法的内容，我认为这个算法的一个疑惑之处是如果你看着这个等式，它实在是太简单了，对吧？仅仅是最小化，像这样的一个二次代价函数（上图编号3所示）是怎么能够让你学习有意义的词嵌入的呢？但是结果证明它确实有效，发明者们发明这个算法的过程是他们以历史上更为复杂的算法，像是<strong>newer language</strong>模型，以及之后的<strong>Word2Vec</strong>、<strong>Skip-Gram</strong>模型等等为基础，同时希望能够简化所有之前的算法才发明的。</p>
<p>在我们总结词嵌入学习算法之前，有一件更优先的事，我们会简单讨论一下。就是说，我们以这个特制的表格作为例子来开始学习词向量，我们说，第一行的嵌入向量是来表示<strong>Gender</strong>的，第二行是来表示<strong>Royal</strong>的，然后是是<strong>Age</strong>，在之后是<strong>Food</strong>等等。但是当你在使用我们了解过的算法的一种来学习一个词嵌入时，例如我们之前的幻灯片里提到的<strong>GloVe</strong>算法，会发生一件事就是你不能保证嵌入向量的独立组成部分是能够理解的，为什么呢？</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111647.png" alt></p>
<p>假设说有个空间，里面的第一个轴（上图编号1所示）是<strong>Gender</strong>，第二个轴（上图编号2所示）是<strong>Royal</strong>，你能够保证的是第一个嵌入向量对应的轴（上图编号3所示）是和这个轴（上面提到的第一和第二基轴，编号1，2所示）有联系的，它的意思可能是<strong>Gender</strong>、<strong>Royal</strong>、<strong>Age</strong>和<strong>Food</strong>。具体而言，这个学习算法会选择这个（上图编号3所示）作为第一维的轴，所以给定一些上下文词，第一维可能是这个轴（上图编号3所示），第二维也许是这个（上图编号4所示），或者它可能不是正交的，它也可能是第二个非正交轴（上图编号5所示），它可以是你学习到的词嵌入中的第二部分。当我们看到这个（上图编号6所示）的时候，如果有某个可逆矩阵$A$，那么这项（上图编号6所示）就可以简单地替换成$\left(A\theta_{i} \right)^{T}(A^{- T}e_{j})$，因为我们将其展开：</p>
<p>$\left( A\theta_{i} \right)^{T}\left( A^{- T}e_{j} \right) = \theta_{i}^{T}A^{T}A^{- T}e_{j} = \theta_{i}^{T}e_{j}$</p>
<p>不必担心，如果你没有学过线性代数的话会，和这个算法一样有一个简单证明过程。你不能保证这些用来表示特征的轴能够等同于人类可能简单理解的轴，具体而言，第一个特征可能是个<strong>Gender</strong>、<strong>Roya</strong>、<strong>Age</strong>、<strong>Food Cost</strong>和<strong>Size</strong>的组合，它也许是名词或是一个行为动词和其他所有特征的组合，所以很难看出独立组成部分，即这个嵌入矩阵的单行部分，然后解释出它的意思。尽管有这种类型的线性变换，这个平行四边形映射也说明了我们解决了这个问题，当你在类比其他问题时，这个方法也是行得通的。因此尽管存在特征量潜在的任意线性变换，你最终还是能学习出解决类似问题的平行四边形映射。</p>
<h3 id="2-9-情感分类（Sentiment-Classification）"><a href="#2-9-情感分类（Sentiment-Classification）" class="headerlink" title="2.9 情感分类（Sentiment Classification）"></a>2.9 情感分类（Sentiment Classification）</h3><h3 id="2-10-词嵌入除偏（Debiasing-Word-Embeddings）"><a href="#2-10-词嵌入除偏（Debiasing-Word-Embeddings）" class="headerlink" title="2.10 词嵌入除偏（Debiasing Word Embeddings）"></a>2.10 词嵌入除偏（Debiasing Word Embeddings）</h3><h2 id="第三周-序列模型和注意力机制（Sequence-models-amp-Attention-mechanism）"><a href="#第三周-序列模型和注意力机制（Sequence-models-amp-Attention-mechanism）" class="headerlink" title="第三周 序列模型和注意力机制（Sequence models &amp; Attention mechanism）"></a><strong>第三周 序列模型和注意力机制（</strong>Sequence models &amp; Attention mechanism<strong>）</strong></h2><p>在这一周，你将会学习<strong>seq2seq</strong>（<strong>sequence to sequence</strong>）模型，从机器翻译到语音识别，它们都能起到很大的作用，从最基本的模型开始。之后你还会学习集束搜索（<strong>Beam search</strong>）和注意力模型（<strong>Attention Model</strong>），一直到最后的音频模型，比如语音。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112232.png" alt></p>
<p>还有一个与此类似的结构被用来做图像描述，给出一张图片，比如这张猫的图片（上图编号1所示），它能自动地输出该图片的描述，一只猫坐在椅子上，那么你如何训练出这样的网络？通过输入图像来输出描述，像这个句子一样。</p>
<p>方法如下，在之前的卷积网络课程中，你已经知道了如何将图片输入到卷积神经网络中，比如一个预训练的<strong>AlexNet</strong>结构（上图编号2方框所示），然后让其学习图片的编码，或者学习图片的一系列特征。现在幻灯片所展示的就是<strong>AlexNet</strong>结构，我们去掉最后的<strong>softmax</strong>单元（上图编号3所示），这个预训练的<strong>AlexNet</strong>结构会给你一个4096维的特征向量，向量表示的就是这只猫的图片，所以这个预训练网络可以是图像的编码网络。现在你得到了一个4096维的向量来表示这张图片，接着你可以把这个向量输入到<strong>RNN</strong>中（上图编号4方框所示），RNN要做的就是生成图像的描述，每次生成一个单词，这和我们在之前将法语译为英语的机器翻译中看到的结构很像，现在你输入一个描述输入的特征向量，然后让网络生成一个输出序列，或者说一个一个地输出单词序列。</p>
<h3 id="3-2-选择最可能的句子（Picking-the-most-likely-sentence）"><a href="#3-2-选择最可能的句子（Picking-the-most-likely-sentence）" class="headerlink" title="3.2 选择最可能的句子（Picking the most likely sentence）"></a>3.2 选择最可能的句子（Picking the most likely sentence）</h3><p>条件语言模型（<strong>conditional language model</strong>）。相比语言模型，输出任意句子的概率，翻译模型会输出句子的英文翻译（上图编号5所示），这取决于输入的法语句子（上图编号6所示）。换句话说，你将估计一个英文翻译的概率，比如估计这句英语翻译的概率，”<strong>Jane is visiting Africa in September.</strong>“，这句翻译是取决于法语句子，”<strong>Jane visite I’Afrique en septembre.</strong>“，这就是英语句子相对于输入的法语句子的可能性，所以它是一个条件语言模型。</p>
<p>不过在了解束搜索之前，你可能会问一个问题，为什么不用贪心搜索(<strong>Greedy Search</strong>)呢？贪心搜索是一种来自计算机科学的算法，生成第一个词的分布以后，它将会根据你的条件语言模型挑选出最有可能的第一个词进入你的机器翻译模型中，在挑选出第一个词之后它将会继续挑选出最有可能的第二个词，然后继续挑选第三个最有可能的词，这种算法就叫做贪心搜索，但是你真正需要的是一次性挑选出整个单词序列，从$y^{&lt;1&gt;}$、$y^{&lt;2&gt;}$到$y^{&lt;T_{y}&gt;}$来使得整体的概率最大化。所以这种贪心算法先挑出最好的第一个词，在这之后再挑最好的第二词，然后再挑第三个，这种方法其实并不管用，为了证明这个观点，我们来考虑下面两种翻译。</p>
<h3 id="3-3-集束搜索（Beam-Search）"><a href="#3-3-集束搜索（Beam-Search）" class="headerlink" title="3.3 集束搜索（Beam Search）"></a>3.3 集束搜索（Beam Search）</h3><p>贪婪算法只会挑出最可能的那一个单词，然后继续。而集束搜索则会考虑多个选择，集束搜索算法会有一个参数<strong>B</strong>，叫做集束宽（<strong>beam width</strong>）。在这个例子中我把这个集束宽设成3，这样就意味着集束搜索不会只考虑一个可能结果，而是一次会考虑3个，比如对第一个单词有不同选择的可能性，最后找到<strong>in</strong>、<strong>jane</strong>、<strong>september</strong>，是英语输出的第一个单词的最可能的三个选项，然后集束搜索算法会把结果存到计算机内存里以便后面尝试用这三个词。如果集束宽设的不一样，如果集束宽这个参数是10的话，那么我们跟踪的不仅仅3个，而是10个第一个单词的最可能的选择。所以要明白，为了执行集束搜索的第一步，你需要输入法语句子到编码网络，然后会解码这个网络，这个<strong>softmax</strong>层（上图编号3所示）会输出10,000个概率值，得到这10,000个输出的概率值，取前三个存起来。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112523.png" alt></p>
<h3 id="3-4-改进集束搜索（Refinements-to-Beam-Search）"><a href="#3-4-改进集束搜索（Refinements-to-Beam-Search）" class="headerlink" title="3.4 改进集束搜索（Refinements to Beam Search）"></a>3.4 改进集束搜索（Refinements to Beam Search）</h3><p>长度归一化（<strong>Length normalization</strong>）就是对束搜索算法稍作调整的一种方式，帮助你得到更好的结果，下面介绍一下它。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112602.png" alt></p>
<p>这些符号看起来可能比实际上吓人，但这就是我们之前见到的乘积概率（<strong>the product probabilities</strong>）。如果计算这些，其实这些概率值都是小于1的，通常远小于1。很多小于1的数乘起来，会得到很小很小的数字，会造成数值下溢（<strong>numerical underflow</strong>）。数值下溢就是数值太小了，导致电脑的浮点表示不能精确地储存，因此在实践中,我们不会最大化这个乘积，而是取$log$值。如果在这加上一个$log$，最大化这个$log$求和的概率值，在选择最可能的句子$y$时，你会得到同样的结果。所以通过取$log$，我们会得到一个数值上更稳定的算法，不容易出现四舍五入的误差，数值的舍入误差（<strong>rounding errors</strong>）或者说数值下溢（<strong>numerical underflow</strong>）。因为$log$函数它是严格单调递增的函数，最大化$P(y)$，因为对数函数，这就是$log$函数，是严格单调递增的函数，所以最大化$logP(y|x)$和最大化$P(y|x)$结果一样。如果一个$y$值能够使前者最大，就肯定能使后者也取最大。所以实际工作中，我们总是记录概率的对数和（<strong>the sum of logs of the probabilities</strong>），而不是概率的乘积（<strong>the production of probabilities</strong>）。</p>
<p>对于目标函数（<strong>this objective function</strong>），还可以做一些改变，可以使得机器翻译表现的更好。如果参照原来的目标函数（<strong>this original objective</strong>），如果有一个很长的句子，那么这个句子的概率会很低，因为乘了很多项小于1的数字来估计句子的概率。所以如果乘起来很多小于1的数字，那么就会得到一个更小的概率值，所以这个目标函数有一个缺点，它可能不自然地倾向于简短的翻译结果，它更偏向短的输出，因为短句子的概率是由更少数量的小于1的数字乘积得到的，所以这个乘积不会那么小。顺便说一下，这里也有同样的问题，概率的$log$值通常小于等于1，实际上在$log$的这个范围内，所以加起来的项越多，得到的结果越负，所以对这个算法另一个改变也可以使它表现的更好，也就是我们不再最大化这个目标函数了，我们可以把它归一化，通过除以翻译结果的单词数量（<strong>normalize this by the number of words in your translation</strong>）。这样就是取每个单词的概率对数值的平均了，这样很明显地减少了对输出长的结果的惩罚（<strong>this significantly reduces the penalty for outputting longer translations.</strong>）。</p>
<p>在实践中，有个探索性的方法，相比于直接除$T_{y}$，也就是输出句子的单词总数，我们有时会用一个更柔和的方法（<strong>a softer approach</strong>），在$T_{y}$上加上指数$a$，$a$可以等于0.7。如果$a$等于1，就相当于完全用长度来归一化，如果$a$等于0，$T_{y}$的0次幂就是1，就相当于完全没有归一化，这就是在完全归一化和没有归一化之间。$a$就是算法另一个超参数（<strong>hyper parameter</strong>），需要调整大小来得到最好的结果。不得不承认，这样用$a$实际上是试探性的，它并没有理论验证。但是大家都发现效果很好，大家都发现实践中效果不错，所以很多人都会这么做。你可以尝试不同的$a$值，看看哪一个能够得到最好的结果。</p>
<p>总结一下如何运行束搜索算法。当你运行束搜索时，你会看到很多长度等于1的句子，很多长度等于2的句子，很多长度等于3的句子，等等。可能运行束搜索30步，考虑输出的句子可能达到，比如长度30。因为束宽为3，你会记录所有这些可能的句子长度，长度为1、2、 3、 4 等等一直到30的三个最可能的选择。然后针对这些所有的可能的输出句子，用这个式子（上图编号1所示）给它们打分，取概率最大的几个句子，然后对这些束搜索得到的句子，计算这个目标函数。最后从经过评估的这些句子中，挑选出在归一化的$log$ 概率目标函数上得分最高的一个（<strong>you pick the one that achieves the highest value on this normalized log probability objective.</strong>），有时这个也叫作<strong>归一化的对数似然目标函数</strong>（<strong>a normalized log likelihood objective</strong>）。这就是最终输出的翻译结果，这就是如何实现束搜索。</p>
<p>最后还有一些实现的细节，如何选择束宽<strong>B</strong>。<strong>B</strong>越大，你考虑的选择越多，你找到的句子可能越好，但是<strong>B</strong>越大，你的算法的计算代价越大，因为你要把很多的可能选择保存起来。最后我们总结一下关于如何选择束宽<strong>B</strong>的一些想法。接下来是针对或大或小的<strong>B</strong>各自的优缺点。如果束宽很大，你会考虑很多的可能，你会得到一个更好的结果，因为你要考虑很多的选择，但是算法会运行的慢一些，内存占用也会增大，计算起来会慢一点。而如果你用小的束宽，结果会没那么好，因为你在算法运行中，保存的选择更少，但是你的算法运行的更快，内存占用也小。在前面视频里，<strong>我们例子中用了束宽为3，所以会保存3个可能选择，在实践中这个值有点偏小</strong>。<strong>在产品中，经常可以看到把束宽设到10，</strong>我认为束宽为100对于产品系统来说有点大了，这也取决于不同应用。但是对科研而言，人们想压榨出全部性能，这样有个最好的结果用来发论文，也经常看到大家用束宽为1000或者3000，这也是取决于特定的应用和特定的领域。在你实现你的应用时，尝试不同的束宽的值，当B很大的时候，性能提高会越来越少。对于很多应用来说，从束宽1，也就是贪心算法，到束宽为3、到10，你会看到一个很大的改善。但是当束宽从1000增加到3000时，效果就没那么明显了。对于之前上过计算机科学课程的同学来说，如果你熟悉计算机科学里的搜索算法（<strong>computer science search algorithms</strong>）, 比如广度优先搜索（<strong>BFS, Breadth First Search algorithms</strong>），或者深度优先搜索（<strong>DFS, Depth First Search</strong>），你可以这样想束搜索，不像其他你在计算机科学算法课程中学到的算法一样。如果你没听说过这些算法也不要紧，但是如果你听说过广度优先搜索和深度优先搜索，不同于这些算法，这些都是精确的搜索算法（<strong>exact search algorithms</strong>），束搜索运行的更快，但是不能保证一定能找到<strong>argmax</strong>的准确的最大值。如果你没听说过广度优先搜索和深度优先搜索，也不用担心，这些对于我们的目标也不重要，如果你听说过，这就是束搜索和其他算法的关系。</p>
<p>好，这就是束搜索。这个算法广泛应用在多产品系统或者许多商业系统上，在深度学习系列课程中的第三门课中，我们讨论了很多关于误差分析（<strong>error analysis</strong>）的问题。事实上在束搜索上做误差分析是我发现的最有用的工具之一。有时你想知道是否应该增大束宽，我的束宽是否足够好，你可以计算一些简单的东西来指导你需要做什么，来改进你的搜索算法。</p>
<h3 id="3-5-集束搜索的误差分析（Error-analysis-in-beam-search）"><a href="#3-5-集束搜索的误差分析（Error-analysis-in-beam-search）" class="headerlink" title="3.5 集束搜索的误差分析（Error analysis in beam search）"></a>3.5 集束搜索的误差分析（Error analysis in beam search）</h3><p>束搜索算法是一种近似搜索算法（<strong>an approximate search algorithm</strong>），也被称作启发式搜索算法（<strong>a heuristic search algorithm</strong>），它不总是输出可能性最大的句子，它仅记录着<strong>B</strong>为前3或者10或是100种可能。那么如果束搜索算法出现错误会怎样呢?</p>
<p>记住，我们是要计算$P(y^*|x)$和$P(\hat y|x)$，然后比较这两个哪个更大，所以就会有两种情况。</p>
<p>第一种情况，<strong>RNN</strong>模型的输出结果$P(y^<em>|x)$ 大于$P(\hat y|x)$，这意味着什么呢?<br>束搜索算法选择了$\hat y$ ，对吧?<br>你得到$\hat y$的方式是，你用一个<strong>RNN</strong>模型来计算$P(y|x)$，然后束搜索算法做的就是尝试寻找使$P(y|x)$最大的$y$，不过在这种情况下，相比于$\hat y$，$y^</em>$的值更$P(y|x)$大，因此你能够得出束搜索算法实际上不能够给你一个能使$P(y|x)$最大化的$y$值，因为束搜索算法的任务就是寻找一个$y$的值来使这项更大，但是它却选择了$\hat y$，而$y^*$实际上能得到更大的值。因此这种情况下你能够得出是束搜索算法出错了。那另一种情况是怎样的呢?</p>
<p>第二种情况是$P(y^<em>|x)$小于或等于$P(\hat y|x)$对吧？这两者之中总有一个是真的。情况1或是情况2总有一个为真。情况2你能够总结出什么呢?<br>在我们的例子中，$y^</em>$ 是比 $\hat y$更好的翻译结果，不过根据RNN模型的结果，$P(y^<em>)$ 是小于$P(\hat y)$的，也就是说，相比于$\hat y$，$y^</em>$成为输出的可能更小。因此在这种情况下，看来是<strong>RNN</strong>模型出了问题。同时可能值得在<strong>RNN</strong>模型上花更多时间。这里我少讲了一些有关长度归一化（<strong>length normalizations</strong>）的细节。这里我略过了有关长度归一化的细节，如果你用了某种长度归一化，那么你要做的就不是比较这两种可能性大小，而是比较长度归一化后的最优化目标函数值。不过现在先忽略这种复杂的情况。第二种情况表明虽然$y^<em>$是一个更好的翻译结果，<strong>RNN</strong>模型却赋予它更低的可能性，是<em>*RNN</em></em>模型出现了问题。</p>
<p>所以误差分析过程看起来就像下面这样。你先遍历开发集，然后在其中找出算法产生的错误，这个例子中，假如说$P(y^<em>|x)$的值为2 x 10-10，而$P(\hat y|x)$的值为 1 x10-10，根据上页幻灯片中的逻辑关系，这种情况下我们得知束搜索算法实际上选择了比$y^</em>$可能性更低的$\hat y$，因此我会说束搜索算法出错了。我将它缩写为<strong>B</strong>。接着你继续遍历第二个错误，再来看这些可能性。也许对于第二个例子来说，你认为是<strong>RNN</strong>模型出现了问题，我会用缩写<strong>R</strong>来代表<strong>RNN</strong>。再接着你遍历了更多的例子，有时是束搜索算法出现了问题，有时是模型出现了问题，等等。通过这个过程，你就能够执行误差分析，得出束搜索算法和<strong>RNN</strong>模型出错的比例是多少。有了这样的误差分析过程，你就可以对开发集中每一个错误例子，即算法输出了比人工翻译更差的结果的情况，尝试确定这些错误，是搜索算法出了问题，还是生成目标函数(束搜索算法使之最大化)的<strong>RNN</strong>模型出了问题。并且通过这个过程，你能够发现这两个部分中哪个是产生更多错误的原因，并且只有当你发现是束搜索算法造成了大部分错误时，才值得花费努力增大集束宽度。相反地，如果你发现是<strong>RNN</strong>模型出了更多错，那么你可以进行更深层次的分析，来决定是需要增加正则化还是获取更多的训练数据，抑或是尝试一个不同的网络结构，或是其他方案。你在第三门课中，了解到各种技巧都能够应用在这里。</p>
<p>这就是束搜索算法中的误差分析，我认为这个特定的误差分析过程是十分有用的，它可以用于分析近似最佳算法(如束搜索算法)，这些算法被用来优化学习算法(例如序列到序列模型/<strong>RNN</strong>)输出的目标函数。</p>
<h3 id="3-6-Bleu-得分（选修）（Bleu-Score-optional-）"><a href="#3-6-Bleu-得分（选修）（Bleu-Score-optional-）" class="headerlink" title="3.6 Bleu 得分（选修）（Bleu Score (optional)）"></a>3.6 Bleu 得分（选修）（Bleu Score (optional)）</h3><p><strong>BLEU</strong>得分对于机器翻译来说，具有革命性的原因是因为它有一个相当不错的虽然不是完美的但是非常好的单一实数评估指标，因此它加快了整个机器翻译领域的进程，我希望这节视频能够让你了解<strong>BLEU</strong>得分是如何操作的。实践中，很少人会从零实现一个<strong>BLEU</strong>得分（<strong>implement a BLEU score from scratch</strong>），有很多开源的实现结果，你可以下载下来然后直接用来评估你的系统。不过今天，<strong>BLEU</strong>得分被用来评估许多生成文本的系统（<strong>systems that generate text</strong>），比如说机器翻译系统（<strong>machine translation systems</strong>），也有我之前简单提到的图像描述系统（<strong>image captioning systems</strong>）。也就是说你会用神经网络来生成图像描述，然后使用<strong>BLEU</strong>得分来看一下，结果在多大程度上与参考描述或是多个人工完成的参考描述内容相符。<strong>BLEU</strong>得分是一个有用的单一实数评估指标，用于评估生成文本的算法，判断输出的结果是否与人工写出的参考文本的含义相似。不过它并没有用于语音识别（<strong>speech recognition</strong>）。因为在语音识别当中，通常只有一个答案，你可以用其他的评估方法，来看一下你的语音识别结果，是否十分相近或是字字正确（<strong>pretty much, exactly word for word correct</strong>）。不过在图像描述应用中，对于同一图片的不同描述，可能是同样好的。或者对于机器翻译来说，有多个一样好的翻译结果，<strong>BLEU</strong>得分就给了你一个能够自动评估的方法，帮助加快算法开发进程。说了这么多，希望你明白了<strong>BLEU</strong>得分是怎么运行的。</p>
<h3 id="3-7-注意力模型直观理解（Attention-Model-Intuition）"><a href="#3-7-注意力模型直观理解（Attention-Model-Intuition）" class="headerlink" title="3.7 注意力模型直观理解（Attention Model Intuition）"></a>3.7 注意力模型直观理解（Attention Model Intuition）</h3><h3 id="3-8注意力模型（Attention-Model）"><a href="#3-8注意力模型（Attention-Model）" class="headerlink" title="3.8注意力模型（Attention Model）"></a>3.8注意力模型（Attention Model）</h3><p><strong>注意力模型如何让一个神经网络只注意到一部分的输入句子。当它在生成句子的时候，更像人类翻译</strong>。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112935.png" alt></p>
<p>跟上个视频一样，我们先假定有一个输入句子，并使用双向的<strong>RNN</strong>，或者双向的<strong>GRU</strong>或者双向的<strong>LSTM</strong>，去计算每个词的特征。实际上<strong>GRU</strong>和<strong>LSTM</strong>经常应用于这个，可能<strong>LSTM</strong>更经常一点。对于前向传播（<strong>the forward occurrence</strong>），你有第一个时间步的前向传播的激活值（<strong>a forward occurrence first time step</strong>），第一个时间步后向传播的激活值，后向的激活值，以此类推。他们一共向前了五个时间步，也向后了五个时间步，技术上我们把这里设置为0。我们也可以后向传播6次，设一个都是0的因子，实际上就是个都是0的因子。为了简化每个时间步的记号，即使你在双向<strong>RNN</strong>已经计算了前向的特征值和后向的特征值，我就用$a^{<t>}$来一起表示这些联系。所以$a^{<t>}$就是时间步$t$上的特征向量。<strong>但是为了保持记号的一致性，我们用第二个，也就是$t’$，实际上我将用$t’$来索引法语句子里面的词</strong>。接下来我们只进行前向计算，就是说这是个单向的<strong>RNN</strong>，用状态$S$表示生成翻译。所以第一个时间步，它应该生成$y^{&lt;1&gt;}$，当你输入上下文$C$的时候就会这样，如果你想用时间来索引它，你可以写$C^{&lt;1&gt;}$，但有时候我就写个$C$，就是没有上标的$C$，这个会取决于注意力参数，即$a^{&lt;1,1&gt;}$，$a^{&lt;1,2&gt;}$以此类推，告诉我们应该花多少注意力。同样的，这个$a$参数告诉我们上下文有多少取决于我们得到的特征，或者我们从不同时间步中得到的激活值。所以我们定义上下文的方式实际上来源于被注意力权重加权的不同时间步中的特征值。于是更公式化的注意力权重将会满足非负的条件，所以这就是个0或正数，它们加起来等于1。我们等会会见到我们如何确保这个成立，我们将会有上下文，或者说在$t=1$时的上下文，我会经常省略上标，这就会变成对$t’$的求和。这个权重的所有的$t’$值，加上这些激活值。所以这里的这项（上图编号1所示）就是注意力权重，这里的这项（上图编号2）来自于这里（上图编号3），于是$a^{&lt;t,t’&gt;}$就是$y^{<t>}$应该在$t’$时花在$a$上注意力的数量。换句话来说，当你在$t$处生成输出词，你应该花多少注意力在第$t’$个输入词上面，这是生成输出的其中一步。然后下一个时间步，你会生成第二个输出。于是相似的，你现在有了一个新的注意力权重集，再找到一个新的方式将它们相加，这就产生了一个新的上下文，这个也是输入，且允许你生成第二个词。只有现在才用这种方式相加，它会变成第二个时间步的上下文。即对$t’$的$a^{&lt;2,t’&gt;}$进行求和，于是使用这些上下文向量，$C^{&lt;1&gt;}$写到这里，$C^{&lt;2&gt;}$也同理。这里的神经网络看起来很像相当标准的<strong>RNN</strong>序列，这里有着上下文向量作为输出，我们可以一次一个词地生成翻译，我们也定义了如何通过这些注意力权重和输入句子的特征值来计算上下文向量。剩下唯一要做的事情就是定义如何计算这些注意力权重。让我们下张幻灯片看看。</t></t></t></p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112950.png" alt></p>
<p>回忆一下$a^{&lt;t,t’&gt;}$，是你应该花费在$a^{&lt;t’&gt;}$上的注意力的数量，当你尝试去生成第$t$个输出的翻译词，让我们先把式子写下来，再讨论它是怎么来的。这个式子你可以用来计算$a^{&lt;t,t’&gt;}$，在此之前我们要先计算$e^{&lt;t,t’&gt;}$，关键要用<strong>softmax</strong>，来确保这些权重加起来等于1。如果你对$t’$求和，比如每一个固定的$t$值，这些加起来等于1。如果你对$t’$求和，然后优先使用<strong>softmax</strong>，确保这些值加起来等于1。</p>
<p>现在我们如何计算这些$e$项，一种我们可以用的方式是用下面这样的小的神经网络，于是$s^{<t-1>}$就是神经网络在上个时间步的状态，于是这里我们有一个神经网络，如果你想要生成$y^{<t>}$，那么$s^{<t-1>}$就是上一时间步的隐藏状态，即$s^{<t>}$。这是给小神经网络的其中一个输入，也就是在神经网络中的一个隐藏层，因为你需要经常计算它们，然后$a^{&lt;t’&gt;}$，即上个时间步的的特征是另一个输入。直观来想就是，如果你想要决定要花多少注意力在$t’$的激活值上。于是，似乎它会很大程度上取决于你上一个时间步的的隐藏状态的激活值。你还没有当前状态的激活值，因为上下文会输入到这里，所以你还没计算出来，但是看看你生成上一个翻译的<strong>RNN</strong>的隐藏状态，然后对于每一个位置，每一个词都看向他们的特征值，这看起来很自然，即$a^{&lt;t,t’&gt;}$和$e^{&lt;t,t’&gt;}$应该取决于这两个量。但是我们不知道具体函数是什么，所以我们可以做的事情就是训练一个很小的神经网络，去学习这个函数到底是什么。相信反向传播算法，相信梯度下降算法学到一个正确的函数。这表示，如果你应用这整个的模型，然后用梯度下降来训练它，这是可行的。这个小型的神经网络做了一件相当棒的事情，告诉你$y^{<t>}$应该花多少注意力在$a^{<t>}$上面，然后这个式子确保注意力权重加起来等于1，于是当你持续地一次生成一个词，这个神经网络实际上会花注意力在右边的这个输入句子上，它会完全自动的通过梯度下降来学习。</t></t></t></t-1></t></t-1></p>
<p>这个算法的一个缺点就是它要花费三次方的时间，就是说这个算法的复杂是$O(n3)$的，如果你有$T_x$个输入单词和$T_y$个输出单词，于是注意力参数的总数就会是$T_x\times T_y$，所以这个算法有着三次方的消耗。但是在机器翻译的应用上，输入和输出的句子一般不会太长，可能三次方的消耗是可以接受，但也有很多研究工作，尝试去减少这样的消耗。那么讲解注意想法在机器翻译中的应用，就到此为止了。虽然没有讲到太多的细节，但这个想法也被应用到了其他的很多问题中去了，比如图片加标题（<strong>image captioning</strong>），图片加标题就是看一张图，写下这张图的标题。底下的这篇论文来源于<strong>Kevin Chu</strong>，<strong>Jimmy Barr</strong>, <strong>Ryan Kiros</strong>, <strong>Kelvin Shaw</strong>, <strong>Aaron Korver</strong>, <strong>Russell Zarkutnov</strong>, <strong>Virta Zemo</strong>, 和 <strong>Andrew Benjo</strong>。他们也显示了你可以有一个很相似的结构看图片，然后，当你在写图片标题的时候，一次只花注意力在一部分的图片上面。如果你感兴趣，那么我鼓励你，也去看看这篇论文，做一些编程练习。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113000.png" alt></p>
<p>因为机器翻译是一个非常复杂的问题，在之前的练习中，你应用了注意力，在日期标准化的问题（<strong>the date normalization problem</strong>）上面，问题输入了像这样的一个日期，这个日期实际上是阿波罗登月的日期，把它标准化成标准的形式，或者这样的日期。用一个序列的神经网络，即序列模型去标准化到这样的形式，这个日期实际上是威廉·莎士比亚的生日。一般认为是这个日期正如你之前联系中见到的，你可以训练一个神经网络，输入任何形式的日期，生成标准化的日期形式。其他可以做的有意思的事情是看看可视化的注意力权重（<strong>the visualizations of the attention weights</strong>）。这个一个机器翻译的例子，这里被画上了不同的颜色，不同注意力权重的大小，我不想在这上面花太多时间，但是你可以发现，对应的输入输出词，你会发现注意力权重，会变高，因此这显示了当它生成特定的输出词时通常会花注意力在输入的正确的词上面，包括学习花注意在哪。<br>在注意力模型中，使用反向传播时， 什么时候学习完成。</p>
<h3 id="3-9语音识别（Speech-recognition）"><a href="#3-9语音识别（Speech-recognition）" class="headerlink" title="3.9语音识别（Speech recognition）"></a>3.9语音识别（Speech recognition）</h3><p>现今，最令人振奋的发展之一，就是<strong>seq2seq</strong>模型（<strong>sequence-to-sequence models</strong>）在语音识别方面准确性有了很大的提升。这门课程已经接近尾声，现在我想通过剩下几节视频，来告诉你们，<strong>seq2seq</strong>模型是如何应用于音频数据的（<strong>audio data</strong>），比如语音（<strong>the speech</strong>）。</p>
<p>什么是语音视频问题呢？现在你有一个音频片段$x$（<strong>an audio clip,x</strong>），你的任务是自动地生成文本$y$。现在有一个音频片段，画出来是这样，该图的横轴是时间。一个麦克风的作用是测量出微小的气压变化，现在你之所以能听到我的声音，是因为你的耳朵能够探测到这些微小的气压变化，它可能是由你的扬声器或者耳机产生的，也就是像图上这样的音频片段，气压随着时间而变化。假如这个我说的音频片段的内容是：”<strong>the quick brown fox</strong>“(敏捷的棕色狐狸)，这时我们希望一个语音识别算法（<strong>a speech recognition algorithm</strong>），通过输入这段音频，然后输出音频的文本内容。考虑到人的耳朵并不会处理声音的原始波形，而是通过一种特殊的物理结构来测量这些，不同频率和强度的声波。音频数据的常见预处理步骤，就是运行这个原始的音频片段，然后生成一个声谱图（<strong>a spectrogram</strong>），就像这样。同样地，横轴是时间，纵轴是声音的频率（<strong>frequencies</strong>），而图中不同的颜色，显示了声波能量的大小（<strong>the amount of energy</strong>），也就是在不同的时间和频率上这些声音有多大。通过这样的声谱图，或者你可能还听过人们谈到过伪空白输出（<strong>the false blank outputs</strong>），也经常应用于预处理步骤，也就是在音频被输入到学习算法之前，而人耳所做的计算和这个预处理过程非常相似。语音识别方面，最令人振奋的趋势之一就是曾经有一段时间，语音识别系统是用音位（<strong>phonemes</strong>）来构建的，也就是人工设计的基本单元（<strong>hand-engineered basic units of cells</strong>），如果用音位来表示”<strong>the quick brown fox</strong>“，我这里稍微简化一些，”<strong>the</strong>“含有”<strong>th</strong>“和”<strong>e</strong>“的音，而”<strong>quick</strong>“有”<strong>k</strong>“ “<strong>w</strong>“ “<strong>i</strong>“ “<strong>k</strong>“的音，语音学家过去把这些音作为声音的基本单元写下来，把这些语音分解成这些基本的声音单元，而”<strong>brown</strong>“不是一个很正式的音位，因为它的音写起来比较复杂，不过语音学家（<strong>linguists</strong>）们认为用这些基本的音位单元（<strong>basic units of sound called phonemes</strong>）来表示音频（<strong>audio</strong>），是做语音识别最好的办法。不过在<strong>end-to-end</strong>模型中，我们发现这种音位表示法（<strong>phonemes representations</strong>）已经不再必要了，而是可以构建一个系统，通过向系统中输入音频片段（<strong>audio clip</strong>），然后直接输出音频的文本（<strong>a transcript</strong>），而不需要使用这种人工设计的表示方法。使这种方法成为可能的一件事就是用一个很大的数据集，所以语音识别的研究数据集可能长达300个小时，在学术界，甚至3000小时的文本音频数据集，都被认为是合理的大小。大量的研究，大量的论文所使用的数据集中，有几千种不同的声音，而且，最好的商业系统现在已经训练了超过1万个小时的数据，甚至10万个小时，并且它还会继续变得更大。在文本音频数据集中（<strong>Transcribe audio data sets</strong>）同时包含$x$和$y$，通过深度学习算法大大推进了语音识别的进程。那么，如何建立一个语音识别系统呢？</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113125.png" alt></p>
<p>在上一节视频中，我们谈到了注意力模型，所以，一件你能做的事就是在横轴上，也就是在输入音频的不同时间帧上，你可以用一个注意力模型，来输出文本描述，如”<strong>the quick brown fox</strong>“，或者其他语音内容。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113056.png" alt></p>
<p>还有一种效果也不错的方法，就是用<strong>CTC</strong>损失函数（<strong>CTC cost</strong>）来做语音识别。<strong>CTC</strong>就是<strong>Connectionist Temporal Classification</strong>，它是由<strong>Alex Graves</strong>、<strong>Santiago Fernandes</strong>, <strong>Faustino Gomez</strong>、和<strong>Jürgen Schmidhuber</strong>提出的。（<strong>Graves A, Gomez F. Connectionist temporal classification:labelling unsegmented sequence data with recurrent neural networks[C]// International Conference on Machine Learning. ACM, 2006:369-376.</strong>）</p>
<p>算法思想如下:</p>
<p>假设语音片段内容是某人说：”<strong>the quick brown fox</strong>“，这时我们使用一个新的网络，结构像这个样子，这里输入$x$和输出$y$的数量都是一样的，因为我在这里画的，只是一个简单的单向<strong>RNN</strong>结构。然而在实际中，它有可能是双向的<strong>LSTM</strong>结构，或者双向的<strong>GIU</strong>结构，并且通常是很深的模型。但注意一下这里时间步的数量，它非常地大。在语音识别中，通常输入的时间步数量（<strong>the number of input time steps</strong>）要比输出的时间步的数量（<strong>the number of output time steps</strong>）多出很多。举个例子，比如你有一段10秒的音频，并且特征（<strong>features</strong>）是100赫兹的，即每秒有100个样本，于是这段10秒的音频片段就会有1000个输入，就是简单地用100赫兹乘上10秒。所以有1000个输入，但可能你的输出就没有1000个字母了，或者说没有1000个字符。这时要怎么办呢？<strong>CTC</strong>损失函数允许<strong>RNN</strong>生成这样的输出：<strong>ttt</strong>，这是一个特殊的字符，叫做空白符，我们这里用下划线表示，这句话开头的音可表示为<strong>h_eee_ _ _</strong>，然后这里可能有个空格，我们用这个来表示空格，之后是<strong>_ _ _qqq__</strong>，这样的输出也被看做是正确的输出。下面这段输出对应的是”<strong>the q</strong>“。<strong>CTC损失函数的一个基本规则是将空白符之间的重复的字符折叠起来，再说清楚一些，我这里用下划线来表示这个特殊的空白符（a special blank character），它和空格（the space character）是不一样的</strong>。所以<strong>the</strong>和<strong>quick</strong>之间有一个空格符，所以我要输出一个空格，通过把用空白符所分割的重复的字符折叠起来，然后我们就可以把这段序列折叠成”<strong>the q</strong>“。这样一来你的神经网络因为有很多这种重复的字符，和很多插入在其中的空白符（<strong>blank characters</strong>），所以最后我们得到的文本会短上很多。于是这句”<strong>the quick brown fox</strong>“包括空格一共有19个字符，在这样的情况下，通过允许神经网络有重复的字符和插入空白符使得它能强制输出1000个字符，甚至你可以输出1000个$y$值来表示这段19个字符长的输出。这篇论文来自于<strong>Alex Grace</strong>以及刚才提到的那些人。我所参与的深度语音识别系统项目就使用这种思想来构建有效的语音识别系统。</p>
<p>希望这能给你一个粗略的理解，理解语音识别模型是如何工作的：注意力模型是如何工作的，以及<strong>CTC</strong>模型是如何工作的，以及这两种不同的构建这些系统的方法。现今，在生产技术中，构建一个有效语音识别系统，是一项相当重要的工作，并且它需要很大的数据集</p>
<h3 id="3-10触发字检测（Trigger-Word-Detection）"><a href="#3-10触发字检测（Trigger-Word-Detection）" class="headerlink" title="3.10触发字检测（Trigger Word Detection）"></a>3.10触发字检测（Trigger Word Detection）</h3><p>现在你已经学习了很多关于深度学习和序列模型的内容，于是我们可以真正去简便地描绘出一个触发字系统（<strong>a trigger word system</strong>），就像上节视频中你看到的那样。随着语音识别的发展，越来越多的设备可以通过你的声音来唤醒，这有时被叫做触发字检测系统（<strong>rigger word detection systems</strong>）。我们来看一看如何建立一个触发字系统。</p>
<p>有关于触发字检测系统的文献，还处于发展阶段。对于触发字检测，最好的算法是什么，目前还没有一个广泛的定论。我这里就简单向你介绍一个你能够使用的算法好了。现在有一个这样的<strong>RNN</strong>结构，<strong>我们要做的就是把一个音频片段（an audio clip）计算出它的声谱图特征（spectrogram features）得到特征向量</strong>$x^{&lt;1&gt;}$, $x^{&lt;2&gt;}$, $x^{&lt;3&gt;}$..，然后把它放到<strong>RNN</strong>中，最后要做的，就是定义我们的目标标签$y$。假如音频片段中的这一点是某人刚刚说完一个触发字，比如”<strong>Alexa</strong>“，或者”小度你好” 或者”<strong>Okay Google</strong>“，那么在这一点之前，你就可以在训练集中把目标标签都设为0，然后在这个点之后把目标标签设为1。假如在一段时间之后，触发字又被说了一次，比如是在这个点说的，那么就可以再次在这个点之后把目标标签设为1。这样的标签方案对于<strong>RNN</strong>来说是可行的，并且确实运行得非常不错。不过该算法一个明显的缺点就是它构建了一个很不平衡的训练集（<strong>a very imbalanced training set</strong>），0的数量比1多太多了。</p>
<p>这里还有一个解决方法，虽然听起来有点简单粗暴，但确实能使其变得更容易训练。比起只在一个时间步上去输出1，其实你可以在输出变回0之前，多次输出1，或说在固定的一段时间内输出多个1。这样的话，就稍微提高了1与0的比例，这确实有些简单粗暴。在音频片段中，触发字刚被说完之后，就把多个目标标签设为1，这里触发字又被说了一次。说完以后，又让<strong>RNN</strong>去输出1。在之后的编程练习中，你可以进行更多这样的操作，我想你应该会对自己学会了这么多东西而感到自豪。我们仅仅用了一张幻灯片来描述这种复杂的触发字检测系统。在这个基础上，希望你能够实现一个能有效地让你能够检测出触发字的算法，不过在编程练习中你可以看到更多的学习内容。这就是触发字检测，希望你能对自己感到自豪。因为你已经学了这么多深度学习的内容，现在你可以只用几分钟时间，就能用一张幻灯片来描述触发字能够实现它，并让它发挥作用。你甚至可能在你的家里用触发字系统做一些有趣的事情，比如打开或关闭电器，或者可以改造你的电脑，使得你或者其他人可以用触发字来操作它。</p>
<h3 id="3-11结论和致谢（Conclusion-and-thank-you）"><a href="#3-11结论和致谢（Conclusion-and-thank-you）" class="headerlink" title="3.11结论和致谢（Conclusion and thank you）"></a>3.11结论和致谢（Conclusion and thank you）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113224.png" alt></p>
<p>我们一起经历了一段很长的旅程，如果你已经学完了整个专业的课程，那么现在你已经学会了神经网络和深度学习，如何改进深度神经网络，如何结构化机器学习项目，和卷积神经网络。在最近的课程中还学了序列模型，我知道你为此非常努力，也希望你能对自己感到自豪，为你的努力，为你所做的这一切。</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113243.png" alt></p>
<p>我想向你传达一个对你来说可能很重要的想法。就是我觉得深度学习是一种超能力，通过深度学习算法，你可以让计算机拥有”视觉”（<strong>make a computer see</strong>），可以让计算机自己合成小说（<strong>synthesize novel art</strong>），或者合成音乐（<strong>synthesized music</strong>），可以让计算机将一种语言翻译成另一种（<strong>translate from one language to another</strong>），或者对放射影像进行定位然后进行医疗诊断（<strong>Maybe have it located radiology image and render a medical diagnosis</strong>），或者构建自动驾驶系统（<strong>build pieces of a car that can drive itself</strong>）。如果说这还不是超能力的话，那还能是什么呢？当我们结束这一系列课程的时候，结束整个专业的时候，我希望你能够使用这些思想来发展你的事业，追逐你的梦想，但最重要的是，去做你认为最合适的能对人类有贡献的事。这个世界现在面临着诸多挑战，但是在这种力量下，在人工智能和深度学习的力量下，我觉得我们可以让世界变得更美好。现在这种超能力就掌握在你的手中，去突破障碍，让生活变得更好，这不单单是为自己，也是为了其他人。当然我也希望你能够对自己取得的成就以及你学到的一切感到自豪。当你完成这一系列课程的学习后，我想你可以把课程分享到社交媒体上，比如<strong>Twitter</strong>和<strong>Facebook</strong>，让你的朋友也能知道这门课程。</p>
<p>最后，我想告诉你的最后一件事，就是恭喜你完成了这门课程的学习，为自己所取得的成就欢呼吧！同时也非常感谢你们，因为我知道大家都很忙，即便如此你们还是花了很多时间来学习这些视频，可能还花了很多时间来做课堂测验还有编程练习，希望你们能够乐在其中，并学到很多算法流程。我很荣幸你们能够花费时间，付诸精力，来学习这些东西，非常感谢大家！</p>
<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113305.png" alt></p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《关于神经网络与深度学习》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/06/25/deeplearning/" property="cc:attributionName"
               rel="cc:attributionURL">
                Henry-Avery
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'bcac118c07efd37bb7c3',
        clientSecret: '59ace8a6f5bc3daffc7aa090f2f8e93c971668e8',
        repo: 'Blogtalk',
        owner: 'henry-avery',
        admin: "henry-avery",
        id: '2021/06/25/deeplearning/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/06/29/acwing/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="AcWing算法基础学习">
                        
                        <span class="card-title">AcWing算法基础学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            开始认真学算法
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-06-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/学习笔记/" class="post-category" target="_blank">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/算法/" target="_blank">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/06/23/shugame/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="SHU智科大二夏季学期游戏开发">
                        
                        <span class="card-title">SHU智科大二夏季学期游戏开发</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            如题，关于游戏和学习游戏开发，相关书目《游戏改变世界》
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-06-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/学习笔记/" class="post-category" target="_blank">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SHU/" target="_blank">
                        <span class="chip bg-color">SHU</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 小天爷的博客<br />'
            + '作者: Henry-Avery<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2020 Henry-Avery. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">228.6k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/henry-avery" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>







    <a href="http://wpa.qq.com/msgrd?v=3&uin=849095098&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 1;
        var uvcountOffset = 1;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 07, 30, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        /*document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
        document.getElementById("sitetime").innerHTML = "本站已运行 " +  diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>