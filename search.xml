<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SHU运筹与优化</title>
      <link href="/2021/12/16/shuop/"/>
      <url>/2021/12/16/shuop/</url>
      
        <content type="html"><![CDATA[<h2 id="MATLAB实验"><a href="#MATLAB实验" class="headerlink" title="MATLAB实验"></a>MATLAB实验</h2><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>1.判断是否存在单位矩阵，并输出列</p><pre class="line-numbers language-matlab"><code class="language-matlab">m<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>n<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span> A <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span><span class="token function">rand</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>I <span class="token operator">=</span> <span class="token function">eye</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>randIndex <span class="token operator">=</span> <span class="token function">randperm</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token function">randIndex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span>I<span class="token punctuation">;</span><span class="token comment" spellcheck="true">%准备数据，想了好久这是在干嘛</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>C <span class="token operator">=</span> <span class="token function">nchoosek</span><span class="token punctuation">(</span>randIndex<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%R = rref(A)</span><span class="token comment" spellcheck="true">%%%</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>I<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">%disp("find eye!");</span>        count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        Column <span class="token operator">=</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%%%</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">disp</span><span class="token punctuation">(</span>"no eye<span class="token punctuation">!</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>        <span class="token function">disp</span><span class="token punctuation">(</span>"find eye<span class="token punctuation">!</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>    Column<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>组合排列函数</strong></p><p>nchoosek(n,m) </p><p>含义：从n个元素中取出m个元素的所有组合。</p><hr><p><strong>将矩阵化成行最简形</strong>的命令是rref或rrefmovie。<br>函数 rref或rrefmovie格式<br>R = rref(A)  %用高斯—约当消元法和行主元法求A的行最简行矩阵R</p><hr><p>2.高斯消元解方程</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> x<span class="token operator">=</span><span class="token function">gauss_elim</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%参量说明：A,系数矩阵；B，常数列向量；zg，增广矩阵</span><span class="token comment" spellcheck="true">%将增广矩阵化为上三角，再回带求解x</span><span class="token comment" spellcheck="true">%此方法较为常规，将zg(k,k)元素乘以-zg(i,k)/zg(k,k)加到第i行</span><span class="token comment" spellcheck="true">%从1:n-1列，主对角元素的以下行，通过两层循环来遍历</span>zg<span class="token operator">=</span><span class="token punctuation">[</span>A<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>zj<span class="token operator">=</span><span class="token function">rref</span><span class="token punctuation">(</span>zg<span class="token punctuation">)</span><span class="token punctuation">;</span>n<span class="token operator">=</span><span class="token function">length</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>ra<span class="token operator">=</span><span class="token function">rank</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>rz<span class="token operator">=</span><span class="token function">rank</span><span class="token punctuation">(</span>zg<span class="token punctuation">)</span><span class="token punctuation">;</span>temp<span class="token operator">=</span>rz<span class="token operator">-</span>ra<span class="token punctuation">;</span><span class="token keyword">if</span> temp<span class="token operator">></span><span class="token number">0</span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'无解'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> ra<span class="token operator">==</span>rz    <span class="token keyword">if</span> ra<span class="token operator">==</span>n        x<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> p<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token number">-1</span>            <span class="token keyword">for</span> k<span class="token operator">=</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>n                m<span class="token operator">=</span><span class="token function">zg</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">zg</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">zg</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>p<span class="token operator">:</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">zg</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>p<span class="token operator">:</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span>m<span class="token operator">*</span><span class="token function">zg</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>p<span class="token operator">:</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>        <span class="token comment" spellcheck="true">%用第p层（从1到n-1）消元</span>        b<span class="token operator">=</span><span class="token function">zg</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        A<span class="token operator">=</span><span class="token function">zg</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">x</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">b</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">A</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> q<span class="token operator">=</span>n<span class="token number">-1</span><span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span>            <span class="token function">x</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">A</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>find（）</p><p>查找非零元素的索引和值</p><pre><code>k = find(X)k = find(X,n)k = find(X,n,direction)</code></pre><p>返回一个包含数组 <code>X</code> 中每个非零元素的<a href="https://ww2.mathworks.cn/help/matlab/ref/find.html#buf0c2r-8" target="_blank" rel="noopener">线性索引</a>的向量。</p><hr><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p>实现函数function [xs,Bs,x_num]=BFS(A,b)，求基本可行解和对应的基（矩阵）。</p><p>测试程序</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%BFS_test.m</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">]</span>b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">'</span><span class="token punctuation">[</span>xs<span class="token punctuation">,</span>Bs<span class="token punctuation">,</span>x_num<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">BFS</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> <span class="token punctuation">[</span>xs<span class="token punctuation">,</span>Bs<span class="token punctuation">,</span>x_num<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">BFS</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%参量说明：A,系数矩阵；b，常数列向量；xs,基本可行解，Bs对应基矩阵，x_num，个数</span>clc <span class="token comment" spellcheck="true">%清屏</span><span class="token comment" spellcheck="true">%clear all % 清除变量</span>close all <span class="token comment" spellcheck="true">% 关掉图像窗口</span>format RAT <span class="token comment" spellcheck="true">% 显示分数形式</span><span class="token comment" spellcheck="true">%m = 3; %矩阵A的行数</span><span class="token comment" spellcheck="true">%n =5; %矩阵A的列数% 随机生成一个m*n行满秩矩阵A测试,这里按照ppt给的例子设置</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>x_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>idxs <span class="token operator">=</span> <span class="token function">nchoosek</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">%所有可能的基阵的下标组合</span>count <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>idxs<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span>count    idx <span class="token operator">=</span> <span class="token function">idxs</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Bs_ <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token function">det</span><span class="token punctuation">(</span>Bs_<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">%fprintf([</span><span class="token string">'\n1.B不能构成基阵.\n'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% B是奇异矩阵，不能构成基阵</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">%fprintf([</span><span class="token string">'\n1. B能构成基阵.\n'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% B不是奇异矩阵，能构成基阵</span>        <span class="token comment" spellcheck="true">% 令X_N=0，解方程B_X*B+N*X_N=b,计算基本解为X_B=B^(-1)b,XN=0;</span>        xs_ <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        X_B <span class="token operator">=</span> <span class="token function">inv</span><span class="token punctuation">(</span>Bs_<span class="token punctuation">)</span><span class="token operator">*</span>b<span class="token punctuation">;</span>        X_N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">xs_</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token operator">=</span>X_B<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">%fprintf(</span><span class="token string">'2. 该基阵对应的基本解：xs= [%s].\n'</span><span class="token punctuation">,</span><span class="token function">rats</span><span class="token punctuation">(</span>xs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% 判断是否为基本可行解</span>        <span class="token punctuation">[</span>r<span class="token punctuation">,</span>c<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>xs_<span class="token punctuation">)</span><span class="token punctuation">;</span>        flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%判断基本解是否为基本可行解</span>        <span class="token keyword">for</span> <span class="token number">i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span>c           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">xs_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>               flag<span class="token operator">=</span>flag<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token keyword">end</span>        <span class="token keyword">end</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">%fprintf([</span><span class="token string">'\n3. xs是基本可行解.\n'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            x_num <span class="token operator">=</span>x_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">xs</span><span class="token punctuation">(</span>x_num<span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">=</span>xs_<span class="token punctuation">;</span>            <span class="token function">Bs</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span>x_num<span class="token punctuation">)</span><span class="token operator">=</span>Bs_<span class="token punctuation">;</span>        <span class="token keyword">else</span>             <span class="token comment" spellcheck="true">%fprintf([</span><span class="token string">'\n3. xs不是基本可行解.\n'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h3><p>测试程序</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%test</span>A<span class="token operator">=</span><span class="token punctuation">[</span> <span class="token number">2</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span> <span class="token number">5</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">15</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">'</span><span class="token punctuation">;</span> c<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>format rat <span class="token comment" spellcheck="true">%元素使用分数表示</span><span class="token comment" spellcheck="true">% [x_opt,fx_opt,iter] = Simplex_eye(A,b,c);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数实现</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> <span class="token punctuation">[</span>x_opt<span class="token punctuation">,</span>fx_opt<span class="token punctuation">,</span>iter<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Simplex_eye</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%参量说明：x_opt为最求解，fx_opt为最优函数值，iter为迭代次数</span><span class="token comment" spellcheck="true">% max z=(c)'x</span><span class="token comment" spellcheck="true">% Ax=b,x>=0</span><span class="token comment" spellcheck="true">% r(A)=m,A大小(m*n),(n>=m),b>=0(m*1),c(1*n)这里有问题输入可以是，</span><span class="token comment" spellcheck="true">%可能是方便输入,直接输入的c其实是是转置后（c'）的行向量</span><span class="token comment" spellcheck="true">%A是化作标准型后的系数矩阵，</span>format rat <span class="token comment" spellcheck="true">%元素使用分数表示</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%m约束条件个数, n决策变量数</span>I <span class="token operator">=</span> <span class="token function">eye</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>randIndex <span class="token operator">=</span> <span class="token function">randperm</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%A的列数整数的随机排列</span>C <span class="token operator">=</span> <span class="token function">nchoosek</span><span class="token punctuation">(</span>randIndex<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%列数的排列组合的集合</span>ind_B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%遍历每一种组合</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>I<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%找到单位矩阵</span>        <span class="token function">disp</span><span class="token punctuation">(</span>"find eye<span class="token punctuation">!</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>        ind_B <span class="token operator">=</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%找到基变量的列数序号</span>    <span class="token keyword">end</span><span class="token keyword">end</span>ind_N <span class="token operator">=</span> <span class="token function">setdiff</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">,</span> ind_B<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">%非基变量的索引，从小到大排序</span>iter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%记录迭代次数</span><span class="token comment" spellcheck="true">%开始循环迭代</span><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">%取基变量，非基变量取值为0</span>    <span class="token comment" spellcheck="true">%选择初始可行基</span>    x0<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">x0</span><span class="token punctuation">(</span>ind_B<span class="token punctuation">)</span> <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">%初始基可行解</span>    cB <span class="token operator">=</span> <span class="token function">c</span><span class="token punctuation">(</span>ind_B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%计算检验数，选一个检验数最大的非基变量作为换入变量</span>    cN<span class="token operator">=</span><span class="token function">c</span><span class="token punctuation">(</span>ind_N<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">%注意基变量检验数为0</span>    B<span class="token operator">=</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_B<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%基本矩阵</span>    Pjlist<span class="token operator">=</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_N<span class="token punctuation">)</span>    wlist<span class="token operator">=</span><span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">*</span>Pjlist<span class="token punctuation">;</span><span class="token comment" spellcheck="true">%wlist=y_k</span>    zlist<span class="token operator">=</span><span class="token punctuation">(</span>cB<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">*</span>Pjlist<span class="token punctuation">;</span>    clist<span class="token operator">=</span>cN<span class="token operator">-</span>zlist<span class="token punctuation">;</span>    clist<span class="token punctuation">;</span>    <span class="token punctuation">[</span>maxVal maxInd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>clist<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%找到换入变量xk，k=maxInd</span>    k<span class="token operator">=</span>maxInd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%判断是否已经是最优解</span>    <span class="token keyword">if</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token function">clist</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%clist中检验值是否都&lt;=0</span>        x_opt <span class="token operator">=</span> x0<span class="token punctuation">;</span>        fx_opt <span class="token operator">=</span> c<span class="token operator">*</span>x_opt<span class="token punctuation">;</span>        <span class="token keyword">return</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true">%判断是否已经是无界</span>    <span class="token keyword">if</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token function">wlist</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%clist中元素是否都&lt;=0</span>        x_opt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        fx_opt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'问题无界'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true">%选一个基变量作为换出变量</span>    Pk<span class="token operator">=</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>    yk<span class="token operator">=</span><span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">*</span>Pk    <span class="token comment" spellcheck="true">%     yk(yk&lt;=0)=0.0000001;</span>    thetalist<span class="token operator">=</span>b<span class="token operator">./</span>yk<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%a_ik>0，b一定大于0，如果a_ik&lt;=0就让b_i/a_ik变得无穷大</span>    <span class="token function">thetalist</span><span class="token punctuation">(</span>thetalist<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token operator">~</span><span class="token punctuation">,</span>minId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>thetalist<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%确定出基变量xr索引r,这里写错好多次改好久</span>    r<span class="token operator">=</span><span class="token function">ind_B</span><span class="token punctuation">(</span>minId<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">% 换基</span>    <span class="token function">ind_B</span><span class="token punctuation">(</span>ind_B <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">%新的基变量索引</span>    ind_N <span class="token operator">=</span> <span class="token function">setdiff</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">,</span> ind_B<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">%非基变量索引</span>    <span class="token comment" spellcheck="true">% 更新A和b,化最简型</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_N<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_B<span class="token punctuation">)</span> <span class="token operator">\</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_N<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%基矩阵的逆乘以非基矩阵</span>    b <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_B<span class="token punctuation">)</span> <span class="token operator">\</span> b <span class="token comment" spellcheck="true">%基矩阵的逆乘以b</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span>ind_B<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">eye</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%基矩阵更新为单位矩阵</span>    iter<span class="token operator">=</span>iter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211216113249.png" alt="image-20211216113249251"></p><p>花了好久把单纯形法和单纯形表代码写出来，结果正确！</p><hr><p>1.setdiff函数<br>set difference.</p><p>C=setdiff(A,B) for vector A and B, return the values in A that are not in B with no repetitions. C will be sorted.</p><p>对于向量A,向量B，C=setdiff(A,B)函数返回在向量A中却不在向量B中的元素，并且C中不包含重复元素，并且从小到大排序。<br>————————————————<br>版权声明：本文为CSDN博主「风景不在对岸wj」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u011089523/article/details/79986511" target="_blank" rel="noopener">https://blog.csdn.net/u011089523/article/details/79986511</a></p><hr><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/abbcdc/article/details/111324457" target="_blank" rel="noopener">运筹学——matlab实现单纯形法</a></p><blockquote><p>CSDN一搜全是上大智科的学长，学长太强了。我的代码水平还是不够。</p></blockquote><p>以收集上大智科学长的运筹学博客为乐，这些代码可以一直传承下去。</p><p><a href="https://blog.csdn.net/weixin_43499182/article/details/103524245?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.highlightwordscore&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.highlightwordscore" target="_blank" rel="noopener">单纯形法以及对偶单纯形法的Matlab实现</a></p><blockquote><p>“最近在上《运筹与优化》这门课，讲到了单纯形法这部分，老师让我们上机用Matlab实现单纯形法，数学公式实现过程看不懂的我就暴力模拟了单纯形法的整个过程，包含无界解等情况。”——努力变成大白的小白学长</p><p>学长写的代码好复杂，不如上面18级学长写的清楚。</p><p>这个17级的学长写了120行，其实只要写50行不到（20行注释），可以年年优化，减少代码行数。</p></blockquote><p>纸质作业周四交</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于概率论与数理统计</title>
      <link href="/2021/12/09/gai-lu-lun/"/>
      <url>/2021/12/09/gai-lu-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大三这个学期开始上机器学习和模式识别的专业课，发现数学在这个学期每门课上都很重要，特别是线代和概率论，运筹优化需要用到线代的知识，智能控制要用到信号处理的知识。除了学矩阵代数的时候完整复习过一遍线代以外，之前学的数学知识基本上都是考完之后就放下了，而且当时概率论考试考的也不是很好，又已经隔了很久没有复习过，正好抽出时间来复习一下数学。</p><p>通经过上学期的算法考试大失败反思了自己的学习习惯和方式，发现自己大学里对这些需要静下心来好好学的数学课并没有很好的掌握，而且之所以这些考试考不好也是因为自己没有始终保持一个初学者心态，对学过的知识没有一定的敬畏，花的时间也不对，没有经过系统的反思。所以这次复习要做到有点有面，先从这学期可能更重要的概率论开始复习。</p><p>由于要准备ASC超算比赛时间有限，打算先快速将基础过一遍，这次我将结合电脑和iPad手写笔记的使用来对知识进行整理，并以博客的形式呈现出来。</p><blockquote><p>对知识的整理很重要</p></blockquote><h2 id="第一章-概率论的基本概念"><a href="#第一章-概率论的基本概念" class="headerlink" title="第一章 概率论的基本概念"></a>第一章 概率论的基本概念</h2><p>概率论与数理统计是研究和揭示<strong>随机现象统计规律性</strong>的一门数学学科。</p><blockquote><p>在个别试验中其结果呈现不确定性，在大量重复试验中其结果又具有统计规律性的现象。</p></blockquote><p>我们通过研究随机试验来研究随机现象，<strong>随机现象</strong>具有三个特点：</p><p>1、可在相同条件下重复</p><p>2、每次试验可能结果不止一个，但能明确所有可能结果。</p><p>3、进行试验前不知道结果</p><hr><p>随机试验E<strong>所有可能结果的集合</strong>成为E的<strong>样本空间</strong>，记为S。</p><p>样本空间的元素就是E的每个结果，称为<strong>样本点</strong>。</p><p>试验E的<strong>样本空间S的子集</strong>为E的<strong>随机事件</strong>，简称事件。</p><p>在每次试验中，当且仅当这一子集中的一个样本点出现时，称这一<strong>事件发生</strong>。</p><p>必然事件，全集。不可能事件，空集。</p><hr><p><strong>事件的关系与运算</strong></p><p>包含，相等</p><p>和事件</p><p>积事件</p><p>差事件</p><p>互斥（A与B是互不相容的），基本事件是两两互不相容的。</p><p>逆事件（A与B是对立事件）</p><hr><p>交换律，结合律，分配律，德摩根律</p><hr><p><strong>频率与概率</strong></p><p>在相同条件下，在n次试验中如果事件A出现了nA次，nA/n称为事件A发生的<strong>频率</strong>。记为$f_n(A)$</p><p>频率具有三条性质：</p><p>1.[0,1]</p><p>2、$f_n(S)=1$</p><p>3、$A_1,…,A_k$两两互不相容的事件有</p><p>$f_n(A_1\cup…\cup A_k)=f_n(A_1)+…+f_n(A_k)$</p><hr><blockquote><p>大量试验验证，当试验次数n增大，频率趋于稳定性到某个常数。但在实际中我们不可能对每个事件做大量的尝试，然后求得频率，于是为了研究理论的需要给出如下表征事件发生可能性的概率定义。</p></blockquote><p><strong>概率定义</strong></p><p>设任一随机试验E，S为相应的样本空间，若对任意事件A，有唯一实P（A）与之对应，且集合函数P（·）满足下面三个条件，则数P（A）称为事件A的概率。</p><p>集合函数P（·）满足下面三个条件：</p><p>1、非负性，$P(A)\ge 0$</p><p>2、规范性，对于必然事件S有$P(S)=1$</p><p>3、可列可加性，$A_1,…,A_k$两两互不相容的事件有</p><p>$P(A_1\cup A_2\cup…)=P(A_1)+P(A_1)+…$</p><hr><p>由定义推出概率的六条性质：</p><ol><li>$P(\emptyset)=0$</li><li>有限可加性，由性质1和定义3</li><li>若$A \subseteq B$，则有$P(B-A)=P(B)-P(A)$;$P(B) \ge P(A)$.</li></ol><blockquote><p>由$A \subseteq B$，知$B=A \cup(B-A)$，且$A(B-A)= \empty$，再定义3可列可加性得$P(B)=P(A \cup (B-A))=P(A)+P(B-A)$，由定义1概率非负性得$P(B-A) \ge 0$</p><p>所以$P(B) \ge P(A)$</p></blockquote><p>   4.由性质3，任意事件A有$P(A) \le P(S)$，即$P(A) \le 1$ .</p><p>   5.逆事件的概率，$P(\bar{A})=1-P(A)$</p><p>   6.加法公式，对于任意事件A和B有$P(A \cup B)=P(A)+P(B)-P(AB)$，</p><blockquote><p>同性质3证明，$A \cup B = A \cup (B-AB)$，知$A(B-AB)= \empty$,$AB \subset B$,</p><p>由性质2有限可加性，$P(A \cup B)=P(A \cup (B-AB))=P(A)+P(B-AB)$</p><p>由性质3，有$P(B-AB)=P(B)-P(AB)$,可得$P(A \cup B)=P(A)+P(B)-P(AB)$.</p></blockquote><hr><p>等可能概型（<strong>古典概型</strong>）</p><p>两个特点：1、试验样本空间只包含有限个元素；2、每个基本事件发生可能性相同</p><p>古典概型事件A概率计算公式</p><hr><p>放回抽样与不放回抽样</p><p>n球放m盒，相同生日问题（23，64）</p><p>抽检次品，超几何分布</p><p>随机抽数被6和8整除问题</p><p>分配新生优生分配问题</p><hr><p>规定时间接待问题</p><blockquote><p><strong>实际推断原理</strong>，“概率很小的事件在一次试验中实际上几乎不发生。”</p></blockquote><hr><p><strong>条件概率</strong></p><p><strong>乘法公式</strong></p><p><strong>全概率公式</strong></p><p><strong>贝叶斯公式</strong></p><hr><p><strong>独立的定义</strong></p><h2 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h2><h3 id="随机变量的定义"><a href="#随机变量的定义" class="headerlink" title="随机变量的定义"></a>随机变量的定义</h3><p>设随机试验的样本空间为S={e}.</p><p>X=X(e)是定义在样本空间S上的<strong>实值单值函数</strong>.称X=X(e)为<strong>随机变量</strong>。</p><hr><p>离散型随机变量及其分布律</p><p>随机变量的分布函数</p><p>连续型随机变量及其概率密度</p><p>随机变量的函数的分布</p><h2 id="第三章-多维随机变量及其分布"><a href="#第三章-多维随机变量及其分布" class="headerlink" title="第三章 多维随机变量及其分布"></a>第三章 多维随机变量及其分布</h2><h2 id="第四章-随机变量的数字特征"><a href="#第四章-随机变量的数字特征" class="headerlink" title="第四章 随机变量的数字特征"></a>第四章 随机变量的数字特征</h2><h2 id="第五章-大数定律及中心极限定理"><a href="#第五章-大数定律及中心极限定理" class="headerlink" title="第五章 大数定律及中心极限定理"></a>第五章 大数定律及中心极限定理</h2><h2 id="第六章-样本及抽样分布"><a href="#第六章-样本及抽样分布" class="headerlink" title="第六章 样本及抽样分布"></a>第六章 样本及抽样分布</h2><p><strong>总体</strong></p><p><strong>统计量</strong></p><p>随机变量的函数，不含任何未知参数</p><h2 id="第七章-参数估计"><a href="#第七章-参数估计" class="headerlink" title="第七章 参数估计"></a>第七章 参数估计</h2><p><strong>估计量</strong></p><p>$X_1,X_2,…,X_n$是$X$的一个样本</p><p>构造了一个适当的统计量$\hat{\theta}(X_1,X_2,…,X_n)$，估计量是样本的函数。</p><h2 id="第八章-假设检验"><a href="#第八章-假设检验" class="headerlink" title="第八章 假设检验"></a>第八章 假设检验</h2>]]></content>
      
      
      <categories>
          
          <category> 数学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于CUDA</title>
      <link href="/2021/12/09/guan-yu-cuda/"/>
      <url>/2021/12/09/guan-yu-cuda/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA从0开始"><a href="#CUDA从0开始" class="headerlink" title="CUDA从0开始"></a>CUDA从0开始</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>为了ASC！为了速度！</p></blockquote><p><strong>统一计算设备架构</strong>（Compute Unified Device Architecture, <strong>CUDA</strong>），是由<strong>NVIDIA</strong>推出的通用并行计算架构。解决的是用更加廉价的设备资源，实现更高效的并行计算。</p><p>参考资料见ASC22备赛博客文章CUDA部分。</p><h2 id="一、异构并行计算"><a href="#一、异构并行计算" class="headerlink" title="一、异构并行计算"></a>一、异构并行计算</h2><p>先简要介绍了使用GPU来完善CPU的异构架构，以及向异构并行编程进行的模式转变</p><hr><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112042019459.png" alt="1"></p><p>上面这张图能大致反应CPU和GPU的架构不同。</p><ul><li>左图：一个四核CPU一般有四个ALU，ALU是完成逻辑计算的核心，也是我们平时说四核八核的核，控制单元，缓存也在片上，DRAM是内存，一般不在片上，CPU通过总线访问内存。</li><li>右图：GPU，绿色小方块是ALU，我们注意红色框内的部分SM，这一组ALU公用一个Control单元和Cache，这个部分相当于一个完整的多核CPU，但是不同的是ALU多了，control部分变小，可见计算能力提升了，控制能力减弱了，所以对于控制（逻辑）复杂的程序，一个GPU的SM是没办法和CPU比较的，但是对了逻辑简单，数据量大的任务，GPU更搞笑，并且，注意，一个GPU有好多个SM，而且越来越多。</li></ul><blockquote><p>SP和SM（流处理器）<br>SP：最基本的处理单元，streaming processor，也称为CUDA core。最后具体的指令和任务都是在SP上处理的。GPU进行并行计算，也就是很多个SP同时做处理。<br>SM：多个SP加上其他的一些资源组成一个streaming multiprocessor。也叫GPU大核，其他资源如：warp scheduler，register，shared memory等。SM可以看做GPU的心脏（对比CPU核心），register和shared memory是SM的稀缺资源。CUDA将这些资源分配给所有驻留在SM中的threads。因此，这些有限的资源就使每个SM中active warps有非常严格的限制，也就限制了并行能力。</p><p>需要指出，每个SM包含的SP数量依据GPU架构而不同，Fermi架构GF100是32个，GF10X是48个，Kepler架构都是192个，Maxwell都是128个</p><p>简而言之，SP是线程执行的硬件单位，SM中包含多个SP，一个GPU可以有多个SM（比如16个），最终一个GPU可能包含有上千个SP。这么多核心“同时运行”，速度可想而知，这个引号只是想表明实际上，软件逻辑上是所有SP是并行的，但是物理上并不是所有SP都能同时执行计算（比如我们只有8个SM却有1024个线程块需要调度处理），因为有些会处于挂起，就绪等其他状态，这有关GPU的线程调度。</p></blockquote><p>CPU和GPU之间通过PCIe总线连接，用于传递指令和数据，这部分也是后面要讨论的性能瓶颈之一。<br>一个异构应用包含两种以上架构，所以代码也包括不止一部分：</p><ul><li>主机代码</li><li>设备代码</li></ul><p>主机代码在主机端运行，被编译成主机架构的机器码，设备端的在设备上执行，被编译成设备架构的机器码，所以主机端的机器码和设备端的机器码是隔离的，自己执行自己的，没办法交换执行。<br>主机端代码主要是控制设备，完成数据传输等控制类工作，设备端主要的任务就是计算。<br>因为当没有GPU的时候CPU也能完成这些计算，只是速度会慢很多，所以可以把GPU看成CPU的一个加速设备。<br>NVIDIA目前的计算平台（不是架构）有：</p><ul><li>Tegra</li><li>Geforce</li><li>Quadro</li><li>Tesla</li></ul><p>每个平台针对不同的应用场景，比如Tegra用于嵌入式，Geforce是我们平时打游戏用到，Tesla是我们昨天租的那台腾讯云的，主要用于计算。</p><p>衡量GPU计算能力的主要靠下面两种<strong><em>容量\</em></strong>特征：</p><ul><li>CUDA核心数量（越多越好）</li><li>内存大小（越大越好）</li></ul><p>相应的也有计算能力的<strong><em>性能\</em></strong>指标:</p><ul><li>峰值计算能力</li><li>内存带宽</li></ul><p>nvidia自己有一套描述GPU计算能力的代码，其名字就是“计算能力”，主要区分不同的架构，早其架构的计算能力不一定比新架构的计算能力强</p><table><thead><tr><th align="left">计算能力</th><th align="left">架构名</th></tr></thead><tbody><tr><td align="left">1.x</td><td align="left">Tesla</td></tr><tr><td align="left">2.x</td><td align="left">Fermi</td></tr><tr><td align="left">3.x</td><td align="left">Kepler</td></tr><tr><td align="left">4.x</td><td align="left">Maxwell</td></tr><tr><td align="left">5.x</td><td align="left">Pascal</td></tr><tr><td align="left">6.x</td><td align="left">Volta</td></tr></tbody></table><p>CPU和GPU线程的区别：</p><ol><li>CPU线程是重量级实体，操作系统交替执行线程，线程上下文切换花销很大</li><li>GPU线程是轻量级的，GPU应用一般包含成千上万的线程，多数在排队状态，线程之间切换基本没有开销。</li><li>CPU的核被设计用来尽可能减少一个或两个线程运行时间的延迟，而GPU核则是大量线程，最大幅度提高吞吐量</li></ol><p>CUDA平台不是单单指软件或者硬件，而是建立在Nvidia GPU上的一整套平台，并扩展出多语言支持</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112042022516.png" alt="4"></p><p>CUDA C 是标准ANSI C语言的扩展，扩展出一些语法和关键字来编写设备端代码，而且CUDA库本身提供了大量API来操作设备完成计算。</p><p>对于API也有两种不同的层次，一种相对交高层，一种相对底层。</p><ul><li>CUDA驱动API</li><li>CUDA运行时API</li></ul><p>驱动API是低级的API，使用相对困难，运行时API是高级API使用简单，其实现基于驱动API。<br>这两种API是互斥的，也就是你只能用一个，两者之间的函数不可以混合调用，只能用其中的一个库。</p><p>一个CUDA应用通常可以分解为两部分，</p><ul><li>CPU 主机端代码</li><li>GPU 设备端代码</li></ul><p>CUDA nvcc编译器会自动分离你代码里面的不同部分，如图中主机代码用C写成，使用本地的C语言编译器编译，设备端代码，也就是核函数，用CUDA C编写，通过nvcc编译，链接阶段，在内核程序调用或者明显的GPU设备操作时，添加运行时库。</p><p><strong>注意：核函数是我们后面主要接触的一段代码，就是设备上执行的程序段</strong></p><h2 id="“Hello-World-”"><a href="#“Hello-World-”" class="headerlink" title="“Hello World!”"></a>“Hello World!”</h2><p>Hello World是所有程序初学者都非常喜欢的，之前GPU是不能printf的，我当时就很懵，GPU是个做显示的设备，为啥不能输出，后来就可以直接在CUDA核里面打印信息了，我们写下面程序</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**hello_world.cu*/</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>__global__ <span class="token keyword">void</span> <span class="token function">hello_world</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"GPU: Hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"CPU: Hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hello_world<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">cudaDeviceReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//if no this line ,it can not output hello world from gpu</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般CUDA程序分成下面这些步骤：</p><ol><li>分配GPU内存</li><li>拷贝内存到设备</li><li>调用CUDA内核函数来执行计算</li><li>把计算完成数据拷贝回主机端</li><li>内存销毁</li></ol><p>CPU与GPU的编程主要区别在于对GPU架构的熟悉程度，理解机器的结构是对编程效率影响非常大的一部分，了解你的机器，才能写出更优美的代码，而目前计算设备的架构决定了局部性将会严重影响效率。<br>数据局部性分两种</p><ul><li>空间局部性</li><li>时间局部性</li></ul><p>CUDA中有两个模型是决定性能的：</p><ul><li>内存层次结构</li><li>线程层次结构</li></ul><p>CUDA C写核函数的时候我们只写一小段串行代码，但是这段代码被成千上万的线程执行，所有线程执行的代码都是相同的，CUDA编程模型提供了一个层次化的组织线程，直接影响GPU上的执行顺序。</p><p>CUDA抽象了硬件实现：</p><ol><li>线程组的层次结构</li><li>内存的层次结构</li><li>障碍同步</li></ol><p>这些都是我们后面要研究的，线程，内存是主要研究的对象，我们能用到的工具相当丰富，NVIDIA为我们提供了：</p><ul><li>Nvidia Nsight集成开发环境</li><li>CUDA-GDB 命令行调试器</li><li>性能分析可视化工具</li><li>CUDA-MEMCHECK工具</li><li>GPU设备管理工具</li></ul><h2 id="二、CUDA编程模型"><a href="#二、CUDA编程模型" class="headerlink" title="二、CUDA编程模型"></a>二、CUDA编程模型</h2><blockquote><p>从<strong>逻辑视角</strong>解释了在CUDA中的大规模并行计算：通过编程模型直观展示的两层线程层次结构。同时也探讨了线程配置启发性方法和它们对性能的影响。 </p></blockquote><p>CUDA编程模型为应用和硬件设备之间的桥梁，所以CUDA C是编译型语言，不是解释型语言，OpenCL就有点类似于解释型语言，通过编译器和链接，给操作系统执行（操作系统包括GPU在内的系统），下面的结构图片能形象的表现他们之间的关系：</p><p><img src="https://face2ai.com/CUDA-F-2-0-CUDA%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B01/1.png" alt="img"></p><p>其中Communication Abstraction是编程模型和编译器，库函数之间的分界线。<br>可能大家还不太明白编程模型是啥，编程模型可以理解为，我们要用到的语法，内存结构，线程结构等这些我们写程序时我们自己控制的部分，这些部分控制了异构计算设备的工作模式，都是属于编程模型。<br>GPU中大致可以分为：</p><ul><li>核函数</li><li>内存管理</li><li>线程管理</li><li>流</li></ul><p>等几个关键部分。</p><hr><p>以上这些理论同时也适用于其他非CPU+GPU异构的组合。<br>下面我们会说两个我们GPU架构下特有几个功能：</p><ul><li>通过组织层次结构在GPU上组织线程的方法</li><li>通过组织层次结构在GPU上组织内存的方法</li></ul><p>也就是对内存和线程的控制将伴随我们写完前十几篇。<br>从宏观上我们可以从以下几个环节完成CUDA应用开发：</p><ol><li>领域层</li><li>逻辑层</li><li>硬件层</li></ol><h2 id="三、CUDA执行模型"><a href="#三、CUDA执行模型" class="headerlink" title="三、CUDA执行模型"></a>三、CUDA执行模型</h2><blockquote><p>研究成千上万的线程是如何在GPU中调度的，来探讨<strong>硬件层面</strong>的内核执行问 题。解释了计算资源是如何在多粒度线程间分配的，也从硬件视角说明了它如何被用于指导内核设计，以及如何用配置文件驱动方法来开发和优化内核程序。</p></blockquote><p>一个异构环境，通常有多个CPU多个GPU，他们都通过PCIe总线相互通信，也是通过PCIe总线分隔开的。所以我们要区分一下两种设备的内存：</p><ul><li>主机：CPU及其内存</li><li>设备：GPU及其内存</li></ul><p>注意这两个内存从硬件到软件都是隔离的（CUDA6.0 以后支持统一寻址），我们目前先不研究统一寻址，我们现在还是用内存来回拷贝的方法来编写调试程序，以巩固大家对两个内存隔离这个事实的理解。</p><p>一个完整的CUDA应用可能的执行顺序如下图：<br><img src="https://face2ai.com/CUDA-F-2-0-CUDA%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B01/2.png" alt="img"><br>从host的串行到调用核函数（核函数被调用后控制马上归还主机线程，也就是在第一个并行代码执行时，很有可能第二段host代码已经开始同步执行了）。</p><p>我们接下来的研究层次是：</p><ul><li><p>内存</p></li><li><p>线程</p></li><li><p>核函数</p><ul><li>启动核函数</li><li>编写核函数</li><li>验证核函数</li></ul></li><li><p>错误处理</p></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理在传统串行程序是非常常见的，寄存器空间，栈空间内的内存由机器自己管理，堆空间由用户控制分配和释放，CUDA程序同样，只是CUDA提供的API可以分配管理设备上的内存，当然也可以用CDUA管理主机上的内存，主机上的传统标准库也能完成主机内存管理。</p><p>下面表格有一些主机API和CUDA C的API的对比：</p><table><thead><tr><th align="center">标准C函数</th><th align="center">CUDA C 函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">malloc</td><td align="center">cudaMalloc</td><td align="center">内存分配</td></tr><tr><td align="center">memcpy</td><td align="center">cudaMemcpy</td><td align="center">内存复制</td></tr><tr><td align="center">memset</td><td align="center">cudaMemset</td><td align="center">内存设置</td></tr><tr><td align="center">free</td><td align="center">cudaFree</td><td align="center">释放内存</td></tr></tbody></table><p>我们先研究最关键的一步，这一步要走总线的（郭德纲：我到底能不能走二环）</p><pre><code>cudaError_t cudaMemcpy(void * dst,const void * src,size_t count,  cudaMemcpyKind kind)</code></pre><p>这个函数是内存拷贝过程，可以完成以下几种过程（cudaMemcpyKind kind）</p><ul><li>cudaMemcpyHostToHost</li><li>cudaMemcpyHostToDevice</li><li>cudaMemcpyDeviceToHost</li><li>cudaMemcpyDeviceToDevice</li></ul><p>这四个过程的方向可以清楚的从字面上看出来，这里就不废话了，如果函数执行成功，则会返回 cudaSuccess 否则返回 cudaErrorMemoryAllocation</p><p>使用下面这个指令可以吧上面的错误代码翻译成详细信息：</p><pre><code>char* cudaGetErrorString(cudaError_t error)</code></pre><p>共享内存（shared Memory）和全局内存（global Memory）后面我们会特别详细深入的研究，这里我们来个例子，两个向量的加法：</p><p>解释下内存管理部分的代码：</p><pre><code>cudaMalloc((float**)&amp;a_d,nByte);</code></pre><p>分配设备端的内存空间，为了区分设备和主机端内存，我们可以给变量加后缀或者前缀h_表示host，d_表示device</p><p>一个经常会发生的错误就是混用设备和主机的内存地址！</p><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>当内核函数开始执行，如何组织GPU的线程就变成了最主要的问题了，我们必须明确，一个核函数只能有一个grid，一个grid可以有很多个块，每个块可以有很多的线程，这种分层的组织结构使得我们的并行过程更加自如灵活：</p><p><img src="https://face2ai.com/CUDA-F-2-0-CUDA%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B01/4.png" alt="img"></p><p>一个线程块block中的线程可以完成下述协作：</p><ul><li>同步</li><li>共享内存</li></ul><p><strong>不同块内线程不能相互影响！他们是物理隔离的！</strong></p><p>接下来就是给每个线程一个编号了，我们知道每个线程都执行同样的一段串行代码，那么怎么让这段相同的代码对应不同的数据呢？首先第一步就是让这些线程彼此区分开，才能对应到相应从线程，使得这些线程也能区分自己的数据。如果线程本身没有任何标记，那么没办法确认其行为。<br>依靠下面两个内置结构体确定线程标号：</p><ul><li>blockIdx（线程块在线程网格内的位置索引）</li><li>threadIdx（线程在线程块内的位置索引）</li></ul><p>注意这里的Idx是index的缩写（我之前一直以为是identity x的缩写），这两个内置结构体基于 uint3 定义，包含三个无符号整数的结构，通过三个字段来指定：</p><ul><li>blockIdx.x</li><li>blockIdx.y</li><li>blockIdx.z</li><li>threadIdx.x</li><li>threadIdx.y</li><li>threadIdx.z</li></ul><p>上面这两个是坐标，当然我们要有同样对应的两个结构体来保存其范围，也就是blockIdx中三个字段的范围threadIdx中三个字段的范围：</p><ul><li>blockDim</li><li>gridDim</li></ul><p>他们是dim3类型(基于uint3定义的数据结构)的变量，也包含三个字段x,y,z.</p><ul><li>blockDim.x</li><li>blockDim.y</li><li>blockDim.z</li></ul><p>注意：dim3是手工定义的，主机端可见。uint3是设备端在执行的时候可见的，不可以在核函数运行时修改，初始化完成后uint3值就不变了。他们是有区别的！这一点必须要注意。</p><p>下面有一段代码，块的索引和维度：</p><h2 id="四、内存"><a href="#四、内存" class="headerlink" title="四、内存"></a>四、内存</h2><p>CUDA<strong>内存模型</strong>，探讨全局内存数据布局，并分析了全局内存的访问模式。<strong>共享内存</strong>，即管理程序的低延迟缓存，是如何提高内核性能的。它描述了共享内存的优化数据布局，并说明了如何避免较差的性能。最后还说明了如何在相邻线程之间执行低延迟通信。 </p><h2 id="五、流和并发"><a href="#五、流和并发" class="headerlink" title="五、流和并发"></a>五、流和并发</h2><p>如何使用CUDA流实现<strong>多内核并发执行</strong>，如何<strong>重叠通信和计算</strong>，以及不同的<strong>任务分配</strong>策略是如何影响内核间的并发的。</p><h2 id="六、指令级原语"><a href="#六、指令级原语" class="headerlink" title="六、指令级原语"></a>六、指令级原语</h2><p>本章解释了浮点运算、标准的内部数学函数和CUDA原子操作的性质。它展示了如何使用相对<strong>低级别的CUDA原语和编译器标志来优化</strong>应用程序的性能、准确度和正确性。 </p><h2 id="七、GPU加速库和OpenACC"><a href="#七、GPU加速库和OpenACC" class="headerlink" title="七、GPU加速库和OpenACC"></a>七、GPU加速库和OpenACC</h2><p>程序并行的CUDA<strong>专用函数库</strong>，包括线性代数、傅里叶变换和随机数 生成等范例。本章还解释了OpenACC和基于编译器指令的GPU编程模型是如何利用更简单 的方法辅助CUDA挖掘GPU计算能力的。</p><h2 id="八、多GPU编程"><a href="#八、多GPU编程" class="headerlink" title="八、多GPU编程"></a>八、多GPU编程</h2><p>阐述了如何在多个GPU上管理和执行计算问题，还说明了在GPU加速计算集群上的大规模应用是如何利用MPI与GPUDirectRDMA来实现性能线性扩展的。 </p><h2 id="九、程序实现注意事项"><a href="#九、程序实现注意事项" class="headerlink" title="九、程序实现注意事项"></a>九、程序实现注意事项</h2><p>本章介绍了CUDA的开发过程和各种配置文件驱动的优化策略，演示了如何使用<strong>CUDA调试工具</strong>来调试内核和内存错误，通过案例教你如何将一个传统的C程序一步步移植到CUDA C中，以有助于加强你对于这一方法的理解，同时将此过程可视化，并验证了这些<strong>工具</strong>。</p><h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><p>cmake和cuda万能模板</p><pre class="line-numbers language-cmake"><code class="language-cmake"># CMakeLists.txt for test -x cu option project　by guan shiyuanproject(test_cuda_project)# required cmake versioncmake_minimum_required(VERSION 2.8)# packagesfind_package(CUDA)set(CUDA_SOURCE_PROPERTY_FORMAT OBJ)set(CUDA_SEPARABLE_COMPILATION ON)include_directories(${CUDA_INCLUDE_DIRS})set(CUDA_PROPAGATE_HOST_FLAGS OFF)set(CUDA_NVCC_FLAGS -arch=sm_61;-O3;-G;-g;-std=c++11)file(GLOB_RECURSE CURRENT_HEADERS  *.h *.hpp *.cuh)file(GLOB CURRENT_SOURCES  *.cpp *.cu)set_source_files_properties(main.cpp PROPERTIES CUDA_SOURCE_PROPERTY_FORMAT OBJ)source_group("Include" FILES ${CURRENT_HEADERS})source_group("Source" FILES ${CURRENT_SOURCES})cuda_add_executable(test_cuda_project ${CURRENT_HEADERS} ${CURRENT_SOURCES} )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU智能系统控制</title>
      <link href="/2021/12/04/shuic/"/>
      <url>/2021/12/04/shuic/</url>
      
        <content type="html"><![CDATA[<h1 id="SHU智能系统控制课程笔记"><a href="#SHU智能系统控制课程笔记" class="headerlink" title="SHU智能系统控制课程笔记"></a>SHU智能系统控制课程笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>“物有本末，事有终始，知所先后，则近道矣”<br>——《大学·大学之道章》</p></blockquote><blockquote><p>院长上课，不敢作妖</p></blockquote><p>什么是控制？</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749775.png" alt="image-20211203081249733"></p><p>开环控制，无反馈</p><p>闭环控制，有反馈</p><hr><p>线性系统总可以用线性微分方程描述</p><p>定常系统，时变系统</p><p>瞬态响应，稳态响应</p><p>基本要求：稳准好</p><hr><p>传统控制方法包括<strong>经典控制</strong>和<strong>现代控制</strong>，是基于<strong>被控对象</strong>精确模型的控制方式。</p><p><strong>经典控制</strong></p><p>以<strong>传递函数</strong>为数学基础，主要研究单输入——单输出、线性定常系统的分析和设计问题。</p><p><strong>传递函数</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749776.png" alt="image-20211203081912543"></p><p><strong>现代控制</strong><br>以<strong>状态空间法</strong>为基础，主要用于研究具有较高性能控制要求的多变量变参数系统的最有控制问题。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749777.png" alt="image-20211203081945003"></p><h2 id="第一章概论"><a href="#第一章概论" class="headerlink" title="第一章概论"></a>第一章概论</h2><p><strong>知识点</strong></p><p>1．如何理解智能控制的定义；<br>2．了解智能控制与传统自动控制间的关系；<br>3．深入掌握智能控制的学科结构理论，特别是智能控制四元交集结构理论的内涵。</p><blockquote><p>智能控制的定义，肯定要考</p></blockquote><h3 id="1-1-智能控制的产生和发展"><a href="#1-1-智能控制的产生和发展" class="headerlink" title="1.1 智能控制的产生和发展"></a>1.1 智能控制的产生和发展</h3><p>传统控制方法包括经典控制和现代控制，是基于被控对象精确模型的控制方式，缺乏灵活性和应变能力，适于解决线性、时不变性等相对简单的控制问题，难以解决对复杂系统的控制。</p><hr><p><strong>智能控制的概念</strong></p><p><strong>智能控制</strong>是一门交叉学科，著名美籍华人傅京逊教授1971年首先提出智能控制是人工智能与自动控制的交叉，即二元论。美国学者G.N.Saridis1977年在此基础上引入运筹学，提出了三元论的智能控制概念，即IC=AC∩AI∩OR</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749778.png" alt="image-20211203082830136"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749779.png" alt="image-20211203083741546"></p><blockquote><p>人脑的五大记忆模块：记忆工作模块，知觉关联模块，知觉记忆（感知？）模块，常识记忆模块，短时记忆模块</p></blockquote><p><strong>智能控制的发展</strong></p><p> 1966年，J.M.Mendal首先提出将人工智能技术应用于飞船控制系统的设计。</p><p>1971年，傅京逊首次提出智能控制这一概念，并归纳了三种类型的智能控制系统：人作为控制器，人-机结合作为控制器的控制系统，无人参与的自主控制系统。</p><h3 id="1-2-智能控制的定义、特点和应用"><a href="#1-2-智能控制的定义、特点和应用" class="headerlink" title="1.2 智能控制的定义、特点和应用"></a>1.2 智能控制的定义、特点和应用</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749780.png" alt="image-20211203090505842"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749781.png" alt="image-20211203090612120"></p><blockquote><p>如何判断是否有智能，选择</p></blockquote><p><strong>智能控制特点</strong></p><p>学习功能</p><p>适应功能</p><p>自组织功能</p><p>优化功能</p><p>IC<strong>学派理论</strong></p><p>符号主义，连接主义，行为主义。</p><p><strong>智能控制分支</strong></p><p>模糊逻辑控制。传统控制方法均是建立在被控对象精确数学模型基础上的，然而，随着系统复杂程度的提高，将难以建立系统的精确数学模型。</p><p>​    在工程实践中，人们发现，一个复杂的控制系统可由一个操作人员凭着丰富的实践经验得到满意的控制效果。这说明，如果通过模拟人脑的思维方法设计控制器，可实现复杂系统的控制，由此产生了模糊控制。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112041749782.png" alt="image-20211203092801763"></p><p>神经网络控制，面对复杂、非线性对象的控制，尤其是难以用模型或规则描述的对象。</p><p>智能算法，基于人工智能技术的搜索算法，有代表性的有遗传算法、粒子群算法、差分进化算法和蚁群算法等。</p><h3 id="1-3-智能控制的结构理论（补充）"><a href="#1-3-智能控制的结构理论（补充）" class="headerlink" title="1.3 智能控制的结构理论（补充）"></a>1.3 智能控制的结构理论（补充）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060809963.png" alt="image-20211206080933747"></p><p>引入信息论IT。信息论参与智能控制的全过程，并对执行级起到核心作用。</p><h2 id="第二章专家控制"><a href="#第二章专家控制" class="headerlink" title="第二章专家控制"></a>第二章专家控制</h2><p>传统控制理论的不足，在于它必须依赖于被控对象严格的数学模型，试图对精确模型来求取最优的控制效果。而实际的被控对象存在着许多难以建模的因素。</p><h3 id="2-1-专家系统"><a href="#2-1-专家系统" class="headerlink" title="2.1  专家系统"></a>2.1  专家系统</h3><blockquote><p>传统控制理论的不足，在于它必须依赖于<strong>被控对象严格的数学模型</strong>，试图对精确模型来求取最优的控制效果。而实际的被控对象存在着许多难以建模的因素。</p></blockquote><p>专家系统能处理定性的、启发式或不确定的知识信息，经过各种推理来达到系统的任务目标。</p><h4 id="2-1-1-专家系统概述"><a href="#2-1-1-专家系统概述" class="headerlink" title="2.1.1  专家系统概述"></a>2.1.1  专家系统概述</h4><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060830462.png" alt="image-20211206083011343"></p><p>专家系统是包含<strong>知识</strong>和<strong>推理</strong>的智能计算机程序。基本功能取决于所含知识，所以叫基于知识的系统。</p><p><strong>发展历史</strong></p><p>(1) 初创期（1965-1971年）<br>       第一代专家系统DENLDRA和MACSMA的出现，标志着专家系统的诞生。其中DENLDRA为推断化学分子结构的专家系统，由专家系统的奠基人，Stanford大学计算机系的Feigenbaum教授及其研究小组研制。MACSMA为用于数学运算的数学专家系统，由麻省理工学院完成。</p><p>（2）成熟期（1972-1977年）：<br>    在此期间斯坦福大学研究开发了最著名的专家系统-血液感染病诊断专家系统MYCIN，标志专家系统从理论走向应用。另一个著名的专家系统-语音识别专家系统HEARSAY的出现，标志着专家系统的理论走向成熟。</p><p>（3）发展期（1978-现在）<br>        在此期间，专家系统走向应用领域，专家系统的数量增加，仅1987年研制成功的专家系统就有1000种。<br>        专家系统可以解决的问题一般包括解释、预测、设计、规划、监视、修理、指导和控制等。目前，专家系统已经广泛地应用于医疗诊断、语音识别、图象处理、金融决策、地质勘探、石油化工、教学、军事、计算机设计等领域。</p><h4 id="2-1-2-专家系统的构成"><a href="#2-1-2-专家系统的构成" class="headerlink" title="2.1.2  专家系统的构成"></a>2.1.2  专家系统的构成</h4><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060843949.png" alt="image-20211206084336846"></p><blockquote><p>考填空题</p></blockquote><p><strong>知识库</strong></p><p>知识分为三类：事实性知识，过程性知识，控制性知识（元知识，知识的知识）。</p><p><strong>推理机</strong></p><p>用于对知识库中的知识进行推理来得到结论的“思维”机构。（用于记忆所采用的规则和控制策略的程序，使整个专家系统能够以逻辑方式协调地工作。）</p><p>推理方式有三种：正向推理，反向推理，双向推理。</p><hr><p>人机接口</p><h4 id="2-1-3-专家系统的建立"><a href="#2-1-3-专家系统的建立" class="headerlink" title="2.1.3  专家系统的建立"></a>2.1.3  专家系统的建立</h4><p>知识库设计</p><p> 知识的表示方法：产生式规则</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060911577.png" alt="image-20211206091153473"></p><p>推理机设计</p><p>人机接口设计</p><h3 id="2-2-专家控制系统"><a href="#2-2-专家控制系统" class="headerlink" title="2.2  专家控制系统"></a>2.2  专家控制系统</h3><h4 id="2-2-1-专家控制概述"><a href="#2-2-1-专家控制概述" class="headerlink" title="2.2.1  专家控制概述"></a>2.2.1  专家控制概述</h4><p>瑞典学者K.J.Astrom在1983年首先把人工智能中的专家系统引入智能控制领域，于1986年提出“专家控制”的概念，构成<strong>一种智能控制方法</strong>。</p><h4 id="2-2-2-专家控制的基本原理"><a href="#2-2-2-专家控制的基本原理" class="headerlink" title="2.2.2  专家控制的基本原理"></a>2.2.2  专家控制的基本原理</h4><p>专家控制试图在传统控制的基础上“加入”一个富有经验的控制工程师，实现控制的功能，它由知识库和推理机构构成主体框架，通过对控制领域知识（先验经验、动态信息、目标等）的获取与组织，按某种策略及时地选用恰当的规则进行推理输出，实现对实际对象的控制。 </p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060925897.png" alt="image-20211206092504643"></p><p>该控制器的任务和功能相对比较简单，但是需要<strong>在线、实时控制</strong>。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060924410.png" alt="image-20211206092421253"></p><p>间接型专家控制器用于<strong>和常规控制器相结合</strong>，组成对生产过程或被控对象进行间接控制的智能控制系统。具有模拟（或延伸，扩展）控制工程师智能的功能。该控制器能够实现优化适应、协调、组织等<strong>高层决策</strong>的智能控制。按照高层决策功能的性质，间接型专家控制器可分为以下几种类型：</p><ul><li>优化型专家控制器</li><li>适应型专家控制器</li><li>协调型专家控制器</li><li>组织型专家控制器</li></ul><p>间接型专家控制器可以在线或离线运行。通常，<strong>优化型、适应型</strong>需要在线、实时、联机运行。<strong>协调型、组织型</strong>可以离线、非实时运行。</p><p><strong>专家控制的功能</strong></p><p><strong>专家控制与专家系统的区别</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112060933063.png" alt="image-20211206093352926"></p><p><strong>知识表示</strong></p><p>1、受控过程的知识：先验知识，动态知识。</p><p>2、控制、辨识、诊断知识</p><p>按照专家系统知识库的结构，有关知识可以分类组织，形成数据库和规则库，从而构成专家控制系统的知识源。</p><p>数据库的四部分：</p><p>事实，证据，假设，目标。</p><h4 id="2-2-3-专家控制的关键技术及特点"><a href="#2-2-3-专家控制的关键技术及特点" class="headerlink" title="2.2.3  专家控制的关键技术及特点"></a>2.2.3  专家控制的关键技术及特点</h4><p>（1）灵活性：根据系统的工作状态及误差情况，可灵活地选取相应的控制律；<br>（2）适应性：能根据专家知识和经验，调整控制器的参数，适应对象特性及环境的变化；<br>（3）鲁棒性：通过利用专家规则，系统可以在非线性、大偏差下可靠地工作。</p><h3 id="2-3-专家PID控制"><a href="#2-3-专家PID控制" class="headerlink" title="2.3  专家PID控制"></a>2.3  专家PID控制</h3><p>PID专家控制的实质是，基于受控对象和控制规律的各种知识，无需知道被控对象的精确模型，利用专家经验来设计PID参数。专家PID控制是一种<strong>直接型专家控制器</strong>。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130810999.png" alt="image-20211213081023872"></p><p>r(t)是要稳定的值<br>n(t)/y(t)是当前输出值<br>e(t) = r(t) - y(t)<br>输入r(t)与输出y(t)进行比较，其差值e(t) = r(t) - y(t)，经过PID控制器调整后输出电压控制信号u(t), u(t)经过被控对象后输出y(t).</p><p>P系数，放大器。</p><p>I稳态特性。</p><p>D动态特性。</p><p>$u(t)=K_pe(t)+K_I \int{e(t)dt}  +K_D \frac{d e(t)}{dt}$</p><blockquote><p><a href="https://blog.csdn.net/he__yuan/article/details/80739800" target="_blank" rel="noopener">PID算法的解析</a></p><p>PID算法解析和公式推导 - 老司机带我飞的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/129254220" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/129254220</a></p></blockquote><p>专家PID控制器的本质在于通过偏差和偏差的增量来判断应采用的PID控制类型。</p><p>专家规则分为五种情况设计：</p><hr><h2 id="第三章模糊控制"><a href="#第三章模糊控制" class="headerlink" title="第三章模糊控制"></a>第三章模糊控制</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130914849.png" alt="image-20211213090920639"></p><blockquote><p>鲁棒性，就是比较皮实。。。确实很皮。。。</p></blockquote><h3 id="3-2-模糊集合及其运算"><a href="#3-2-模糊集合及其运算" class="headerlink" title="3.2 模糊集合及其运算"></a>3.2 模糊集合及其运算</h3><p><strong>集合和隶属度函数</strong></p><p>Zadeh 在1965年对模糊集合的定义为：给定论域U，U到[0，1]闭区间的任一映射$\mu_A$</p><p>$$\mu_A : U \to [0,1]$$</p><p>都能确定U的一个模糊集合A，$\mu_A$称为模糊集合A的隶属函数，它反映了模糊集合中的元素属于该集合的程度。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130923691.png" alt="image-20211213092326524"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130924787.png" alt="image-20211213092410683"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130924962.png" alt="image-20211213092440823"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130926789.png" alt="image-20211213092634623"></p><blockquote><p>模糊集合是以隶属函数来描述的，隶属度的概念是模糊集合理论的基石。</p></blockquote><p>当论域U为有限连续域时，Zadeh表示法为</p><p>$$A=\int$$</p><hr><p><strong>模糊集合的有关术语</strong></p><p>台集合，论域U中所有使$\mu_A(x)&gt;0$的x的全体。</p><p>$\alpha$截集，强$\alpha$截集和弱$\alpha$截集</p><p>正则模糊集合，$max\quad \mu_A(x)=1$</p><p>凸模糊集合</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130936949.png" alt="image-20211213093609849"></p><p>分界点</p><p>单点模糊集合</p><hr><p><strong>模糊集合的运算</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130932104.png" alt="image-20211213093237977"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130933379.png" alt="image-20211213093300248"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112130934512.png" alt="image-20211213093405387"></p><hr><p><strong>模糊运算的基本性质</strong></p><p>和集合运算的基本性质相同</p><h3 id="3-3-隶属函数"><a href="#3-3-隶属函数" class="headerlink" title="3.3 隶属函数"></a>3.3 隶属函数</h3><h3 id="3-4-模糊关系及其运算"><a href="#3-4-模糊关系及其运算" class="headerlink" title="3.4 模糊关系及其运算"></a>3.4 模糊关系及其运算</h3><h2 id="第四章神经网络控制"><a href="#第四章神经网络控制" class="headerlink" title="第四章神经网络控制"></a>第四章神经网络控制</h2><h2 id="第五章智能算法"><a href="#第五章智能算法" class="headerlink" title="第五章智能算法"></a>第五章智能算法</h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://blog.csdn.net/weixin_44511439/article/details/118073993?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link" target="_blank" rel="noopener">CSDN智控课程笔记</a></p><h1 id="上机实验"><a href="#上机实验" class="headerlink" title="上机实验"></a>上机实验</h1><h2 id="实验一：开环系统与闭环系统的抗扰动性能对比"><a href="#实验一：开环系统与闭环系统的抗扰动性能对比" class="headerlink" title="实验一：开环系统与闭环系统的抗扰动性能对比"></a>实验一：开环系统与闭环系统的抗扰动性能对比</h2><p><strong>实验目的</strong></p><p>设输入电压为0时，扰动信号为Td=1/s，分别比较在无转速计开环控制状态下和有转速计闭环控制状态下电机输出转速稳定误差。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211204163722.jpg" alt="img"></p><p><strong>实验原理</strong></p><p>传统控制方法包括<strong>经典控制</strong>和<strong>现代控制</strong>，是基于<strong>被控对象</strong>精确模型的控制方式。<strong>经典控制</strong>以<strong>传递函数</strong>为数学基础，主要研究单输入——单输出、线性定常系统的分析和设计问题。系统的<strong>传递函数</strong>是指线性定常系统在零初始条件下微分方程中的输出量的拉氏变换与输入量的拉氏变换之比。线性定常系统可以使用叠加原理处理。</p><p>经分析，开环控制无反馈，闭环控制有反馈，所以转速计闭环控制状态下电机的抗扰动性能更佳，输出转速稳定误差更小，下面使用matlab进行实验。</p><p><strong>实验过程和结果</strong></p><p>opentach.m是开环控制系统的模拟实验代码</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%opentach.m</span>%Ra<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>Km<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>J<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>b<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">;</span>Kb<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">;</span>num1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>den1<span class="token operator">=</span><span class="token punctuation">[</span>J<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>sys1<span class="token operator">=</span><span class="token function">tf</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span>den1<span class="token punctuation">)</span><span class="token punctuation">;</span>num2<span class="token operator">=</span><span class="token punctuation">[</span>Km<span class="token operator">*</span>Kb<span class="token operator">/</span>Ra<span class="token punctuation">]</span><span class="token punctuation">;</span>den2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sys2<span class="token operator">=</span><span class="token function">tf</span><span class="token punctuation">(</span>num2<span class="token punctuation">,</span>den2<span class="token punctuation">)</span><span class="token punctuation">;</span>sys_o<span class="token operator">=</span><span class="token function">feedback</span><span class="token punctuation">(</span>sys1<span class="token punctuation">,</span>sys2<span class="token punctuation">)</span><span class="token punctuation">;</span>%sys_o<span class="token operator">=</span><span class="token operator">-</span>sys_o%<span class="token punctuation">[</span>yo<span class="token punctuation">,</span>T<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">step</span><span class="token punctuation">(</span>sys_o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>yo<span class="token punctuation">)</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'Open-loop Disturbance Step Response'</span><span class="token punctuation">)</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'Time(sec)'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'\omega_o(rad/s)'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>grid%<span class="token function">yo</span><span class="token punctuation">(</span><span class="token function">length</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实验结果如下图：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211204163324.png" alt="ex1_1"></p><p>closetach.m是闭环系统的模拟实验代码</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%closetach.m</span>%Ra<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>Km<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>J<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>b<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">;</span>Kb<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">;</span>Ka<span class="token operator">=</span><span class="token number">54</span><span class="token punctuation">;</span>Kt<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>num1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>den1<span class="token operator">=</span><span class="token punctuation">[</span>J<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>sys1<span class="token operator">=</span><span class="token function">tf</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span>den1<span class="token punctuation">)</span><span class="token punctuation">;</span>num2<span class="token operator">=</span><span class="token punctuation">[</span>Ka<span class="token operator">*</span>Kt<span class="token punctuation">]</span><span class="token punctuation">;</span>den2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sys2<span class="token operator">=</span><span class="token function">tf</span><span class="token punctuation">(</span>num2<span class="token punctuation">,</span>den2<span class="token punctuation">)</span><span class="token punctuation">;</span>num3<span class="token operator">=</span><span class="token punctuation">[</span>Kb<span class="token punctuation">]</span><span class="token punctuation">;</span>den3<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sys3<span class="token operator">=</span><span class="token function">tf</span><span class="token punctuation">(</span>num3<span class="token punctuation">,</span>den3<span class="token punctuation">)</span><span class="token punctuation">;</span>num4<span class="token operator">=</span><span class="token punctuation">[</span>Km<span class="token operator">/</span>Ra<span class="token punctuation">]</span><span class="token punctuation">;</span>den4<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sys4<span class="token operator">=</span><span class="token function">tf</span><span class="token punctuation">(</span>num4<span class="token punctuation">,</span>den4<span class="token punctuation">)</span><span class="token punctuation">;</span>sysa<span class="token operator">=</span><span class="token function">parallel</span><span class="token punctuation">(</span>sys2<span class="token punctuation">,</span>sys3<span class="token punctuation">)</span><span class="token punctuation">;</span>sysb<span class="token operator">=</span><span class="token function">series</span><span class="token punctuation">(</span>sysa<span class="token punctuation">,</span>sys4<span class="token punctuation">)</span><span class="token punctuation">;</span>sys_c<span class="token operator">=</span><span class="token function">feedback</span><span class="token punctuation">(</span>sys1<span class="token punctuation">,</span>sysb<span class="token punctuation">)</span><span class="token punctuation">;</span>%sys_c<span class="token operator">=</span><span class="token operator">-</span>sys_c%<span class="token punctuation">[</span>yc<span class="token punctuation">,</span>T<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">step</span><span class="token punctuation">(</span>sys_c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>yc<span class="token punctuation">)</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'Closed-loop Disturbance Step Response'</span><span class="token punctuation">)</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'Time(sec)'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'\omega_c(rad/s)'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>grid%<span class="token function">yc</span><span class="token punctuation">(</span><span class="token function">length</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实验结果如下图：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211204171943.png" alt="ex1_2"></p><p>开环系统和闭环系统实验中输入均为单位阶跃信号，由于输入电压为0，我们假定初始转速为0，</p><p>由实验结果可得出在无转速计开环控制状态下，当时间t=7s时电机转速下降至$ \omega_o=-0.66rad/s$并保持相对平稳。</p><p>在有转速计闭环控制状态下电机下，当时间t=0.02s时电机转速下降至$\omega_c = -0.002rad/s$并保持相对平稳。</p><p>因此我们可以推断得：<br>$$<br>\omega_o(\infty) \approx \omega_o(7)=-0.66rad/s<br>$$</p><p>$$<br>\omega_c(\infty) \approx \omega_c(0.02)=-0.002rad/s<br>$$</p><p>$$<br>\frac{\omega_c(\infty)}{\omega_o(\infty)}=0.003<br>$$</p><p><strong>实验结论</strong></p><p>显然，有转速计闭环控制状态下的电机输出稳定误差远远小于在无转速计开环控制状态。通过比较实验结果，同样也验证了实验的假设，即闭环有反馈的系统比开环无反馈的系统抗扰动性能更强。</p><p><strong>实验体会</strong></p><p>通过一个简单的开环闭环模拟实验很好地了解了控制系统的基本概念，也更直观地了解了开环控制与闭环控制的区别。</p><p>通过动手实验模拟实验理解底层数学原理在实际工作中发挥的重要作用，对基本的数学学习有了更深的体会，意识到自己数学基本功的不足，从而去学习之前落下的数学知识。了解了傅里叶变换、拉普拉斯变换、Z 变换之间的联系，以及为什么要进行这些变换。</p><p>506机房电脑还是一如既往的卡，打开matlab就要十几二十分钟，第一次使用线上版的matlab，结果机房网速也不行，还是只能用自己电脑装的matlab。</p><p><strong>参考资料</strong></p><p>傅里叶变换、拉普拉斯变换、Z 变换的联系是什么？为什么要进行这些变换？ </p><blockquote><p>大二信号处理上课只学到了傅里叶变换，果然欠了的总要还回来，数学只能慢慢补。</p></blockquote><ul><li>徐北熊的回答 - 知乎 <a href="https://www.zhihu.com/question/22085329/answer/103926934" target="_blank" rel="noopener">https://www.zhihu.com/question/22085329/answer/103926934</a></li><li>逸珺的回答 - 知乎 <a href="https://www.zhihu.com/question/22085329/answer/1664661894" target="_blank" rel="noopener">https://www.zhihu.com/question/22085329/answer/1664661894</a></li></ul><blockquote><p><strong>傅里叶变换是将函数分解到频率不同、幅值恒为1的单位圆上；拉普拉斯变换是将函数分解到频率幅值都在变化的圆上。因为拉普拉斯变换的基有两个变量，因此更灵活，适用范围更广。</strong></p></blockquote><hr><h2 id="实验二：-PID控制和专家PID控制对比"><a href="#实验二：-PID控制和专家PID控制对比" class="headerlink" title="实验二： PID控制和专家PID控制对比"></a>实验二： PID控制和专家PID控制对比</h2><p><strong>实验目的</strong></p><p>对比分析PID和专家PID控制器的控制效果。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211194406.png" alt="image-20211211194406669"></p><p><strong>实验原理</strong></p><p>PID专家控制的实质是，基于受控对象和控制规律的各种知识，无需知道被控对象的精确模型，利用专家经验来设计PID参数。专家PID控制是一种直接型专家控制器。</p><p>专家PID控制器的本质在于通过偏差和偏差的增量来判断应采用的PID控制类型。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211175532.png" alt="image-20211211175532902"></p><p>根据误差及其变化，可设计专家PID控制器，该控制器可分为以下五种情况进行设计：<br>（1）当$|e(k)|&gt;M_1$（M1是上界）时，说明<strong>误差的绝对值已经很大</strong>。不论误差变化趋势如何，都应考虑控制器的输出应按最大（或最小）输出，以达到迅速调整误差，使误差绝对值以最大速度减小。此时，它相当于实施开环控制。</p><p>（2）当$e(k)\triangle e(k) &gt; 0$或$e(k)=0$时，说明<strong>误差在朝误差绝对值增大方向变化</strong>，或误差为某一常值，未发生变化。<br>       此时，如果$|e(k)|&gt;M_2$（M2为误差下界），说明<strong>误差也较大，可考虑由控制器实施较强的控制作用</strong>，以达到扭转误差绝对值朝减小方向变化，并迅速减小误差的绝对值，控制器输出为</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211193641.png" alt></p><p>（3）当$e(k)\triangle e(k) &lt; 0$、$ \triangle e(k)\triangle e(k-1)&gt;0$或$e(k)=0$时，说明<strong>误差的绝对值朝减小的方向变化</strong>，或者已经达到平衡状态。此时，可考虑采取<strong>保持控制器输出不变</strong>。</p><p>（4）当$e(k)\triangle e(k) &lt; 0$、$ \triangle e(k)\triangle e(k-1)&lt;0$时，说明误差处于极值状态。如果此时误差的绝对值较大，即$|e(k)|\ge M_2$，可考虑<strong>实施较强的控制作用</strong>。</p><p>$$u(k)=u(k-1)+k_1 k_p e_m(k)$$</p><p>如果此时误差的绝对值较小，即$|e(k)|&lt; M_2$，可考虑<strong>实施较弱的控制作用</strong>。</p><p>$$u(k)=u(k-1)+k_2 k_p e_m(k)$$</p><p>（5）设定控制精度ε，当$|e(k)|\le$ε时，说明误差的绝对值很小，使用PI控制，减少稳态误差。</p><p><strong>实验代码和结果</strong></p><pre class="line-numbers language-matlab"><code class="language-matlab">clear all<span class="token punctuation">;</span>close all<span class="token punctuation">;</span>ts <span class="token operator">=</span> <span class="token number">0.001</span><span class="token punctuation">;</span>sys <span class="token operator">=</span> <span class="token function">tf</span><span class="token punctuation">(</span><span class="token number">5.235e005</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">87.35</span><span class="token punctuation">,</span><span class="token number">1.047e004</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dsys<span class="token operator">=</span><span class="token function">c2d</span><span class="token punctuation">(</span>sys<span class="token punctuation">,</span>ts<span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>num<span class="token punctuation">,</span>den<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">tfdata</span><span class="token punctuation">(</span>dsys<span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>u_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>u_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>u_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>u_4<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>y_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>y_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>y_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>ei<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>kp<span class="token operator">=</span><span class="token number">0.96</span><span class="token punctuation">;</span>ki<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">;</span>kd<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">;</span>error_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">500</span>    <span class="token function">time</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>k<span class="token operator">*</span>ts<span class="token punctuation">;</span>    <span class="token function">yd</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token function">den</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span>y_1<span class="token operator">-</span><span class="token function">den</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span>y_2<span class="token operator">-</span><span class="token function">den</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span>y_3<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>u_1<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span>u_2<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span>u_3<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span>u_4<span class="token punctuation">;</span>    <span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">yd</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">derror</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">-</span>error_1<span class="token punctuation">;</span>    ei<span class="token operator">=</span>ei<span class="token operator">+</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">*</span>ts<span class="token punctuation">;</span>    <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>kp<span class="token operator">*</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">+</span>kd<span class="token operator">*</span><span class="token function">derror</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">/</span>ts<span class="token operator">+</span>ki<span class="token operator">*</span>ei<span class="token punctuation">;</span>    u_4<span class="token operator">=</span>u_3<span class="token punctuation">;</span>u_3<span class="token operator">=</span>u_2<span class="token punctuation">;</span>u_2<span class="token operator">=</span>u_1<span class="token punctuation">;</span>u_1<span class="token operator">=</span><span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    y_3<span class="token operator">=</span>y_2<span class="token punctuation">;</span>y_2<span class="token operator">=</span>y_1<span class="token punctuation">;</span>y_1<span class="token operator">=</span><span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    error_1<span class="token operator">=</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span>yd<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>time<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'linewidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'time(s)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'r,y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">saveas</span><span class="token punctuation">(</span>gcf<span class="token punctuation">,</span> <span class="token string">'save1.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span>yd<span class="token operator">-</span>y<span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'linewidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'time(s)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">saveas</span><span class="token punctuation">(</span>gcf<span class="token punctuation">,</span> <span class="token string">'save2.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211174705.jpg" alt="save1"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211174722.jpg" alt="save2"></p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%Expert PID Controller</span>clear all<span class="token punctuation">;</span>clc<span class="token punctuation">;</span>close all<span class="token punctuation">;</span>ts<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">;</span>sys <span class="token operator">=</span> <span class="token function">tf</span><span class="token punctuation">(</span><span class="token number">5.235e005</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">87.35</span><span class="token punctuation">,</span><span class="token number">1.047e004</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dsys<span class="token operator">=</span><span class="token function">c2d</span><span class="token punctuation">(</span>sys<span class="token punctuation">,</span>ts<span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>num<span class="token punctuation">,</span>den<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">tfdata</span><span class="token punctuation">(</span>dsys<span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>u_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>u_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>u_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>y_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>y_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>y_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">'</span><span class="token punctuation">;</span>x2_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>kp<span class="token operator">=</span><span class="token number">0.6</span><span class="token punctuation">;</span>ki<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">;</span>kd<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">;</span>error_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">500</span>    <span class="token function">time</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>k<span class="token operator">*</span>ts<span class="token punctuation">;</span>    <span class="token function">r</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span>    <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>kp<span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>kd<span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span>ki<span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%Expert Control Rules</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0.8</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%Rule1:误差特别大时开环控制</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0.45</span><span class="token punctuation">;</span>    <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0.40</span><span class="token punctuation">)</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0.40</span><span class="token punctuation">;</span>    <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0.20</span><span class="token punctuation">)</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0.12</span><span class="token punctuation">;</span>    <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0.01</span><span class="token punctuation">)</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0.10</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0.05</span>            <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>u_1<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>kp<span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>u_1<span class="token operator">+</span><span class="token number">0.4</span><span class="token operator">*</span>kp<span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span>x2_1<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span>x2_1<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0.05</span>            <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>u_1<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>kp<span class="token operator">*</span>error_1<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span>u_1<span class="token operator">+</span><span class="token number">0.6</span><span class="token operator">*</span>kp<span class="token operator">*</span>error_1<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0.001</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0.5</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0.010</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">10</span>        <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token operator">-</span><span class="token number">10</span>       <span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span>     <span class="token keyword">end</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token function">den</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span>y_1<span class="token operator">-</span><span class="token function">den</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span>y_2<span class="token operator">-</span><span class="token function">den</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span>y_3<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span>u_1<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span>u_2<span class="token operator">+</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span>u_3<span class="token punctuation">;</span>    <span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">r</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    u_3<span class="token operator">=</span>u_2<span class="token punctuation">;</span>u_2<span class="token operator">=</span>u_1<span class="token punctuation">;</span>u_1<span class="token operator">=</span><span class="token function">u</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    y_3<span class="token operator">=</span>y_2<span class="token punctuation">;</span>y_2<span class="token operator">=</span>y_1<span class="token punctuation">;</span>y_1<span class="token operator">=</span><span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    x2_1<span class="token operator">=</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">-</span>error_1<span class="token punctuation">)</span><span class="token operator">/</span>ts<span class="token punctuation">;</span>    <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">*</span>ts<span class="token punctuation">;</span>    error_1<span class="token operator">=</span><span class="token function">error</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span>r<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>time<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'linewidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'time(s)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'r,y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">saveas</span><span class="token punctuation">(</span>gcf<span class="token punctuation">,</span> <span class="token string">'save3.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span>r<span class="token operator">-</span>y<span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'linewidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'time(s)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">saveas</span><span class="token punctuation">(</span>gcf<span class="token punctuation">,</span> <span class="token string">'save4.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211174742.jpg" alt="save3"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211211174747.jpg" alt="save4"></p><p><strong>实验结论</strong></p><p>由实验结果可以看出专家PID控制比PID控制效果要好，专家PID控制在时间t=0.1s时已经使系统平稳并且误差下降至0，而PID控制器系统的误差随时间变化的曲线波动较大，在时间t=0.3s后误差才下降至0。</p><p><strong>实验体会</strong></p><p>实验课之前还没讲完专家PID控制的内容，课后自己对照课本和ppt先看也能看懂，就是一开始敲代码还没明白实验的目的和内容，写完实验代码再看书理解的实验还是第一次做，感觉很新奇。</p><hr><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><blockquote><p>难得一次没带课本，结果就临时花了十分钟找课本PDF，九分钟百度，一分钟谷歌。下次找资料还是直接谷歌省事。</p></blockquote><p><strong>实验目的</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151520612.png" alt="image-20211215152037513"></p><blockquote><p>短短两句话，就能让我戴上痛苦面具</p></blockquote><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%chap3_1.m“年轻”的隶属函数仿真程序参考代码</span><span class="token comment" spellcheck="true">%Membership function for Young People  “年轻”的隶属函数曲线</span>clear all<span class="token punctuation">;</span>close all<span class="token punctuation">;</span><span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1001</span>    <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">0.10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% x取值范围0~100</span><span class="token keyword">if</span> <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">25</span>   <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">else</span>   <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'X Years'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'Degree of membership'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实验过程和结果</strong></p><p>(1)六种隶属度函数的仿真</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%chap3_2.m</span><span class="token comment" spellcheck="true">%Membership function</span>clear all<span class="token punctuation">;</span>close all<span class="token punctuation">;</span>M<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> M<span class="token operator">==</span><span class="token number">1</span>          <span class="token comment" spellcheck="true">%Guassian membership function 高斯型隶属函数</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">gaussmf</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">%高斯函数依赖两个参数，gaussmf(x,[sig,c])</span>    <span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> M<span class="token operator">==</span><span class="token number">2</span>      <span class="token comment" spellcheck="true">%General Bell membership function 广义钟型隶属函数</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">gbellmf</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> M<span class="token operator">==</span><span class="token number">3</span>      <span class="token comment" spellcheck="true">%S membership function S型隶属函数</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">sigmf</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> M<span class="token operator">==</span><span class="token number">4</span>      <span class="token comment" spellcheck="true">%Trapezoid membership function 梯形隶属函数</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">trapmf</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> M<span class="token operator">==</span><span class="token number">5</span>      <span class="token comment" spellcheck="true">%Triangle membership function 三角型隶属函数</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">trimf</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> M<span class="token operator">==</span><span class="token number">6</span>      <span class="token comment" spellcheck="true">%Z membership function Z型隶属函数</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">zmf</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>高斯型隶属函数</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151542498.jpg" alt="1"></p><hr><p>广义钟型隶属函数</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151542839.jpg" alt="2"></p><hr><p>S型隶属函数</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151542490.jpg" alt="3"></p><hr><p>梯形隶属函数</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151542579.jpg" alt="4"></p><hr><p>三角型隶属函数</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151542136.jpg" alt="5"></p><hr><p>Z型隶属函数</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151543898.jpg" alt="6"></p><hr><p>(2)习题3-1隶属度函数设计和仿真输出</p><p>“很年轻W”设计：<br>$$<br>\mu_W(a)=\begin{equation}<br>\left\{<br>             \begin{array}{lr}<br>             1.0, &amp; 0\leq a\leq 20 \<br>             \displaystyle{\frac{50-a}{30}}, &amp; 20 \leq a\leq 50\<br>             0, &amp; a\geq 50\<br>             \end{array}<br>\right.<br>\end{equation}<br>$$</p><blockquote><p>老爸上周刚过49岁大生日，在学校一天只能晚上打了个电话回去，老爸可能已经不年轻了，但在我心里还是可以“很年轻”的，所以设成50岁。同理，50岁是最”不老也不年轻“的。</p></blockquote><p>“不老也不年轻V”设计：<br>$$<br>\mu_V==\begin{equation}<br>\left\{<br>             \begin{array}{lr}<br>             0, &amp; 0\leq a\leq 20 \<br>             \displaystyle{\frac{a-20}{30}}, &amp; 20 \leq a\leq 50\<br>             \dfrac{70-a}{20}, &amp; 50 \leq a\leq 70\<br>             0, &amp; a\geq 70\<br>             \end{array}<br>\right.<br>\end{equation}<br>$$</p><hr><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%Membership function for W People  “很年轻W”的隶属函数曲线</span>clear all<span class="token punctuation">;</span>close all<span class="token punctuation">;</span><span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1001</span>    <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">0.10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% x取值范围0~100</span><span class="token keyword">if</span> <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">20</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">20</span><span class="token operator">&amp;</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">50</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token operator">-</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'X Years'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'Degree of W'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151623895.png" alt="不老也不年轻V"></p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%Membership function for V People  “不老也不年轻V”的隶属函数曲线</span>clear all<span class="token punctuation">;</span>close all<span class="token punctuation">;</span><span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1001</span>    <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">0.10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% x取值范围0~100</span><span class="token keyword">if</span> <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">20</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">20</span><span class="token operator">&amp;</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">50</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">elseif</span> <span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">50</span><span class="token operator">&amp;</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">70</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">70</span><span class="token operator">-</span><span class="token function">x</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token function">y</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'X Years'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'Degree of V'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202112151626807.png" alt="不老也不年轻V"></p><blockquote><p>长大总是要比变老慢，所以前面上升的直线斜率小</p></blockquote><p><strong>实验体会</strong></p><p>这次matlab online好用很多，就是下载图片不方便，索性直接截图，图片大小反而合适。难得一次没带课本，结果就临时花了十分钟找课本PDF，九分钟百度，一分钟谷歌。下次找资料还是直接谷歌省事。这么简单的实验做了我一个半小时，太慢了。</p><hr><p><strong>资料</strong></p><p><a href="https://blog.csdn.net/qq_32809093/article/details/102974447" target="_blank" rel="noopener">9分钟百度CSDN的结果</a></p><p><a href="https://iridescent.ink/studynotes/pdf/IntelligentControl.pdf" target="_blank" rel="noopener">1分钟谷歌找到的PDF课本</a></p><p><a href="https://blog.csdn.net/weixin_39883065/article/details/109908342" target="_blank" rel="noopener">latex大括号 多行公式_Typora数学公式汇总（Markdown）</a></p><hr><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 智能系统控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU操作系统</title>
      <link href="/2021/11/28/shuos/"/>
      <url>/2021/11/28/shuos/</url>
      
        <content type="html"><![CDATA[<h1 id="SHU操作系统"><a href="#SHU操作系统" class="headerlink" title="SHU操作系统"></a>SHU操作系统</h1><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><h3 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h3><p><strong>五道大题</strong></p><p><strong>单选题</strong>20，一个一分，后4题是linux相关，两个系统工作调用和命令，存储管理4个，进程好多9个，第三章1小题，第一章1小题</p><p>相关状态，核心态用户态，特权指令和非特权指令，系统调用和库函数（CPU状态不变），必考内容</p><p>处理机上下文是context，所有寄存器。PSW，处理机状态搞错了。</p><p>2.3，现代操作系统，模糊处理，古代操作系统也是分成多个层次，核心态下运行的叫内核</p><p>处理机上下文切换，把所有寄存器腾出来</p><p>进程状态，进程抽象都没有问题</p><p>临界区</p><p>三种指令，实现临界区互斥</p><p>管程</p><blockquote><p>sychronized同步，其实非同步</p></blockquote><blockquote><p>volatile易变的，说明一个变量等于0，x=0，if x==0，可能进行了进程切换所以改了。 </p></blockquote><p><strong>存储管理</strong></p><p>TLB，快表，translation Looksside Buffer，有一题</p><p>分配算法，伙伴系统</p><p>存储扩充，对换，虚拟内存</p><p><strong>判断题</strong>20,20题</p><p>出了一道Unix，估计都不会，文件目录，unlink</p><p>存储管理考了好多</p><p>微内核</p><p>进程和程序的关系，进程和程序没什么一对一关系，fork，exec</p><p>算法？</p><p>装入和链接，动态链接，不需要把程序装入内存，load on reference，copy on write。</p><p>虚实分离，地址重定位，地址映射，地址变换，<strong>页表</strong>，快表，多级页表，反置页表，挖坑，从物理地址变虚地址？不是！</p><p>请求分页中的请求页表机制，图，错的，没有外存地址，存在位访问位修改位，缺页中断图。6次缺页中断</p><p>丹宁的悲催结论，内存条不足神仙没办法。</p><p><strong>设备管理</strong></p><p>驱动程序有关，硬件公司写的，不同操作系统有在核内有在核外，不知道。虽然主流在核内。</p><p>磁盘调度，读写调度。电梯调度，判断题，前无古人？</p><p><strong>填空题5大题</strong>20，4文件相关，5Unix,文件链接怎么换名，link和unlink。符号链接。创建和删除文件和符号链接的关系。</p><p>8个空，unix，第九章</p><p>文件系统</p><p><strong>简答题10</strong></p><p>核心态</p><p>调度算法scan</p><p>五个大题30</p><p>系统工作调用和函数</p><p>程序在干嘛</p><p>6分，肯定写过</p><p>这是第五题</p><p>第四题，地址变换，画了一张图，386,</p><p>第三题，页表结构。</p><p>第二题，死锁</p><p>第一题，PV操作实现同步互斥，猴子过桥读写问题改进</p><blockquote><p>注意事项：答题纸，别作弊。</p></blockquote><h3 id="考试范围"><a href="#考试范围" class="headerlink" title="考试范围"></a>考试范围</h3><p>操作系统是个平台，你不知道app用操作系统干什么，界面怎么设计，Unix里没有删除文（文件换名）件的系统调用，Unlink，link=0文件就没了。加一个文件名，减一个文件名。</p><p>界面设计。</p><p>图</p><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>每次最后一排的人坐到最前面。</p><p>操作系统是什么？</p><h2 id="上机实验"><a href="#上机实验" class="headerlink" title="上机实验"></a>上机实验</h2><p>提前一天装好Ubuntu虚拟机，我用VMware16 pro装的最新版本，自己上网找办法破解一下，不像机组的时候装了个centos7还要自己配置网络，直接可以上浏览器。</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>一些简单命令</p><p>whoami</p><p>who am i，参数-m也一样</p><p>用户分权，安全组策略。</p><p>who</p><p>所有命令都是可执行文件。</p><p>date，原子操作</p><p>ls，参数-a显示隐藏文件</p><ul><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li><li>-t将文件以相反次序显示(原定依英文字母次序)</li><li>-l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li></ul><blockquote><p>-rw——-. 1 root root 1.3K Dec 14 01:38 anaconda-ks.cfg</p></blockquote><p>从上面可以看到，每一行都有7列，分别是：</p><ol><li><strong>第一列</strong>共10位，第1位表示文档类型，<code>d</code>表示目录，<code>-</code>表示文件，<code>l</code>表示链接文件，<code>d</code>表示可随机存取的设备，如U盘等，<code>c</code>表示一次性读取设备，如鼠标、键盘等。后9位，依次对应三种身份所拥有的权限，身份顺序为：owner、group、others，权限顺序为：readable、writable、excutable。如：<code>-r-xr-x---</code>的含义为<strong>当前文档是一个文件，拥有者可读、可执行，同一个群组下的用户，可读、可执行，其他人没有任何权限</strong>。</li><li><strong>第二列</strong>表示链接数，表示有多少个文件链接到inode号码。</li><li><strong>第三列</strong>表示拥有者</li><li><strong>第四列</strong>表示所属群组</li><li><strong>第五列</strong>表示文档容量大小，单位字节</li><li><strong>第六列</strong>表示文档最后修改时间，注意不是文档的创建时间哦</li><li><strong>第七列</strong>表示文档名称。以点(.)开头的是隐藏文档</li></ol><p>ps进程</p><p>pwd当前路径</p><p>clear</p><p>什么是文件？什么都是文件。</p><p>mkdir</p><p>touch用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>rm,rmdir</p><p>cp从前到后</p><p>rm -rf /</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>se nu行号</p><p>：/ 查找</p><p>1,23</p><p><strong>VIM 的正常模式（Normal-model）</strong></p><p>VIM 正常模式下，主要进行的操作有光标的移动，复制文本，删除文本，黏贴文本等。</p><p><strong>快速移动光标</strong></p><p>几个重要的快捷键</p><p>请记住这几个快捷键 <code>h,j,k,l</code> 这几个按键主要是用来快速移动光标的，<code>h</code> 是向左移动光标，<code>l</code> 是向右移动光标，<code>j</code> 是向下移动光标，<code>k</code> 是向上移动光标，<code>h , j , k ,l</code> 在主键盘区完全可以取代键盘上的 <code>↑ ,↓ ,← , →</code> 的功能。</p><p><strong>在当前行上移动光标</strong></p><p><code>0</code> 移动到行头</p><p><code>^</code>   移动到本行的第一个不是 blank 字符</p><p><code>$</code>  移动到行尾</p><p><code>g_</code>  移动到本行最后一个不是 blank 字符的位置</p><p><code>w</code> 光标移动到下一个单词的开头</p><p><code>e</code>  光标移动到下一个单词的结尾</p><p><code>fa</code>  移动到本行下一个为 a 的字符处，fb 移动到下一个为 b 的字符处</p><p><code>nfa</code> 移动到本行光标处开始的第 n 个 字符为 a 的地方（n 是 1，2，3，4 … 数字）</p><p><code>Fa</code> 同 <code>fa</code> 一样，光标移动方向同 <code>fa</code> 相反</p><p><code>nFa</code> 同 <code>nfa</code> 类似，光标移动方向同 <code>nfa</code>相反</p><p><code>ta</code> 移动光标至 a 字符的前一个字符</p><p><code>nta</code> 移动到第二个 a 字符的前一个字符处</p><p><code>Ta</code> 同 <code>ta</code> 移动光标方向相反</p><p><code>nTa</code> 同 <code>nta</code> 移动光标方向相反</p><p><code>;</code> 和<code>,</code> 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 <code>；</code>可以快速跳转到写一个指定的字符，<code>,</code> 是跳到前一个指定的字符</p><p><strong>跨行移动光标</strong></p><p><code>nG</code> 光标定位到第 n 行的行首</p><p><code>gg</code> 光标定位到第一行的行首</p><p><code>G</code>  光标定位到最后一行的行首</p><p><code>H</code> 光标定位到当前屏幕的第一行行首</p><p><code>M</code>   光标移动到当前屏幕的中间</p><p><code>L</code> 光标移动到当前屏幕的尾部</p><p><code>zt</code> 把当前行移动到当前屏幕的最上方，也就是第一行</p><p><code>zz</code> 把当前行移动到当前屏幕的中间</p><p><code>zb</code> 把当前行移动到当前屏幕的尾部</p><p><code>%</code>   匹配括号移动，包括 ( , { , [  需要把光标先移动到括号上</p><p><code>*</code> 和 <code>#</code> 匹配光标当前所在的单词，移动光标到下一个（或者上一个）匹配的单词（ <code>*</code> 是下一个，<code>#</code> 是上一个）</p><p><strong>翻页操作</strong></p><p><code>ctrl+f</code> 查看下一页内容</p><p><code>ctrl+b</code> 查看上一页内容</p><p><strong>VIM 的复制，黏贴 ，删除</strong></p><p>三个重要的快捷键 <code>d</code> , <code>y</code> , <code>p</code></p><p><code>d</code> 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：</p><p><code>dw</code> 删除一个单词</p><p><code>dnw</code> 删除 n 个单词，</p><p><code>dfa</code> 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ）</p><p><code>dnfa</code> 删除光标处到第 n 个 a 的字符处</p><p><code>dd</code> 删除一整行</p><p><code>ndd</code> 删除光标处开始的 n 行</p><p><code>d$</code> 删除光标到本行的结尾</p><p><code>dH</code> 删除屏幕显示的第一行文本到光标所在的行</p><p><code>dG</code> 删除光标所在行到文本的结束</p><p><code>y</code> 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：</p><pre><code>yw` 复制一个单词，还有 `ynwyfa` 复制光标到下一个 a 的字符处,还有`ynfayy` 复制一行，还有 `nyy</code></pre><p><code>y$</code> 复制光标到本号的结尾</p><p><code>yH</code> 复制屏幕显示的第一行文本到光标所在的行</p><p><code>yG</code> 复制光标所在行到文本的结束</p><p><code>p</code> ，<code>P</code>是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来。</p><p><code>p</code> 在光标后开始复制</p><p><code>P</code> 大写的 P 光标前开始复制</p><p><strong>撤销操作和恢复</strong></p><p><code>u</code> 撤销刚才的操作</p><p><code>ctrl + r</code> 恢复撤销操作</p><p><strong>删除字符操作和替换</strong></p><p><code>x</code> 删除光标当前所在的字符</p><p><code>r</code> 替换掉光标当前所在的字符</p><p><code>R</code> 替换掉从光标开始以后的所有字符，除非 <code>&lt;ESC &gt;</code> 退出，或者 <code>jj</code> （代替 <esc> 上文有提到）退出。</esc></p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><hr><p>另见博客</p><hr><h3 id="实验一Hello-world"><a href="#实验一Hello-world" class="headerlink" title="实验一Hello world"></a>实验一Hello world</h3><pre class="line-numbers language-shell"><code class="language-shell">#include <stdio.h>#include <stdlib.h>main(){printf("Hello World!\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#include <stdio.h>#include <stdlib.h>int main(){printf("Hello World!\n");return 123;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#include <stdio.h>#include <stdlib.h>int main(int argc,char* argv[]){    int i;    for(i=0;i<argc;i++){        printf("%d:%s\n",i,argv[i]);    }    return 123;}# echo ./a.out $?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#include <stdio.h>#include <stdlib.h>int main(int argc,char* argv[],char **envp){    int i;    for(i=0;;i++){        if (envp[i]==NULL) break;        printf("%d:%s\n",i,envp[i]);    }    return 123;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>argc<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d:%s\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>getenv<span class="token punctuation">[</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MY_V=123456</p><p>export MY_V</p><p>./a.out MY_V</p><h3 id="实验二fork"><a href="#实验二fork" class="headerlink" title="实验二fork"></a>实验二fork</h3><pre><code>fork#include &lt;unistd.h&gt;</code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> pid<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am parent ,child PID is %d.\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"I am child.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>   <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>   <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>   <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> pid<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am parent ,child PID is %d, my pid is %d.\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">else</span><span class="token punctuation">{</span>         <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"I am child,my pid is %d, my parent pid is %d.\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//sleep(1);</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>p2.c</strong></p><p>if else{} 并发性，父进程结束，1号进程成为父进程。进程duplicate自己创建子进程。</p><p><strong>p3.c</strong></p><p>sleep(1)</p><p><strong>p4.c</strong></p><pre class="line-numbers language-c"><code class="language-c">pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//父进程等待子进程结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Begin\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"End\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>echo $?</p><p><strong>p5.c</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span> </span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> pid<span class="token punctuation">,</span>status<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am parent ,child PID is %d, my pid is %d.\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*if (WIFEXITED(status))            printf("Child return code is %d\n",WEXITSTATUS(status));        else            printf("Child exit abnormally\n");    */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child return code is %d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token punctuation">}</span>     <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"I am child,my pid is %d, my parent pid is %d.\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//exit(123); </span>        <span class="token comment" spellcheck="true">//for (;;);</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>p6.c</strong></p><p>exit(123)</p><p><strong>p7.c</strong></p><p>死循环，kill -1 2219，返回“Child return code is 0”</p><p>异常返回</p><h3 id="实验三execve"><a href="#实验三execve" class="headerlink" title="实验三execve"></a>实验三execve</h3><p>SYNOPSIS</p><pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>#include <stdlib.h>#include <unistd.h>main(){    execl("/bin/ls","ls","-al",NULL);    //printf("hello world!\n");    //无输出    // The exec() family of functions replaces the current process image with    // a new process image. }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实验四pipe"><a href="#实验四pipe" class="headerlink" title="实验四pipe"></a>实验四pipe</h3><p>ls|sort</p><p>ls|sort -r</p><pre class="line-numbers language-c++"><code class="language-c++">#include<stdio.h>#include<stdlib.h>#include<unistd.h>main(){    int fd[2];    pipe(fd);//创建一个管道    if(fork()!=0){        close(1);//关闭标准输出        dup(fd[1]);//标准输出描述符接上管道输出fd        close(fd[0]);        close(fd[1]);        //execl("/bin/ls","ls",NULL);    }else{        close(0);        dup(fd[0]);        close(fd[0]);        close(fd[1]);        //execl("/bin/sort","sort","-r",NULL);    //execlp（“sort”,"sort",NULL）;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tee连接多个管道</p><p>grep搜索</p><blockquote><p>sort文件位置找不到，whereis找一下</p></blockquote><h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h3><hr><p><strong>资料</strong></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/82964713?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163278810116780262563550%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fnavwordall.%2522%257D&request_id=163278810116780262563550&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~navwordall~first_rank_ecpm_v1~hot_rank-1-82964713.first_rank_v2_pc_rank_v29&utm_term=shell&spm=1018.2226.3001.4187" target="_blank" rel="noopener">CSDN的Linux中编写Shell脚本</a></p><p><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">菜鸟教程shell</a></p><p><a href="https://www.runoob.com/try/showbash.php?filename=helloworld" target="_blank" rel="noopener"><strong>Shell 在线工具</strong></a></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p><a href="https://zhuanlan.zhihu.com/p/36801617" target="_blank" rel="noopener">看完这篇Linux基本的操作就会了</a> - Java3y的文章 - 知乎 </p><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p><a href="https://blog.csdn.net/qq_19339041/article/details/80058575" target="_blank" rel="noopener">ubuntu 16.04 更改系统语言为简体中文</a></p><h3 id="linux教程"><a href="#linux教程" class="headerlink" title="linux教程"></a>linux教程</h3><p><a href="https://www.runoob.com/linux/linux-tutorial.html" target="_blank" rel="noopener">linux菜鸟教程</a></p><h3 id="做个简单的OS"><a href="#做个简单的OS" class="headerlink" title="做个简单的OS"></a>做个简单的OS</h3><p><a href="https://www.xuetangx.com/course/THU08091000267/7753473" target="_blank" rel="noopener">清华学堂在线</a></p><p><a href="https://blog.csdn.net/Go_forward_/article/details/113717530" target="_blank" rel="noopener">【清华大学操作系统课】虚拟机实验环境搭建-手把手图文教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHUIoT</title>
      <link href="/2021/11/28/shuiot/"/>
      <url>/2021/11/28/shuiot/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281535134.jpg" alt="19122362晏云天_01"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534458.jpg" alt="19122362晏云天_02"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534910.jpg" alt="19122362晏云天_03"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534848.jpg" alt="19122362晏云天_04"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534291.jpg" alt="19122362晏云天_05"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534747.jpg" alt="19122362晏云天_06"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534372.jpg" alt="19122362晏云天_07"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534328.jpg" alt="19122362晏云天_08"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534774.jpg" alt="19122362晏云天_09"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281534396.jpg" alt="19122362晏云天_10"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281535896.jpeg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281535290.jpg" alt="19122362晏云天_12"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281535061.jpg" alt="19122362晏云天_13"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281535975.jpg" alt="19122362晏云天_14"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281535561.jpg" alt="19122362晏云天_15"></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> IoT </tag>
            
            <tag> 5G </tag>
            
            <tag> 课程报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU语义网与知识图谱</title>
      <link href="/2021/11/28/shukg/"/>
      <url>/2021/11/28/shukg/</url>
      
        <content type="html"><![CDATA[<h1 id="SHU语义网与知识图谱"><a href="#SHU语义网与知识图谱" class="headerlink" title="SHU语义网与知识图谱"></a>SHU语义网与知识图谱</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从大二的选导师那个实践课就是lw老师负责，那个时候就开始忽悠我们来上这门课（虽然不忽悠我也应该会选这门课），然后后面高级研讨课也是他，有同学选了这个研讨方向，多多少少有了一点了解。</p><p>但是课程考核真的好麻烦啊。</p><h2 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h2><h3 id="第一讲：语义网概述"><a href="#第一讲：语义网概述" class="headerlink" title="第一讲：语义网概述"></a>第一讲：语义网概述</h3><blockquote><p><strong>语义网就是一种描述网络Web数据，具有模型语义，并且在一定程度上支持语义推理的知识表示方法</strong></p></blockquote><p><strong>基本概念</strong></p><ol><li><strong>语义web的组成</strong>：语义web信息的开放标准、从web描述信息中进一步获取语义的方法。</li><li>本体：本体是一种形式化的，对共享概念体系的明确而又详细的说明。提供一种共享词表。核心是分类体系。</li><li>RDF使用<strong>有向图</strong>作为数据类型。</li><li>语义网和语义网络的<strong>区别</strong>：语义网是未来发展的趋势，是web3.0的特征；而语义网络是一种知识表示方法，仅仅是一个方法。</li><li>知识图谱：学术角度上讲，知识图谱本质上是一种揭示实体之间关系的语义网络，可以对现实世界的事物及其相互关系进行形式化地描述。</li><li>知识图谱的技术流程：知识表示、知识获取、知识融合、知识推理、知识检索、知识分析</li><li>Datalog的基本语法包含：原子、规则、事实。</li><li>知识图谱的存储：关系型数据库、三元组库、图数据库</li><li>知识图谱的应用：推荐系统、知识问答等</li><li>逻辑语义包含：模型论和证明论</li><li>知识谱图的表示：符号表示、向量表示。</li><li>描述逻辑的基本概念：个体、类、属性。</li></ol><blockquote><p>第一节课没带电脑，抄一点学长做的笔记。</p></blockquote><p>人类之所以能用自然语言思维，能用自然语言互相交流，关键在于每个人的大脑中，有一个结构相同、内容近似、涵盖丰富、查询和推理功能强大并能方便提升的知识库系统。</p><p>对机器而言，也是同样的，机器之间要相互理解和沟通。也需要一个这样的知识库，这个知识库我们通常称之为<strong>本体</strong>。</p><p>什么是本体？</p><p>本体是指一种“<strong>形式化</strong>的，对亍共享概念体系的明确而又详细的说明“</p><p>本体实际上就是对特定领域之中某套概念及其相互之间关系的形式化表达（formal representation）</p><p>本体是指一种“<strong>形式化</strong>的，对于共享概念体系的明确而又详细的说明”</p><p><strong>本体语言</strong></p><p>实现语义技术最重要的是有合适的<strong>知识表示语言</strong>。</p><p>含义（Meaning,语义）通常通过逻辑和推理算法实现。</p><p>本体语言的可伸缩性（Scalability）具有挑战</p><p><strong>本体</strong></p><p>本体的核心通常是分类体系（Taxonomy）：</p><p>事物的类，以层次结构进行</p><p>部分-整体分类体系 (Partonomy , not a taxonomy)</p><p><strong>Partonomy vs. Taxonomy</strong></p><p><strong>语义网发展历史</strong></p><p><strong>1998年由Tim Berners-Lee提出</strong></p><p>• <strong>Partonomy:</strong></p><p><strong>A is part of B</strong></p><p>hand is part of body</p><p>Germany is part of Europe</p><p>Wing is part of aircraft</p><p>Engine is part of car</p><p>• <strong>Taxonomy</strong></p><p><strong>every A is a B</strong></p><p>every father is a man</p><p>every dog is a mammal</p><p>every bottle is a container</p><p>every arm is a limb</p><hr><h3 id="第二讲：RDF和RDFs"><a href="#第二讲：RDF和RDFs" class="headerlink" title="第二讲：RDF和RDFs"></a>第二讲：RDF和RDFs</h3><h4 id="RDF部分"><a href="#RDF部分" class="headerlink" title="RDF部分"></a>RDF部分</h4><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524448.png" alt="RDF"></p><hr><p><strong>RDf知识点</strong></p><ol><li><p>动机Motivation</p></li><li><p>三元组和图Triples and Graphs</p></li><li><p>RDF语法 RDF syntaxes: Turtle and RDF/XML</p></li><li><p>数据类型Datatypes</p></li><li><p>n元关系n-ary relationships</p></li><li><p>空节点Empty nodes</p></li><li><p>列表Lists</p></li></ol><hr><p><strong>为什么用RDF？</strong></p><p>用XML描述信息（知识），被编码成树结构。但是当把XML中的树状信息进行合并时，会变得累赘笨重，不易理解。</p><p>RDF使用（有向）图作为数据模型</p><p>RDF把对象之间的关系作为构建信息的基础，大量这样的实体关系很自然地构成了图，而不是层次化的树结构。RDF是为Web和其他电子网络的数据设计的一种描述语言。在这样的环境中，信息通常被分散存储和管理，合并不同来源的RDF数据变得更加容易。</p><p>（合并简单，总之就是好用）</p><hr><p>URIs描述资源，Literals 文字，Empty nodes 空节点</p><p><strong>一个图表示一系列的三元组（点-边-点）</strong></p><p><strong>一个三元组包含：</strong></p><p><strong>规则:</strong> </p><p>主语 : URIs 和空节点</p><p>谓语: URIs (通常被称为属性properties)</p><p>宾语: URIs 、空节点或文字Literals</p><hr><p><strong>Turtle</strong>——<strong>为RDF提供简单语法</strong></p><p>三元组表示方法：</p><p>– URIs 放在&lt;&gt;中 </p><p>– 文字用双引号“”</p><p>– 三元组用英文句号结束</p><p>– 忽略空格</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524449.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524450.png" alt="简写"></p><p>Turtle只是方便阅读，实际使用xml语法。</p><p><strong>RDF的xml-based语法</strong></p><p>用名字空间消除歧义。</p><p>RDF中标签通常固有的名字空间简写为rdf</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>RDF</span><span class="token attr-name"><span class="token namespace">xmlns:</span>rdf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/1999/02/22-rdf-syntax-ns#<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>rdfs</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/01/rdf-schema#<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>iswww</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>Description</span> <span class="token attr-name"><span class="token namespace">rdf:</span>about</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#germany<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> # 通过about属性标识一个资源，格式对称    ....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>Description</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无类型的文字可以使自由文本</p><p>一个主语可以包含多个属性</p><p>宾语描述可以用作更深层次三元组的主语，就是说可以嵌套。</p><p>利用XML的属性值代替文字的表示</p><p>通过属性标签内rdf:resource值表示的URIs表示宾语</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524451.png" alt></p><p>问题: 命名空间丌能出现在XML的属性值，例如，在XML属性出现’book’将会出错，因为会被解释为URI模式。</p><p>解决方案: 使用 XML ENTITYs.</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524452.png" alt="&book;uri等同于"></p><hr><p>rdf:about=“uri” 等同亍rdf:about=“<a href="http://semantic-web-book.org/uri”" target="_blank" rel="noopener">http://semantic-web-book.org/uri”</a></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524453.png" alt></p><hr><p><strong>Rdf:XMLLiteral是RDF唯一内嵌数据类型，它允许嵌入形式良好的XML片段作为RDF的文字值</strong></p><blockquote><p>好在能看懂一点xml，大概能理解</p></blockquote><hr><p>rdf:parserType:”Resource”表示属性值是空节点，自动创建。</p><p>Turtle中 _:xxx , 空白节点由一个下划线代替命名空间前缀。</p><p>[]上省略谓语宾语，下省略主语</p><hr><p><strong>List</strong></p><ul><li>Openlist</li></ul><p>“open”: 可添加新元素. </p><p>rdf:Seq – 顺序列表</p><p>rdf:Bag – 无序</p><p>rdf:Alt –为替代，是一组可选择的资源或文字集合</p><ul><li>Closed list</li></ul><p>Trutle（xxx yyy zzz）</p><hr><p><strong>小结</strong></p><p>上次花了一下午时间把实验做了，看了很多RDF教程，感觉没有上课的时候讲的详细，听一遍比自己看轻松。</p><p>ps：这一部分是考核重点。</p><hr><h4 id="RDFs及其形式语义"><a href="#RDFs及其形式语义" class="headerlink" title="RDFs及其形式语义"></a>RDFs及其形式语义</h4><p><strong>知识点</strong></p><p><strong>1. 动机</strong></p><p><strong>2. 类和类层次结构 Classes and Class Hierarchies</strong></p><p><strong>3. 属性和属性层次结构 Properties and Property Hierarchies</strong></p><p><strong>4. 属性约束 Property Restrictions</strong></p><p><strong>5. 开放列表回顾 Open Lists Revisited</strong></p><p><strong>6.关于命题的命题：物化 Reification</strong></p><p><strong>7. RDFS附加信息 Supplementary Information in RDFS</strong></p><p><strong>8. RDFS中的简单本体 Simple Ontologies in RDFS</strong></p><hr><p>RDF用于表示事实，RDFS允许我们进行模式（Schema）知识建模（又叫术语化知识，有点像抽象概念，什么是什么）</p><p>RDFS文档也是RDF文档，词汇通用</p><hr><p>rdf:type属于某个类的实例</p><p>rdfs：subClassOf属于子类</p><p>rdfs：class 道生一</p><p>rdfs:Resource</p><p>rdf:Property</p><p>rdf:XMLLiteral RDF唯一的预定义类型</p><p>rdfs:Literal所有字面体类</p><p>rdf:Bag, rdf:Alt, rdf:Seq, rdfs:Container , rdf:List, rdf:nil 列表类</p><p>rdfs:ContainerMembershipProperty容器属性类</p><p>rdfs:Datatype数据类型类</p><p>rdf:Statement (see later) <strong>物化的三元组的类</strong></p><hr><p>隐式知识</p><p>推理逻辑结论由形式语义决定。</p><p>rdfs:subClassOf 是传递的</p><p>类等价：两个类包含相同的个体，互为子类</p><hr><p><strong>属性层次结构</strong>，我的理解就是对谓语类划分</p><p>可以声明某个属性的类型以及它的取值范围，即定义域和值域。</p><p>还可以用数据类型来约束。</p><p>每个被声明的属性限制会全局地影响此属性所有的出现情况，在使用属性限制时要非常小心，尽量使用足够一般的类。</p><p>潜在的类型不匹配问题，RDF无法判定并拒绝接受。</p><blockquote><p>机器不能理解隐喻。ismarriedto，</p></blockquote><hr><p><strong>开饭列表</strong></p><p>新的类: rdfs:Container 是 rdf:Seq, rdf:Bag, rdf:Alt等列表类的超类</p><p> rdfs:ContainerMembershipProperty 包含用于各种列表容器的属性类</p><p>rdfs:member 是所有包含rdfs:ContainerMembershipProperty中的属性的超属性</p><p>如果 rdfs:叔叔 rdf:type rdfs:长辈</p><p>如果 a rdfs:叔叔 b</p><p>可推出： a rdfs:长辈 b</p><blockquote><p>谓语的层次结构</p></blockquote><hr><p><strong>关于命题的命题</strong></p><p>“The detective supposes that the butler killed the gardener.”</p><p> “侦探推测管家杀死了园丁”，简单建模如下：</p><p>通过字面体表达不能被其他三元组引用，因此使用一个URI来指定更合理。为了避免缺乏结构透明性，将URI部分建模成一个独立三元组。</p><p>引入辅助接点，用于描述要声明的命题中的三元组，该接点用</p><p>作“句柄”来指代整个声明：ex:theory </p><p>如果物化命题只被本身引用，可以用空白接点来表示，代替ex:theroy.</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524454.png" alt></p><p><strong>画图是重点考点</strong>，大题</p><hr><p>rdfs:label URI命名e.g. to give a human-readable name for a URI。</p><p>rdfs:comment: 用于为资源指定注解。</p><p>rdfs:seeAlso, rdfs:definedBy:用于连接到提供关于主语资源更多信息或定义的URIs.</p><blockquote><p>可用可不用，暗示不是考点，能看懂就行</p></blockquote><hr><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524455.png" alt="考"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524456.png" alt="答"></p><p><strong>考试重点</strong></p><blockquote><p>虚线上都是事实知识（assertion，断言），上面都是模式知识。</p></blockquote><hr><p><strong>RDF（s）形式语义</strong></p><blockquote><p>这部分偏数学，抽象</p></blockquote><p>获得逻辑结论（logical consequence）的过程，我们称为演绎(deduction)或推理(inference)，我们不需要显式地声明。</p><p>什么样的陈述（statement）是逻辑结论，由形式语义决定。</p><p>我们主要考虑语义概念的<strong>逻辑维度</strong>(logic dimension)，即<strong>形式语义</strong>(formal semantics)</p><blockquote><p>不太确定是什么，编译原理，命令？应该不是语言学里说的那些语义，名词动词之类的。</p></blockquote><p>虽然有些特定情况，可以通过样例来获得结论是否有效，但丌能保证对于无限多种推理，都能达成共识。解决这一问题<strong>最好的方法</strong>就是通过定义良好的形式语义来避免非形式化规格说明造成的不确定性。 </p><hr><p>为什么定义语义？</p><p>P加粗代表命题全集。</p><p>用一个符号 ⊧ 表示推论关系（entailment relation）,比如命题p3和p4是命题p1和p2的逻辑推论，表示为{p1 ,p2 } ⊧{p3 ,p4}。 </p><p>推论关系把命题的集合不命题的集合关联起来。</p><p>一个逻辑L是由一个命题集合一个推论关系共同组成的，在抽象的层次上可以被描述为L=(P, ⊧)</p><hr><p><strong>语法和语义</strong></p><p>Syntax: 没有“意义”的字符串character strings without meaning</p><p>Semantics:有“意义”的字符串meaning of the character strings</p><p><strong>逻辑语义</strong></p><p>逻辑语义主要包括两个方面：模型论和证明论。</p><blockquote><p>重点讨论模型论语义</p></blockquote><p><strong>什么样的语义是好的？</strong></p><p>可共享，陈述性，可计算</p><blockquote><p>我们获取语义信息不通过指定其意思（含义meaning）(这是不可能的）<strong>而是通过定义信息如何与其他信息进行交互，并通过信息交互产生的结果来非直接地描述它的语义。</strong></p></blockquote><hr><p><strong>Interpretation解释</strong></p><hr><p><strong>RDF(S)的模型语义</strong></p><p><strong>Simple Interpretations</strong></p><blockquote><p>人都名字，你可以叫这个名字，他也可以叫这个名字，你是谁？</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524457.png" alt="Snipaste_2021-09-17_11-36-36"></p><h3 id="第三讲：本体论与OWL语言"><a href="#第三讲：本体论与OWL语言" class="headerlink" title="第三讲：本体论与OWL语言"></a>第三讲：本体论与OWL语言</h3><h4 id="本体论"><a href="#本体论" class="headerlink" title="本体论"></a>本体论</h4><p><strong>概念</strong>是抽象层面的泛指，通常是对一类事物共性的总结；它代表的总是这一类事物的总体，而非特指其中的一个具体事物。</p><p><strong>符号</strong>，亦即概念的名称，是用以表征概念的标记（可以是文字或图形）。在交流中，人们通常都是通过符号来传达概念及其含义；在此意义上，符号是概念的载体。</p><p><strong>实体</strong>是概念的具体化、实例化表现，亦即个别化的概念。概念所对应的所有实体构成概念的外延。</p><hr><p><strong>定义</strong></p><p><strong>Ontology</strong>本是哲学领域的概念，源自哲学中称为“形而上学”的分支，形而上学所关注的是现实的本质，也就是存在的本质。后被计算机界的研究者借用到信息领域，以描述用亍交流和共享的语义空间。Ontology 是一种用以描述语义的、概念化的显式说明（an explicit specification of a conceptualization. Gruber, 93）。它是对某一个领域内事物的共同理解（a shared understanding）</p><hr><p>Ontolgoy 在本质上是对<strong>客观世界的一种分类描述</strong>，因此，Ontology 模型实际上就是一种知识表示模型。</p><p><strong>本体(Ontology)</strong></p><p><strong>＝概念(Concept)＋属性(Property)＋公理(Axiom)＋取值(Value)＋命名(Nominal)</strong></p><hr><h4 id="OWL语言"><a href="#OWL语言" class="headerlink" title="OWL语言"></a>OWL语言</h4><p>信息交换语言主要包括：数据模型RDF，语义RDFS，OWL，语法Turtle。</p><p><strong>rdf回顾</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524458.png" alt="image-20210926153159204"></p><blockquote><p>RDF和RDFS不够，需更强的OWL</p></blockquote><p>OWL是一种在互联网上公布和共享实体的语义语言（semanticmarkup language）。OWL 起 源 亍 DAML+OIL 网 络 实 体 语 言 ， 是作为 RDF(the Resource Description Framework)的扩展词典进行开发。 </p><p><strong>OWL设计目标（特性）</strong></p><p>本体进化，本体协作，不一致性检测，表达性和可伸缩性的权衡（相斥），易用性，兼容性，国际化。</p><p>OWL成为一种Web语言，丌在亍它引入了描述逻辑的表达和推理能力，而在亍它用URI引用替代了名称，将XML Schema数据类型用于数据值，并且提供了连接到WWW文档上的能力，这些能力都是源于RDF(S)。</p><p>OWL Lite，OWL DL，OWL Full。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524459.png" alt="image-20210926154328285"></p><p>OWL-Full推理不可判定。lite只支持0和1的基数。枚举类只能在Full</p><p>为帮助书写冗长的URLs，在本体的定义之前，在文档类型声明（DOCTYPE）中提供一些实体定义（entity definitions）常常是很有用的。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524460.png" alt="image-20210926160901580"></p><blockquote><p>命名空间只能用在标签上。</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524461.png" alt="image-20210926160946299"></p><hr><p>OWL<strong>基本元素</strong></p><p><strong>简单的类</strong></p><p>用到的标签：Class, rdfs:subClassOf</p><p>OWL中的所有个体都是类owl:Thing的成员。因此，各个用户自定义的类都隐含地是owl:Thing的一个子类。要定义特定领域的根类，只将它们声明为一个具名类（named class）即可。</p><p>OWL也可以定义空类，owl:Nothing。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524462.png" alt="image-20210926161250899"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524463.png" alt="image-20210926161304969"></p><p>一个个体，中间地区是地区的一个实例。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524464.png" alt="image-20210926161504513"></p><p>用一个类的标签申明一个个体。</p><p><strong>简单属性</strong></p><p>数据类型属性（datatype properties）：类实例与RDF文字或XML Schema数据类型间的关系。</p><p>对象属性（object properties）：两个类的实例间的关系。</p><p>可以指定定义域（domain）和值域（range）。</p><p>可以将一个属性定义为某个已有属性的特殊化（子属性）</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524465.png" alt="image-20210926161805131"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524466.png" alt="image-20210926162030198"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524467.png" alt="image-20210928100827066"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524468.png" alt="image-20210928100843182"></p><blockquote><p>madeFromGrape定义域是这个匿名类</p></blockquote><p><strong>属性特性</strong></p><p><strong>TransitiveProperty</strong></p><p><strong>FunctionalProperty</strong></p><p><strong>inverseOf</strong></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>owl：ObjectProperty</span> <span class="token attr-name"><span class="token namespace">rdf：ID:</span>"hasMaker"</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">owl:</span>type</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&amp;owl;FunctionalProperety<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>owl：ObjectProperty</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>属性限制</strong></p><p>前面所讲述的机制都是全局的（global），因为这些机制都会应用到属性的所有实例。而allValuesFrom与someValuesFrom是局部的（local），它们仅仅在包含它们的类的定义中起作用</p><p>owl:allValuesFrom属性限制要求：对于每一个有指定属性实例的类实例，该属性的值必须是由owl:allValuesFrom从句指定的类的成员。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524469.png" alt="image-20210928103031827"></p><p>allValuesFrom，someValuesFrom至少有一个厂商是Winery</p><p><strong>基数限制：</strong>值域限制在0和1的基数表达式(Cardinality expressions)是OWL Lite的一部分。这使得用户能够表示“至少一个”，“不超过一个”，和“恰好一个”这几种意思。OWL DL中还允许使用除0与1以外的正整数值。</p><p>owl:maxCardinality能够用来指定一个上界。</p><p>owl:minCardinality能够用来指定一个下界。</p><p>使用二者的组合就能够将一个属性的基数限制为一个数值区间</p><p><strong>hasValue</strong> 使得我们能够根据“特定的”属性值的存在来标识类。因此，一个个体只要至少有“一个”属性值等于hasValue的资源，这一个体就是该类的成员</p><blockquote><p>Burgundy是干糖（Dry）的</p></blockquote><hr><p><strong>本体映射</strong></p><p> 为了让本体发挥最大的作用，就需要让本体得到充分的共享。</p><p><strong>类和属性之间的等价关系</strong></p><p><strong>equivalentClass,equivalentProperty</strong></p><p><strong>个体间的同一性</strong> <strong>–sameAs</strong></p><p><strong>不同的个体</strong>–AllDifferent</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524470.png" alt="image-20210928104300819"></p><hr><p><strong>复杂类</strong></p><p><strong>交运算–intersectionOf</strong></p><p><strong>并运算–unionOf</strong></p><p><strong>补运算–complementOf</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524471.png" alt="image-20210928104453085"></p><blockquote><p><strong>注意：考试要考，挖空填核心关键词</strong>.</p></blockquote><pre><code>&lt;owl:Restriction&gt; # 代表匿名类</code></pre><p><strong>集合：</strong>RDF 集合用于描述仅包含指定成员的组。</p><p><strong>集合是通过属性 rdf:parseType=”Collection” 来描述的。</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524472.png" alt="image-20210928105912979"></p><p><strong>枚举类</strong> <strong>–oneOf</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524473.png" alt="image-20210928110418373"></p><p><strong>不相交类</strong> <strong>–disjointWith</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524474.png" alt="image-20210928110603292"></p><hr><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524475.png" alt="image-20210928110733811"></p><hr><p><strong>总结</strong></p><p>这周上机的时候了解了本体论的基本概念，学习了本体语言OWL，三种子语言的区别，今天讲完基本语法等。继续往下。</p><hr><h3 id="第四讲：描述逻辑与描述逻辑语义"><a href="#第四讲：描述逻辑与描述逻辑语义" class="headerlink" title="第四讲：描述逻辑与描述逻辑语义"></a>第四讲：描述逻辑与描述逻辑语义</h3><h4 id="一、描述逻辑"><a href="#一、描述逻辑" class="headerlink" title="一、描述逻辑"></a><strong>一、描述逻辑</strong></h4><h5 id="1-描述逻辑简介"><a href="#1-描述逻辑简介" class="headerlink" title="1. 描述逻辑简介"></a><strong>1. 描述逻辑简介</strong></h5><p><strong>定义</strong></p><p><strong>DL描述逻辑</strong>（Description Logic）是基于对象的知识表示的形式化，也叫概念表示语言或术语逻辑。它吸收了KL-ONE的主要思想，是一阶谓词逻辑的一个<strong>可判定子集</strong>。</p><blockquote><p>可判定的，总能保证推理算法终止.</p></blockquote><blockquote><p>建立在概念和关系(Role)之上</p></blockquote><hr><p><strong>特性</strong></p><p>是以往表示工具的逻辑重构和统一形式化，具有很强的表达能力，是可判定的，总能保证推理算法终止。</p><hr><p>为什么要用DL？</p><h5 id="2-描述逻辑基础"><a href="#2-描述逻辑基础" class="headerlink" title="2. 描述逻辑基础"></a><strong>2. 描述逻辑基础</strong></h5><p><strong>基本概念</strong></p><p>个体，类，属性</p><p>命名规范</p><p>DL<strong>语法</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524476.png" alt="image-20210928112928597"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524477.png" alt="image-20210928113121173"></p><blockquote><p>一阶谓词逻辑FOL，蓝色是关于个体实例，绿色关于概念</p></blockquote><p><strong>DL基础—特殊类和属性</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524478.png" alt="image-20210928113517171"></p><blockquote><p>top,bottom</p></blockquote><h5 id="3-描述逻辑的体系结构"><a href="#3-描述逻辑的体系结构" class="headerlink" title="3. 描述逻辑的体系结构"></a><strong>3. 描述逻辑的体系结构</strong></h5><p>5个构造子构成了最基本的描述逻辑形式语言ALC</p><p>（Attribute concept description Language Complement)</p><h5 id="4-Description-Logic-SROIQ-D"><a href="#4-Description-Logic-SROIQ-D" class="headerlink" title="4. Description Logic SROIQ(D)"></a><strong>4. Description Logic SROIQ(D)</strong></h5><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524479.png" alt="image-20211012101704949"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524480.png" alt="image-20211012101733124"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524481.png" alt="image-20211012101805028"></p><p>属性声明特性</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524482.png" alt="image-20211012102303550"></p><p><strong>语法考试要考</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524483.png" alt="image-20211012102640827"></p><p><strong>两种全局限制(Global Restriction)</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524484.png" alt="image-20211012103103636"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524485.png" alt="image-20211012103140089"></p><h4 id="二、描述逻辑语义"><a href="#二、描述逻辑语义" class="headerlink" title="二、描述逻辑语义"></a><strong>二、描述逻辑语义</strong></h4><p>OWL有两种语义，描述逻辑语义（直接语义），RDF-based语义</p><p>一个解释就是一个公理集合的模型，如果所有公理在解释下成立。</p><p><strong>知识库的模型</strong></p><hr><p>通过谓词逻辑定义直接语义。</p><p><strong>知识库或者一个具名类的不可满足性通常可以指出模型错误。</strong></p><hr><p><strong>考试注意：附录</strong></p><p><strong>描述逻辑（OWL）的Turtle语法</strong></p><hr><h3 id="第五讲：知识图谱概览"><a href="#第五讲：知识图谱概览" class="headerlink" title="第五讲：知识图谱概览"></a>第五讲：知识图谱概览</h3><blockquote><p>回顾一下</p></blockquote><hr><p><strong>知识图谱概述</strong></p><p><strong>1. 什么是知识图谱</strong></p><p><strong>2. 知识图谱发展历程</strong></p><p><strong>3. 知识图谱技术流程</strong></p><p><strong>4. 知识图谱的相关技术</strong></p><p><strong>5. 典型的知识图谱项目</strong></p><hr><p>知识表示是现实世界的可计算模型。</p><p>知识图谱本身可以看作是一种新型的信息基础设施，就像通往人工智能的“燃料”</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524486.png" alt="image-20211015110544369"></p><h3 id="第六讲：知识图谱的表示与关联建模"><a href="#第六讲：知识图谱的表示与关联建模" class="headerlink" title="第六讲：知识图谱的表示与关联建模"></a>第六讲：知识图谱的表示与关联建模</h3><p><strong>一、知识图谱的表示与建模</strong></p><p><strong>1. 什么是知识表示</strong></p><p><strong>2. 知识图谱的表示框架与语言</strong></p><hr><p>⼀阶谓词逻辑 (First-Order Logic)</p><p>产⽣式规则 (Production Rule)</p><p>框架 (Framework)</p><p>语义⽹络 (Semantic Network)</p><p>逻辑程序 (Logic Programming)</p><p>缺省逻辑 (Default Logic)</p><p>模态逻辑 (Modal Logic)</p><hr><h4 id="知识图谱查询语言——SPARQL"><a href="#知识图谱查询语言——SPARQL" class="headerlink" title="知识图谱查询语言——SPARQL"></a><strong>知识图谱查询语言——SPARQL</strong></h4><p>常见查询算子</p><hr><p>​    DISTINCT去重</p><hr><h3 id="第七讲：知识图谱的存储查询"><a href="#第七讲：知识图谱的存储查询" class="headerlink" title="第七讲：知识图谱的存储查询"></a>第七讲：知识图谱的存储查询</h3><p><strong>内容概览</strong></p><p><strong>1. 前言</strong></p><p><strong>2. 知识图谱数据库基础知识</strong></p><p><strong>3. 常见知识图谱存储方法</strong></p><p><strong>4. 原生图数据库存储原理</strong></p><hr><p>典型的知识存储引擎分为基于关系数据库的存储、面向RDF的三元组数据库和基于原生图的存储。</p><p><strong>知识图谱数据模型</strong>——RDF图</p><p><strong>知识图谱查询语言</strong></p><p>RDF图上的查询语言SPARQL，属性图上的常用的查询语言Cypher和Gremlin</p><p><strong>SPARQL 1.1:</strong></p><p>W3C制定的RDF图数据标准查询语言；</p><p>借鉴了SQL，属于声明式查询语言；</p><p>设计了三元组模式、子图模式、属性路径等多种查询机制</p><p><strong>SPARQL查询实例</strong></p><blockquote><p>考试重点，每年考大题</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524487.png" alt="image-20211019102100365"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524488.png" alt="image-20211019102151434"></p><pre><code>SELECT ?p,WHERE {    ?p ex:participate ?q.    ?q ex:项目 ex：&quot;图数据库&quot;}</code></pre><p>查询参加“图数据库”项目的所有程序员。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524489.png" alt="image-20211019103442287"></p><p>label改成项目。</p><pre><code>SELECT ?prWHERE {    ?p ex:participate ex:triple.    ?p ex:age ?age.    FILTER(?age&lt;35).    ?p ex:participate ?pr.    FILTER(?pr != ex:ex:triple)}</code></pre><hr><p><strong>Cypher</strong></p><p>Cypher语法手册：</p><p><strong><a href="https://neo4j.com/docs/cyphermanual/current/" target="_blank" rel="noopener">https://neo4j.com/docs/cyphermanual/current/</a></strong></p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524490.png" alt="image-20211019104457650"><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524491.png" alt="image-20211019110155198"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524492.png" alt="image-20211019110251833"></p><pre><code>MATCH (4:程序员)-[r:参加]-&gt;(pr:项目)RETURN pr.name</code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524493.png" alt="image-20211019111048044"></p><p>基于关系数据库的存储方案是目前知识图谱采用的一种主要的存储方法。</p><hr><p><strong>主要存储结构</strong></p><p><strong>三元组表</strong>（主，谓，宾）</p><p>缺点<strong>：</strong>当三元组规模较大时<strong>，</strong>多个自连接操作会使SQL查询性能低下。</p><p><strong>水平表</strong></p><p>优点：查询大大简化，不用进行表连接操作。</p><p>缺点：列太多，可能超出上限，空值过多影响表的存储、索引和查询性能。</p><p><strong>属性表</strong></p><p><strong>优点：</strong>解决了三元组表自连接的问题和水平表列数过多的问题，缓解空值问题。</p><p><strong>缺点：</strong>对于规模大的图谱数据，主语的类别多，需要建立成千上万个表，也会超出数据库的限制。对于复杂的查询，仍然要迚行多表连接操作，影响效率，也存在空值问题。</p><p><strong>垂直划分</strong></p><p><strong>优点：</strong>谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；能够使用归幵排序连接快速执行丌同谓语表的链接查询操作。</p><p><strong>缺点：</strong>大规模图谱，表的数目超过几千个，增加数据开销，越是复杂的查询操作，执行的表连接操作越多，数据更新维护代价大，更新一个主语涉及多张表时，增加I/O开销。</p><p><strong>六重索引</strong></p><p><strong>优点：</strong>空间换时间，避免了单表的自连接</p><p><strong>缺点：</strong>花费6倍的存储空间，索引维护代价和数据更新代价，随着图谱规模增大，愈加突出。当图谱查询复杂时，产生大量的连接索引表查询，自连接不可避免。</p><p><strong>DB2RDF</strong></p><p><strong>DB2RDF的关键：</strong>谓语到列的映射，转化为图着色问题，将一个主语上出现的不同谓语称为共现谓语，目标是让共现谓语着上不同的色（映射到丌同的列），非共现谓语可以着上相同的色（映射到同一列）。利用着色冲突图解决。</p><p>DB2RDF方案由4张表组成，即DPH（主谓宾），RPH（宾谓主），DS和RS表（多值lid:1，多谓语多主语）。</p><hr><p><strong>原生图数据库存储原理</strong></p><p>免索引邻接，neo4j</p><p>文件存储结构</p><p>属性数据的存储处理</p><p>索引，一种是对节点或边属性数据索引，一种是对图结构的索引</p><hr><p><strong>总结</strong></p><p>典型的知识存储引擎分为基于关系数据库的存储、面向RDF的三元组数据库和基于原生图的存储</p><p>属性图是目前被图数据库业界采纳最广的一种图数据模型。</p><p>RDF三元组数据库的查询语言SPARQL和属性图查询语言CYPHER或GREMLIN.</p><p>基于关系型数据库的知识图谱存储：三元组表、水平表、属性表、垂直划分、六重索引、DB2RDF</p><p>图数据库存储原理：采⽤免索引邻接（Index-free adjacency）构建的图数据库引擎。</p><hr><blockquote><p>今天有个上海同学被隔离了，在家上网课</p></blockquote><h3 id="第八讲：知识抽取"><a href="#第八讲：知识抽取" class="headerlink" title="第八讲：知识抽取"></a>第八讲：知识抽取</h3><p><strong>内容概览</strong></p><p>一、知识获取与知识图谱获取</p><p>二、面向结构化的知识抽取</p><p>三、面向非结构化的知识抽取：实体抽取</p><p>四、面向非结构化的知识抽取：关系抽取</p><hr><h4 id="知识获取与知识图谱获取"><a href="#知识获取与知识图谱获取" class="headerlink" title="知识获取与知识图谱获取"></a>知识获取与知识图谱获取</h4><p>知识图谱工程</p><p>自动内容抽取(Automatic Content Extraction, ACE)</p><p>TAC Knowledge Base Population(KBP，知识库填充)对ACE定义的任务进一步修订</p><h4 id="面向结构化的知识抽取"><a href="#面向结构化的知识抽取" class="headerlink" title="面向结构化的知识抽取"></a>面向结构化的知识抽取</h4><p>直接映射方法定义了一个从关系数据库到 RDF 图数据的简单转换</p><p>R2RML映射语言是一种用亍表示从关系数据库到RDF数据集的自定义映射的语言。</p><h4 id="实体抽取"><a href="#实体抽取" class="headerlink" title="实体抽取"></a>实体抽取</h4><p>方法：基于模板与规则，基于统计模型，基于深度学习</p><p>正则表达式</p><p>序列标注</p><p>HMM隐马尔可夫模型</p><p>CRF条件随机场</p><h4 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a>关系抽取</h4><p>流水线方法，联合抽取方法</p><h3 id="第九讲：知识图谱推理"><a href="#第九讲：知识图谱推理" class="headerlink" title="第九讲：知识图谱推理"></a>第九讲：知识图谱推理</h3><p>什么是推理？</p><p><strong>演绎推理</strong></p><p>肯定前件假言推理</p><p>否定后件假言推理</p><p>假言三段论</p><p>演绎三段论</p><p><strong>归纳推理</strong></p><p>归纳泛化</p><p>统计推理</p><p><strong>溯因推理</strong></p><p><strong>类比推理</strong></p><p>其他推理，不确定性推理，单调推理，非单调推理，模糊推理，精确推理。</p><p><strong>知识图谱推理</strong></p><p>基于演绎，基于归纳</p><p>基于符号的推理——本体推理</p><p><strong>owl语言</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524495.png" alt="image-20211109104454979"></p><blockquote><p>考试考概念组成，这上面四个会考</p></blockquote><p>OWL<strong>本体推理</strong></p><p> 可满足性 (satisfiability)</p><p> 分类 (classification)</p><p> 实例化 (materialization)</p><p><strong>典型推理算法——Tableaux算法</strong></p><p>检查某一本体概念的可满足性，以及实例检测</p><p>通过一系列规则构建Abox，以检测可满足性，或者检测某一实例是否存在于某概念</p><blockquote><p>考原理，这章考概念推理</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524496.png" alt="image-20211109112155729"></p><blockquote><p>考一下规则</p></blockquote><p>相关工具</p><p><strong>基于逻辑编程改写的方法</strong></p><p>引入规则推理</p><p>Datalog语言</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524497.png" alt="image-20211112101340827"></p><p>事实是特殊的规则</p><p>推理举例</p><p><strong>基于产生式规则方法</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524498.png" alt="image-20211112102601781"></p><p>LHS条件集合，RHS动作集合</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524499.png" alt="image-20211112103104882"></p><p>产生式系统=事实集+产生式集合+推理引擎</p><p>RETE算法</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524500.png" alt="image-20211112104456833"></p><hr><h3 id="第十讲：项目报告"><a href="#第十讲：项目报告" class="headerlink" title="第十讲：项目报告"></a>第十讲：项目报告</h3><p>另见项目</p><hr><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验一、二RDF（RDFS）应用"><a href="#实验一、二RDF（RDFS）应用" class="headerlink" title="实验一、二RDF（RDFS）应用"></a>实验一、二<strong>RDF（RDFS）应用</strong></h3><blockquote><p><strong>RDF(资源描述框架)</strong>是描述网络资源的 W3C 标准, ，比如网页的标题、作者、修改日期、内容以及版权信息等。</p></blockquote><blockquote><ul><li><p>RDF 使用 Web 标识符来标识事物，并通过属性和属性值来描述资源。</p><p>对资源、属性和属性值的解释：</p><ul><li><em>资源</em>是可拥有 URI 的任何事物，比如 “<a href="https://www.runoob.com//rdf&quot;" target="_blank" rel="noopener">https://www.runoob.com//rdf&quot;</a></li><li><em>属性</em>是拥有名称的资源，比如 “author” 或 “homepage”</li><li><em>属性值</em>是某个属性的值，比如 “David” 或 “<a href="https://www.runoob.com/&quot;" target="_blank" rel="noopener">https://www.runoob.com/&quot;</a> （请注意一个属性值可以是另外一个资源）</li></ul></li></ul></blockquote><hr><p>Turtle syntax，海龟句法？</p><p>Turtle, the Terse RDF Triple Language, a concrete syntax for RDF</p><blockquote><p><strong>Terse RDF Triple Language</strong> (<strong>Turtle</strong>) is a <a href="https://en.wikipedia.org/wiki/Syntax_(programming_languages)" target="_blank" rel="noopener">syntax</a> and <a href="https://en.wikipedia.org/wiki/File_format" target="_blank" rel="noopener">file format</a> for expressing data in the <a href="https://en.wikipedia.org/wiki/Resource_Description_Framework" target="_blank" rel="noopener">Resource Description Framework</a> (RDF) data model. Turtle syntax is similar to that of <a href="https://en.wikipedia.org/wiki/SPARQL" target="_blank" rel="noopener">SPARQL</a>, an <a href="https://en.wikipedia.org/wiki/RDF_query_language" target="_blank" rel="noopener">RDF query language</a>. It is a common data format for storing RDF data, along with <a href="https://en.wikipedia.org/wiki/N-Triples" target="_blank" rel="noopener">N-Triples</a>, <a href="https://en.wikipedia.org/wiki/JSON-LD" target="_blank" rel="noopener">JSON-LD</a> and <a href="https://en.wikipedia.org/wiki/RDF/XML" target="_blank" rel="noopener">RDF/XML</a>.</p><p>——Wikipedia维基百科</p></blockquote><p>RDF represents information using <a href="https://en.wikipedia.org/wiki/Semantic_triple" target="_blank" rel="noopener">semantic triples</a>, which comprise a subject, predicate, and object. Each item in the triple is expressed as a Web <a href="https://en.wikipedia.org/wiki/URI" target="_blank" rel="noopener">URI</a>. Turtle provides a way to group three URIs to make a triple, and provides ways to abbreviate such information, for example by factoring out common portions of URIs. For example, information about <a href="https://en.wikipedia.org/wiki/Huckleberry_Finn" target="_blank" rel="noopener">Huckleberry Finn</a> could be expressed as:</p><pre class="line-numbers language-xml"><code class="language-xml">&lt;http://example.org/person/Mark_Twain>   &lt;http://example.org/relation/author>   &lt;http://example.org/books/Huckleberry_Finn> .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p><strong>ex1</strong></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>RDF</span><span class="token attr-name"><span class="token namespace">xmlns:</span>rdf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/1999/02/22-rdf-syntax-ns#<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>rdfs</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/01/rdf-schema#<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>iswww</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>Description</span> <span class="token attr-name"><span class="token namespace">rdf:</span>about</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#germany<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>type</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#country<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>Description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>Description</span> <span class="token attr-name"><span class="token namespace">rdf:</span>about</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#capital_of<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>type</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/1999/02/22-rdf-syntax-ns#Property<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdfs:</span>domain</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#city<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdfs:</span>range</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#country<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>Description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>Description</span> <span class="token attr-name"><span class="token namespace">rdf:</span>about</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#country<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>type</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/01/rdf-schema#Class<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdfs:</span>label</span> <span class="token attr-name"><span class="token namespace">xml:</span>lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>de<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Land<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdfs:</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>Description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>Description</span> <span class="token attr-name"><span class="token namespace">rdf:</span>about</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#berlin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdfs:</span>label</span> <span class="token attr-name"><span class="token namespace">xml:</span>lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Berlin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdfs:</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>type</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#city<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">iswww:</span>capital_of</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#germany<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>Description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>Description</span> <span class="token attr-name"><span class="token namespace">rdf:</span>about</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://sw.edu/#city<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdf:</span>type</span> <span class="token attr-name"><span class="token namespace">rdf:</span>resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/01/rdf-schema#Class<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">rdfs:</span>label</span> <span class="token attr-name"><span class="token namespace">xml:</span>lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>de<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Stadt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdfs:</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>Description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">rdf:</span>RDF</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考资料</strong></p><p><a href="https://www.runoob.com/rdf/rdf-tutorial.html" target="_blank" rel="noopener">RDF菜鸟教程</a></p><p><a href="http://www.w3.org/RDF/Validator/" target="_blank" rel="noopener">W3C 的 RDF 验证服务</a></p><p><a href="https://zhuanlan.zhihu.com/p/44381615" target="_blank" rel="noopener">RDF1.1 Turtle 中文翻译</a>  - Pelhans的文章 - 知乎 </p><h3 id="实验三：本体建模工具Protege使用及领域本体构建"><a href="#实验三：本体建模工具Protege使用及领域本体构建" class="headerlink" title="实验三：本体建模工具Protege使用及领域本体构建"></a><strong>实验三：</strong>本体建模工具Protege使用及领域本体构建</h3><h3 id="实验四：基亍描述逻辑的知识建模"><a href="#实验四：基亍描述逻辑的知识建模" class="headerlink" title="实验四：基亍描述逻辑的知识建模"></a><strong>实验四：</strong>基亍描述逻辑的知识建模</h3><h3 id="实验五：玩转第一个知识图谱"><a href="#实验五：玩转第一个知识图谱" class="headerlink" title="实验五：玩转第一个知识图谱"></a><strong>实验五：</strong>玩转第一个知识图谱</h3><p>neo4j安装</p><pre><code>CALL n10s.rdf.import.fetch(&quot;https://github.com/neo4j-labs/neosemantics/raw/3.5/docs/rdf/nsmntx.ttl&quot;,&quot;Turtle&quot;);</code></pre><h3 id="实验七、八、九：知识图谱应用课程项目"><a href="#实验七、八、九：知识图谱应用课程项目" class="headerlink" title="实验七、八、九：知识图谱应用课程项目"></a><strong>实验七、八、九：</strong>知识图谱应用课程项目</h3><h3 id="实验十：项目验收与报告"><a href="#实验十：项目验收与报告" class="headerlink" title="实验十：项目验收与报告"></a><strong>实验十：</strong>项目验收与报告</h3><hr><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><h3 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h3><p>选择题15，单选多选都有，一题一分</p><p>填空题20，每空一分</p><p>判断题10</p><p><strong>八个大题</strong>？</p><p>1、<strong>简答题</strong>，给一个模型写一个知识图谱查询语言</p><p>2、<strong>画图RDF</strong>，物化三元组</p><p>3、<strong>SPARQ语言</strong>，重点10分</p><p>4、<strong>DL描述逻辑</strong>，给一些句子描述，看ppt例子，写个五六个，一个两分</p><p>5、<strong>RDF填空</strong>，基于xml。</p><p>6、<strong>trutle语法</strong>（OWL），作业</p><p>7、大题，<strong>本体建模</strong>，画一个本体模型？？？</p><h3 id="考试范围"><a href="#考试范围" class="headerlink" title="考试范围"></a>考试范围</h3><p><strong>每年必考</strong></p><p><strong>语义网络（semantic network）</strong>是一种以网络格式表达人类知识构造的形式。是<a href="https://baike.baidu.com/item/人工智能/9180" target="_blank" rel="noopener">人工智能</a>程序运用的表示方式之一。由<a href="https://baike.baidu.com/item/奎林/2555196" target="_blank" rel="noopener">奎林</a>(J. R. Quillian)于1968年提出。</p><p>互联网的创始人Tim Berners-Lee在2000年提出了语义Web的概念和体系结构。</p><p>本体发展</p><p>新ppt</p><p>本体定义，关键词</p><p>本体分类体系</p><p>RDF组成，两种语法，Literals特别是</p><p>Turtle和xml语法，重点</p><p>空节点，看下作业吧</p><p>RDFs类和实例的表示，9101112，例子</p><p>属性约束</p><p>物化三元组，图</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524501.png" alt="image-20211112110326275"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524502.png" alt="image-20211112110304943"></p><p>turtle</p><p>语义基本特性</p><p>模型论语义，重点</p><p>RDF-s的模型论语义，简单解释，看得懂</p><p>三元组的解释62以后不用看</p><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a><strong>第三章</strong></h4><p>本体论基本概念</p><p>OWL基本概念</p><p>三个子语言，基本特性，表达能力，推理性由强到弱</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524503.png" alt="image-20211112110723691"></p><p>判断</p><p>语言大纲填空，一眼</p><p>OWL基本元素，就是填空，没有大段，例子稍微看看，匿名类填空</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524504.png" alt="image-20211122152435898"></p><p>属性特性，重点</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524505.png" alt="image-20211122154554352"></p><p>本体映射的词汇</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524506.png" alt="image-20211122154653155"></p><h4 id="第四章描述逻辑"><a href="#第四章描述逻辑" class="headerlink" title="第四章描述逻辑"></a><strong>第四章</strong>描述逻辑</h4><p>基本概念</p><p>所有例子</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524507.png" alt="image-20211112111059039"></p><p>每个字母特性。SROIQ（D）</p><p>都是重点。</p><p>什么是可判定性。</p><p>owl的两种语义。</p><p>直接语义。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524508.png" alt="image-20211122164141049"></p><p>rdf的语义？什么是解释什么是模型。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524509.png" alt="image-20211122164236057"></p><p>一个解释就是一个公理集合的模型，如果所有的公理在解释下成立。</p><p>通过谓词逻辑不是重点。</p><p>不一致性和满足问题是重点</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524510.png" alt="image-20211122164508041"></p><p>附录owl的turtle，题目</p><h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a><strong>第五章</strong></h4><p>什么是知识图谱</p><p>应用领域</p><p>知识图谱涉及：知识表示、关系抽取、图数据存储、数据融合、推理补全、语义搜索、知识问答、自动推理、知识驱动等。</p><p>技术知道就可以</p><p><strong>知识图谱的技术流程</strong></p><p>数据-&gt;知识表示-&gt;知识获取-&gt;知识融合-&gt;知识推理-&gt;知识检索-&gt;知识分析-&gt;应用</p><p>主要数据模型，重点</p><p><strong>RDF图和属性图</strong></p><p>知识图谱存储方案</p><p><strong>基于关系的存储方案。包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。</strong></p><p><strong>面向RDF的三元组库。</strong></p><p><strong>原生图数据库。</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524511.png" alt="image-20211112111645447"></p><p>什么是知识表示</p><p>知识表示是现实世界的可计算模型？</p><p>知识表示（KR）就是⽤易亍计算机处理的方式来描述⼈脑的知识。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524512.png" alt="image-20211112111701244"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524513.png" alt="image-20211112111727331"></p><p>前五</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524514.png" alt="image-20211112111742851"></p><p>DL是可判定子集，霍恩子句要知道</p><p><strong>霍恩子句是文字的析取，是最多带一个肯定文字的子句（没有否定符号的文字）。</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524515.png" alt="image-20211122170349175"></p><p>框架系统优缺点，有槽</p><p><strong>SPARQL语法</strong>，所有例子</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524516.png" alt="image-20211122171343490"></p><p>稍微改</p><p>向量表示基本概念one-hot编码词袋模型词向量</p><h4 id="第六章知识存储"><a href="#第六章知识存储" class="headerlink" title="第六章知识存储"></a><strong>第六章知识存储</strong></h4><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524517.png" alt="image-20211112111958933"></p><p>典型知识存储引擎，这句话重点</p><p>更要搞懂，存储原理采用<strong>免索引邻接</strong></p><p>Cypher看情况，稍微看看也可以，以前没考过，<strong>不考</strong></p><p>基于关系型数据库存储方案，名字，优缺点更好</p><p>三元组表，水平表，属性表，垂直划分，六重索引，DB2RDF</p><p>原生图不考</p><h4 id="第七章知识抽取"><a href="#第七章知识抽取" class="headerlink" title="第七章知识抽取"></a><strong>第七章知识抽取</strong></h4><p>基本概念</p><p><strong>知识抽取是实现自动化构建大规模知识图谱的重要技术</strong></p><p>面向结构化的知识抽取，<strong>映射方法</strong></p><p>直接映射方法定义了一个从关系数据库到 RDF 图数据的简单转换</p><p>R2RML映射语言是一种用于表示从关系数据库到RDF数据集的自定义映射的语言。</p><p><strong>实体识别常用方法名字</strong></p><p>方法：基于模板与规则，基于统计模型，基于深度学习</p><p><strong>关系抽取方法</strong></p><p>基亍人工模板基亍监督学习(传统监督学习、深度学习)、基亍弱监督学习(迁秱学习、Bootstrapping)和无监督学习斱法。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524518.png" alt="image-20211112112333696"></p><h4 id="第八章知识推理"><a href="#第八章知识推理" class="headerlink" title="第八章知识推理"></a><strong>第八章知识推理</strong></h4><p>考标题，有哪些大类</p><p>演绎推理方法有哪些，判断属于哪一类里？</p><p><strong>演绎推理</strong></p><p>肯定前件假言推理</p><p>否定后件假言推理</p><p>假言三段论</p><p>演绎三段论</p><p><strong>归纳推理</strong></p><p>归纳泛化</p><p>统计推理</p><p><strong>溯因推理</strong></p><p><strong>类比推理</strong></p><p>其他推理，不确定性推理，单调推理，非单调推理，模糊推理，精确推理。</p><p><strong>知识图谱推理</strong></p><p>基于演绎，基于归纳</p><p>基于符号的推理——本体推理</p><p>推理任务</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524519.png" alt="image-20211112112555255"></p><p>推理方法</p><p>本体推理，可满足性，分类和实例化</p><p>表算法，检查某一本体概念的可满足性以及实例检测</p><p>构建Abox检测可满足性，规则如下</p><p>datalog和 产生式，稍微记一记</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281524520.png" alt="image-20211112112642533"></p><p>每个总结ppt全都是重点。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://www.cnblogs.com/aoru45/p/11788583.html" target="_blank" rel="noopener">学长的期末复习笔记</a></p><p>RDF 1.1 Turtle 中文翻译 - Pelhans的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/44381615" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44381615</a></p><blockquote><p>有大佬翻译文档了，tql</p></blockquote><p><a href="https://www.programmersought.com/article/98146569851/" target="_blank" rel="noopener">Experiment Answers</a></p><blockquote><p>仅供参考，很多问题，虽然老师给的部分参考答案感觉也有问题。</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>第一周考完后玩了两天，然后背了一天半的ppt，考完后对答案心态崩了，概念挖空两个一个语义网基于实体，一个基于对象都看过，还是概念不够熟悉，脑子就是转不过来，填空太难了。</p><p>稍微记了一下索引，结果就考了个图结构索引。推理选择填空都考了，居然考一个推理用于什么，翻了半天ppt才在一个角落看到，而且也没标，这种题就是避免有人满分吧，谁能记得这么细那也太可怕了。考了个ppt上的表算法原题规则，我当时想把规则都背下来也太细了，然后就一定会考原题，结果-写成+了。</p><p>最后还有15分钟基本上人都走完了，就开始催交卷，其实任何考试都还是应该坐到最后一刻，这是态度问题，哪怕就是多看看改一下，哪怕最后错了可能也不会那么揪心了。</p><p>大题都能拿分，全都是很简单的看过ppt做过作业就都会，对于我们完全没有拉开差距的可能，所以难的就是小题。选择第一题问的就是语义网络创始人是谁，当时上课就说了每年必考。而且选择还是不定项选择，很坑。有一个sparql查询朋友的朋友不确定是不是用*/，于是开始瞎写，感觉就不是很好，其实这种不确定就是不会，与其多想不如放宽心，告诉自己不会就不会，照着简单写就是了。</p><p>总而言之，这门课就这样结束了，基本上考前背一背ppt，就看谁背的久抓重点抓得准，整个课程体验还是不错的，除了后面几节课全是概念和方法有点无聊，我感觉自己还是很认真的学了，虽然现在好像也不知道要怎么把这些学到的东西发挥出很大的作用，但也已经算满意了。通过课程项目也大概知道如何做一个带界面的知识图谱问答系统，这是最有意思的部分了，也算了解了知识图谱在实际中的使用流程，而且自学的docker也多少派上了点用处，虽然搞了大半天也没玩明白，只能换了个项目从头开始。</p><p>可惜的就是这门课涉及到自然语言处理的部分其实不多，主要是应用部分偏多。</p><p>这次考试体会最深的还是王道OS考研书上的一段话，也是一些学习计算机科学知识的建议。学习科学知识时，很多同学会陷入一个误区，即只注重对定理、公式的应用，而忽视对基础概念的理解。这是我们从小到大为了应付考试而培养出的一个毛病，因为熟练应用公式和定理对考试有立竿见影的效果。公式定理的应用固然重要，但基础概念的理解能让我们透彻地了解一门学科，更利于我们产生兴趣，培养创造性思维。</p><p>在我看来，考试也好，上课也好，都是帮助我们学会上面这个道理，并且通过最后的成绩来奖励那些能够学会一些道理并且始终贯彻下去的人。生活也是如此。</p><p>后记完。</p><h1 id="语义网与知识图谱课程项目"><a href="#语义网与知识图谱课程项目" class="headerlink" title="语义网与知识图谱课程项目"></a>语义网与知识图谱课程项目</h1><p><a href="https://github.com/xiaoliang8006/Movie-QA-System" target="_blank" rel="noopener">基于知识图谱的电影问答系统</a></p><hr><p>此项目旨在构建一个关于电影的知识图谱问答系统。目前知识库本身的内容并不全面，但是麻雀虽小，五脏俱全，该项目对多种类型的问题形式都能得到正确的相应结果。以“周星驰”为例，本系统能够回答周星驰的个人简介，参演过的电影，参演过的电影类型，参演某一类型的电影都有什么。还能查询某个电影的信息，如上映时间，评分，类型，演员列表等等….</p><hr><p>提供的功能有：</p><ul><li>中文分词</li><li>词性标注</li><li>命名实体识别</li><li>知识图谱关系抽取</li><li>关键词提取</li><li>等等….</li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#搭建环境">搭建环境</a></li><li><a href="#使用方式">使用方式</a></li><li><a href="#思路">思路</a></li><li><a href="#代码说明">代码说明</a></li><li><a href="#评价">评价</a></li><li><a href="#附录">附录</a></li></ul><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p><strong>python3.6 + jdk1.8 + neo4j-3.4.13</strong></p><p>注意： neo4j-3.4.13要求java版本必须在jdk8以上</p><p>网页显示采用flask-0.12.2框架， 和neo4j数据库连接时用的是py2neo-3.0, 之前用py2neo-4.0总是容易出错。</p><hr><p>开了个虚拟环境QAmovie，但是找不到更老版本的py2neo-3.0了，最早的都只有4.0，更新很多版本了，neo4j版本也用最新的试试</p><pre class="line-numbers language-bash"><code class="language-bash">查看所有虚拟环境： conda info -e 启动虚拟环境：activate 环境名创建：conda create -n 环境名 ，如，conda create -n rcnn python<span class="token operator">=</span>3.6删除：conda remove -n rcnn --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><del>环境配置</del></p><blockquote><p>失败项目不用看了，浪费一天时间搞docker和环境配置</p></blockquote><p>docker运行出错，放了一周</p><p><a href="https://www.cnblogs.com/harrymore/p/15465053.html" target="_blank" rel="noopener">解决python3安装库报use_2to3 is invalid的错误</a></p><p>降低refo版本后成功</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281529803.png" alt="image-20211102103918754"></p><p>docker run起来之后打开localhost发现好像少了点什么，难道是因为refo版本减低了？</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/img/202111281529690.png" alt="image-20211102105435376"></p><p>更改DockerFile的pip改回pip3.6再试一次，如果不行就直接在requirement里加match</p><p>尝试多次后无果，match会不会是re库啊，看上去很像，但不知道要怎么改代码。再将refo版本降0.1试试 。不行就用DockerFile来pip安装match。或者我把python版本升到3.7.</p><p>每次build docker都要六七分钟，太久了。</p><pre><code>docker build -t kbqa:V0.1 .docker run -p 80:80 --name test -d kbqa:V0.1docker exec -it 243c32535da7 /bin/bash</code></pre><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p> 先安装依赖:</p><pre><code>pip install -r requirements.txt</code></pre><p>注意依赖包版本最好和requirements.txt一致或者不要相差太大，不然容易出错。然后运行服务器:</p><pre><code>python server.py</code></pre><p>最后打开浏览器进入<code>http://127.0.0.1:5000</code>即可进行问答。</p><pre><code>http://127.0.0.1:5000/</code></pre><p>目前本系统可以回答类似如下类型的问题(以李连杰和警察故事为例)：</p><pre><code>1.喜剧之王的评分是多少2.喜剧之王的上映时间3.喜剧之王是什么类型的电影4.喜剧之王的主要情节5.喜剧之王中的演员都有谁6.周星驰的简介7.周星驰演过的动作电影有哪些8.周星驰演过哪些电影9.周星驰演的电影评分在7以上的都有哪些10.周星驰演的电影评分低于7的都有哪些11.周星驰演过的电影类型有哪些/周星驰演过哪些风格的电影12.李连杰和章子怡一起演过哪些电影13.周星驰演过多少部电影14.周星驰生日是什么时候</code></pre><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h4 id="data文件夹"><a href="#data文件夹" class="headerlink" title="data文件夹"></a>data文件夹</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;首先是数据的准备，利用爬虫从维基和豆瓣上爬取电影数据及演员数据，这里我直接把数据预处理的结果放入了data文件夹</p><h4 id="questions文件夹"><a href="#questions文件夹" class="headerlink" title="questions文件夹"></a>questions文件夹</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;放的是关于问题分类的训练数据</p><h4 id="data2neo4j-py"><a href="#data2neo4j-py" class="headerlink" title="data2neo4j.py"></a>data2neo4j.py</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;将data文件夹下csv文件导入neo4j数据库。注意这里我放上了我的服务器，可以直接用。你也可以用data2neo4j.py将数据导入到自己的本地服务器，并在question_template.py修改地址即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;import文件夹是neo4j默认的数据导入文件夹，所以首先要将data文件夹下所有csv文件拷贝到neo4j数据库的根目录import文件夹下，没有则先创建import文件夹，然后运行此程序。</p><h4 id="question-classification-py"><a href="#question-classification-py" class="headerlink" title="question_classification.py"></a>question_classification.py</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对问题进行分类</p><h4 id="question-template-py"><a href="#question-template-py" class="headerlink" title="question_template.py"></a>question_template.py</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;连接数据库，生成查询语句，返回结果</p><h4 id="process-question-py"><a href="#process-question-py" class="headerlink" title="process_question.py"></a>process_question.py</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;分类并回答问题</p><h4 id="static文件夹"><a href="#static文件夹" class="headerlink" title="static文件夹"></a>static文件夹</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;放的是关于前端显示的静态文件</p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>随机生成了30个问题，发现问题分类的准确率在90%左右，可能是因为训练样本较少的缘故。然后问题回答的准确取决于数据库中有无数据，如果分类正确而且数据库中有相关数据，基本都能正常返回答案。后续工作需要增加问题分类的训练样本和补充数据库资源….</p><h2 id="报错问题及解决"><a href="#报错问题及解决" class="headerlink" title="报错问题及解决"></a>报错问题及解决</h2><p>neo4j.exceptions.ServiceUnavailable: Cannot to connect to Bolt service on IPv4Address((‘127.0.0.1’, 7474)) (looks like HTTP)</p><pre><code>neo4jAddress = &#39;&#39;&#39;bolt://127.0.0.1:7474&#39;&#39;&#39;   #本地地址，应该是7687    neo4jUser = &quot;neo4j&quot;                  #用户名    neo4jPassword = &quot;123456&quot;            #密码</code></pre><h2 id="资料-1"><a href="#资料-1" class="headerlink" title="资料"></a>资料</h2><h3 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a>github项目</h3><p><a href="https://github.com/SimmerChan/KG-demo-for-movie" target="_blank" rel="noopener">从无到有构建一个电影知识图谱，开发一个简易的KBQA程序</a></p><p><a href="https://zhuanlan.zhihu.com/knowledgegraph" target="_blank" rel="noopener">知乎配套</a></p><hr><p><a href="https://github.com/lemonhu/stock-knowledge-graph" target="_blank" rel="noopener">利用网络上公开的数据构建一个小型的证券知识图谱</a></p><p>比较简单</p><p><a href="https://github.com/liuhuanyong/QASystemOnMedicalKG" target="_blank" rel="noopener">以疾病为中心的一定规模医药领域知识图谱，并以该知识图谱完成自动问答与分析服务</a></p><p>数据量大</p><p><a href="https://github.com/jm199504/Financial-Knowledge-Graphs" target="_blank" rel="noopener">小型金融知识图谱构建流程</a></p><p>有算法</p><hr><p><a href="https://github.com/xiaoliang8006/Movie-QA-System" target="_blank" rel="noopener">基于知识图谱的电影问答系统</a></p><p>搞不定，换个项目重开。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 语义网 </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11月复盘</title>
      <link href="/2021/11/28/2021-11/"/>
      <url>/2021/11/28/2021-11/</url>
      
        <content type="html"><![CDATA[<h1 id="11月复盘（11-28）"><a href="#11月复盘（11-28）" class="headerlink" title="11月复盘（11.28）"></a>11月复盘（11.28）</h1><h2 id="本月关键词：救赎"><a href="#本月关键词：救赎" class="headerlink" title="本月关键词：救赎"></a>本月关键词：救赎</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p>Some birds aren’t mean to be caged, their feathers are just too bright. And when they fly away, the part of you that knows it was a sin to lock them up does rejoice. Still, the place you live in is that much more drab and empty that they are gone. I guess I just miss you my friend.</p><p><strong>有些鸟终究还是关不住的，他们的羽翼闪耀着自由的光芒。</strong></p><p>——《肖申克的救赎》  </p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p>大三秋季期末考试</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>无，健康状态欠佳，考试周还感冒了，好在没发烧，多喝热水就过去了，有点流鼻涕，下个月要去锻炼锻炼才能恢复好。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p>物联网课程报告</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>准备撤了，从年初到年末也没多少收入，这波疫情来之前要快跑。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>社团又认识了一些学弟学妹，但是老学长表示完全融入不进年轻人之中。看样子大二一年社交能力没有任何长进。已经二十岁了还被人说看起来年龄小，实在受不了了，直接改头换面。打理一下发型，感觉是有点不一样了，但也就一点而已。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>计划是美好的，现实是骨感的，还是希望记录时间，每天早起养成习惯，不要再失眠了。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>无</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><h3 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>选课基本上没有多少纠结，想着反正都是自学而已，而且暑假早就提前刷过一遍王道的网课了，所以就直接选教师编号靠前的老师，选了两年课了多少也有点经验，同样的课程教师编号在后的老师一般会更年轻一些，果然另外一个班的老师是第一次上操作系统。</p><p>lfy老师上课和一般老师不一样，不会照着课本讲（“课本写的很垃圾”），会讲很多上课用的教材里没有的东西，可以配套《现代操作系统》和《CSAPP》使用，这样或许听他上课讲的一些东西理解起来会更好一些，一本好的课本对于课程学习来说还是很重要的，但总的来说还是要自己愿意去多学，不能停留在课堂和课本。</p><p>考试分为面试和考试，考试不提了，会写猴子过桥问题，没写对读写问题，估计是感冒影响到大脑了，果然不能熬夜，还是要好好休息。面试我带着实验的笔记第一个就去了，然后就是跟我聊聊天，可能每次上课坐前面也给老师留下了印象，给老师看了我的博客，看到我书架的照片，然后推荐我去读原版的《人月神话》，上课其实也感受得出来老师也是一个很喜欢阅读的人。</p><p>之后问了问超算MPI和机组学了什么，还有课程感受和建议，就是感觉考研和我们学的内容以及期末要考的差距有点大，然后有的同学可能还不太了解自己的专业，所以没有学习热情。然后老师说知道我是个好学生，就是不知道能不能捞一捞我了。</p><p>有一个很奇怪的现象，那些绩点比较高的同学好像都跑去选另外一个老师了，让我觉得自己好像一个异类一样。不知道图个啥。</p><p>上机实验包括一些很基本的linux相关操作，之前机组都用过了，感觉可以再提高一点难度或者增加一些内容，系统调用和老师写的那些小程序（不超过10行）可以到《CS：APP》上第八章异常处理看一看，有书还是可以看的详细一点，然后这本书上最后也有一个很好的例子，结合了所有我们实验里学到内容，可以实现一下然后再去验收。</p><p>至于考试方面，填空，选择，简答，判断都老要命了，希望能过就好。</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>cch老师，之前那个学期就去蹭过课，这次选课的时候有一堆人都要抢着选的美女老师，强推。</p><p>这门课可以说是很靠谱了，也是暑假提前刷完了王道网课，虽然内容上和考研计网还是有不小的出入，但是从讲课质量上来说，cch老师讲得比王道专门的网课老师还好，而且也很负责。</p><p>有一次上课她说有的同学交作业交的很快，但是连作业名字都不改，就直接把别人的作业交上去了，我还想是谁，结果下课她就找到我告诉我上课说的人就是我，建议我还是自己做一遍熟悉题目。我才反应过来当时作业一发布我就提前把syy的作业交上去了，想等到上完课再自己做一遍，省的万一到时候作业时间截止给忘交了。</p><p>实验部分做的也有点水分，虽然这种报告写与不写完全在自己，但还是自己亲手做一遍，就当是体验其中的实验乐趣。</p><p>考试是真的犯迷糊，过度自信，甚至懒得看作业原题，连夜突击复习了一天加一上午，还是觉得十分愧疚。没想到题目真的这么简单。</p><h4 id="算法设计分析"><a href="#算法设计分析" class="headerlink" title="算法设计分析"></a>算法设计分析</h4><p>yxd老师是好老师，没有平时作业也不会签到，上课会点人回答问题加平时分，我一次都没加，只做了个可视化，希望能过。考试题目就像他说的认真做没问题，仔细一点全都会，就是粗心，或者说在算法上花的时间不到位，错把动态规划当分治，典型概念没有内化理解。这是要花时间的。</p><h4 id="语义网与知识图谱"><a href="#语义网与知识图谱" class="headerlink" title="语义网与知识图谱"></a>语义网与知识图谱</h4><p>4分专选，学习笔记可见博客。</p><p>第一周考完后玩了两天，然后背了一天半的ppt，考完后对答案心态崩了，概念挖空两个一个语义网基于实体，一个基于对象都看过，还是概念不够熟悉，脑子就是转不过来，填空太难了。</p><p>稍微记了一下索引，结果就考了个图结构索引。推理选择填空都考了，居然考一个推理用于什么，翻了半天ppt才在一个角落看到，而且也没标，这种题就是避免有人满分吧，谁能记得这么细那也太可怕了。考了个ppt上的表算法原题规则，我当时想把规则都背下来也太细了，然后就一定会考原题，结果-写成+了。</p><p>最后还有15分钟基本上人都走完了，就开始催交卷，其实任何考试都还是应该坐到最后一刻，这是态度问题，哪怕就是多看看改一下，哪怕最后错了可能也不会那么揪心了。</p><p>大题都能拿分，全都是很简单的看过ppt做过作业就都会，对于我们完全没有拉开差距的可能，所以难的就是小题。选择第一题问的就是语义网络创始人是谁，当时上课就说了每年必考。而且选择还是不定项选择，很坑。有一个sparql查询朋友的朋友不确定是不是用*/，于是开始瞎写，感觉就不是很好，其实这种不确定就是不会，与其多想不如放宽心，告诉自己不会就不会，照着简单写就是了。</p><p>总而言之，这门课就这样结束了，基本上考前背一背ppt，就看谁背的久抓重点抓得准，整个课程体验还是不错的，除了后面几节课全是概念和方法有点无聊，我感觉自己还是很认真的学了，虽然现在好像也不知道要怎么把这些学到的东西发挥出很大的作用，但也已经算满意了。通过课程项目也大概知道如何做一个带界面的知识图谱问答系统，这是最有意思的部分了，也算了解了知识图谱在实际中的使用流程，而且自学的docker也多少派上了点用处，虽然搞了大半天也没玩明白，只能换了个项目从头开始。</p><p>可惜的就是这门课涉及到自然语言处理的部分其实不多，主要是应用部分偏多。</p><p>这次考试体会最深的还是王道OS考研书上的一段话，也是一些学习计算机科学知识的建议。学习科学知识时，很多同学会陷入一个误区，即只注重对定理、公式的应用，而忽视对基础概念的理解。这是我们从小到大为了应付考试而培养出的一个毛病，因为熟练应用公式和定理对考试有立竿见影的效果。公式定理的应用固然重要，但基础概念的理解能让我们透彻地了解一门学科，更利于我们产生兴趣，培养创造性思维。</p><p>在我看来，考试也好，上课也好，都是帮助我们学会上面这个道理，并且通过最后的成绩来奖励那些能够学会一些道理并且始终贯彻下去的人。生活也是如此。</p><h4 id="传感器与物联网"><a href="#传感器与物联网" class="headerlink" title="传感器与物联网"></a>传感器与物联网</h4><p>4分专选</p><p>还是cch老师，也是上了两本书的内容，干货很满，没有想象中的很多硬件知识。</p><p>而且好在不用考试了，不然我真的原地爆炸，选课不宜过多，学习计划上写的不建议超过22分是真的，这学期刚好22分考完整个人直接压力彪到顶。期末读一篇论文写报告做展示，我和lx两个人一篇paper讲了接近一个小时，报告放在博客上了，感觉还是有点意思的。</p><p>可惜没有课本可以看，所以每次上课只要听就好了，PPT没发，不能截图纯手打来不及记笔记的。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>大三冬季学习计划</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 月复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10月复盘</title>
      <link href="/2021/10/31/2021-10/"/>
      <url>/2021/10/31/2021-10/</url>
      
        <content type="html"><![CDATA[<h1 id="10月复盘（10-31）"><a href="#10月复盘（10-31）" class="headerlink" title="10月复盘（10.31）"></a>10月复盘（10.31）</h1><h2 id="本月关键词：休假"><a href="#本月关键词：休假" class="headerlink" title="本月关键词：休假"></a>本月关键词：休假</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>士不可以不弘毅，任重而道远。</strong></p><p>——《礼记》</p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>课程</strong></p><p>算法课心好累，以后尽量不和计科他们那么多人一起卷了。用达芬奇游戏引擎开发了一个棋盘覆盖可视化，后面几个实验更多要求真的整的很无语。还考虑要不要用flutter再做一个什么可视化，但是没有好的想法。算法如果是学习思想，为什么还要搞那么多乱七八糟的东西，说实话有点打击学习兴趣。</p><p>专选课读了一篇SIGMMON21最新的论文，期末要交一篇《商业5G全面观察报告》，本来是计划月末最后一周写完，结果又要拖到最后两周上课的时候写了。希望能够充分利用好上课时间。</p><p>计网和操作系统倒是一边上课一边把王道选择题跟着刷的差不多了。</p><p><strong>其他</strong></p><p>休假状态。</p><p><strong>专业学习</strong></p><p>GNN，DGL比赛，cpu服务器环境配置以及跑模型。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>貌似就去了一两次健身房，天气有点不适，因为体测要跑步还是去跑了跑。最后一周连着七天都没有运动，一来上课有点累，早上起不来，晚上又懒得去操场了，坐在教室或者图书馆自习懒得挪动。等下个月考试考完估计又得胖了。本来是计划这个学期锻炼降低一点体重，结果因为作息不规律和好吃懒做，前面还不容易下降了一两斤，结果全部反弹胖回来了。</p><p>体测拉了五个引体向上，只完成了目标的一半，有点难看。</p><p>1km倒是和去年一样都是3分50没变，感觉还是跑不出全力，但跑完确实很累，缓了老半天。</p><p>大三都没怎么去过球馆打球了，最后一周体育节许昕来学校都没有动力早起去看开幕。Orz</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>小说</strong></p><p>《沧浪之水》</p><p>“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”</p><p>关于中国政治以及官场风云变幻里的个人命运。</p><p>这个月微信读书时间总计超过50小时，每天看电子书的时间接近一个半小时，好像这是一个不怎么多的时间，当如果能用在正当的事情上也能做出不小的成绩来。花了20h看完这本闫真写的《沧浪之水》，剩下的时间都是在看小说。</p><p><strong>娱乐</strong></p><p>b站40h以上，刷了三四部十月新番，看完了三季《文豪野犬》15h，《黑色四叶草》看了两三天，然后就突然对动漫失去兴趣了。看了王一快老师做的Reaction系列视频，《心动的Offer2》，一个关于律所实习的综艺节目，主要是up主和他两个朋友都是从北大毕业然后到红圈所工作很多年的经历，以及他们的经验分享，总计大概十几个小时，边下饭边看，不过看到后面也没兴趣了。</p><p><strong>写作</strong></p><p>有一天路过学校人脸识别门禁突然来个灵感，因为门禁那个人脸识别经常会认错人，虽然基本上都是相差十万八千里，但是或许真的有那么一两次将某个人和另一个长的十分相像的人认错，于是一个悬疑故事就这么开始了，一提到悬疑就会想起每年都有高校大学生自杀的事件发生。但是没时间细思，只好先记一下这个突如其来的想法。</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>不超过100w，就没必要认真琢磨琢磨投资理财了，好好用来打磨技能点。等下个月结束就抽身而退。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>通过qq找今年保研的学长们咨询建议，在图书馆和自习教室基本上都是一个人，线上和人沟通比较多。</p><p>感觉大家平常会聊的话题大多也就是未来的方向之类的。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>更改作息规律，五个睡眠周期7.5h把握不住，调整为11.30必定睡觉，最晚早上6.30起床，那就保证四个睡眠周期，所以每天晚上八点到十一点都可以去自习，但是很遗憾地说效果也就一般般。每天中午都要花费更多时间休息才能恢复。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>无</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>在宿舍环境也太放松了，容易自我放纵，从作息到饮食都会有不良影响，需要主动切换环境，比如每晚固定时间去东区找个空教室自习，经过一周的适应发现有效果，仍需要坚持两周养成习惯。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>复习期末考试</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9月复盘</title>
      <link href="/2021/10/01/2021-9/"/>
      <url>/2021/10/01/2021-9/</url>
      
        <content type="html"><![CDATA[<h1 id="9月复盘（10-1）"><a href="#9月复盘（10-1）" class="headerlink" title="9月复盘（10.1）"></a>9月复盘（10.1）</h1><h2 id="本月关键词：并行"><a href="#本月关键词：并行" class="headerlink" title="本月关键词：并行"></a>本月关键词：并行</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20211001203933.png" alt="约翰霍普金斯"></p><blockquote><p><strong>Veritas vos liberabit.</strong></p><p><strong>知识使人自由！</strong></p><p>——JHU约翰·霍普金斯校训</p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>课程</strong></p><p>两门专业课都很轻松，刷刷题，写写实验报告。一门专选划水，另外一门有点硬，但也还算感兴趣所以体验还不错，实验题很难，每次估计都做不对多少，要之后的课程内容讲到才大概理解要怎么做，但是上课老是慢实验一步，不过看学长写的好像也错的很离谱就是了。算法很顶，关键老提考试和提问加分让我体验很不佳，人太多根本抢不到。课外加分做个棋盘覆盖的可视化，直接上游戏引擎，别的我也不会。一周上课时间其实不长，但是周一周二满课上下来会很累，最多再去跑跑步，完全没精力做其他事情了。等到周三或者周末一般有时间写一写小项目的代码，把双创那个learnmap的nlp项目交接了，之后有需要再完善吧。</p><p><strong>专业学习</strong></p><p>看了《CS：APP》的网络编程和链接两章（英文版没看完），英语不是很吃力，就是花的时间太少了，每天早上起不来，六点半都觉得起晚了有点赶。</p><p>重启TensorFlow和pytorch的学习，使用Keras搭建网络模型训练，在learnmap那个项目里正好也练习一下，因为至今没有可以正式测试的数据，下载了《自私的基因》这本书的txt充当文本数据，以是否为开头句为正负标签，用word2vec求词向量平均表示句子，先用简单的svm去分类判断是否是每段开头，效果不理想，发现句子长度应该是一个很重要的feature，估计是因为句子长短不一，不像文本分类基本上都在一个数量级可以忽略长度这个参数。加进去之后在测试集上效果更好了，不过因为数据太少实在不好评价模型，也不好评价数据划分，在请教老师之后不再考虑使用复杂的方法，用神经网络效果也不一定好，我们的任务场景是一篇不长的演讲稿，因果关系不靠谱，就直接自底向上做关键句的分析简单一点，老师的意思是一句句比较相似度或者聚类，然后生成一个树，然后再向上去合并就可以了。我大概花了一个周末下午加晚上用textrank找关键句，然后以关键句为划分成更多小段，想在小段文本上调用相同的方法去抽取关键句或关键词挂在上一级关键句下作为下一个层次，这样就能够将脑图画出来。这个过程很有意思，在数据结构上有点想太多，实现上有不小干扰，逻辑结构就是树肯定没问题，关键是存储结构，而且还想用分治的思想，给算法实现又带来很多麻烦。所以最后直接手动多实现两层看看结果再说，递归出口什么的都先放一边，最后打算采用网络分级的思想，用1234这种简单的level去表示嵌套关系，省的用什么多叉树，算法里实现起来也不方便，直接跳过这部分，使用dataframe很方便，而且由于情景限制最多叉也不可能超过9，只需要往下层调用里传一个上级level就解决了。感觉起码光是写代码也花了20h吧，虽然写的也不多，肯定不到一千行，也没实现多少底层功能，有轮子都不可能自己造的，就当熟悉了一下python。如果可以每天写点代码也不错。</p><p>搭了个ftp服务器玩，是真玩明白了，总算把腾讯云那个云空间利用起来了，传文件很方便。telnet也自己搞了一下，没几天就被美国一个IP黑登陆了那个测试账号，明文发送账号密码果然不安全，赶紧给关了。</p><p><strong>英语学习</strong></p><p>托福单词过完了，歇一口气吧，接下来好好看论文和专业书。报名12月的六级再冲一次600试试。</p><p><strong>超算比赛</strong></p><p>组队，开了两三次会，学习基本的openmp和mpi并行编程，使用可能还有点小问题，把MPI和openmp几个基本函数都看完了，《IPP》那本后面一些应用例子还没看完。</p><p>从学校要到了服务器硬件支持，后面马上要开始在集群上测试hpl和后续的学习了。</p><p><strong>工作</strong></p><p>导生总算告一段落了，感觉和我们当时社区学院的导生还是差蛮多的。很多东西说不出来，学习需要集中注意力，工作总归是会分散精力和时间的。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>这学期想练引体向上，再不练就毕业了，能拉上5个了，明显能感觉到小突破</p><p>上旬12km，健身房开学才开门，只去了一次</p><p>中旬台风，健身4次，12km，健身不能五点多出门搞到八点还在宿舍洗完澡，效率太低。</p><p>下旬懒了，健身才去2次，跑了5km，有几天确实天气下雨不方便吧，剩下其实就少了那么几天，感觉就很不一样。</p><p>才一个月而且也还是有点随便，没太大变化，但能感觉很有精神，也有动力继续保持下去。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>《科学之路》，这些大佬们的故事一直以来都激励着我前进，让我对这个学科的兴趣更加浓厚。</p><p>“图灵奖”得主、“深度学习三巨头”之一、“卷积神经网络之父”……由于在人工智能领域的突出贡献，Jeffery Hinton被中国计算机科学界和企业界所熟知。</p><p>杨立昆的科学之路，谱写了一段关于勇气的宣言。他为了知识本身求学，而不是文凭，他用自己的经历，证明了通过激烈的考试竞争进入名校不是科学成功的窄门。他广泛阅读，为他科学思维的形成奠定了坚实的理论基础。他特立独行，做自己感兴趣的事情，即便那件事在短时间里不被人看好。在人工神经网络研究的低谷期，他寂寞地坚持，终于取得了举世瞩目的成就。</p><p>人工智能正在颠覆人类社会，未来机器能思考吗？杨立昆的这部著作，讲述正是人工智能在我们面前崛起——这个历史上仅有的时刻发生的故事。真的是让人充满干劲。</p><p>听专业课老师提起上届大佬学长们的去向，有保研去复旦等名校的，有直接出国拿到CMU，纽约大学，加州伯克利等offer的，不由得再想起自己高中时曾有过很幼稚的出国想法，于是又重读了《大学之路》，想起吴军老师曾待过JHU在NLP方面的顶尖水平，不经再次憧憬起一个出国读博的梦想，只是一看每年6w以上美刀的学费就又被打回现实，默默安慰自己要向Jeffery学习，要为了知识本身求学，而不是文凭，更要像他一样用自己的经历去证明自己所相信的事物是不会因为他人看法而改变的。</p><p><strong>电影</strong></p><p>《HP3》把在家没看完的后半部分看完。</p><p>《SpongeBob》1.5h大电影，放松一晚上。</p><p><strong>娱乐</strong></p><p>《龙与少年游》江南的几篇散文又看了一遍，重新勾起了当年年少时的那股冲动。</p><blockquote><p>​    北京是座天圆地方的城市，只有经常站在北京的天空下你才能体会到这一点。</p><p>​    有差不多两年我在上海工作，雇过一位来自北京的副总经理，那位兄弟不远千里南下与我同事，却在一周之后就递交了辞呈。辞职的理由当然有很多，其中一条是说上海让他觉得太压抑了，他带我来到窗口远眺，说你看，我在北京一眼能看到地平线，你走在上海的南京西路上，抬头只看见两侧锯齿般的天际线，和一道笔直的天空。</p><p>​    想想确实如此，我初到北京是十八岁那年，如今车水马龙的海淀区那是还是郊区，尘土飞扬遮天蔽日，但你仰头西望，仍然可见南山幽幽九野浩然，天如锅盖地若棋枰。</p><p>​    上海像个积木之城，给人巴比伦塔的奇绝感，北京城的建筑平摊在大地上，上面笼罩着滚远的天空。</p><p>​    如今北京城里保存着“天圆地方”这个概念的地方已经不多了，日复一日周围的大厦向着天空中生长，仿佛茂密的竹林，似乎总有一天它们会长得跟天空接在一起。CBD区变得越来越像上海了，三里屯也不例外。</p><p>…..</p><p>​    我大学的时候经常趁夜里留在颐和园中喝酒，踢着昆明湖的水，看着西边的地平线跟朋友聊天，那时我想去美国，觉得那里天大地大，很多年后我从美国回来了，才知道那里不过是一些城市。</p></blockquote><p>曾经想来上海，一部分原因就是因为这个家伙对于上海这座城市的描写给我留下了特别深的印象，就像他书里的故事总能深深打动我一样。直到今天再看他随笔中的那些文字还是不免被触动，或许就像江南老贼自己说的一样，“我之所以能写出那种被人追读的青春故事，并非我拥有比别人更加璀璨的青春，值得大书特书，而是我的青春特别普通，和路人甲路人乙路人丙的青春一样。”</p><p>打动人心的总是最真实的那一部分。看他在北大的生活让人觉得那么真实，看他美国留学的经历和过程中的纠结也是一样真实，这份真实让我有勇气去把曾经有过的理想再擦擦干净。有心理学研究说一个人十三岁以前的经历很大程度上会决定他的一生，而我十八岁前都是在那个小城里度过的，所以也注定成不了贵族，但我要用我这一生去证明，别人说的什么”三岁看大，七岁看老“全都是他娘的屁话。</p><h3 id="4-人际交往副本"><a href="#4-人际交往副本" class="headerlink" title="4 人际交往副本"></a>4 人际交往副本</h3><p>这个月一共跟老黄他们出去吃了三次饭，跑了两趟上财，中秋那天跑到复旦门口的川菜店小聚一下，感触颇多。</p><p>开小灶就在对面鸿基广场解决了。</p><h3 id="5-生活习惯副本"><a href="#5-生活习惯副本" class="headerlink" title="5 生活习惯副本"></a>5 生活习惯副本</h3><p>有好几天早上一睡睡到八点，睡眠很不好，有两次明显感觉熬夜带来的影响，赶紧好好休息一下。</p><p>十一点前准时睡，五点半起床，这是下个月的重心。</p><h3 id="6-其他计划副本"><a href="#6-其他计划副本" class="headerlink" title="6 其他计划副本"></a>6 其他计划副本</h3><p>无</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于效率。</p><p>第二件事，关于睡眠。</p><p>第三件事，关于运动。</p><p>第四件事，关于学习。</p><p>第五件事，关于成长。</p><p>第六件事，关于出国。</p><p>第七件事，关于反思。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>备考雅思：学好英语</p><p>ASC集群搭建：国庆加上之后再花一周的时间学习</p><p>期末考试：复习一个月的时间，每天一门课。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在上海大学(SHU)就读是什么体验？</title>
      <link href="/2021/09/12/shulife/"/>
      <url>/2021/09/12/shulife/</url>
      
        <content type="html"><![CDATA[<p>在上海大学就读是什么体验？ - 夏小天的回答 - 知乎 <a href="https://www.zhihu.com/question/401645789/answer/1354461326" target="_blank" rel="noopener">https://www.zhihu.com/question/401645789/answer/1354461326</a></p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openmp并行计算学习</title>
      <link href="/2021/09/12/openmp/"/>
      <url>/2021/09/12/openmp/</url>
      
        <content type="html"><![CDATA[<h1 id="Openmp和MPI"><a href="#Openmp和MPI" class="headerlink" title="Openmp和MPI"></a>Openmp和MPI</h1><p><strong>区别</strong></p><p>1.OpenMP </p><p>OpenMP是一种用于共享内存并行系统的多线程程序设计的库(Compiler Directive),特别适合于多核CPU上的并行程序开发设计。它支持的语言包括：C语言、C++、Fortran；不过，用以上这些语言进行程序开发时，并非需要特别关注的地方，因为现如今的大多数编译器已经支持了OpenMP，例如：Sun Compiler,GNU Compiler、Intel Compiler、Visual Studio等等。程序员在编程时，只需要在特定的源代码片段的前面加入OpenMP专用的#pargma omp预编译指令，就可以“通知”编译器将该段程序自动进行并行化处理，并且在必要的时候加入线程同步及通信机制。当编译器选择忽略#pargma omp预处理指令时，或者编译器不支持OpenMP时，程序又退化为一般的通用串行程序，此时，代码依然可以正常运作，只是不能利用多线程和多核CPU来加速程序的执行而已。</p><p>​    OpenMP使得程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节。对基于数据分集的多线程程序设计，它是一个很好的选择。同时，使用OpenMP也提供了更强的灵活性，可以较容易的适应不同的并行系统配置。线程粒度和负载平衡等是传统多线程程序设计中的难题，然而，在OpenMP中，OpenMP库从程序员手中接管了部分这两方面的工作，从而使得程序员可以更加专注于具体的算法本身，而非如何编程使得代码在CPU负载平衡和线程粒度方面做出平衡。但是，作为高层抽象，OpenMP并不适合需要复杂的线程间同步和互斥的场合。OpenMP的另一个缺点是不能在非共享内存系统(如计算机集群)上使用。在这样的系统上，MPI使用较多。</p><p>​    标准并行模式执行代码的基本思想是，程序开始时只有一个主线程，程序中的串行部分都由主线程执行，并行的部分是通过派生其他线程来执行，但是如果并行部分没有结束时是不会执行串行部分的。这就是标准的并行模式fork/join式并行模式，共享存储式并行程序就是使用fork/join式并行的，OpenMP亦是如此。</p><p>2.MPI</p><p>​    MPI（MPI是一个标准，有不同的具体实现，比如MPICH等）是多主机联网协作进行并行计算的工具，当然也可以用于单主机上多核/多CPU的并行计算，不过效率低。它能协调多台主机间的并行计算，因此并行规模上的可伸缩性很强，能在从个人电脑到世界TOP10的超级计算机上使用。缺点是使用进程间通信的方式协调并行计算，这导致并行效率较低、内存开销大、不直观、编程麻烦。</p><p>​    OpenMP是针对单主机上多核/多CPU并行计算而设计的工具，换句话说，OpenMP更适合单台计算机共享内存结构上的并行计算。由于使用线程间共享内存的方式协调并行计算，它在多核/多CPU结构上的效率很高、内存开销小、编程语句简洁直观，因此编程容易、编译器实现也容易（现在最新版的C、C++、Fortran编译器基本上都内置OpenMP支持）。不过OpenMP最大的缺点是只能在单台主机上工作，不能用于多台主机间的并行计算！</p><h2 id="Openmp"><a href="#Openmp" class="headerlink" title="Openmp"></a>Openmp</h2><p>OpenMP是一种用于共享内存并行系统的多线程程序设计方案，支持的编程语言包括C、C++和Fortran。OpenMP提供了对并行算法的高层抽象描述，特别适合在多核CPU机器上的并行程序设计。编译器根据程序中添加的pragma指令，自动将程序并行处理，使用OpenMP降低了并行编程的难度和复杂度。当编译器不支持OpenMP时，程序会退化成普通（串行）程序。程序中已有的OpenMP指令不会影响程序的正常编译运行。</p><p><a href="https://blog.csdn.net/laobai1015/article/details/79020128?ops_request_misc=%7B%22request%5Fid%22%3A%22162843230216780265414989%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=162843230216780265414989&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79020128.first_rank_v2_pc_rank_v29&utm_term=openMP%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187" target="_blank" rel="noopener">OpenMP的配置及简单使用</a></p><p>简单使用：测试本机是几核的</p><pre class="line-numbers language-c++"><code class="language-c++">#include<omp.h>#include<iostream>int main(){    std::cout << "parallel begin:\n";#pragma omp parallel    {        std::cout << omp_get_thread_num();    }    std::cout << "\n parallel end.\n";    std::cin.get();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下，按照那篇文章的说法，那么本计算机是16核，或者说是16线程的：</p><blockquote><p>parallel begin:<br>2<strong>12</strong>0<strong>7</strong>8<strong>6</strong>4<strong>15</strong>3<strong>9</strong>11<strong>10</strong>13<strong>14</strong>15<br>parallel end.</p></blockquote><p>而我买的code01电脑官方提供的配置信息是八核十六线程，难道设备商好心多给了四核？事实是设备商采用了超线程技术。</p><p>超线程技术是英特尔在奔腾四年代在奔腾处理器上广泛采用的一个技术，让一个处理器通过技术手段模拟成两个处理器，从而提高多任务的协调处理性能。也由于这个原因，所以单核心支持超线程技术的处理器在Windows操作系统下均会被识别成两个处理器。</p><h2 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h2><p>MPI(Message Passing Interface)，由其字面意思也可些许看出，是一个信息传递接口。可以理解为是一种独立于语言的信息传递标准。而OpenMPI和MPICH等是对这种标准的具体实现。也就是说，OpenMPI和MPICH这类库是具体用代码实现浏MPI标准。因此我们需要安装OpenMPI或者MPICH去实现我们所学的MPI的信息传递标准。</p><p>作者：Venney<br>链接：<a href="https://zhuanlan.zhihu.com/p/356705583" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/356705583</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>两小时入门MPI与并行计算系列 - Venney的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/355652501" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355652501</a></p><p><a href="https://blog.csdn.net/laobai1015/article/details/79020128?ops_request_misc=%7B%22request%5Fid%22%3A%22162843230216780265414989%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=162843230216780265414989&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79020128.first_rank_v2_pc_rank_v29&utm_term=openMP%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187" target="_blank" rel="noopener">OpenMP的配置及简单使用</a></p><p>大数据处理 | 五分钟上手MPI多机并行计算实验 - Ricolove的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/84642385" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84642385</a></p><p>高性能计算–mpi - yeah的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/69497154" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69497154</a></p><p><strong>linux下安装mpich</strong></p><p><a href="https://www.jianshu.com/p/54a676de4d0e" target="_blank" rel="noopener">Linux源码安装mpich</a></p><p>Ubuntu 20.04下安装和配置MPI - 胡黑的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/355850573" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355850573</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8月复盘</title>
      <link href="/2021/08/31/2021-8/"/>
      <url>/2021/08/31/2021-8/</url>
      
        <content type="html"><![CDATA[<h1 id="八月复盘（8-31）"><a href="#八月复盘（8-31）" class="headerlink" title="八月复盘（8.31）"></a>八月复盘（8.31）</h1><h2 id="本月关键词：暑假"><a href="#本月关键词：暑假" class="headerlink" title="本月关键词：暑假"></a>本月关键词：暑假</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>追逐梦想就是追逐自己的厄运</strong>，在满地都是六便士的街上，他抬起头看到了月光</p><p><strong>——毛姆《月亮和六便士》</strong></p><p>我质问主人公：“假如你怎么折腾都是三流画家，你还值得放弃一切重新开始吗？”<br>“我告诉你我必须画画儿，我由不了我自己。一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。”</p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p>王道《计算机网络》21h</p><p>王道《操作系统》21h</p><p>《超能竞赛导引》ASC备赛</p><p>计算机学院直招智科班导生工作</p><p>ocr标题提取项目</p><p>导生（廉价劳动力都有价的，剥削是无价的）</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>这个月购置了一系列健身器材，包括跑步机，但是都只能放在家里，回到学校后留给爸妈锻炼。</p><p>花了九块九试用keep的训练计划，很不错而且能感觉到有效果，但是需要花时间坚持，练了十次之后感觉就不能同时完成两项计划了，主要是时间不太够，训练量也需要根据自己情况去调整。</p><p>从军训前的六月末重新开始健身，中间停了一段时间，就像叔本华《人生的智慧》里所说的一样，健康是幸福的源泉。回到学校后不方便再记录自己每天摄入的卡路里，但是也要注意控制饮食和睡眠习惯。把健身当做一项兴趣爱好，目前的体脂率是18%，21岁的目标是刷脂到15%。不知不觉体重接近70kg了，比高中涨了5kg，也不知道是不是这两个月增加的，体重差到这样是不是就可以不用增肌了。不过也应该控制一下，减到两年前的体重就很合理，接下来先养成一个习惯，坚持二十天早起跑步。体脂秤也利用起来，每天早上空腹称一下。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>精读</strong></p><p>《CS：APP》小部分</p><p><strong>略读</strong></p><p>叔本华《人生的智慧》关于什么是人生的智慧。</p><p>王小波《爱你就像爱生命》，关于什么样的爱情才是浪漫的？</p><p>《贫穷的本质:我们为什么摆脱不了贫穷》阿比吉特•班纳吉 (Abhijit V.Banerjee) / 埃斯特•迪弗洛 (Esther Duflo)。</p><p>内容简介：他们曾被说成是白人的负担，是弱国劣政的牺牲者。他们是最底层的10亿人，生活在每天0.99美元的贫困线之下。数万亿美元的援助未能救他们于水火之中，他们，依然深陷贫穷的陷阱，前路不明……为什么贫穷，为什么穷人摆脱不了贫穷？这是《贫穷的本质:我们为什么摆脱不了贫穷》探讨的主要问题。</p><p>《笑场》李诞</p><p>《过得刚好》郭德纲</p><p>《人生由我》梅耶·马斯克写的自传</p><p>她15岁次登台，22岁结婚，31岁成为破产的单身母亲，随后辗转于3个国家的多个城市开展自己的事业，独立培养出3个出色的子女，同时获得了两个硕士学位。60多岁的她重返模特舞台，在头发变白的时候走红，69岁时，她的形象在美国时代广场独占4个广告牌。</p><blockquote><p>这些名人出的书很少有高质量的，我现在已经不愿意多读这样的书了。可能适合买来给其他人看一看。</p></blockquote><p><strong>娱乐</strong></p><p>各种小说45h，平均每天一个半小时，足以看完两门专业课，所以说这个月的时间都去哪了？</p><p>《声之形》1h</p><p>《金钱帝国：巅峰之战》2h</p><p>《扫黑风暴》27集，还冲了个腾讯会员。</p><p>《哈利波特2密室》《哈利波特3》没看完。4h</p><p>《脱口秀大会S4》8h</p><blockquote><p>短短四周，每天放松。早知道不如去找份实习了，每天足不出户，在家缺少学习的动力。去过一次萍乡市新建的图书馆，实在是太远了。</p></blockquote><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>跑步机，相比于去健身房办卡是很划算的，算是给家里配了个微型健身房，希望老爸老妈以后可以在家多多锻炼，我也要好好学习健身知识。</p><p>买书。</p><p>《CS：APP》英文版，深入理解自己的专业。也是为ASC备赛。</p><p>《科学之路》大佬的故事一直以来都激励着我前进。</p><p>“图灵奖”得主、“深度学习三巨头”之一、“卷积神经网络之父”……由于在人工智能领域的突出贡献，杨立昆被中国计算机科学界和企业界所熟知。</p><p>杨立昆的科学之路，谱写了一段关于勇气的宣言。他为了知识本身求学，而不是文凭，他用自己的经历，证明了通过激烈的考试竞争进入名校不是科学成功的窄门。他广泛阅读，为他科学思维的形成奠定了坚实的理论基础。他特立独行，做自己感兴趣的事情，即便那件事在短时间里不被人看好。在人工神经网络研究的低谷期，他寂寞地坚持，终于取得了举世瞩目的成就。</p><p>人工智能正在颠覆人类社会，未来机器能思考吗？杨立昆的这部著作，讲述正是人工智能在我们面前崛起——这个历史上仅有的时刻发生的故事。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>回去四周，暑假里大概有花一周多的时间在陪别人，包括出去武功山玩了两天。</p><p>跟在萍乡的一些高中同学聚了一下，有些人就是叫不出来我也没办法。聊了聊以后的规划，好像大家都是想考研。</p><p>本来对于剧本杀完全不感兴趣的我还想尝试改变一下，但老刘一说我就通了，剧本杀就跟开会一样，每个人那一堆材料，然后轮流发言，一开就是一下午三四个小时，关键还要自己花钱。我是从中完全找不到乐趣的，不喜欢就不喜欢，萝卜青菜各有所爱。</p><p>做大二总结的时候从知乎认识了一个交大药学专业的小姐姐，和我一样刚刚结束大二，英语特别好，而且因为很喜欢英语去辅修英语专业，特别佩服她勇于去做自己喜欢的事情，其他各方面也真的特别优秀，要向她学习。多认识一些比自己优秀的人并且和他们交流沟通的好处就是发现自己的不足，比如我就总觉得自己大二过的很混，和别人对比之后才能发现到底是哪些地方做的不够好，通过和别人交流讨论才能更好地认识自己。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>这个月生活作息变得和军训前一样混乱，基本上没有十一点前睡着的，十二点前睡着的都很好了，导致假期里每天都是七点左右才起，本来还是想把军训时的良好作息坚持下来的。回到学校后再重新开始调整。日记中间断了十多天。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>ASC超算，接下来要和学校老师沟通协调。</p><p>健身，keep going，keep health。</p><p>app开发，目前只能先放一放了，因为做起来很简单，只是很好玩但是不太重要。</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>见大二总结</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>大三计划</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7月复盘</title>
      <link href="/2021/07/31/2021-7-1/"/>
      <url>/2021/07/31/2021-7-1/</url>
      
        <content type="html"><![CDATA[<h1 id="7月复盘（7-31）"><a href="#7月复盘（7-31）" class="headerlink" title="7月复盘（7.31）"></a>7月复盘（7.31）</h1><h2 id="本月关键词：及冠"><a href="#本月关键词：及冠" class="headerlink" title="本月关键词：及冠"></a>本月关键词：及冠</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“但我在二十一岁生日时没有预见到这一点，我觉得我会永远生猛下去，谁也锤不了我。”</strong></p><p>——王小波《黄金时代》</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210731201505.jpg" alt="王小波帅照"></p><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p>夏季小学期：<a href="https://henryavery.cn/2021/06/23/shugame/">SHU游戏开发</a></p><p>b站flutter，薅到一堆内部学习资料。简单两个页面设计了一下。</p><p>大学军训。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>军训前16km，中间躺平，挣扎一天，然后就没了。十天去了5次。每次一断就是两天，这个松懈点要想想办法。</p><p>军训两周，直接报废。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>《爱的艺术》，爱的理论+爱的实践，不只是男女之间的爱情，是更宏大的人类爱情。母胎solo看这本书也收获很多，比如晚上想太多睡不着，爬起来一看凌晨一点半，睡不着那就看会书，看完然后就安心地睡着了。</p><p>《穷查理宝典》查理芒格的演讲集，读完这本书的时长跨度略长。</p><p><strong>小说</strong></p><p>《从红月开始》150w字，暑假小学期放飞了，废寝忘食看小说，耗时三天。。。要是能有这种劲头早把《经济学》看完了。</p><p><strong>电影</strong></p><p>《女狙击手》，很少看主要是女性视角的剧情片，而且在我的印象中好像也没有那种能够称为影帝的女主角，当然我不是说没有好的女演员，只不过可能我看的大多数是男性视角的经典电影，而且我一下子就能想到小李子，星爷，阿德里安·布洛迪这些男演员，基本上我知道有他们的电影都看过了。像是《天使爱美丽》《穿普拉达的女王》里的女主角都很不错，但我说不出她们其他的电影了。那些中国女星就不用说了，没一个喜欢的。没错这就是偏见。电影这个行业里的本来就存在着偏见，观众有偏见也正常。</p><p>《飞行家》，小李子出演，三个小时看了三分之一，学校宿舍网太卡。</p><p>《风雨同路》，星爷。”我是卧底“那段演技很经典，还以为居然还有星爷的电影被我漏了，估计是太久看过忘了。</p><p><strong>动漫</strong></p><p>《R&amp;M 5》已经出完前六集了，第七集提前泄露，感觉这一集不如以前的瑞克了。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210731205803.png" alt="S5E1"></p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>伙食费1370。这个月和同学在外面吃了三次饭，一共花了200（正好老妈发了个200的生日红包），M记和鸡排80，炒饭90，其他100，食堂650，水果50，这个月没怎么去食堂，在学校门口小吃200，有点过分了，不在食堂吃也没每周记账，就忘了注意控制。</p><p>日常开销350，京东上买了电动牙刷39和防晒77，洗衣服20，会员费20，军训衣服128，理发10，交通费35（不包月只是偶尔骑一下共享单车，包月也不划算），其他15（买了个帽子）</p><hr><p>上面是正常开销，接近1.7k，伙食费创新高，这个月实在是没控制住，好像两年里都从来没吃过这么多，以前还以为最多一个月也就1.2k，。乱吃东西和乱买东西就容易多花钱，牙刷和防晒可买可不买，不过小米电动牙刷好像也确实挺好用的，本来也是想试试，还行的话回去就给爸妈推荐一下，之后只要换牙刷头，实际上也差不多。军训衣服是真浪费，花了一百多块穿了7天也不回收，军训完室友直接当垃圾扔了。有几天作息不太规律，然后可能益新食堂吃得太勤了，到大二开始有些生理上的腻味，而且饭点很早，一天的早上如果过了7点起床，这一天可能就都不太想去益新了，其他食堂又太远，一个人不想去，所以才就近鸿基解决。</p><hr><p>放假回家400，高铁学生票331，把15本书寄回家运费61，地铁从学校到虹桥火车站5块,15号线转2号线站外换乘。</p><p>健身投资，185买了个哑铃凳放家里。</p><p>读书投资，250买了八本书，生日想给自己买点东西，拆书很快乐。</p><p>学习投资，一本超算竞赛书65，很薄一本。</p><hr><p>额外开销0.9k，真的难得花这么多钱。</p><p>基金也直接回到解放前，放了半年本来还以为有点搞头，结果白搞了。这个月很破财，总支出2.6k，8月回家之后预算降到500。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>大学最后加入一个社团，迷途之家，大三有空的话当当临时工。</p><p>ASC开始招人。先自己理清一下，再联系一下我院大佬。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>早起。军训一周起的很早，但是台风一来又刮回了寝室同步的作息。</p><p>运动。这个月的健身好像有点效果，很多人说我体型有变化？否则那就是真的是吃胖了。</p><p>读书。坚持每天晚上读书半小时，小说不算。从二十岁开始坚持这个简单点的习惯，可根据不同阶段具体情况调整，最好的情况是每天晚上还能读书学习4小时。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>这个暑假就三件事，健身，ASC竞赛，app开发。</p><p>二十岁生日想了想要买点什么，然后买了一堆书，起码得看完个一两本。买书心得：八本书，能买到三四本不错的书，一两本经典好书就超过心理预期了。</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于成长。“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”高中的时候读王小波的《黄金时代》，那时候就想等自己也到了一生之中的黄金时代会是什么样子。</p><p>经过了从十八岁到二十岁的两年时间，再回顾起以前的自己会觉得很幼稚，犯了很多错误，但是太过苛责过去的自己是不公平的， 不能用现在的成熟程度和信息量去苛责过去的自己<em>。</em>因为就算回到过去,以过去的我的，心态和状态还是会做出同样的选择。 就原谅和接受每段时期的自己，以及现在的自己，并且永远保持乐观。</p><p>所以成长就是在从上海回萍乡的高铁上，看着路上人海茫茫，却能安静地想清楚自己未来十年的方向。</p><p><strong>25岁的我在北京，30岁的我在美国华盛顿D.C.</strong></p><blockquote><p>“一个人究竟是怎样成长的呢？就是在这样一个个无比具体的时间点，处理一件件无比具体的事情之中成长的。”</p></blockquote><p>第二件事，关于健身。有一次去学校健身房，里面同时有三个女生，两个都在跑步，一个在练器械，数量居然和我们大学班上的女生数量持平，感慨我院男女比例真的感人。有很多健身大佬，才碰见一两次，没来得及加上微信认识一下，以后第一次就先加微信再说。果然，适度健身吸引异性，过度健身吸引同性。平时有氧跑跑步，所以一直没练腿，才知道原来还有“健身不练腿，迟早要XX”的说法，回家深蹲得做起来了。</p><p>第三件事，关于未来。争取保研去北大软微，换个城市，上海待够四年就是时候该北上了，人大也可以考虑，不过保研怕是很难保到特别好的学校，到时候看情况，如果是复旦类脑也可以考虑再在上海待几年。不过相较之下，目前可能还是想考到北大去多一点。到时候自己是否又要像高考填志愿一样求稳，可能又会是一个重要的人生抉择。</p><p>第四件事，关于方向。想搞ASC，的确很大程度上是因为需要一个奖项，而且自己好像有一种直觉，甚至超越了拿奖，觉得这是一次非常难得的挑战，在未来这一段经历也会变得十分重要。就好像大一就关注到了复旦类脑科学研究院，然后认识的psj学长也考研到了复旦类脑，总觉得冥冥之中有一种力量牵引着我。文本和脑电波都是时间序列，而且从某种意义上来说，我认为人类更容易理解语言和文字，口语其实和书面是语言的两个层面，背后隐藏的是人类思考逻辑的不同，而实现通用人工智能很关键的一点就是模仿人类的思考逻辑。简单来讲，听说和读写是两套复杂古老的机制。我认为人类至今为止对图像的“使用”（包括接收输入和输出）都还很像是一个新生儿手里玩的新玩具。记录是人类进步过程中的关键一环。文字就是我们目前知道的最早的记录，相对来说，用照相机做记录则很晚才出现。而直到近代智能手机的普及，才出现了大量可以被机器学习的图片数据，所以我认为人类对于语言和文字的利用程度是高于对视觉和图形的。但不得不说，在思维方式和数学上图形都很重要，而且更加直观，这是视觉独特的优点。总之，cv虽然很火，但nlp方向也仍有巨大潜力，我会坚持下去。如果说打超算比赛部分原因是因为自己有更为长远的布局，那么不放弃nlp方向则是考虑到它未来的意义可能重大到我无法想象。</p><p>第五件事，关于爱情。恋爱前，恋爱时，恋爱后，都可以读的《爱的艺术》。这个夏天，狗都不单身了。另外会写一篇书评。</p><p>第六件事，关于计划。计划要一个一个做，做完一个计划就快速完成一个，至少是阶段性完成，然后切换到其他任务上，多线程不适用于冲突的任务，比如都需要大量思考的脑力活动。创造性活动和输入式的学习（预习）不知道会不会冲突。</p><p>第七件事，关于军训。详情见军训小结。家有家风，国有国风。活动倒是没什么好写的，只晒了一周不到，因为退伍的同学（松哥yyds）来当我们连教官，已经放了很多水了，再加上后一周的台风“烟花”，很轻松就度过了整个军训。抢了个排长来当，拿到了优秀营员，很开心。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210801205057.jpg" alt="优秀学员"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210801205112.jpg" alt="3-2-3"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210801205128.jpg" alt="女营长来训人"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210801205146.jpg" alt="台风天宿舍站军姿"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210801205205.jpg" alt="通讯稿"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210801205212.jpg" alt="还是通讯稿"></p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>暑假学习计划，健身计划</p><p>作息安排</p><table><thead><tr><th>时间</th><th>安排</th></tr></thead><tbody><tr><td>5:00-6:00</td><td>跑步</td></tr><tr><td>6:00-8:00</td><td>早饭，休息</td></tr><tr><td>8:00-12:00</td><td>专业学习，ASC</td></tr><tr><td>12:00-14:00</td><td>午饭，午休</td></tr><tr><td>14:00-16:00</td><td>工作，App开发</td></tr><tr><td>16:00-17:00</td><td>健身</td></tr><tr><td>17:00-19:00</td><td>晚饭，休息，开会</td></tr><tr><td>19:00-20:00</td><td>英语学习</td></tr><tr><td>20:00-22:00</td><td>调整，读书学习</td></tr><tr><td>22:00-22:30</td><td>写日记，睡觉</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6月复盘</title>
      <link href="/2021/07/02/2021-7/"/>
      <url>/2021/07/02/2021-7/</url>
      
        <content type="html"><![CDATA[<h1 id="6月复盘（7-2）"><a href="#6月复盘（7-2）" class="headerlink" title="6月复盘（7.2）"></a>6月复盘（7.2）</h1><h2 id="本月关键词："><a href="#本月关键词：" class="headerlink" title="本月关键词："></a>本月关键词：</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>王，人求多闻，时惟建事。</strong></p><p>——《资治通鉴序御制》（<strong>语出自《尚书》</strong>）</p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p>大二冬季期末考试，从绩点来看应该是大二考得最好的一次，排名也进了个六名，但是还是没发挥不出来，不知道为什么明明感觉自己应该很能拿捏得住考试，但是每次考试结果都摸不着头脑地发挥不出来，这难道是天性?</p><p>大二学习总结等夏季学期结束一起写吧。</p><p>不拿考试成绩来衡量自己，要自己找出一套能够认识自己的方法。</p><p><a href="https://henryavery.cn/2021/06/25/deeplearning/">吴恩达深度学习</a>b站上差不多一周零零碎碎地看完，对基础概念有了了解，就差自己动手实践了。</p><p><a href="https://henryavery.cn/2021/01/22/flutter/#toc-heading-1">重启Flutter</a>这次是认真的，从前端到后端打通，“时刻”app的策划也会认真写个草案出来。</p><p><a href="https://henryavery.cn/2021/06/17/asc2022/">ASC2022</a>又是一次新的挑战，还是感觉无从下手，五个人组队还不知道要找谁。但这是一个机会，一个虽千万人吾往矣的机会。</p><p>谈到工作，突然发现自己好像真的跟志愿者工作绝缘了一样，搞不理清。</p><p>国赛数模，不假思索地选择了不参加，为什么我有的时候反应会这么快这么果断，一点都不拖泥带水？要是一直都能有这样的专注果断就好了。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>这个月基本上是考试完才开始运动，可能打球上课除外，运动量都在六月后旬，跑了20km，每次平均跑3km以上。重新开始健身，暑假一定要把腹肌练出来，这个月有7h在健身，只得及去了四五次，能感觉到自己确实需要练练体型了，脱光衣服有氧跑步自己看着都觉得丢人。练了几次腹部之后感觉就没那么痛了，还需要把体脂降低一点才好。暂时没打算练腿了，虽然说健身不练腿，咳咳咳，但还是先集中练好一块，坚持一段时间再说。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p>没看什么书，写了一堆报告倒是真的。不过那可能连学术垃圾都算不上，可能就是学术空气吧。垃圾还能回收利用，空气虽然重要，但从来不缺，而且因为到处都是也没有任何价值。</p><p>快速阅读《游戏改变世界》，作者的观点就是游戏不是消极地逃避现实世界，而是让玩家积极地，乐观地生活。挺奇怪的，但好像又有道理，虽然她举的例子我都没玩过。正好夏季学期的游戏开发课程和这个相关，也算是了解了不少游戏相关的软知识吧，希望能用得上。</p><p>《爱的艺术》，有了爱的理论，缺少实践。需要理论结合实践，毕竟实践才能出真知。个人以为本书讨论内容不止关于爱情，其实是深入人性本质去讨论人所谓的爱。前段时间有一些心理波动，这本书也给我的帮助极大，暂剩下最后两章时没舍得看完，留着以后有用。</p><blockquote><p>就是以为只看完了爱的理论，没看到最后爱的实践部分，所以才没有实践吧······</p></blockquote><p>重读《卓有成效的管理者》经典，找灵感。</p><p>《穿普拉达的女王》，很不错的片子，对于审美谈不上有新的认知，对那种高强度的工作效率和超强的工作能力有了新的理解。</p><p>《龙樱》，第二部不想看了，只看第一部我觉得就足够了。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210702211317.jpg" alt="img"></p><p>《因为太怕痛所以就全点防御力了》，只记得一点特效</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>买了备用的code01大出血一回，大概是今年做的回报率最高的一笔投资了。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>社交，好难。</p><p>不过也没那么难就是了，毕竟我好像也很少用得上刻意去社交。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>六月不知道怎么回事，==，考试压力大或者太累，迷茫没有方向？经常感觉自己整个人一天都是瘫的，好在后面开始健身之后这种现象基本上就没有了。这个月好像经常赖床，室友一个个都是修仙高手。有一个经常两点半还没睡，早上七点多起来去上课，实在佩服，虽然感觉没对我早上床睡觉有多少影响，但我也不知道为什么我的睡眠好像也不太行，可能是因为处在了一个晚睡的环境里？为什么计算机学院的都习惯晚睡？为什么大学生好像比社畜还能熬夜，我真心不觉得有那么多重要的不得了的事情是一定要拖到晚上做，也许少部分真的是，但也不可能形成一种常态，很奇怪。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p><a href="https://henryavery.cn/2021/02/10/2021-nian-ji-hua/#toc-heading-2">2021暑期计划</a></p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于社交。</p><p>第二件事，关于志愿。</p><p>第三件事，关于爱情。</p><p>第四件事，关于哲学。</p><p>第五件事，关于穿搭。</p><p>第六件事，关于消费。</p><p>第七件事，关于毅力。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing算法基础学习</title>
      <link href="/2021/06/29/acwing/"/>
      <url>/2021/06/29/acwing/</url>
      
        <content type="html"><![CDATA[<h1 id="2021暑假ACwing算法基础课"><a href="#2021暑假ACwing算法基础课" class="headerlink" title="2021暑假ACwing算法基础课"></a>2021暑假ACwing算法基础课</h1><p><strong>学习方法6.29</strong></p><p>上课学主要思想，课后理解代码模板背诵默写，<strong>提高最快的方法</strong>，课后习题检验，默写背诵模板，<strong>一个题目ctrl+D删除三到五遍重写，提高熟练度</strong></p><p><strong>开始看视频7.5</strong></p><h2 id="基础算法模板"><a href="#基础算法模板" class="headerlink" title="基础算法模板"></a>基础算法模板</h2><h3 id="快速排序算法模板"><a href="#快速排序算法模板" class="headerlink" title="快速排序算法模板"></a>快速排序算法模板</h3><pre class="line-numbers language-c++"><code class="language-c++">void quick_sort(int q[], int l, int r){    if (l >= r) return;    int i = l - 1, j = r + 1, x = q[l + r >> 1];    //l+r的值右移1位，相当l+r的值除以2取整。    while (i < j)    {        do i ++ ; while (q[i] < x);        do j -- ; while (q[j] > x);        if (i < j) swap(q[i], q[j]);    }    quick_sort(q, l, j), quick_sort(q, j + 1, r);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序算法模板"><a href="#归并排序算法模板" class="headerlink" title="归并排序算法模板"></a>归并排序算法模板</h3><pre class="line-numbers language-c++"><code class="language-c++">void merge_sort(int q[], int l, int r){    if (l >= r) return;    int mid = l + r >> 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i <= mid && j <= r)        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i <= mid) tmp[k ++ ] = q[i ++ ];    while (j <= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="整数二分算法模板"><a href="#整数二分算法模板" class="headerlink" title="整数二分算法模板"></a>整数二分算法模板</h3><pre class="line-numbers language-c++"><code class="language-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r){    while (l < r)    {        int mid = l + r >> 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    }    return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r){    while (l < r)    {        int mid = l + r + 1 >> 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度-模板"><a href="#高精度-模板" class="headerlink" title="高精度+-*/模板"></a>高精度+-*/模板</h3><pre class="line-numbers language-c++"><code class="language-c++">// C = A + B, A >= 0, B >= 0vector<int> add(vector<int> &A, vector<int> &B){    if (A.size() < B.size()) return add(B, A);    vector<int> C;    int t = 0;    for (int i = 0; i < A.size(); i ++ )    {        t += A[i];        if (i < B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    }    if (t) C.push_back(t);    return C;}// C = A - B, 满足A >= B, A >= 0, B >= 0vector<int> sub(vector<int> &A, vector<int> &B){    vector<int> C;    for (int i = 0, t = 0; i < A.size(); i ++ )    {        t = A[i] - t;        if (i < B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if (t < 0) t = 1;        else t = 0;    }    while (C.size() > 1 && C.back() == 0) C.pop_back();    return C;}// C = A * b, A >= 0, b >= 0vector<int> mul(vector<int> &A, int b){    vector<int> C;    int t = 0;    for (int i = 0; i < A.size() || t; i ++ )    {        if (i < A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    }    while (C.size() > 1 && C.back() == 0) C.pop_back();    return C;}// A / b = C ... r, A >= 0, b > 0vector<int> div(vector<int> &A, int b, int &r){    vector<int> C;    r = 0;    for (int i = A.size() - 1; i >= 0; i -- )    {        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    }    reverse(C.begin(), C.end());    while (C.size() > 1 && C.back() == 0) C.pop_back();    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他模板"><a href="#其他模板" class="headerlink" title="其他模板"></a>其他模板</h3><pre class="line-numbers language-c++"><code class="language-c++">/*一维前缀和*/S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]/*二维前缀和*/    S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]/*一维差分*/    给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c/*二维差分*/给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c/*位运算*/求n的第k位数字: n >> k & 1返回n的最后一位1：lowbit(n) = n & -n//双指针for (int i = 0, j = 0; i < n; i ++ ){    while (j < i && check(i, j)) j ++ ;    // 具体问题的逻辑}常见问题分类：    (1) 对于一个序列，用两个指针维护一段区间    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作/*离散化*/vector<int> alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置{    int l = 0, r = alls.size() - 1;    while (l < r)    {        int mid = l + r >> 1;        if (alls[mid] >= x) r = mid;        else l = mid + 1;    }    return r + 1; // 映射到1, 2, ...n}// 将所有存在交集的区间合并void merge(vector<PII> &segs){    vector<PII> res;    sort(segs.begin(), segs.end());    int st = -2e9, ed = -2e9;    for (auto seg : segs)        if (ed < seg.first)        {            if (st != -2e9) res.push_back({st, ed});            st = seg.first, ed = seg.second;        }        else ed = max(ed, seg.second);    if (st != -2e9) res.push_back({st, ed});    segs = res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据结构模板"><a href="#数据结构模板" class="headerlink" title="数据结构模板"></a>数据结构模板</h2><h3 id="单链表-——-模板题-AcWing-826-单链表"><a href="#单链表-——-模板题-AcWing-826-单链表" class="headerlink" title="单链表 —— 模板题 AcWing 826. 单链表"></a>单链表 —— 模板题 AcWing 826. 单链表</h3><pre class="line-numbers language-c++"><code class="language-c++">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init(){    head = -1;    idx = 0;}// 在链表头插入一个数avoid insert(int a){    e[idx] = a, ne[idx] = head, head = idx ++ ;}// 将头结点删除，需要保证头结点存在void remove(){    head = ne[head];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双链表-——-模板题-AcWing-827-双链表"><a href="#双链表-——-模板题-AcWing-827-双链表" class="headerlink" title="双链表 —— 模板题 AcWing 827. 双链表"></a>双链表 —— 模板题 AcWing 827. 双链表</h3><pre class="line-numbers language-c++"><code class="language-c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init(){    //0是左端点，1是右端点    r[0] = 1, l[1] = 0;    idx = 2;}// 在节点a的右边插入一个数xvoid insert(int a, int x){    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++ ;}// 删除节点avoid remove(int a){    l[r[a]] = l[a];    r[l[a]] = r[a];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈-——-模板题-AcWing-828-模拟栈"><a href="#栈-——-模板题-AcWing-828-模拟栈" class="headerlink" title="栈 —— 模板题 AcWing 828. 模拟栈"></a>栈 —— 模板题 AcWing 828. 模拟栈</h3><pre class="line-numbers language-c++"><code class="language-c++">// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt > 0){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列-——-模板题-AcWing-829-模拟队列"><a href="#队列-——-模板题-AcWing-829-模拟队列" class="headerlink" title="队列 —— 模板题 AcWing 829. 模拟队列"></a>队列 —— 模板题 AcWing 829. 模拟队列</h3><ol><li>普通队列：</li></ol><pre class="line-numbers language-c++"><code class="language-c++">// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh <= tt){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.循环队列</p><pre class="line-numbers language-c++"><code class="language-c++">// hh 表示队头，tt表示队尾的后一个位置   int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c</p><h3 id="单调栈-——-模板题-AcWing-830-单调栈"><a href="#单调栈-——-模板题-AcWing-830-单调栈" class="headerlink" title="单调栈 —— 模板题 AcWing 830. 单调栈"></a>单调栈 —— 模板题 AcWing 830. 单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大/小的数</p><pre class="line-numbers language-c++"><code class="language-c++">int tt = 0;for (int i = 1; i <= n; i ++ ){    while (tt && check(stk[tt], i)) tt -- ;    stk[ ++ tt] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调队列-——-模板题-AcWing-154-滑动窗口"><a href="#单调队列-——-模板题-AcWing-154-滑动窗口" class="headerlink" title="单调队列 —— 模板题 AcWing 154. 滑动窗口"></a>单调队列 —— 模板题 AcWing 154. 滑动窗口</h3><pre class="line-numbers language-c++"><code class="language-c++">常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i < n; i ++ ){    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口    while (hh <= tt && check(q[tt], i)) tt -- ;    q[ ++ tt] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP-——-模板题-AcWing-831-KMP字符串"><a href="#KMP-——-模板题-AcWing-831-KMP字符串" class="headerlink" title="KMP —— 模板题 AcWing 831. KMP字符串"></a>KMP —— 模板题 AcWing 831. KMP字符串</h3><pre class="line-numbers language-c++"><code class="language-c++">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i <= m; i ++ ){    while (j && p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++ ;    ne[i] = j;}// 匹配for (int i = 1, j = 0; i <= n; i ++ ){    while (j && s[i] != p[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++ ;    if (j == m)    {        j = ne[j];        // 匹配成功后的逻辑    }}Trie树 —— 模板题 AcWing 835. Trie字符串统计int son[N][26], cnt[N], idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str){    int p = 0;    for (int i = 0; str[i]; i ++ )    {        int u = str[i] - 'a';        if (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    }    cnt[p] ++ ;}// 查询字符串出现的次数int query(char *str){    int p = 0;    for (int i = 0; str[i]; i ++ )    {        int u = str[i] - 'a';        if (!son[p][u]) return 0;        p = son[p][u];    }    return cnt[p];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并查集-——-模板题-AcWing-836-合并集合-AcWing-837-连通块中点的数量"><a href="#并查集-——-模板题-AcWing-836-合并集合-AcWing-837-连通块中点的数量" class="headerlink" title="并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量"></a>并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量</h3><p>(1)朴素并查集：</p><pre class="line-numbers language-c++"><code class="language-c++">int p[N]; //存储每个点的祖宗节点// 返回x的祖宗节点int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}// 初始化，假定节点编号是1~nfor (int i = 1; i <= n; i ++ ) p[i] = i;// 合并a和b所在的两个集合：p[find(a)] = find(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)维护size的并查集：</p><pre class="line-numbers language-c++"><code class="language-c++">int p[N], size[N];//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量// 返回x的祖宗节点int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}// 初始化，假定节点编号是1~nfor (int i = 1; i <= n; i ++ ){    p[i] = i;    size[i] = 1;}// 合并a和b所在的两个集合：size[find(b)] += size[find(a)];p[find(a)] = find(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3)维护到祖宗节点距离的并查集：</p><pre class="line-numbers language-c++"><code class="language-c++">int p[N], d[N];//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离// 返回x的祖宗节点int find(int x){    if (p[x] != x)    {        int u = find(p[x]);        d[x] += d[p[x]];        p[x] = u;    }    return p[x];}// 初始化，假定节点编号是1~nfor (int i = 1; i <= n; i ++ ){    p[i] = i;    d[i] = 0;}// 合并a和b所在的两个集合：p[find(a)] = find(b);d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆-——-模板题-AcWing-838-堆排序-AcWing-839-模拟堆"><a href="#堆-——-模板题-AcWing-838-堆排序-AcWing-839-模拟堆" class="headerlink" title="堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆"></a>堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆</h3><pre class="line-numbers language-c++"><code class="language-c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b){    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);}void down(int u){    int t = u;    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;    if (u != t)    {        heap_swap(u, t);        down(t);    }}void up(int u){    while (u / 2 && h[u] < h[u / 2])    {        heap_swap(u, u / 2);        u >>= 1;    }}// O(n)建堆for (int i = n / 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一般哈希-——-模板题-AcWing-840-模拟散列表"><a href="#一般哈希-——-模板题-AcWing-840-模拟散列表" class="headerlink" title="一般哈希 —— 模板题 AcWing 840. 模拟散列表"></a>一般哈希 —— 模板题 AcWing 840. 模拟散列表</h3><p>(1) 拉链法</p><pre class="line-numbers language-c++"><code class="language-c++">// 向哈希表中插入一个数，int h[N], e[N], ne[N], idx;void insert(int x){    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;}// 在哈希表中查询某个数是否存在bool find(int x){    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 开放寻址法</p><pre class="line-numbers language-c++"><code class="language-c++">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int h[N];int find(int x){    int t = (x % N + N) % N;    while (h[t] != null && h[t] != x)    {        t ++ ;        if (t == N) t = 0;    }    return t;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串哈希-——-模板题-AcWing-841-字符串哈希"><a href="#字符串哈希-——-模板题-AcWing-841-字符串哈希" class="headerlink" title="字符串哈希 —— 模板题 AcWing 841. 字符串哈希"></a>字符串哈希 —— 模板题 AcWing 841. 字符串哈希</h3><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p><pre class="line-numbers language-c++"><code class="language-c++">typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i <= n; i ++ ){    h[i] = h[i - 1] * P + str[i];    p[i] = p[i - 1] * P;}// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r){    return h[r] - h[l - 1] * p[r - l + 1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-STL简介"><a href="#C-STL简介" class="headerlink" title="C++ STL简介"></a>C++ STL简介</h3><pre class="line-numbers language-c++"><code class="language-c++">vector, 变长数组，倍增的思想    size()  返回元素个数    empty()  返回是否为空    clear()  清空    front()/back()    push_back()/pop_back()    begin()/end()    []    支持比较运算，按字典序pair<int, int>    first, 第一个元素    second, 第二个元素    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串    size()/length()  返回字符串长度    empty()    clear()    substr(起始下标，(子串长度))  返回子串    c_str()  返回字符串所在字符数组的起始地址queue, 队列    size()    empty()    push()  向队尾插入一个元素    front()  返回队头元素    back()  返回队尾元素    pop()  弹出队头元素priority_queue, 优先队列，默认是大根堆    size()    empty()    push()  插入一个元素    top()  返回堆顶元素    pop()  弹出堆顶元素    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;stack, 栈    size()    empty()    push()  向栈顶插入一个元素    top()  返回栈顶元素    pop()  弹出栈顶元素deque, 双端队列    size()    empty()    clear()    front()/back()    push_back()/pop_back()    push_front()/pop_front()    begin()/end()    []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列    size()    empty()    clear()    begin()/end()    ++, -- 返回前驱和后继，时间复杂度 O(logn)set/multiset    insert()  插入一个数    find()  查找一个数    count()  返回某一个数的个数    erase()        (1) 输入是一个数x，删除所有x   O(k + logn)        (2) 输入一个迭代器，删除这个迭代器    lower_bound()/upper_bound()        lower_bound(x)  返回大于等于x的最小的数的迭代器        upper_bound(x)  返回大于x的最小的数的迭代器map/multimap    insert()  插入的数是一个pair    erase()  输入的参数是pair或者迭代器    find()    []  注意multimap不支持此操作。 时间复杂度是 O(logn)    lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表    和上面类似，增删改查的时间复杂度是 O(1)    不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位    bitset<10000> s;    ~, &, |, ^    >>, <<    ==, !=    []count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><p>(1) 邻接矩阵：g[a] [b]存储边a-&gt;b</p><p>(2) 邻接表：</p><pre class="line-numbers language-c++"><code class="language-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a->bvoid add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}// 初始化idx = 0;memset(h, -1, sizeof h);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p><p><strong>(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心</strong></p><pre class="line-numbers language-c++"><code class="language-c++">int dfs(int u){    st[u] = true; // st[u] 表示点u已经被遍历过​    for (int i = h[u]; i != -1; i = ne[i])​    {​        int j = e[i];​        if (!st[j]) dfs(j);​    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次</strong></p><pre class="line-numbers language-c++"><code class="language-c++">queue<int> q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size()){    int t = q.front();    q.pop();​    for (int i = h[t]; i != -1; i = ne[i])​    {​        int j = e[i];​        if (!st[j])​        {​            st[j] = true; // 表示点j已经被遍历过​            q.push(j);​        }​    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拓扑排序-——-模板题-AcWing-848-有向图的拓扑序列"><a href="#拓扑排序-——-模板题-AcWing-848-有向图的拓扑序列" class="headerlink" title="拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列"></a>拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列</h3><p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">bool topsort(){    int hh = 0, tt = -1;​    // d[i] 存储点i的入度​    for (int i = 1; i <= n; i ++ )​        if (!d[i])​            q[ ++ tt] = i;​    ​    while (hh <= tt)​    {​        int t = q[hh ++ ];​    ​        for (int i = h[t]; i != -1; i = ne[i])​        {​            int j = e[i];​            if (-- d[j] == 0)​                q[ ++ tt] = j;​        }​    }​    ​    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。​    return tt == n - 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="朴素dijkstra算法-——-模板题-AcWing-849-Dijkstra求最短路-I"><a href="#朴素dijkstra算法-——-模板题-AcWing-849-Dijkstra求最短路-I" class="headerlink" title="朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I"></a>朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I</h3><p>时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">typedef pair<int, int> PII;int g[N][N];  // 存储每条边int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;​    for (int i = 0; i < n - 1; i ++ )​    {​        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点​        for (int j = 1; j <= n; j ++ )​            if (!st[j] && (t == -1 || dist[t] > dist[j]))​                t = j;​    ​        // 用t更新其他点的距离​        for (int j = 1; j <= n; j ++ )​            dist[j] = min(dist[j], dist[t] + g[t][j]);​    ​        st[t] = true;​    }​    ​    if (dist[n] == 0x3f3f3f3f) return -1;​    return dist[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆优化版dijkstra-——-模板题-AcWing-850-Dijkstra求最短路-II"><a href="#堆优化版dijkstra-——-模板题-AcWing-850-Dijkstra求最短路-II" class="headerlink" title="堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II"></a>堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II</h3><p>时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">typedef pair<int, int> PII;int n;      // 点的数量int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储所有点到1号点的距离bool st[N];     // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    priority_queue<PII, vector<PII>, greater<PII>> heap;    heap.push({0, 1});      // first存储距离，second存储节点编号​    while (heap.size())​    {​        auto t = heap.top();​        heap.pop();​    ​        int ver = t.second, distance = t.first;​    ​        if (st[ver]) continue;​        st[ver] = true;​    ​        for (int i = h[ver]; i != -1; i = ne[i])​        {​            int j = e[i];​            if (dist[j] > distance + w[i])​            {​                dist[j] = distance + w[i];​                heap.push({dist[j], j});​            }​        }​    }​    ​    if (dist[n] == 0x3f3f3f3f) return -1;​    return dist[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bellman-Ford算法-——-模板题-AcWing-853-有边数限制的最短路"><a href="#Bellman-Ford算法-——-模板题-AcWing-853-有边数限制的最短路" class="headerlink" title="Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路"></a>Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路</h3><p>时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数<br>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p><p>Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路<br>时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数<br>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p><pre class="line-numbers language-c++"><code class="language-c++">int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重{    int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;​    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。​    for (int i = 0; i < n; i ++ )​    {​        for (int j = 0; j < m; j ++ )​        {​            int a = edges[j].a, b = edges[j].b, w = edges[j].w;​            if (dist[b] > dist[a] + w)​                dist[b] = dist[a] + w;​        }​    }​    ​    if (dist[n] > 0x3f3f3f3f / 2) return -1;​    return dist[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="spfa-算法（队列优化的Bellman-Ford算法）-——-模板题-AcWing-851-spfa求最短路"><a href="#spfa-算法（队列优化的Bellman-Ford算法）-——-模板题-AcWing-851-spfa求最短路" class="headerlink" title="spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路"></a>spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路</h3><p>时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储每个点到1号点的最短距离bool st[N];     // 存储每个点是否在队列中// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;​    queue<int> q;​    q.push(1);​    st[1] = true;​    ​    while (q.size())​    {​        auto t = q.front();​        q.pop();​    ​        st[t] = false;​    ​        for (int i = h[t]; i != -1; i = ne[i])​        {​            int j = e[i];​            if (dist[j] > dist[t] + w[i])​            {​                dist[j] = dist[t] + w[i];​                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入​                {​                    q.push(j);​                    st[j] = true;​                }​            }​        }​    }​    ​    if (dist[n] == 0x3f3f3f3f) return -1;​    return dist[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="spfa判断图中是否存在负环-——-模板题-AcWing-852-spfa判断负环"><a href="#spfa判断图中是否存在负环-——-模板题-AcWing-852-spfa判断负环" class="headerlink" title="spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环"></a>spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环</h3><p>时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N];     // 存储每个点是否在队列中spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数// 如果存在负环，则返回true，否则返回false。bool spfa(){    // 不需要初始化dist数组    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。​    queue<int> q;​    for (int i = 1; i <= n; i ++ )​    {​        q.push(i);​        st[i] = true;​    }​    ​    while (q.size())​    {​        auto t = q.front();​        q.pop();​    ​        st[t] = false;​    ​        for (int i = h[t]; i != -1; i = ne[i])​        {​            int j = e[i];​            if (dist[j] > dist[t] + w[i])​            {​                dist[j] = dist[t] + w[i];​                cnt[j] = cnt[t] + 1;​                if (cnt[j] >= n) return true;           // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环​                if (!st[j])​                {​                    q.push(j);​                    st[j] = true;​                }​            }​        }​    }​    ​    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="floyd算法-——-模板题-AcWing-854-Floyd求最短路"><a href="#floyd算法-——-模板题-AcWing-854-Floyd求最短路" class="headerlink" title="floyd算法 —— 模板题 AcWing 854. Floyd求最短路"></a>floyd算法 —— 模板题 AcWing 854. Floyd求最短路</h3><p>时间复杂度是 O(n3)O(n3), nn 表示点数</p><pre class="line-numbers language-c++"><code class="language-c++">初始化：    for (int i = 1; i <= n; i ++ )        for (int j = 1; j <= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k <= n; k ++ )        for (int i = 1; i <= n; i ++ )            for (int j = 1; j <= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="朴素版prim算法-——-模板题-AcWing-858-Prim算法求最小生成树"><a href="#朴素版prim算法-——-模板题-AcWing-858-Prim算法求最小生成树" class="headerlink" title="朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树"></a>朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树</h3><p>时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">int n;      // n表示点数int g[N][N];        // 邻接矩阵，存储所有边int dist[N];        // 存储其他点到当前最小生成树的距离bool st[N];     // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim(){    memset(dist, 0x3f, sizeof dist);    int res = 0;    for (int i = 0; i < n; i ++ )    {        int t = -1;        for (int j = 1; j <= n; j ++ )            if (!st[j] && (t == -1 || dist[t] > dist[j]))                t = j;        if (i && dist[t] == INF) return INF;        if (i) res += dist[t];        st[t] = true;        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Kruskal算法-——-模板题-AcWing-859-Kruskal算法求最小生成树"><a href="#Kruskal算法-——-模板题-AcWing-859-Kruskal算法求最小生成树" class="headerlink" title="Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树"></a>Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树</h3><p>时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">int n, m;       // n是点数，m是边数int p[N];       // 并查集的父节点数组struct Edge     // 存储边{    int a, b, w;    bool operator< (const Edge &W)const    {        return w < W.w;    }}edges[M];int find(int x)     // 并查集核心操作{    if (p[x] != x) p[x] = find(p[x]);    return p[x];}int kruskal(){    sort(edges, edges + m);    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集    int res = 0, cnt = 0;    for (int i = 0; i < m; i ++ )    {        int a = edges[i].a, b = edges[i].b, w = edges[i].w;        a = find(a), b = find(b);        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并        {            p[a] = b;            res += w;            cnt ++ ;        }    }    if (cnt < n - 1) return INF;    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="染色法判别二分图-——-模板题-AcWing-860-染色法判定二分图"><a href="#染色法判别二分图-——-模板题-AcWing-860-染色法判定二分图" class="headerlink" title="染色法判别二分图 —— 模板题 AcWing 860. 染色法判定二分图"></a>染色法判别二分图 —— 模板题 AcWing 860. 染色法判定二分图</h3><p>时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">int n;      // n表示点数int h[N], e[M], ne[M], idx;     // 邻接表存储图int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c){    color[u] = c;    for (int i = h[u]; i != -1; i = ne[i])    {        int j = e[i];        if (color[j] == -1)        {            if (!dfs(j, !c)) return false;        }        else if (color[j] == c) return false;    }    return true;}bool check(){    memset(color, -1, sizeof color);    bool flag = true;    for (int i = 1; i <= n; i ++ )        if (color[i] == -1)            if (!dfs(i, 0))            {                flag = false;                break;            }    return flag;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匈牙利算法-——-模板题-AcWing-861-二分图的最大匹配"><a href="#匈牙利算法-——-模板题-AcWing-861-二分图的最大匹配" class="headerlink" title="匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配"></a>匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配</h3><p>时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数</p><pre class="line-numbers language-c++"><code class="language-c++">int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过bool find(int x){    for (int i = h[x]; i != -1; i = ne[i])    {        int j = e[i];        if (!st[j])        {            st[j] = true;            if (match[j] == 0 || find(match[j]))            {                match[j] = x;                return true;            }        }    }    return false;}// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i <= n1; i ++ ){    memset(st, false, sizeof st);    if (find(i)) res ++ ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="试除法判定质数-——-模板题-AcWing-866-试除法判定质数"><a href="#试除法判定质数-——-模板题-AcWing-866-试除法判定质数" class="headerlink" title="试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数"></a>试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数</h3><pre class="line-numbers language-c++"><code class="language-c++">bool is_prime(int x){    if (x < 2) return false;    for (int i = 2; i <= x / i; i ++ )        if (x % i == 0)            return false;    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="试除法分解质因数-——-模板题-AcWing-867-分解质因数"><a href="#试除法分解质因数-——-模板题-AcWing-867-分解质因数" class="headerlink" title="试除法分解质因数 —— 模板题 AcWing 867. 分解质因数"></a>试除法分解质因数 —— 模板题 AcWing 867. 分解质因数</h3><pre class="line-numbers language-c++"><code class="language-c++">void divide(int x){    for (int i = 2; i <= x / i; i ++ )        if (x % i == 0)        {            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout << i << ' ' << s << endl;        }    if (x > 1) cout << x << ' ' << 1 << endl;    cout << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="朴素筛法求素数-——-模板题-AcWing-868-筛质数"><a href="#朴素筛法求素数-——-模板题-AcWing-868-筛质数" class="headerlink" title="朴素筛法求素数 —— 模板题 AcWing 868. 筛质数"></a>朴素筛法求素数 —— 模板题 AcWing 868. 筛质数</h3><pre class="line-numbers language-c++"><code class="language-c++">int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i <= n; i ++ )    {        if (st[i]) continue;        primes[cnt ++ ] = i;        for (int j = i + i; j <= n; j += i)            st[j] = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性筛法求素数-——-模板题-AcWing-868-筛质数"><a href="#线性筛法求素数-——-模板题-AcWing-868-筛质数" class="headerlink" title="线性筛法求素数 —— 模板题 AcWing 868. 筛质数"></a>线性筛法求素数 —— 模板题 AcWing 868. 筛质数</h3><pre class="line-numbers language-c++"><code class="language-c++">int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i <= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] <= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="试除法求所有约数-——-模板题-AcWing-869-试除法求约数"><a href="#试除法求所有约数-——-模板题-AcWing-869-试除法求约数" class="headerlink" title="试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数"></a>试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数</h3><pre class="line-numbers language-c++"><code class="language-c++">vector<int> get_divisors(int x){    vector<int> res;    for (int i = 1; i <= x / i; i ++ )        if (x % i == 0)        {            res.push_back(i);            if (i != x / i) res.push_back(x / i);        }    sort(res.begin(), res.end());    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="约数个数和约数之和-——-模板题-AcWing-870-约数个数-AcWing-871-约数之和"><a href="#约数个数和约数之和-——-模板题-AcWing-870-约数个数-AcWing-871-约数之和" class="headerlink" title="约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和"></a>约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和</h3><p>如果 N = p1^c1 <em> p2^c2 </em> … <em>pk^ck<br>约数个数： (c1 + 1) </em> (c2 + 1) <em> … </em> (ck + 1)<br>约数之和： (p1^0 + p1^1 + … + p1^c1) <em> … </em> (pk^0 + pk^1 + … + pk^ck)</p><h3 id="欧几里得算法-——-模板题-AcWing-872-最大公约数"><a href="#欧几里得算法-——-模板题-AcWing-872-最大公约数" class="headerlink" title="欧几里得算法 —— 模板题 AcWing 872. 最大公约数"></a>欧几里得算法 —— 模板题 AcWing 872. 最大公约数</h3><pre class="line-numbers language-c++"><code class="language-c++">int gcd(int a, int b){    return b ? gcd(b, a % b) : a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求欧拉函数-——-模板题-AcWing-873-欧拉函数"><a href="#求欧拉函数-——-模板题-AcWing-873-欧拉函数" class="headerlink" title="求欧拉函数 —— 模板题 AcWing 873. 欧拉函数"></a>求欧拉函数 —— 模板题 AcWing 873. 欧拉函数</h3><pre class="line-numbers language-c++"><code class="language-c++">int phi(int x){    int res = x;    for (int i = 2; i <= x / i; i ++ )        if (x % i == 0)        {            res = res / i * (i - 1);            while (x % i == 0) x /= i;        }    if (x > 1) res = res / x * (x - 1);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="筛法求欧拉函数-——-模板题-AcWing-874-筛法求欧拉函数"><a href="#筛法求欧拉函数-——-模板题-AcWing-874-筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数"></a>筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数</h3><pre class="line-numbers language-c++"><code class="language-c++">int primes[N], cnt;     // primes[]存储所有素数int euler[N];           // 存储每个数的欧拉函数bool st[N];         // st[x]存储x是否被筛掉void get_eulers(int n){    euler[1] = 1;    for (int i = 2; i <= n; i ++ )    {        if (!st[i])        {            primes[cnt ++ ] = i;            euler[i] = i - 1;        }        for (int j = 0; primes[j] <= n / i; j ++ )        {            int t = primes[j] * i;            st[t] = true;            if (i % primes[j] == 0)            {                euler[t] = euler[i] * primes[j];                break;            }            euler[t] = euler[i] * (primes[j] - 1);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速幂-——-模板题-AcWing-875-快速幂"><a href="#快速幂-——-模板题-AcWing-875-快速幂" class="headerlink" title="快速幂 —— 模板题 AcWing 875. 快速幂"></a>快速幂 —— 模板题 AcWing 875. 快速幂</h3><p>求 m^k mod p，时间复杂度 O(logk)。</p><pre class="line-numbers language-c++"><code class="language-c++">int qmi(int m, int k, int p){    int res = 1 % p, t = m;    while (k)    {        if (k&1) res = res * t % p;        t = t * t % p;        k >>= 1;    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展欧几里得算法-——-模板题-AcWing-877-扩展欧几里得算法"><a href="#扩展欧几里得算法-——-模板题-AcWing-877-扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法"></a>扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法</h3><p>// 求x, y，使得ax + by = gcd(a, b)</p><pre class="line-numbers language-c++"><code class="language-c++">int exgcd(int a, int b, int &x, int &y){    if (!b)    {        x = 1; y = 0;        return a;    }    int d = exgcd(b, a % b, y, x);    y -= (a/b) * x;    return d;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高斯消元-——-模板题-AcWing-883-高斯消元解线性方程组"><a href="#高斯消元-——-模板题-AcWing-883-高斯消元解线性方程组" class="headerlink" title="高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组"></a>高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组</h3><pre class="line-numbers language-c++"><code class="language-c++">// a[N][N]是增广矩阵int gauss(){    int c, r;    for (c = 0, r = 0; c < n; c ++ )    {        int t = r;        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行            if (fabs(a[i][c]) > fabs(a[t][c]))                t = i;        if (fabs(a[t][c]) < eps) continue;        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0            if (fabs(a[i][c]) > eps)                for (int j = n; j >= c; j -- )                    a[i][j] -= a[r][j] * a[i][c];        r ++ ;    }    if (r < n)    {        for (int i = r; i < n; i ++ )            if (fabs(a[i][n]) > eps)               return 2; // 无解        return 1; // 有无穷多组解    }    for (int i = n - 1; i >= 0; i -- )        for (int j = i + 1; j < n; j ++ )            a[i][n] -= a[i][j] * a[j][n];    return 0; // 有唯一解}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归法求组合数-——-模板题-AcWing-885-求组合数-I"><a href="#递归法求组合数-——-模板题-AcWing-885-求组合数-I" class="headerlink" title="递归法求组合数 —— 模板题 AcWing 885. 求组合数 I"></a>递归法求组合数 —— 模板题 AcWing 885. 求组合数 I</h3><pre class="line-numbers language-c++"><code class="language-c++">// c[a][b] 表示从a个苹果中选b个的方案数for (int i = 0; i < N; i ++ )    for (int j = 0; j <= i; j ++ )        if (!j) c[i][j] = 1;        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过预处理逆元的方式求组合数-——-模板题-AcWing-886-求组合数-II"><a href="#通过预处理逆元的方式求组合数-——-模板题-AcWing-886-求组合数-II" class="headerlink" title="通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II"></a>通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II</h3><p>首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元</p><pre class="line-numbers language-c++"><code class="language-c++">int qmi(int a, int k, int p)    // 快速幂模板{    int res = 1;    while (k)   {        if (k & 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k >>= 1;    }    return res;}// 预处理阶乘的余数和阶乘逆元的余数fact[0] = infact[0] = 1;for (int i = 1; i < N; i ++ ){    fact[i] = (LL)fact[i - 1] * i % mod;    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;}Lucas定理 —— 模板题 AcWing 887. 求组合数 III若p是质数，则对于任意整数 1 <= m <= n，有：    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)int qmi(int a, int k, int p)  // 快速幂模板{    int res = 1 % p;    while (k)    {        if (k & 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k >>= 1;    }    return res;}int C(int a, int b, int p)  // 通过定理求组合数C(a, b){    if (a < b) return 0;    LL x = 1, y = 1;  // x是分子，y是分母    for (int i = a, j = 1; j <= b; i --, j ++ )    {        x = (LL)x * i % p;        y = (LL) y * j % p;    }    return x * (LL)qmi(y, p - 2, p) % p;}int lucas(LL a, LL b, int p){    if (a < p && b < p) return C(a, b, p);    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分解质因数法求组合数-——-模板题-AcWing-888-求组合数-IV"><a href="#分解质因数法求组合数-——-模板题-AcWing-888-求组合数-IV" class="headerlink" title="分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV"></a>分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV</h3><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p><pre><code>   1. 筛法求出范围内的所有质数      2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...         3. 用高精度乘法将所有质因子相乘</code></pre><pre class="line-numbers language-c++"><code class="language-c++">int primes[N], cnt;     // 存储所有质数int sum[N];     // 存储每个质数的次数bool st[N];     // 存储每个数是否已被筛掉void get_primes(int n)      // 线性筛法求素数{    for (int i = 2; i <= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] <= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}int get(int n, int p)       // 求n！中的次数{    int res = 0;    while (n)    {        res += n / p;        n /= p;    }    return res;}vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板{    vector<int> c;    int t = 0;    for (int i = 0; i < a.size(); i ++ )    {        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    }    while (t)    {        c.push_back(t % 10);        t /= 10;    }   return c;}get_primes(a);  // 预处理范围内的所有质数for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数{    int p = primes[i];    sum[i] = get(a, p) - get(b, p) - get(a - b, p);}vector<int> res;res.push_back(1);for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘    for (int j = 0; j < sum[i]; j ++ )        res = mul(res, primes[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="卡特兰数-——-模板题-AcWing-889-满足条件的01序列"><a href="#卡特兰数-——-模板题-AcWing-889-满足条件的01序列" class="headerlink" title="卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列"></a>卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列</h3><p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)</p><h3 id="NIM游戏-——-模板题-AcWing-891-Nim游戏"><a href="#NIM游戏-——-模板题-AcWing-891-Nim游戏" class="headerlink" title="NIM游戏 —— 模板题 AcWing 891. Nim游戏"></a>NIM游戏 —— 模板题 AcWing 891. Nim游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p><strong>定理</strong>： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</p><h3 id="公平组合游戏ICG"><a href="#公平组合游戏ICG" class="headerlink" title="公平组合游戏ICG"></a>公平组合游戏ICG</h3><p>若一个游戏满足：</p><p>由两名玩家交替行动；<br>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；<br>不能行动的玩家判负；<br>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h3><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h3 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h3><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) = min{x}, x属于自然数，且x不属于S</p><h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。</p><h3 id="有向图游戏的和-——-模板题-AcWing-893-集合-Nim游戏"><a href="#有向图游戏的和-——-模板题-AcWing-893-集合-Nim游戏" class="headerlink" title="有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏"></a>有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏</h3><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p><p><strong>定理</strong><br>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于神经网络与深度学习</title>
      <link href="/2021/06/25/deeplearning/"/>
      <url>/2021/06/25/deeplearning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小时候，每个人都会鼓励不断成长</p><p>变成一个心智成熟，不在耍小孩子脾气的人</p><p>但是，<strong>很少有人鼓励继续成长</strong></p><p><strong>变成一个怀疑和抵制社会错误潮流的人</strong></p><p>——保罗•格雷厄姆《黑客与画家》</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong>课程</strong></p><p><a href="https://www.bilibili.com/video/BV164411b7dx?p=1" target="_blank" rel="noopener">b站[中英字幕]吴恩达机器学习系列课程</a></p><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习</a></p><p><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera深度学习</a></p><blockquote><p>主成分数据选择那里有一节课没有字幕，建议移步Coursera</p></blockquote><p><strong>黄海广笔记</strong></p><p><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener"><strong>Coursera深度学习教程中文笔记</strong></a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>斯坦福大学2014（吴恩达）机器学习教程中文笔记</strong></a></p><p><strong>其他</strong></p><p><a href="https://henryavery.cn/2021/01/25/ml/">我的机器学习笔记</a></p><p><a href="https://nndl.github.io/" target="_blank" rel="noopener">神经网络与深度学习邱席鹏</a></p><blockquote><p>27个小时，集中时间的话三天左右看完。估计分散在一周时间内吧。</p></blockquote><iframe src="//player.bilibili.com/player.html?aid=926316362&bvid=BV1FT4y1E74V&cid=216510190&page=183" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="第一门课-神经网络和深度学习-Neural-Networks-and-Deep-Learning"><a href="#第一门课-神经网络和深度学习-Neural-Networks-and-Deep-Learning" class="headerlink" title="第一门课 神经网络和深度学习(Neural Networks and Deep Learning)"></a>第一门课 神经网络和深度学习(Neural Networks and Deep Learning)</h1><h2 id="第一周：深度学习引言-Introduction-to-Deep-Learning"><a href="#第一周：深度学习引言-Introduction-to-Deep-Learning" class="headerlink" title="第一周：深度学习引言(Introduction to Deep Learning)"></a><strong>第一周：深度学习引言(Introduction to Deep Learning)</strong></h2><h2 id="第二周：神经网络的编程基础-Basics-of-Neural-Network-programming"><a href="#第二周：神经网络的编程基础-Basics-of-Neural-Network-programming" class="headerlink" title="第二周：神经网络的编程基础(Basics of Neural Network programming)"></a>第二周：神经网络的编程基础(Basics of Neural Network programming)</h2><h3 id="2-1-二分类-Binary-Classification"><a href="#2-1-二分类-Binary-Classification" class="headerlink" title="2.1 二分类(Binary Classification)"></a><strong>2.1 二分类(Binary Classification)</strong></h3><h3 id="2-2-逻辑回归-Logistic-Regression"><a href="#2-2-逻辑回归-Logistic-Regression" class="headerlink" title="2.2 逻辑回归(Logistic Regression)"></a><strong>2.2 逻辑回归(Logistic Regression)</strong></h3><h3 id="2-3-逻辑回归的代价函数（Logistic-Regress）"><a href="#2-3-逻辑回归的代价函数（Logistic-Regress）" class="headerlink" title="2.3 逻辑回归的代价函数（Logistic Regress）"></a><strong>2.3 逻辑回归的代价函数（Logistic Regress）</strong></h3><p>损失函数又叫做误差函数，用来衡量算法的运行情况，Loss function</p><p>练样本中表现如何，为了衡量算法在全部训练样本上的表现如何，我们需要定义一个算法的代价函数cost function</p><h3 id="2-4-梯度下降法（Gradient-Descent）"><a href="#2-4-梯度下降法（Gradient-Descent）" class="headerlink" title="2.4 梯度下降法（Gradient Descent）"></a><strong>2.4 梯度下降法（Gradient Descent）</strong></h3><h3 id="2-9-逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）"><a href="#2-9-逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）" class="headerlink" title="2.9 逻辑回归中的梯度下降（Logistic Regression Gradient Descent）"></a><strong>2.9 逻辑回归中的梯度下降（Logistic Regression Gradient Descent）</strong></h3><h3 id="2-10-m-个样本的梯度下降-Gradient-Descent-on-m-Examples"><a href="#2-10-m-个样本的梯度下降-Gradient-Descent-on-m-Examples" class="headerlink" title="2.10  m 个样本的梯度下降(Gradient Descent on m Examples)"></a><strong>2.10  m 个样本的梯度下降(Gradient Descent on m Examples)</strong></h3><h3 id="2-11-向量化-Vectorization"><a href="#2-11-向量化-Vectorization" class="headerlink" title="2.11 向量化(Vectorization)"></a><strong>2.11 向量化(Vectorization)</strong></h3><h3 id="2-13-向量化逻辑回归-Vectorizing-Logistic-Regression"><a href="#2-13-向量化逻辑回归-Vectorizing-Logistic-Regression" class="headerlink" title="2.13 向量化逻辑回归(Vectorizing Logistic Regression)"></a><strong>2.13 向量化逻辑回归(Vectorizing Logistic Regression)</strong></h3><h3 id="2-14-向量化-logistic-回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）"><a href="#2-14-向量化-logistic-回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）" class="headerlink" title="2.14 向量化 logistic 回归的梯度输出（Vectorizing Logistic Regression’s Gradient）"></a><strong>2.14 向量化 logistic 回归的梯度输出（Vectorizing Logistic Regression’s Gradient）</strong></h3><h2 id="第三周：浅层神经网络-Shallow-neural-networks"><a href="#第三周：浅层神经网络-Shallow-neural-networks" class="headerlink" title="第三周：浅层神经网络(Shallow neural networks)"></a>第三周：浅层神经网络(Shallow neural networks)</h2><h3 id="3-1-神经网络概述（Neural-Network-Overview）"><a href="#3-1-神经网络概述（Neural-Network-Overview）" class="headerlink" title="3.1 神经网络概述（Neural Network Overview）"></a><strong>3.1 神经网络概述（Neural Network Overview）</strong></h3><h3 id="3-2-神经网络的表示（Neural-Network-Representation）"><a href="#3-2-神经网络的表示（Neural-Network-Representation）" class="headerlink" title="3.2 神经网络的表示（Neural Network Representation）"></a><strong>3.2 神经网络的表示（Neural Network Representation）</strong></h3><h3 id="3-3-计算一个神经网络的输出（Computing-a-Neural-Network’s-output）"><a href="#3-3-计算一个神经网络的输出（Computing-a-Neural-Network’s-output）" class="headerlink" title="3.3 计算一个神经网络的输出（Computing a Neural Network’s output）"></a><strong>3.3 计算一个神经网络的输出（Computing a Neural Network’s output）</strong></h3><h3 id="3-4-多样本向量化（Vectorizing-across-multiple-examples）"><a href="#3-4-多样本向量化（Vectorizing-across-multiple-examples）" class="headerlink" title="3.4 多样本向量化（Vectorizing across multiple examples）"></a><strong>3.4 多样本向量化（Vectorizing across multiple examples）</strong></h3><h3 id="3-5-向量化实现的解释（Justification-for-vectorized-implementation）"><a href="#3-5-向量化实现的解释（Justification-for-vectorized-implementation）" class="headerlink" title="3.5 向量化实现的解释（Justification for vectorized implementation）"></a><strong>3.5 向量化实现的解释（Justification for vectorized implementation）</strong></h3><h3 id="3-6-激活函数（Activation-functions）"><a href="#3-6-激活函数（Activation-functions）" class="headerlink" title="3.6 激活函数（Activation functions）"></a><strong>3.6 激活函数（Activation functions）</strong></h3><p><strong>tanh</strong>函数或者双曲正切函数是总体上都优于<strong>sigmoid</strong>函数的激活函数。</p><p><strong>sigmoid</strong>函数和<strong>tanh</strong>函数两者共同的缺点是，在$z$特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于0，导致降低梯度下降的速度。</p><p>在机器学习另一个很流行的函数是：修正线性单元的函数（<strong>ReLu</strong>）</p><p>如果输出是0、1值（二分类问题），则输出层选择<strong>sigmoid</strong>函数，然后其它的所有单元都选择<strong>Relu</strong>函数。</p><p>这是很多激活函数的默认选择，如果在隐藏层上不确定使用哪个激活函数，那么通常会使用<strong>Relu</strong>激活函数。有时，也会使用<strong>tanh</strong>激活函数，但<strong>Relu</strong>的一个优点是：当$z$是负值的时候，导数等于0。</p><p>这里也有另一个版本的<strong>Relu</strong>被称为<strong>Leaky Relu</strong>。</p><p>当$z$是负值时，这个函数的值不是等于0，而是轻微的倾斜。</p><p>如图。（图在心中）</p><p>两者的优点是：</p><p>第一，在$z$的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个<strong>if-else</strong>语句，而<strong>sigmoid</strong>函数需要进行浮点四则运算，在实践中，使用<strong>ReLu</strong>激活函数神经网络通常会比使用<strong>sigmoid</strong>或者<strong>tanh</strong>激活函数学习的更快。</p><p>第二，<strong>sigmoid</strong>和<strong>tanh</strong>函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而<strong>Relu</strong>和<strong>Leaky ReLu</strong>函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，<strong>Relu</strong>进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而<strong>Leaky ReLu</strong>不会有这问题)</p><p>$z$在<strong>ReLu</strong>的梯度一半都是0，但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。</p><p>快速概括一下不同激活函数的过程和结论。</p><p><strong>sigmoid</strong>激活函数：除了输出层是一个二分类问题基本不会用它。</p><p><strong>tanh</strong>激活函数：<strong>tanh</strong>是非常优秀的，几乎适合所有场合。</p><p><strong>ReLu</strong>激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用<strong>ReLu</strong>或者<strong>Leaky ReLu</strong>。</p><h3 id="3-7-为什么需要非线性激活函数？（why-need-a-nonlinear-activation-function-）"><a href="#3-7-为什么需要非线性激活函数？（why-need-a-nonlinear-activation-function-）" class="headerlink" title="3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?）"></a><strong>3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?）</strong></h3><h3 id="3-8-激活函数的导数（Derivatives-of-activation-functions）"><a href="#3-8-激活函数的导数（Derivatives-of-activation-functions）" class="headerlink" title="3.8 激活函数的导数（Derivatives of activation functions）"></a><strong>3.8 激活函数的导数（Derivatives of activation functions）</strong></h3><h3 id="3-9-神经网络的梯度下降（Gradient-descent-for-neural-networks）"><a href="#3-9-神经网络的梯度下降（Gradient-descent-for-neural-networks）" class="headerlink" title="3.9 神经网络的梯度下降（Gradient descent for neural networks）"></a><strong>3.9 神经网络的梯度下降（Gradient descent for neural networks）</strong></h3><h3 id="3-10（选修）直观理解反向传播（Backpropagation-intuition）"><a href="#3-10（选修）直观理解反向传播（Backpropagation-intuition）" class="headerlink" title="3.10（选修）直观理解反向传播（Backpropagation intuition）"></a><strong>3.10（选修）直观理解反向传播（Backpropagation intuition）</strong></h3><p>看懂逻辑回归就清楚了，主要是梯度下降用到loss function对某参数的导数来更新，求导就是链式法则，神经网络就是矩阵求导。</p><h3 id="3-11-随机初始化（Random-Initialization）"><a href="#3-11-随机初始化（Random-Initialization）" class="headerlink" title="3.11 随机初始化（Random+Initialization）"></a><strong>3.11 随机初始化（Random+Initialization）</strong></h3><p>如果$W$很大，$z$就会很大或者很小，因此这种情况下你很可能停在<strong>tanh</strong>/<strong>sigmoid</strong>函数的平坦的地方(见图3.8.2)，这些地方梯度很小也就意味着梯度下降会很慢，因此学习也就很慢。</p><p>事实上有时有比0.01更好的常数，当你训练一个只有一层隐藏层的网络时（这是相对浅的神经网络，没有太多的隐藏层），设为0.01可能也可以。但当你训练一个非常非常深的神经网络，你可能要试试0.01以外的常数。下一节课我们会讨论怎么并且何时去选择一个不同于0.01的常数，但是无论如何它通常都会是个相对小的数。</p><h2 id="第四周：深层神经网络-Deep-Neural-Networks"><a href="#第四周：深层神经网络-Deep-Neural-Networks" class="headerlink" title="第四周：深层神经网络(Deep Neural Networks)"></a>第四周：深层神经网络(Deep Neural Networks)</h2><h3 id="4-1-深层神经网络（Deep-L-layer-neural-network）"><a href="#4-1-深层神经网络（Deep-L-layer-neural-network）" class="headerlink" title="4.1 深层神经网络（Deep L-layer neural network）"></a>4.1 深层神经网络（Deep L-layer neural network）</h3><h3 id="4-2-前向传播和反向传播（Forward-and-backward-propagation）"><a href="#4-2-前向传播和反向传播（Forward-and-backward-propagation）" class="headerlink" title="4.2 前向传播和反向传播（Forward and backward propagation）"></a>4.2 前向传播和反向传播（Forward and backward propagation）</h3><h3 id="4-3-深层网络中的前向传播（Forward-propagation-in-a-Deep-Network）"><a href="#4-3-深层网络中的前向传播（Forward-propagation-in-a-Deep-Network）" class="headerlink" title="4.3 深层网络中的前向传播（Forward propagation in a Deep Network）"></a>4.3 深层网络中的前向传播（Forward propagation in a Deep Network）</h3><h3 id="4-4-核对矩阵的维数（Getting-your-matrix-dimensions-right）"><a href="#4-4-核对矩阵的维数（Getting-your-matrix-dimensions-right）" class="headerlink" title="4.4 核对矩阵的维数（Getting your matrix dimensions right）"></a>4.4 核对矩阵的维数（Getting your matrix dimensions right）</h3><h3 id="4-5-为什么使用深层表示？（Why-deep-representations-）"><a href="#4-5-为什么使用深层表示？（Why-deep-representations-）" class="headerlink" title="4.5 为什么使用深层表示？（Why deep representations?）"></a>4.5 为什么使用深层表示？（Why deep representations?）</h3><h3 id="4-6-搭建神经网络块（Building-blocks-of-deep-neural-networks）"><a href="#4-6-搭建神经网络块（Building-blocks-of-deep-neural-networks）" class="headerlink" title="4.6 搭建神经网络块（Building blocks of deep neural networks）"></a>4.6 搭建神经网络块（Building blocks of deep neural networks）</h3><h3 id="4-7-参数VS超参数（Parameters-vs-Hyperparameters）"><a href="#4-7-参数VS超参数（Parameters-vs-Hyperparameters）" class="headerlink" title="4.7 参数VS超参数（Parameters vs Hyperparameters）"></a>4.7 参数VS超参数（Parameters vs Hyperparameters）</h3><h3 id="4-8-深度学习和大脑的关联性（What-does-this-have-to-do-with-the-brain-）"><a href="#4-8-深度学习和大脑的关联性（What-does-this-have-to-do-with-the-brain-）" class="headerlink" title="4.8 深度学习和大脑的关联性（What does this have to do with the brain?）"></a>4.8 深度学习和大脑的关联性（What does this have to do with the brain?）</h3><h1 id="第二门课-改善深层神经网络：超参数调试、正则化以及优化-Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization"><a href="#第二门课-改善深层神经网络：超参数调试、正则化以及优化-Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization" class="headerlink" title="第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)"></a>第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)</h1><h2 id="第一周：深度学习的实践层面-Practical-aspects-of-Deep-Learning"><a href="#第一周：深度学习的实践层面-Practical-aspects-of-Deep-Learning" class="headerlink" title="第一周：深度学习的实践层面(Practical aspects of Deep Learning)"></a>第一周：深度学习的实践层面(Practical aspects of Deep Learning)</h2><h3 id="1-1-训练，验证，测试集（Train-Dev-Test-sets）"><a href="#1-1-训练，验证，测试集（Train-Dev-Test-sets）" class="headerlink" title="1.1 训练，验证，测试集（Train / Dev / Test sets）"></a>1.1 训练，验证，测试集（Train / Dev / Test sets）</h3><p>比如我们有100万条数据，那么取1万条数据便足以进行评估，找出其中表现最好的1-2种算法。同样地，根据最终选择的分类器，测试集的主要目的是正确评估分类器的性能，所以，如果拥有百万数据，我们只需要1000条数据，便足以评估单个分类器，并且准确评估该分类器的性能。假设我们有100万条数据，其中1万条作为验证集，1万条作为测试集，100万里取1万，比例是1%，即：训练集占98%，验证集和测试集各占1%。对于数据量过百万的应用，训练集可以占到99.5%，验证和测试集各占0.25%，或者验证集占0.4%，测试集占0.1%。</p><p>根据经验，我建议大家要确保验证集和测试集的数据来自<strong>同一分布</strong>，关于这个问题我也会多讲一些。因为你们要用验证集来评估不同的模型，尽可能地优化性能。如果验证集和测试集来自同一个分布就会很好。</p><h3 id="1-2-偏差，方差（Bias-Variance）"><a href="#1-2-偏差，方差（Bias-Variance）" class="headerlink" title="1.2 偏差，方差（Bias /Variance）"></a>1.2 偏差，方差（Bias /Variance）</h3><p>高偏差（<strong>high bias</strong>）的情况，我们称为“欠拟合”（<strong>underfitting</strong>）。</p><p>方差较高（<strong>high variance</strong>），数据过度拟合（<strong>overfitting</strong>）。</p><p>理解偏差和方差的两个关键数据是训练集误差（<strong>Train set error</strong>）和验证集误差（<strong>Dev set error</strong>）</p><p>假定训练集误差是1%，为了方便论证，假定验证集误差是11%，可以看出训练集设置得非常好，而验证集设置相对较差，我们可能过度拟合了训练集，在某种程度上，验证集并没有充分利用交叉验证集的作用，像这种情况，我们称之为“高方差”。</p><p>通过查看训练集误差和验证集误差，我们便可以诊断算法是否具有高方差。也就是说衡量训练集和验证集误差就可以得出不同结论。</p><p>假设训练集误差是15%，我们把训练集误差写在首行，验证集误差是16%，假设该案例中人的错误率几乎为0%，人们浏览这些图片，分辨出是不是猫。算法并没有在训练集中得到很好训练，如果训练数据的拟合度不高，就是数据欠拟合，就可以说这种算法偏差比较高。相反，它对于验证集产生的结果却是合理的，验证集中的错误率只比训练集的多了1%，所以这种算法偏差高，因为它甚至不能拟合训练集</p><p>再举一个例子，训练集误差是15%，偏差相当高，但是，验证集的评估结果更糟糕，错误率达到30%，在这种情况下，我会认为这种算法偏差高，因为它在训练集上结果不理想，而且方差也很高，这是方差偏差都很糟糕的情况。</p><h3 id="1-3-机器学习基础（Basic-Recipe-for-Machine-Learning）"><a href="#1-3-机器学习基础（Basic-Recipe-for-Machine-Learning）" class="headerlink" title="1.3 机器学习基础（Basic Recipe for Machine Learning）"></a>1.3 机器学习基础（Basic Recipe for Machine Learning）</h3><h3 id="1-4-正则化（Regularization）"><a href="#1-4-正则化（Regularization）" class="headerlink" title="1.4 正则化（Regularization）"></a>1.4 正则化（Regularization）</h3><p>深度学习可能存在过拟合问题——高方差，有两个解决方法，<strong>一个是正则化，另一个是准备更多的数据</strong>，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。</p><blockquote><p>今天上午起晚了，进度拖慢了，然后又改了一手cnn模型的代码。明天上午再看。今天晚上休息一会。</p></blockquote><h3 id="1-5-为什么正则化有利于预防过拟合呢？（Why-regularization-reduces-overfitting-）"><a href="#1-5-为什么正则化有利于预防过拟合呢？（Why-regularization-reduces-overfitting-）" class="headerlink" title="1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）"></a>1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）</h3><h3 id="1-6-dropout-正则化（Dropout-Regularization）"><a href="#1-6-dropout-正则化（Dropout-Regularization）" class="headerlink" title="1.6 dropout 正则化（Dropout Regularization）"></a>1.6 dropout 正则化（Dropout Regularization）</h3><p>除了$L2$正则化，还有一个非常实用的正则化方法——“<strong>Dropout</strong>（随机失活）”</p><h3 id="1-7-理解-dropout（Understanding-Dropout）"><a href="#1-7-理解-dropout（Understanding-Dropout）" class="headerlink" title="1.7 理解 dropout（Understanding Dropout）"></a>1.7 理解 dropout（Understanding Dropout）</h3><p><strong>Dropout</strong>可以随机删除网络中的神经单元，他为什么可以通过正则化发挥如此大的作用呢？</p><p>直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，通过传播所有权重，<strong>dropout</strong>将产生收缩权重的平方范数的效果，和之前讲的$L2$正则化类似；实施<strong>dropout</strong>的结果实它会压缩权重，并完成一些预防过拟合的外层正则化；$L2$对不同权重的衰减是不同的，它取决于激活函数倍增的大小。</p><h3 id="1-8-其他正则化方法（Other-regularization-methods）"><a href="#1-8-其他正则化方法（Other-regularization-methods）" class="headerlink" title="1.8 其他正则化方法（Other regularization methods）"></a>1.8 其他正则化方法（Other regularization methods）</h3><h3 id="1-9-归一化输入（Normalizing-inputs）"><a href="#1-9-归一化输入（Normalizing-inputs）" class="headerlink" title="1.9 归一化输入（Normalizing inputs）"></a>1.9 归一化输入（Normalizing inputs）</h3><h3 id="1-10-梯度消失-梯度爆炸（Vanishing-Exploding-gradients）"><a href="#1-10-梯度消失-梯度爆炸（Vanishing-Exploding-gradients）" class="headerlink" title="1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）"></a>1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）</h3><h3 id="1-11-神经网络的权重初始化（Weight-Initialization-for-Deep-NetworksVanishing-Exploding-gradients）"><a href="#1-11-神经网络的权重初始化（Weight-Initialization-for-Deep-NetworksVanishing-Exploding-gradients）" class="headerlink" title="1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing / Exploding gradients）"></a>1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing / Exploding gradients）</h3><h3 id="1-12-梯度的数值逼近（Numerical-approximation-of-gradients）"><a href="#1-12-梯度的数值逼近（Numerical-approximation-of-gradients）" class="headerlink" title="1.12 梯度的数值逼近（Numerical approximation of gradients）"></a>1.12 梯度的数值逼近（Numerical approximation of gradients）</h3><h3 id="1-13-梯度检验（Gradient-checking）"><a href="#1-13-梯度检验（Gradient-checking）" class="headerlink" title="1.13 梯度检验（Gradient checking）"></a>1.13 梯度检验（Gradient checking）</h3><h3 id="1-14-梯度检验应用的注意事项（Gradient-Checking-Implementation-Notes）"><a href="#1-14-梯度检验应用的注意事项（Gradient-Checking-Implementation-Notes）" class="headerlink" title="1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes）"></a>1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes）</h3><h2 id="第二周：优化算法-Optimization-algorithms"><a href="#第二周：优化算法-Optimization-algorithms" class="headerlink" title="第二周：优化算法 (Optimization algorithms)"></a>第二周：优化算法 (Optimization algorithms)</h2><h3 id="2-1-Mini-batch-梯度下降（Mini-batch-gradient-descent）"><a href="#2-1-Mini-batch-梯度下降（Mini-batch-gradient-descent）" class="headerlink" title="2.1 Mini-batch 梯度下降（Mini-batch gradient descent）"></a>2.1 Mini-batch 梯度下降（Mini-batch gradient descent）</h3><p>首先，如果训练集较小，直接使用<strong>batch</strong>梯度下降法，样本集较小就没必要使用<strong>mini-batch</strong>梯度下降法，你可以快速处理整个训练集，所以使用<strong>batch</strong>梯度下降法也很好，这里的少是说小于2000个样本，这样比较适合使用<strong>batch</strong>梯度下降法。不然，样本数目较大的话，一般的<strong>mini-batch</strong>大小为64到512，考虑到电脑内存设置和使用的方式，如果<strong>mini-batch</strong>大小是2的$n$次方，代码会运行地快一些，64就是2的6次方，以此类推，128是2的7次方，256是2的8次方，512是2的9次方。所以我经常把<strong>mini-batch</strong>大小设成2的次方。</p><p><strong>mini-batch</strong>梯度下降法比<strong>batch</strong>梯度下降法运行地更快。</p><h3 id="2-2-理解mini-batch梯度下降法（Understanding-mini-batch-gradient-descent）"><a href="#2-2-理解mini-batch梯度下降法（Understanding-mini-batch-gradient-descent）" class="headerlink" title="2.2 理解mini-batch梯度下降法（Understanding mini-batch gradient descent）"></a>2.2 理解mini-batch梯度下降法（Understanding mini-batch gradient descent）</h3><p>使用<strong>batch</strong>梯度下降法时，每次迭代你都需要历遍整个训练集，可以预期每次迭代成本都会下降，所以如果成本函数$J$是迭代次数的一个函数，它应该会随着每次迭代而减少，如果$J$在某次迭代中增加了，那肯定出了问题，也许你的学习率太大。</p><p>使用<strong>mini-batch</strong>梯度下降法，如果你作出成本函数在整个过程中的图，则并不是每次迭代都是下降的</p><p>另一个极端情况，假设<strong>mini-batch</strong>大小为1，就有了新的算法，叫做随机梯度下降法，每个样本都是独立的<strong>mini-batch</strong></p><h3 id="2-3-指数加权平均数（Exponentially-weighted-averages）"><a href="#2-3-指数加权平均数（Exponentially-weighted-averages）" class="headerlink" title="2.3 指数加权平均数（Exponentially weighted averages）"></a>2.3 指数加权平均数（Exponentially weighted averages）</h3><p>指数加权平均数经常被使用，再说一次，它在统计学中被称为指数加权移动平均值，我们就简称为指数加权平均数。通过调整这个参数（$\beta$），或者说后面的算法学习，你会发现这是一个很重要的参数，可以取得稍微不同的效果，往往中间有某个值效果最好</p><h3 id="2-4-理解指数加权平均数（Understanding-exponentially-weighted-averages）"><a href="#2-4-理解指数加权平均数（Understanding-exponentially-weighted-averages）" class="headerlink" title="2.4 理解指数加权平均数（Understanding exponentially weighted averages）"></a>2.4 理解指数加权平均数（Understanding exponentially weighted averages）</h3><p>指数加权平均数公式的好处之一在于，它占用极少内存，电脑内存中只占用一行数字而已，然后把最新数据代入公式，不断覆盖就可以了，正因为这个原因，其效率，它基本上只占用一行代码，计算指数加权平均数也只占用单行数字的存储和内存，当然它并不是最好的，也不是最精准的计算平均数的方法。如果你要计算移动窗，你直接算出过去10天的总和，过去50天的总和，除以10和50就好，如此往往会得到更好的估测。但缺点是，如果保存所有最近的温度数据，和过去10天的总和，必须占用更多的内存，执行更加复杂，计算成本也更加高昂。</p><h3 id="2-5-指数加权平均的偏差修正（Bias-correction-in-exponentially-weighted-averages）"><a href="#2-5-指数加权平均的偏差修正（Bias-correction-in-exponentially-weighted-averages）" class="headerlink" title="2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages）"></a>2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages）</h3><p>有个办法可以修改这一估测，让估测变得更好，更准确，特别是在估测初期，也就是不用$v_{t}$，而是用$\frac{v_{t}}{1- \beta^{t}}$，t就是现在的天数。</p><p>在机器学习中，在计算指数加权平均数的大部分时候，大家不在乎执行偏差修正，因为大部分人宁愿熬过初始时期，拿到具有偏差的估测，然后继续计算下去。如果你关心初始时期的偏差，在刚开始计算指数加权移动平均数的时候，偏差修正能帮助你在早期获取更好的估测。</p><h3 id="2-6-动量梯度下降法（Gradient-descent-with-Momentum）"><a href="#2-6-动量梯度下降法（Gradient-descent-with-Momentum）" class="headerlink" title="2.6 动量梯度下降法（Gradient descent with Momentum）"></a>2.6 动量梯度下降法（Gradient descent with Momentum）</h3><p>还有一种算法叫做<strong>Momentum</strong>，或者叫做动量梯度下降法，运行速度几乎总是快于标准的梯度下降算法，简而言之，基本的想法就是计算梯度的指数加权平均数，并利用该梯度更新你的权重</p><p>另一个看待问题的角度是，在纵轴上，你希望学习慢一点，因为你不想要这些摆动，但是在横轴上，你希望加快学习，你希望快速从左向右移，移向最小值，移向红点。</p><p>想象你有一个碗，你拿一个球，微分项给了这个球一个加速度，此时球正向山下滚，球因为加速度越滚越快，而因为$\beta$ 稍小于1，表现出一些摩擦力，所以球不会无限加速下去，所以不像梯度下降法，每一步都独立于之前的步骤，你的球可以向下滚，获得动量，可以从碗向下加速获得动量。我发现这个球从碗滚下的比喻，物理能力强的人接受得比较好，但不是所有人都能接受，如果球从碗中滚下这个比喻，你理解不了，别担心。</p><p>最后我们来看具体如何计算，算法在此。</p><p>你有两个超参数，学习率$a$以及参数$\beta$，$\beta$控制着指数加权平均数。$\beta$最常用的值是0.9，我们之前平均了过去十天的温度，所以现在平均了前十次迭代的梯度。实际上$\beta$为0.9时，效果不错，你可以尝试不同的值，可以做一些超参数的研究，不过0.9是很棒的鲁棒数。</p><h3 id="2-7-RMSprop"><a href="#2-7-RMSprop" class="headerlink" title="2.7 RMSprop"></a>2.7 RMSprop</h3><p>你们知道了动量（<strong>Momentum</strong>）可以加快梯度下降，还有一个叫做<strong>RMSprop</strong>的算法，全称是<strong>root mean square prop</strong>算法，它也可以加速梯度下降，我们来看看它是如何运作的。</p><p>该算法会照常计算当下<strong>mini-batch</strong>的微分$dW$，$db$，所以我会保留这个指数加权平均数，我们用到新符号$S_{dW}$，而不是$v_{dW}$，因此$S_{dW}= \beta S_{dW} + (1 -\beta) {dW}^{2}$，澄清一下，这个平方的操作是针对这一整个符号的，这样做能够保留微分平方的加权平均数，同样$S_{db}= \beta S_{db} + (1 - \beta){db}^{2}$，再说一次，平方是针对整个符号的操作。</p><p>接着<strong>RMSprop</strong>会这样更新参数值，$W:= W -a\frac{dW}{\sqrt{S_{dW}}}$，$b:=b -\alpha\frac{db}{\sqrt{S_{db}}}$，我们来理解一下其原理。记得在横轴方向或者在例子中的$W$方向，我们希望学习速度快，而在垂直方向，也就是例子中的$b$方向，我们希望减缓纵轴上的摆动，所以有了$S_{dW}$和$S_{db}$，我们希望$S_{dW}$会相对较小，所以我们要除以一个较小的数，而希望$S_{db}$又较大，所以这里我们要除以较大的数字，这样就可以减缓纵轴上的变化。你看这些微分，垂直方向的要比水平方向的大得多，所以斜率在$b$方向特别大，所以这些微分中，$db$较大，$dW$较小，因为函数的倾斜程度，在纵轴上，也就是b方向上要大于在横轴上，也就是$W$方向上。$db$的平方较大，所以$S_{db}$也会较大，而相比之下，$dW$会小一些，亦或$dW$平方会小一些，因此$S_{dW}$会小一些，结果就是纵轴上的更新要被一个较大的数相除，就能消除摆动，而水平方向的更新则被较小的数相除。</p><p>所以<strong>RMSprop</strong>跟<strong>Momentum</strong>有很相似的一点，可以消除梯度下降中的摆动，包括<strong>mini-batch</strong>梯度下降，并允许你使用一个更大的学习率$a$，从而加快你的算法学习速度。</p><h3 id="2-8-Adam-优化算法-Adam-optimization-algorithm"><a href="#2-8-Adam-优化算法-Adam-optimization-algorithm" class="headerlink" title="2.8 Adam 优化算法(Adam optimization algorithm)"></a>2.8 Adam 优化算法(Adam optimization algorithm)</h3><p>在深度学习的历史上，包括许多知名研究者在内，提出了优化算法，并很好地解决了一些问题，但随后这些优化算法被指出并不能一般化，并不适用于多种神经网络，时间久了，深度学习圈子里的人开始多少有些质疑全新的优化算法，很多人都觉得动量（<strong>Momentum</strong>）梯度下降法很好用，很难再想出更好的优化算法。所以<strong>RMSprop</strong>以及<strong>Adam</strong>优化算法（<strong>Adam</strong>优化算法也是本视频的内容），就是少有的经受住人们考验的两种算法，已被证明适用于不同的深度学习结构，这个算法我会毫不犹豫地推荐给你，因为很多人都试过，并且用它很好地解决了许多问题。</p><h3 id="2-9-学习率衰减-Learning-rate-decay"><a href="#2-9-学习率衰减-Learning-rate-decay" class="headerlink" title="2.9 学习率衰减(Learning rate decay)"></a>2.9 学习率衰减(Learning rate decay)</h3><h3 id="2-10-局部最优的问题-The-problem-of-local-optima"><a href="#2-10-局部最优的问题-The-problem-of-local-optima" class="headerlink" title="2.10 局部最优的问题(The problem of local optima)"></a>2.10 局部最优的问题(The problem of local optima)</h3><p>首先，你不太可能困在极差的局部最优中，条件是你在训练较大的神经网络，存在大量参数，并且成本函数$J$被定义在较高的维度空间。</p><p>第二点，平稳段是一个问题，这样使得学习十分缓慢，这也是像<strong>Momentum</strong>或是<strong>RMSprop</strong>，<strong>Adam</strong>这样的算法，能够加速学习算法的地方。在这些情况下，更成熟的优化算法，如<strong>Adam</strong>算法，能够加快速度，让你尽早往下走出平稳段。</p><h2 id="第三周-超参数调试、Batch正则化和程序框架（Hyperparameter-tuning）"><a href="#第三周-超参数调试、Batch正则化和程序框架（Hyperparameter-tuning）" class="headerlink" title="第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）"></a>第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）</h2><h3 id="3-1-调试处理（Tuning-process）"><a href="#3-1-调试处理（Tuning-process）" class="headerlink" title="3.1 调试处理（Tuning process）"></a>3.1 调试处理（Tuning process）</h3><h3 id="3-2-为超参数选择合适的范围（Using-an-appropriate-scale-to-pick-hyperparameters）"><a href="#3-2-为超参数选择合适的范围（Using-an-appropriate-scale-to-pick-hyperparameters）" class="headerlink" title="3.2 为超参数选择合适的范围（Using an appropriate scale to pick hyperparameters）"></a>3.2 为超参数选择合适的范围（Using an appropriate scale to pick hyperparameters）</h3><h3 id="3-3-超参数调试的实践：Pandas-VS-Caviar（Hyperparameters-tuning-in-practice-Pandas-vs-Caviar）"><a href="#3-3-超参数调试的实践：Pandas-VS-Caviar（Hyperparameters-tuning-in-practice-Pandas-vs-Caviar）" class="headerlink" title="3.3 超参数调试的实践：Pandas VS Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar）"></a>3.3 超参数调试的实践：Pandas VS Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar）</h3><h3 id="3-4-归一化网络的激活函数（Normalizing-activations-in-a-network）"><a href="#3-4-归一化网络的激活函数（Normalizing-activations-in-a-network）" class="headerlink" title="3.4 归一化网络的激活函数（Normalizing activations in a network）"></a>3.4 归一化网络的激活函数（Normalizing activations in a network）</h3><h3 id="3-5-将-Batch-Norm-拟合进神经网络（Fitting-Batch-Norm-into-a-neural-network）"><a href="#3-5-将-Batch-Norm-拟合进神经网络（Fitting-Batch-Norm-into-a-neural-network）" class="headerlink" title="3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）"></a>3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）</h3><h3 id="3-6-Batch-Norm-为什么奏效（Why-does-Batch-Norm-work-）"><a href="#3-6-Batch-Norm-为什么奏效（Why-does-Batch-Norm-work-）" class="headerlink" title="3.6 Batch Norm 为什么奏效（Why does Batch Norm work?）"></a>3.6 Batch Norm 为什么奏效（Why does Batch Norm work?）</h3><h3 id="3-7-测试时的-Batch-Norm（Batch-Norm-at-test-time）"><a href="#3-7-测试时的-Batch-Norm（Batch-Norm-at-test-time）" class="headerlink" title="3.7 测试时的 Batch Norm（Batch Norm at test time）"></a>3.7 测试时的 Batch Norm（Batch Norm at test time）</h3><h3 id="3-8-Softmax-回归（Softmax-regression）"><a href="#3-8-Softmax-回归（Softmax-regression）" class="headerlink" title="3.8 Softmax 回归（Softmax regression）"></a>3.8 Softmax 回归（Softmax regression）</h3><h3 id="3-9-训练一个-Softmax-分类器（Training-a-Softmax-classifier）"><a href="#3-9-训练一个-Softmax-分类器（Training-a-Softmax-classifier）" class="headerlink" title="3.9 训练一个 Softmax 分类器（Training a Softmax classifier）"></a>3.9 训练一个 Softmax 分类器（Training a Softmax classifier）</h3><h3 id="3-10-深度学习框架（Deep-Learning-frameworks）"><a href="#3-10-深度学习框架（Deep-Learning-frameworks）" class="headerlink" title="3.10 深度学习框架（Deep Learning frameworks）"></a>3.10 深度学习框架（Deep Learning frameworks）</h3><h3 id="3-11-TensorFlow"><a href="#3-11-TensorFlow" class="headerlink" title="3.11 TensorFlow"></a>3.11 TensorFlow</h3><blockquote><p>今天晚上多花了点时间，把进度提前推一点，BN是重点，明天回过头来再看看。明天再刷一天就进入cv了。</p></blockquote><h1 id="第三门课-结构化机器学习项目（Structuring-Machine-Learning-Projects）"><a href="#第三门课-结构化机器学习项目（Structuring-Machine-Learning-Projects）" class="headerlink" title="第三门课 结构化机器学习项目（Structuring Machine Learning Projects）"></a>第三门课 结构化机器学习项目（Structuring Machine Learning Projects）</h1><h2 id="第一周-机器学习（ML）策略（1）（ML-strategy（1））"><a href="#第一周-机器学习（ML）策略（1）（ML-strategy（1））" class="headerlink" title="第一周 机器学习（ML）策略（1）（ML strategy（1））"></a>第一周 机器学习（ML）策略（1）（ML strategy（1））</h2><h3 id="1-1-为什么是ML策略？（Why-ML-Strategy-）"><a href="#1-1-为什么是ML策略？（Why-ML-Strategy-）" class="headerlink" title="1.1 为什么是ML策略？（Why ML Strategy?）"></a>1.1 为什么是ML策略？（Why ML Strategy?）</h3><h3 id="1-2-正交化（Orthogonalization）"><a href="#1-2-正交化（Orthogonalization）" class="headerlink" title="1.2 正交化（Orthogonalization）"></a>1.2 正交化（Orthogonalization）</h3><p>所以正交化的概念是指，你可以想出一个维度，这个维度你想做的是控制转向角，还有另一个维度来控制你的速度，那么你就需要一个旋钮尽量只控制转向角，另一个旋钮，在这个开车的例子里其实是油门和刹车控制了你的速度。但如果你有一个控制旋钮将两者混在一起，比如说这样一个控制装置同时影响你的转向角和速度，同时改变了两个性质，那么就很难令你的车子以想要的速度和角度前进。然而正交化之后，正交意味着互成90度。设计出正交化的控制装置，最理想的情况是和你实际想控制的性质一致，这样你调整参数时就容易得多。可以单独调整转向角，还有你的油门和刹车，令车子以你想要的方式运动。</p><h3 id="1-3-单一数字评估指标（Single-number-evaluation-metric）"><a href="#1-3-单一数字评估指标（Single-number-evaluation-metric）" class="headerlink" title="1.3 单一数字评估指标（Single number evaluation metric）"></a>1.3 单一数字评估指标（Single number evaluation metric）</h3><h3 id="1-4-满足和优化指标（Satisficing-and-optimizing-metrics）"><a href="#1-4-满足和优化指标（Satisficing-and-optimizing-metrics）" class="headerlink" title="1.4 满足和优化指标（Satisficing and optimizing metrics）"></a>1.4 满足和优化指标（Satisficing and optimizing metrics）</h3><p>总结一下，如果你需要顾及多个指标，比如说，有一个优化指标，你想尽可能优化的，然后还有一个或多个满足指标，需要满足的，需要达到一定的门槛。现在你就有一个全自动的方法，在观察多个成本大小时，选出”最好的”那个。现在这些评估指标必须是在训练集或开发集或测试集上计算或求出来的。所以你还需要做一件事，就是设立训练集、开发集，还有测试集。</p><h3 id="1-5-训练-开发-测试集划分（Train-dev-test-distributions）"><a href="#1-5-训练-开发-测试集划分（Train-dev-test-distributions）" class="headerlink" title="1.5 训练/开发/测试集划分（Train/dev/test distributions）"></a>1.5 训练/开发/测试集划分（Train/dev/test distributions）</h3><h3 id="1-6-开发集和测试集的大小（Size-of-dev-and-test-sets）"><a href="#1-6-开发集和测试集的大小（Size-of-dev-and-test-sets）" class="headerlink" title="1.6 开发集和测试集的大小（Size of dev and test sets）"></a>1.6 开发集和测试集的大小（Size of dev and test sets）</h3><h3 id="1-7-什么时候该改变开发-测试集和指标？（When-to-change-dev-test-sets-and-metrics）"><a href="#1-7-什么时候该改变开发-测试集和指标？（When-to-change-dev-test-sets-and-metrics）" class="headerlink" title="1.7 什么时候该改变开发/测试集和指标？（When to change dev/test sets and metrics）"></a>1.7 什么时候该改变开发/测试集和指标？（When to change dev/test sets and metrics）</h3><p>所以方针是，如果你在指标上表现很好，在当前开发集或者开发集和测试集分布中表现很好，但你的实际应用程序，你真正关注的地方表现不好，那么就需要修改指标或者你的开发测试集。换句话说，如果你发现你的开发测试集都是这些高质量图像，但在开发测试集上做的评估无法预测你的应用实际的表现。因为你的应用处理的是低质量图像，那么就应该改变你的开发测试集，让你的数据更能反映你实际需要处理好的数据。</p><p>但总体方针就是，如果你当前的指标和当前用来评估的数据和你真正关心必须做好的事情关系不大，那就应该更改你的指标或者你的开发测试集，让它们能更够好地反映你的算法需要处理好的数据。</p><h3 id="1-8-为什么是人的表现？（Why-human-level-performance-）"><a href="#1-8-为什么是人的表现？（Why-human-level-performance-）" class="headerlink" title="1.8 为什么是人的表现？（Why human-level performance?）"></a>1.8 为什么是人的表现？（Why human-level performance?）</h3><h3 id="1-9-可避免偏差（Avoidable-bias）"><a href="#1-9-可避免偏差（Avoidable-bias）" class="headerlink" title="1.9 可避免偏差（Avoidable bias）"></a>1.9 可避免偏差（Avoidable bias）</h3><p>这个差值，贝叶斯错误率或者对贝叶斯错误率的估计和训练错误率之间的差值称为可避免偏差，你可能希望一直提高训练集表现，直到你接近贝叶斯错误率，但实际上你也不希望做到比贝叶斯错误率更好，这理论上是不可能超过贝叶斯错误率的，除非过拟合。而这个训练错误率和开发错误率之前的差值，就大概说明你的算法在方差问题上还有多少改善空间。</p><h3 id="1-10-理解人的表现（Understanding-human-level-performance）"><a href="#1-10-理解人的表现（Understanding-human-level-performance）" class="headerlink" title="1.10 理解人的表现（Understanding human-level performance）"></a>1.10 理解人的表现（Understanding human-level performance）</h3><h3 id="1-11-超过人的表现（Surpassing-human-level-performance）"><a href="#1-11-超过人的表现（Surpassing-human-level-performance）" class="headerlink" title="1.11 超过人的表现（Surpassing human- level performance）"></a>1.11 超过人的表现（Surpassing human- level performance）</h3><h3 id="1-12-改善你的模型的表现（Improving-your-model-performance）"><a href="#1-12-改善你的模型的表现（Improving-your-model-performance）" class="headerlink" title="1.12 改善你的模型的表现（Improving your model performance）"></a>1.12 改善你的模型的表现（Improving your model performance）</h3><p>所以我想要让一个监督学习算法达到实用，基本上希望或者假设你可以完成两件事情。首先，你的算法对训练集的拟合很好，这可以看成是你能做到可避免偏差很低。还有第二件事你可以做好的是，在训练集中做得很好，然后推广到开发集和测试集也很好，这就是说方差不是太大。</p><p>可以修正可避免偏差问题，比如训练更大的网络或者训练更久。还有一套独立的技巧可以用来处理方差问题，比如正则化或者收集更多训练数据。</p><p>总结一下前几段视频我们见到的步骤，如果你想提升机器学习系统的性能，我建议你们看看训练错误率和贝叶斯错误率估计值之间的距离，让你知道可避免偏差有多大。换句话说，就是你觉得还能做多好，你对训练集的优化还有多少空间。然后看看你的开发错误率和训练错误率之间的距离，就知道你的方差问题有多大。换句话说，你应该做多少努力让你的算法表现能够从训练集推广到开发集，算法是没有在开发集上训练的。</p><p>如果你想用尽一切办法减少可避免偏差，我建议试试这样的策略：比如使用规模更大的模型，这样算法在训练集上的表现会更好，或者训练更久。使用更好的优化算法，比如说加入<strong>momentum</strong>或者<strong>RMSprop</strong>，或者使用更好的算法，比如<strong>Adam</strong>。你还可以试试寻找更好的新神经网络架构，或者说更好的超参数。这些手段包罗万有，你可以改变激活函数，改变层数或者隐藏单位数，虽然你这么做可能会让模型规模变大。或者试用其他模型，其他架构，如循环神经网络和卷积神经网络。在之后的课程里我们会详细介绍的，新的神经网络架构能否更好地拟合你的训练集，有时也很难预先判断，但有时换架构可能会得到好得多的结果。</p><p>另外当你发现方差是个问题时，你可以试用很多技巧，包括以下这些：你可以收集更多数据，因为收集更多数据去训练可以帮你更好地推广到系统看不到的开发集数据。你可以尝试正则化，包括$L2$正则化，<strong>dropout</strong>正则化或者我们在之前课程中提到的数据增强。同时你也可以试用不同的神经网络架构，超参数搜索，看看能不能帮助你，找到一个更适合你的问题的神经网络架构。</p><h2 id="第二周：机器学习策略（2）-ML-Strategy-2"><a href="#第二周：机器学习策略（2）-ML-Strategy-2" class="headerlink" title="第二周：机器学习策略（2）(ML Strategy (2))"></a>第二周：机器学习策略（2）(ML Strategy (2))</h2><h3 id="2-1-进行误差分析（Carrying-out-error-analysis）"><a href="#2-1-进行误差分析（Carrying-out-error-analysis）" class="headerlink" title="2.1 进行误差分析（Carrying out error analysis）"></a>2.1 进行误差分析（Carrying out error analysis）</h3><p>总结一下，进行错误分析，你应该找一组错误样本，可能在你的开发集里或者测试集里，观察错误标记的样本，看看假阳性（<strong>false positives</strong>）和假阴性（<strong>false negatives</strong>），统计属于不同错误类型的错误数量。在这个过程中，你可能会得到启发，归纳出新的错误类型，就像我们看到的那样。如果你过了一遍错误样本，然后说，天，有这么多<strong>Instagram</strong>滤镜或<strong>Snapchat</strong>滤镜，这些滤镜干扰了我的分类器，你就可以在途中新建一个错误类型。总之，通过统计不同错误标记类型占总数的百分比，可以帮你发现哪些问题需要优先解决，或者给你构思新优化方向的灵感。在做错误分析的时候，有时你会注意到开发集里有些样本被错误标记了，这时应该怎么做呢？</p><h3 id="2-2-清除标注错误的数据（Cleaning-up-Incorrectly-labeled-data）"><a href="#2-2-清除标注错误的数据（Cleaning-up-Incorrectly-labeled-data）" class="headerlink" title="2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）"></a>2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）</h3><p>如果你还记得设立开发集的目标的话，开发集的主要目的是，你希望用它来从两个分类器$A$和$B$中选择一个。所以当你测试两个分类器$A$和$B$时，在开发集上一个有2.1%错误率，另一个有1.9%错误率，但是你不能再信任开发集了，因为它无法告诉你这个分类器是否比这个好，因为0.6%的错误率是标记出错导致的。那么现在你就有很好的理由去修正开发集里的错误标签，因为在右边这个样本中，标记出错对算法错误的整体评估标准有严重的影响。而左边的样本中，标记出错对你算法影响的百分比还是相对较小的。</p><p>现在如果你决定要去修正开发集数据，手动重新检查标签，并尝试修正一些标签，这里还有一些额外的方针和原则需要考虑。首先，我鼓励你不管用什么修正手段，都要同时作用到开发集和测试集上，我们之前讨论过为什么，开发和测试集必须来自相同的分布。开发集确定了你的目标，当你击中目标后，你希望算法能够推广到测试集上，这样你的团队能够更高效的在来自同一分布的开发集和测试集上迭代。如果你打算修正开发集上的部分数据，那么最好也对测试集做同样的修正以确保它们继续来自相同的分布。所以我们雇佣了一个人来仔细检查这些标签，但必须同时检查开发集和测试集。</p><h3 id="2-3-快速搭建你的第一个系统，并进行迭代（Build-your-first-system-quickly-then-iterate）"><a href="#2-3-快速搭建你的第一个系统，并进行迭代（Build-your-first-system-quickly-then-iterate）" class="headerlink" title="2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）"></a>2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）</h3><p>如果你想搭建全新的机器学习程序，就是快速搭好你的第一个系统，然后开始迭代。我的意思是我建议你快速设立开发集和测试集还有指标，这样就决定了你的目标所在，如果你的目标定错了，之后改也是可以的。但一定要设立某个目标，然后我建议你马上搭好一个机器学习系统原型，然后找到训练集，训练一下，看看效果，开始理解你的算法表现如何，在开发集测试集，你的评估指标上表现如何。当你建立第一个系统后，你就可以马上用到之前说的偏差方差分析</p><p>建立这个初始系统的所有意义在于，它可以是一个快速和粗糙的实现（<strong>quick and dirty implementation</strong>），你知道的，别想太多。初始系统的全部意义在于，有一个学习过的系统，有一个训练过的系统，让你确定偏差方差的范围，就可以知道下一步应该优先做什么，让你能够进行错误分析，可以观察一些错误，然后想出所有能走的方向，哪些是实际上最有希望的方向。</p><p>你的主要目标是弄出能用的系统，你的主要目标并不是发明全新的机器学习算法，这是完全不同的目标，那时你的目标应该是想出某种效果非常好的算法。</p><h3 id="2-4-使用来自不同分布的数据，进行训练和测试（Training-and-testing-on-different-distributions）"><a href="#2-4-使用来自不同分布的数据，进行训练和测试（Training-and-testing-on-different-distributions）" class="headerlink" title="2.4 使用来自不同分布的数据，进行训练和测试（Training and testing on different distributions）"></a>2.4 使用来自不同分布的数据，进行训练和测试（Training and testing on different distributions）</h3><p>将两组数据合并在一起，这样你就有21万张照片，你可以把这21万张照片随机分配到训练、开发和测试集中。</p><h3 id="2-5-数据分布不匹配时，偏差与方差的分析（Bias-and-Variance-with-mismatched-data-distributions）"><a href="#2-5-数据分布不匹配时，偏差与方差的分析（Bias-and-Variance-with-mismatched-data-distributions）" class="headerlink" title="2.5 数据分布不匹配时，偏差与方差的分析（Bias and Variance with mismatched data distributions）"></a>2.5 数据分布不匹配时，偏差与方差的分析（Bias and Variance with mismatched data distributions）</h3><p>我们继续用猫分类器为例，我们说人类在这个任务上能做到几乎完美，所以贝叶斯错误率或者说贝叶斯最优错误率，我们知道这个问题里几乎是0%。所以要进行错误率分析，你通常需要看训练误差，也要看看开发集的误差。比如说，在这个样本中，你的训练集误差是1%，你的开发集误差是10%，如果你的开发集来自和训练集一样的分布，你可能会说，这里存在很大的方差问题，你的算法不能很好的从训练集出发泛化，它处理训练集很好，但处理开发集就突然间效果很差了。</p><p>但如果你的训练数据和开发数据来自不同的分布，你就不能再放心下这个结论了。特别是，也许算法在开发集上做得不错，可能因为训练集很容易识别，因为训练集都是高分辨率图片，很清晰的图像，但开发集要难以识别得多。所以也许软件没有方差问题，这只不过反映了开发集包含更难准确分类的图片。所以这个分析的问题在于，当你看训练误差，再看开发误差，有两件事变了。首先算法只见过训练集数据，没见过开发集数据。第二，开发集数据来自不同的分布。而且因为你同时改变了两件事情，很难确认这增加的9%误差率有多少是因为算法没看到开发集中的数据导致的，这是问题方差的部分，有多少是因为开发集数据就是不一样。</p><p>为了弄清楚哪个因素影响更大，如果你完全不懂这两种影响到底是什么，别担心我们马上会再讲一遍。但为了分辨清楚两个因素的影响，定义一组新的数据是有意义的，我们称之为训练-开发集，所以这是一个新的数据子集。我们应该从训练集的分布里挖出来，但你不会用来训练你的网络。</p><p>我们说人类水平错误率是4%的话，你的训练错误率是7%，而你的训练-开发错误率是10%，而开发错误率是12%，这样你就大概知道可避免偏差有多大。因为你知道，你希望你的算法至少要在训练集上的表现接近人类。而这大概表明了方差大小，所以你从训练集泛化推广到训练-开发集时效果如何？而这告诉你数据不匹配的问题大概有多大。技术上你还可以再加入一个数字，就是测试集表现，我们写成测试集错误率，你不应该在测试集上开发，因为你不希望对测试集过拟合。但如果你看看这个，那么这里的差距就说明你对开发集过拟合的程度。所以如果开发集表现和测试集表现有很大差距，那么你可能对开发集过拟合了，所以也许你需要一个更大的开发集，对吧？要记住，你的开发集和测试集来自同一分布，所以这里存在很大差距的话。如果算法在开发集上做的很好，比测试集好得多，那么你就可能对开发集过拟合了。如果是这种情况，那么你可能要往回退一步，然后收集更多开发集数据。</p><h3 id="2-6-处理数据不匹配问题（Addressing-data-mismatch）"><a href="#2-6-处理数据不匹配问题（Addressing-data-mismatch）" class="headerlink" title="2.6 处理数据不匹配问题（Addressing data mismatch）"></a>2.6 处理数据不匹配问题（Addressing data mismatch）</h3><p>如果您的训练集来自和开发测试集不同的分布，如果错误分析显示你有一个数据不匹配的问题该怎么办？这个问题没有完全系统的解决方案，但我们可以看看一些可以尝试的事情。如果我发现有严重的数据不匹配问题，我通常会亲自做错误分析，尝试了解训练集和开发测试集的具体差异。技术上，为了避免对测试集过拟合，要做错误分析，你应该人工去看开发集而不是测试集。</p><p>通过人工数据合成，你可以快速制造更多的训练数据，就像真的在车里录的那样，那就不需要花时间实际出去收集数据，比如说在实际行驶中的车子，录下上万小时的音频。所以，如果错误分析显示你应该尝试让你的数据听起来更像在车里录的，那么人工合成那种音频，然后喂给你的机器学习算法，这样做是合理的。</p><p>我们谈到其中一种办法是人工数据合成，人工数据合成确实有效。在语音识别中。我已经看到人工数据合成显著提升了已经非常好的语音识别系统的表现，所以这是可行的。但当你使用人工数据合成时，一定要谨慎，要记住你有可能从所有可能性的空间只选了很小一部分去模拟数据。</p><h3 id="2-7-迁移学习（Transfer-learning）"><a href="#2-7-迁移学习（Transfer-learning）" class="headerlink" title="2.7 迁移学习（Transfer learning）"></a>2.7 迁移学习（Transfer learning）</h3><p>深度学习中，最强大的理念之一就是，有的时候神经网络可以从一个任务中习得知识，并将这些知识应用到另一个独立的任务中。所以例如，也许你已经训练好一个神经网络，能够识别像猫这样的对象，然后使用那些知识，或者部分习得的知识去帮助您更好地阅读x射线扫描图，这就是所谓的迁移学习。</p><p>那么迁移学习什么时候是有意义的呢？迁移学习起作用的场合是，在迁移来源问题中你有很多数据，但迁移目标问题你没有那么多数据。例如，假设图像识别任务中你有1百万个样本，所以这里数据相当多。可以学习低层次特征，可以在神经网络的前面几层学到如何识别很多有用的特征。但是对于放射科任务，也许你只有一百个样本，所以你的放射学诊断问题数据很少，也许只有100次$X$射线扫描，所以你从图像识别训练中学到的很多知识可以迁移，并且真正帮你加强放射科识别任务的性能，即使你的放射科数据很少。</p><h3 id="2-8-多任务学习（Multi-task-learning）"><a href="#2-8-多任务学习（Multi-task-learning）" class="headerlink" title="2.8 多任务学习（Multi-task learning）"></a>2.8 多任务学习（Multi-task learning）</h3><p>最后多任务学习往往在以下场合更有意义，当你可以训练一个足够大的神经网络，同时做好所有的工作，所以多任务学习的替代方法是为每个任务训练一个单独的神经网络。所以不是训练单个神经网络同时处理行人、汽车、停车标志和交通灯检测。你可以训练一个用于行人检测的神经网络，一个用于汽车检测的神经网络，一个用于停车标志检测的神经网络和一个用于交通信号灯检测的神经网络。那么研究员<strong>Rich Carona</strong>几年前发现的是什么呢？多任务学习会降低性能的唯一情况，和训练单个神经网络相比性能更低的情况就是你的神经网络还不够大。但如果你可以训练一个足够大的神经网络，那么多任务学习肯定不会或者很少会降低性能，我们都希望它可以提升性能，比单独训练神经网络来单独完成各个任务性能要更好。</p><h3 id="2-9-什么是端到端的深度学习-（What-is-end-to-end-deep-learning-）"><a href="#2-9-什么是端到端的深度学习-（What-is-end-to-end-deep-learning-）" class="headerlink" title="2.9 什么是端到端的深度学习?（What is end-to-end deep learning?）"></a>2.9 什么是端到端的深度学习?（What is end-to-end deep learning?）</h3><p>研究人员发现，比起一步到位，一步学习，把这个问题分解成两个更简单的步骤。首先，是弄清楚脸在哪里。第二步是看着脸，弄清楚这是谁。这第二种方法让学习算法，或者说两个学习算法分别解决两个更简单的任务，并在整体上得到更好的表现。</p><p>为什么两步法更好呢？实际上有两个原因。一是，你解决的两个问题，每个问题实际上要简单得多。但第二，两个子任务的训练数据都很多。具体来说，有很多数据可以用于人脸识别训练，对于这里的任务1来说，任务就是观察一张图，找出人脸所在的位置，把人脸图像框出来，所以有很多数据，有很多标签数据$(x,y)$，其中$x$是图片，$y$是表示人脸的位置，你可以建立一个神经网络，可以很好地处理任务1。然后任务2，也有很多数据可用，今天，业界领先的公司拥有，比如说数百万张人脸照片，所以输入一张裁剪得很紧凑的照片，比如这张红色照片，下面这个，今天业界领先的人脸识别团队有至少数亿的图像，他们可以用来观察两张图片，并试图判断照片里人的身份，确定是否同一个人，所以任务2还有很多数据。相比之下，如果你想一步到位，这样$(x,y)$的数据对就少得多，其中$x$是门禁系统拍摄的图像，$y$是那人的身份，因为你没有足够多的数据去解决这个端到端学习问题，但你却有足够多的数据来解决子问题1和子问题2。</p><p>实际上，把这个分成两个子问题，比纯粹的端到端深度学习方法，达到更好的表现。不过如果你有足够多的数据来做端到端学习，也许端到端方法效果更好。但在今天的实践中，并不是最好的方法。</p><h3 id="2-10-是否要使用端到端的深度学习-（Whether-to-use-end-to-end-learning-）"><a href="#2-10-是否要使用端到端的深度学习-（Whether-to-use-end-to-end-learning-）" class="headerlink" title="2.10 是否要使用端到端的深度学习?（Whether to use end-to-end learning?）"></a>2.10 是否要使用端到端的深度学习?（Whether to use end-to-end learning?）</h3><p>这里是应用端到端学习的一些好处，首先端到端学习真的只是让数据说话。所以如果你有足够多的$(x,y)$数据，那么不管从$x$到$y$最适合的函数映射是什么，如果你训练一个足够大的神经网络，希望这个神经网络能自己搞清楚，而使用纯机器学习方法，直接从$x$到$y$输入去训练的神经网络，可能更能够捕获数据中的任何统计信息，而不是被迫引入人类的成见。</p><p>端到端深度学习的第二个好处就是这样，所需手工设计的组件更少，所以这也许能够简化你的设计工作流程，你不需要花太多时间去手工设计功能，手工设计这些中间表示方式。</p><p>那么缺点呢？这里有一些缺点，首先，它可能需要大量的数据。要直接学到这个$x$到$y$的映射，你可能需要大量$(x,y)$数据。我们在以前的视频里看过一个例子，其中你可以收集大量子任务数据，比如人脸识别，我们可以收集很多数据用来分辨图像中的人脸，当你找到一张脸后，也可以找得到很多人脸识别数据。但是对于整个端到端任务，可能只有更少的数据可用。所以$x$这是端到端学习的输入端，$y$是输出端，所以你需要很多这样的$(x,y)$数据，在输入端和输出端都有数据，这样可以训练这些系统。这就是为什么我们称之为端到端学习，因为你直接学习出从系统的一端到系统的另一端。</p><p>另一个缺点是，它排除了可能有用的手工设计组件。机器学习研究人员一般都很鄙视手工设计的东西，但如果你没有很多数据，你的学习算法就没办法从很小的训练集数据中获得洞察力。所以手工设计组件在这种情况，可能是把人类知识直接注入算法的途径，这总不是一件坏事。我觉得学习算法有两个主要的知识来源，一个是数据，另一个是你手工设计的任何东西，可能是组件，功能，或者其他东西。所以当你有大量数据时，手工设计的东西就不太重要了，但是当你没有太多的数据时，构造一个精心设计的系统，实际上可以将人类对这个问题的很多认识直接注入到问题里，进入算法里应该挺有帮助的。</p><p>如果你在构建一个新的机器学习系统，而你在尝试决定是否使用端到端深度学习，我认为关键的问题是，你有足够的数据能够直接学到从$x$映射到$y$足够复杂的函数吗？我还没有正式定义过这个词“必要复杂度（<strong>complexity needed</strong>）”。但直觉上，如果你想从$x$到$y$的数据学习出一个函数，就是看着这样的图像识别出图像中所有骨头的位置，那么也许这像是识别图中骨头这样相对简单的问题，也许系统不需要那么多数据来学会处理这个任务。或给出一张人物照片，也许在图中把人脸找出来不是什么难事，所以你也许不需要太多数据去找到人脸，或者至少你可以找到足够数据去解决这个问题。相对来说，把手的X射线照片直接映射到孩子的年龄，直接去找这种函数，直觉上似乎是更为复杂的问题。如果你用纯端到端方法，需要很多数据去学习。</p><p>所以这个例子就表明了，如果你想使用机器学习或者深度学习来学习某些单独的组件，那么当你应用监督学习时，你应该仔细选择要学习的$x$到$y$映射类型，<strong>这取决于那些任务你可以收集数据。</strong></p><blockquote><p>6.25 刚好到周五结束前三门课程，周末可以再把后续的cv的CNN模型和nlp序列模型看完，然后就可以马上自己动手实践了。其实这样看一遍只相当于是简单预习，完全谈不上学完，只有自己一边实践一边学才能真正学会。后两门才是重头，前面都是机器学习课程里曾经涉及过的或者相关的基础内容，这样复习一边前面知识一边继续前进，这个进度很舒服。</p></blockquote><h1 id="第四门课-卷积神经网络（Convolutional-Neural-Networks）"><a href="#第四门课-卷积神经网络（Convolutional-Neural-Networks）" class="headerlink" title="第四门课 卷积神经网络（Convolutional Neural Networks）"></a>第四门课 卷积神经网络（Convolutional Neural Networks）</h1><blockquote><p>起晚了。</p></blockquote><h2 id="第一周-卷积神经网络（Foundations-of-Convolutional-Neural-Networks）"><a href="#第一周-卷积神经网络（Foundations-of-Convolutional-Neural-Networks）" class="headerlink" title="第一周 卷积神经网络（Foundations of Convolutional Neural Networks）"></a>第一周 卷积神经网络（Foundations of Convolutional Neural Networks）</h2><h3 id="1-2-边缘检测示例（Edge-detection-example）"><a href="#1-2-边缘检测示例（Edge-detection-example）" class="headerlink" title="1.2 边缘检测示例（Edge detection example）"></a>1.2 边缘检测示例（Edge detection example）</h3><p>卷积运算是卷积神经网络最基本的组成部分，使用边缘检测作为入门样例。</p><p>在编程练习中，你会使用一个叫<strong>conv_forward</strong>的函数。如果在<strong>tensorflow</strong>下，这个函数叫<strong>tf.conv2d</strong>。在其他深度学习框架中，在后面的课程中，你将会看到<strong>Keras</strong>这个框架，在这个框架下用<strong>Conv2D</strong>实现卷积运算。所有的编程框架都有一些函数来实现卷积运算。</p><h3 id="1-3-更多边缘检测内容（More-edge-detection）"><a href="#1-3-更多边缘检测内容（More-edge-detection）" class="headerlink" title="1.3 更多边缘检测内容（More edge detection）"></a>1.3 更多边缘检测内容（More edge detection）</h3><p>你已经见识到用卷积运算实现垂直边缘检测，在本视频中，你将学习如何区分正边和负边，这实际就是由亮到暗与由暗到亮的区别，也就是边缘的过渡。你还能了解到其他类型的边缘检测以及如何去实现这些算法，而不要总想着去自己编写一个边缘检测程序，让我们开始吧。</p><h3 id="1-4-Padding"><a href="#1-4-Padding" class="headerlink" title="1.4 Padding"></a>1.4 Padding</h3><p>为了构建深度神经网络，你需要学会使用的一个基本的卷积操作就是<strong>padding</strong>，让我们来看看它是如何工作的。</p><p>第一个缺点是每次做卷积操作，你的图像就会缩小，从6×6缩小到4×4，你可能做了几次之后，你的图像就会变得很小了，可能会缩小到只有1×1的大小。你可不想让你的图像在每次识别边缘或其他特征时都缩小，这就是第一个缺点。</p><p>第二个缺点时，如果你注意角落边缘的像素，这个像素点（绿色阴影标记）只被一个输出所触碰或者使用，因为它位于这个3×3的区域的一角。但如果是在中间的像素点，比如这个（红色方框标记），就会有许多3×3的区域与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着你丢掉了图像边缘位置的许多信息。</p><p>为了解决这些问题，你可以在卷积操作之前填充这幅图像。在这个案例中，你可以沿着图像边缘再填充一层像素。如果你这样操作了，那么6×6的图像就被你填充成了一个8×8的图像。</p><p>至于选择填充多少像素，通常有两个选择，分别叫做<strong>Valid</strong>卷积和<strong>Same</strong>卷积。</p><p>因此如果你有一个$n×n$的图像，用$p$个像素填充边缘，输出的大小就是这样的$(n+2p-f+1)×(n+2p-f+1)$。如果你想让$n+2p-f+1=n$的话，使得输出和输入大小相等，如果你用这个等式求解$p$，那么$p=(f-1)/2$。所以当$f$是一个奇数的时候，只要选择相应的填充尺寸，你就能确保得到和输入相同尺寸的输出。</p><h3 id="1-5-卷积步长（Strided-convolutions）"><a href="#1-5-卷积步长（Strided-convolutions）" class="headerlink" title="1.5 卷积步长（Strided convolutions）"></a>1.5 卷积步长（Strided convolutions）</h3><p>卷积中的步幅是另一个构建卷积神经网络的基本操作，让我向你展示一个例子。</p><p>输入和输出的维度是由下面的公式决定的。如果你用一个$f×f$的过滤器卷积一个$n×n$的图像，你的<strong>padding</strong>为$p$，步幅为$s$，在这个例子中$s=2$，你会得到一个输出，因为现在你不是一次移动一个步子，而是一次移动$s$个步子，输出于是变为$\frac{n+2p - f}{s} + 1 \times \frac{n+2p - f}{s} + 1$</p><p>现在只剩下最后的一个细节了，如果商不是一个整数怎么办？在这种情况下，我们向下取整。$⌊ ⌋$这是向下取整的符号，这也叫做对$z$进行地板除(<strong>floor</strong>)，这意味着$z$向下取整到最近的整数。这个原则实现的方式是，你只在蓝框完全包括在图像或填充完的图像内部时，才对它进行运算。如果有任意一个蓝框移动到了外面，那你就不要进行相乘操作，这是一个惯例。你的3×3的过滤器必须完全处于图像中或者填充之后的图像区域内才输出相应结果，这就是惯例。因此正确计算输出维度的方法是向下取整，以免$\frac{n + 2p - f}{s}$不是整数。</p><h3 id="1-6-三维卷积（Convolutions-over-volumes）"><a href="#1-6-三维卷积（Convolutions-over-volumes）" class="headerlink" title="1.6 三维卷积（Convolutions over volumes）"></a>1.6 三维卷积（Convolutions over volumes）</h3><p>你已经知道如何对二维图像做卷积了，现在看看如何执行卷积不仅仅在二维图像上，而是三维立体上。</p><h3 id="1-7-单层卷积网络（One-layer-of-a-convolutional-network）"><a href="#1-7-单层卷积网络（One-layer-of-a-convolutional-network）" class="headerlink" title="1.7 单层卷积网络（One layer of a convolutional network）"></a>1.7 单层卷积网络（One layer of a convolutional network）</h3><p>今天我们要讲的是如何构建卷积神经网络的卷积层，下面来看个例子。</p><h3 id="1-8-简单卷积网络示例（A-simple-convolution-network-example）"><a href="#1-8-简单卷积网络示例（A-simple-convolution-network-example）" class="headerlink" title="1.8 简单卷积网络示例（A simple convolution network example）"></a>1.8 简单卷积网络示例（A simple convolution network example）</h3><p>上节课，我们讲了如何为卷积网络构建一个卷积层。今天我们看一个深度卷积神经网络的具体示例，顺便练习一下我们上节课所学的标记法。</p><h3 id="1-9-池化层（Pooling-layers）"><a href="#1-9-池化层（Pooling-layers）" class="headerlink" title="1.9 池化层（Pooling layers）"></a>1.9 池化层（Pooling layers）</h3><p>除了卷积层，卷积网络也经常使用池化层来缩减模型的大小，提高计算速度，同时提高所提取特征的鲁棒性，我们来看一下。</p><p>最大池化算法。</p><p>另外还有一种类型的池化，平均池化，它不太常用。目前来说，最大池化比平均池化更常用。但也有例外，就是深度很深的神经网络，你可以用平均池化来分解规模为7×7×1000的网络的表示层，在整个空间内求平均值，得到1×1×1000，一会我们看个例子。但在神经网络中，最大池化要比平均池化用得更多。</p><p>总结一下，池化的超级参数包括过滤器大小$f$和步幅$s$，常用的参数值为$f=2$，$s=2$，应用频率非常高，其效果相当于高度和宽度缩减一半。也有使用$f=3$，$s=2$的情况。至于其它超级参数就要看你用的是最大池化还是平均池化了。你也可以根据自己意愿增加表示<strong>padding</strong>的其他超级参数，虽然很少这么用。最大池化时，往往很少用到超参数<strong>padding</strong>，当然也有例外的情况，我们下周会讲。大部分情况下，最大池化很少用<strong>padding</strong>。目前$p$最常用的值是0，即$p=0$。最大池化的输入就是$n_{H} \times n_{W} \times n_{c}$，假设没有<strong>padding</strong>，则输出$\lfloor\frac{n_{H} - f}{s} +1\rfloor \times \lfloor\frac{n_{w} - f}{s} + 1\rfloor \times n_{c}$。输入通道与输出通道个数相同，因为我们对每个通道都做了池化。需要注意的一点是，池化过程中没有需要学习的参数。执行反向传播时，反向传播没有参数适用于最大池化。只有这些设置过的超参数，可能是手动设置的，也可能是通过交叉验证设置的。</p><h3 id="1-10-卷积神经网络示例（Convolutional-neural-network-example）"><a href="#1-10-卷积神经网络示例（Convolutional-neural-network-example）" class="headerlink" title="1.10 卷积神经网络示例（Convolutional neural network example）"></a>1.10 卷积神经网络示例（Convolutional neural network example）</h3><p>构建全卷积神经网络的构造模块我们已经掌握得差不多了，下面来看个例子。</p><p>人们发现在卷积神经网络文献中，卷积有两种分类，这与所谓层的划分存在一致性。一类卷积是一个卷积层和一个池化层一起作为一层，这就是神经网络的<strong>Layer1</strong>。另一类卷积是把卷积层作为一层，而池化层单独作为一层。人们在计算神经网络有多少层时，通常只统计具有权重和参数的层。因为池化层没有权重和参数，只有一些超参数。这里，我们把<strong>CONV1</strong>和<strong>POOL1</strong>共同作为一个卷积，并标记为<strong>Layer1</strong>。虽然你在阅读网络文章或研究报告时，你可能会看到卷积层和池化层各为一层的情况，这只是两种不同的标记术语。一般我在统计网络层数时，只计算具有权重的层，也就是把<strong>CONV1</strong>和<strong>POOL1</strong>作为<strong>Layer1</strong>。这里我们用<strong>CONV1</strong>和<strong>POOL1</strong>来标记，两者都是神经网络<strong>Layer1</strong>的一部分，<strong>POOL1</strong>也被划分在<strong>Layer1</strong>中，因为它没有权重</p><h3 id="1-11-为什么使用卷积？（Why-convolutions-）"><a href="#1-11-为什么使用卷积？（Why-convolutions-）" class="headerlink" title="1.11 为什么使用卷积？（Why convolutions?）"></a>1.11 为什么使用卷积？（Why convolutions?）</h3><p>这是本周最后一节课，我们来分析一下卷积在神经网络中如此受用的原因，然后对如何整合这些卷积，如何通过一个标注过的训练集训练卷积神经网络做个简单概括。<strong>和只用全连接层相比，卷积层的两个主要优势在于参数共享和稀疏连接</strong>，举例说明一下。</p><h2 id="第二周-深度卷积网络：实例探究（Deep-convolutional-models-case-studies）"><a href="#第二周-深度卷积网络：实例探究（Deep-convolutional-models-case-studies）" class="headerlink" title="第二周 深度卷积网络：实例探究（Deep convolutional models: case studies）"></a>第二周 深度卷积网络：实例探究（Deep convolutional models: case studies）</h2><h3 id="2-1-为什么要进行实例探究？（Why-look-at-case-studies-）"><a href="#2-1-为什么要进行实例探究？（Why-look-at-case-studies-）" class="headerlink" title="2.1 为什么要进行实例探究？（Why look at case studies?）"></a>2.1 为什么要进行实例探究？（Why look at case studies?）</h3><h3 id="2-2-经典网络（Classic-networks）"><a href="#2-2-经典网络（Classic-networks）" class="headerlink" title="2.2 经典网络（Classic networks）"></a>2.2 经典网络（Classic networks）</h3><p>这节课，我们来学习几个经典的神经网络结构，分别是<strong>LeNet-5</strong>、<strong>AlexNet</strong>和<strong>VGGNet</strong></p><h3 id="2-3-残差网络-ResNets-（Residual-Networks-ResNets-）"><a href="#2-3-残差网络-ResNets-（Residual-Networks-ResNets-）" class="headerlink" title="2.3 残差网络(ResNets)（Residual Networks (ResNets)）"></a>2.3 残差网络(ResNets)（Residual Networks (ResNets)）</h3><h3 id="2-4-残差网络为什么有用？（Why-ResNets-work-）"><a href="#2-4-残差网络为什么有用？（Why-ResNets-work-）" class="headerlink" title="2.4 残差网络为什么有用？（Why ResNets work?）"></a>2.4 残差网络为什么有用？（Why ResNets work?）</h3><p>之所以能实现跳跃连接是因为<strong>same</strong>卷积保留了维度，所以很容易得出这个捷径连接，并输出这两个相同维度的向量。</p><p>结果表明，残差块学习这个恒等式函数并不难，跳跃连接使我们很容易得出$ a^{\left\lbrack l + 2 \right\rbrack} = a^{\left\lbrack l\right\rbrack}$。这意味着，即使给神经网络增加了这两层，它的效率也并不逊色于更简单的神经网络，因为学习恒等函数对它来说很简单。尽管它多了两层，也只把$a^{[l]}$的值赋值给$a^{\left\lbrack l + 2 \right\rbrack}$。所以给大型神经网络增加两层，不论是把残差块添加到神经网络的中间还是末端位置，都不会影响网络的表现。</p><p>残差网络起作用的主要原因就是这些残差块学习恒等函数非常容易，你能确定网络性能不会受到影响，很多时候甚至可以提高效率，或者说至少不会降低网络的效率，因此创建类似残差网络可以提升网络性能。</p><h3 id="2-5-网络中的网络以及-1×1-卷积（Network-in-Network-and-1×1-convolutions）"><a href="#2-5-网络中的网络以及-1×1-卷积（Network-in-Network-and-1×1-convolutions）" class="headerlink" title="2.5 网络中的网络以及 1×1 卷积（Network in Network and 1×1 convolutions）"></a>2.5 网络中的网络以及 1×1 卷积（Network in Network and 1×1 convolutions）</h3><h3 id="2-6-谷歌-Inception-网络简介（Inception-network-motivation）"><a href="#2-6-谷歌-Inception-网络简介（Inception-network-motivation）" class="headerlink" title="2.6 谷歌 Inception 网络简介（Inception network motivation）"></a>2.6 谷歌 Inception 网络简介（Inception network motivation）</h3><h3 id="2-7-Inception-网络（Inception-network）"><a href="#2-7-Inception-网络（Inception-network）" class="headerlink" title="2.7 Inception 网络（Inception network）"></a>2.7 Inception 网络（Inception network）</h3><h3 id="2-8-使用开源的实现方案（Using-open-source-implementations）"><a href="#2-8-使用开源的实现方案（Using-open-source-implementations）" class="headerlink" title="2.8 使用开源的实现方案（Using open-source implementations）"></a>2.8 使用开源的实现方案（Using open-source implementations）</h3><h3 id="2-9-迁移学习（Transfer-Learning）"><a href="#2-9-迁移学习（Transfer-Learning）" class="headerlink" title="2.9 迁移学习（Transfer Learning）"></a>2.9 迁移学习（Transfer Learning）</h3><h3 id="2-10-数据增强（Data-augmentation）"><a href="#2-10-数据增强（Data-augmentation）" class="headerlink" title="2.10 数据增强（Data augmentation）"></a>2.10 数据增强（Data augmentation）</h3><p>常用的实现数据扩充的方法是使用一个线程或者是多线程，这些可以用来加载数据，实现变形失真，然后传给其他的线程或者其他进程，来训练这个（编号2）和这个（编号1），可以并行实现。</p><p>这就是数据扩充，与训练深度神经网络的其他部分类似，在数据扩充过程中也有一些超参数，比如说颜色变化了多少，以及随机裁剪的时候使用的参数。与计算机视觉其他部分类似，一个好的开始可能是使用别人的开源实现，了解他们如何实现数据扩充。当然如果你想获得更多的不变特性，而其他人的开源实现并没有实现这个，你也可以去调整这些参数。因此，我希望你们可以使用数据扩充使你的计算机视觉应用效果更好。</p><h3 id="2-11-计算机视觉现状（The-state-of-computer-vision）"><a href="#2-11-计算机视觉现状（The-state-of-computer-vision）" class="headerlink" title="2.11 计算机视觉现状（The state of computer vision）"></a>2.11 计算机视觉现状（The state of computer vision）</h3><p>下面是一些有助于在基准测试中表现出色的小技巧</p><p>其中一个是集成，这就意味着在你想好了你想要的神经网络之后，可以独立训练几个神经网络，并平均它们的输出。比如说随机初始化三个、五个或者七个神经网络，然后训练所有这些网络，然后平均它们的输出。另外对他们的输出$\hat y$进行平均计算是很重要的，不要平均他们的权重，这是行不通的。看看你的7个神经网络，它们有7个不同的预测，然后平均他们，这可能会让你在基准上提高1%，2%或者更好。这会让你做得更好，也许有时会达到1%或2%，这真的能帮助你赢得比赛。但因为集成意味着要对每张图片进行测试，你可能需要在从3到15个不同的网络中运行一个图像，这是很典型的，因为这3到15个网络可能会让你的运行时间变慢，甚至更多时间，所以技巧之一的集成是人们在基准测试中表现出色和赢得比赛的利器，但我认为这几乎不用于生产服务于客户的，我想除非你有一个巨大的计算预算而且不介意在每个用户图像数据上花费大量的计算。</p><p>你在论文中可以看到在测试时，对进准测试有帮助的另一个技巧就是<strong>Multi-crop at test time</strong>，我的意思是你已经看到了如何进行数据扩充，<strong>Multi-crop</strong>是一种将数据扩充应用到你的测试图像中的一种形式。</p><p>集成的一个大问题是你需要保持所有这些不同的神经网络，这就占用了更多的计算机内存。对于<strong>multi-crop</strong>，我想你只保留一个网络，所以它不会占用太多的内存，但它仍然会让你的运行时间变慢。</p><p>这些是你看到的小技巧，研究论文也可以参考这些，但我个人并不倾向于在构建生产系统时使用这些方法，尽管它们在基准测试和竞赛上做得很好。</p><blockquote><p>不知道什么时候会用到机器视觉</p></blockquote><h2 id="第三周-目标检测（Object-detection）"><a href="#第三周-目标检测（Object-detection）" class="headerlink" title="第三周 目标检测（Object detection）"></a>第三周 目标检测（Object detection）</h2><h3 id="3-1-目标定位（Object-localization）"><a href="#3-1-目标定位（Object-localization）" class="headerlink" title="3.1 目标定位（Object localization）"></a>3.1 目标定位（Object localization）</h3><h3 id="3-2-特征点检测（Landmark-detection）"><a href="#3-2-特征点检测（Landmark-detection）" class="headerlink" title="3.2 特征点检测（Landmark detection）"></a>3.2 特征点检测（Landmark detection）</h3><h3 id="3-3-目标检测（Object-detection）"><a href="#3-3-目标检测（Object-detection）" class="headerlink" title="3.3 目标检测（Object detection）"></a>3.3 目标检测（Object detection）</h3><h3 id="3-4-滑动窗口的卷积实现（Convolutional-implementation-of-sliding-windows）"><a href="#3-4-滑动窗口的卷积实现（Convolutional-implementation-of-sliding-windows）" class="headerlink" title="3.4 滑动窗口的卷积实现（Convolutional implementation of sliding windows）"></a>3.4 滑动窗口的卷积实现（Convolutional implementation of sliding windows）</h3><p>为了构建滑动窗口的卷积应用，首先要知道如何把神经网络的全连接层转化成卷积层。</p><h3 id="3-5-Bounding-Box预测（Bounding-box-predictions）"><a href="#3-5-Bounding-Box预测（Bounding-box-predictions）" class="headerlink" title="3.5 Bounding Box预测（Bounding box predictions）"></a>3.5 Bounding Box预测（Bounding box predictions）</h3><p>在上一个视频中，你们学到了滑动窗口法的卷积实现，这个算法效率更高，但仍然存在问题，不能输出最精准的边界框。在这个视频中，我们看看如何得到更精准的边界框。</p><p>其中一个能得到更精准边界框的算法是<strong>YOLO</strong>算法，<strong>YOLO</strong>(<strong>You only look once</strong>)意思是你只看一次，这是由<strong>Joseph Redmon</strong>，<strong>Santosh Divvala</strong>，<strong>Ross Girshick</strong>和<strong>Ali Farhadi</strong>提出的算法。</p><p>是这么做的，比如你的输入图像是100×100的，然后在图像上放一个网格。为了介绍起来简单一些，我用3×3网格，实际实现时会用更精细的网格，可能是19×19。基本思路是使用图像分类和定位算法，前几个视频介绍过的，然后将算法应用到9个格子上。（基本思路是，采用图像分类和定位算法，本周第一个视频中介绍过的，逐一应用在图像的9个格子中。）更具体一点，你需要这样定义训练标签，所以对于9个格子中的每一个指定一个标签$y$，$y$是8维的，和你之前看到的一样，$y= \ \begin{bmatrix} p_{c} \\ b_{x} \\ b_{y} \\ b_{h} \\ b_{w} \\ c_{1} \\ c_{2}\\ c_{3} \\\end{bmatrix}$，$p_{c}$等于0或1取决于这个绿色格子中是否有图像。然后$b_{x}$、$b_{y}$、$b_{h}$和$b_{w}$作用就是，如果那个格子里有对象，那么就给出边界框坐标。然后$c_{1}$、$c_{2}$和$c_{3}$就是你想要识别的三个类别，背景类别不算，所以你尝试在背景类别中识别行人、汽车和摩托车，那么$c_{1}$、$c_{2}$和$c_{3}$可以是行人、汽车和摩托车类别。这张图里有9个格子，所以对于每个格子都有这么一个向量。</p><p>事实上<strong>YOLO</strong>算法有一个好处，也是它受欢迎的原因，因为这是一个卷积实现，实际上它的运行速度非常快，可以达到实时识别。</p><h3 id="3-6-交并比（Intersection-over-union）"><a href="#3-6-交并比（Intersection-over-union）" class="headerlink" title="3.6 交并比（Intersection over union）"></a>3.6 交并比（Intersection over union）</h3><p>在对象检测任务中，你希望能够同时定位对象，所以如果实际边界框是这样的，你的算法给出这个紫色的边界框，那么这个结果是好还是坏？所以交并比（<strong>loU</strong>）函数做的是计算两个边界框交集和并集之比。两个边界框的并集是这个区域，就是属于包含两个边界框区域（绿色阴影表示区域），而交集就是这个比较小的区域（橙色阴影表示区域），那么交并比就是交集的大小，这个橙色阴影面积，然后除以绿色阴影的并集面积。</p><p>一般约定，在计算机检测任务中，如果$loU≥0.5$，就说检测正确，如果预测器和实际边界框完美重叠，<strong>loU</strong>就是1，因为交集就等于并集。但一般来说只要$loU≥0.5$，那么结果是可以接受的，看起来还可以。一般约定，0.5是阈值，用来判断预测的边界框是否正确。一般是这么约定，但如果你希望更严格一点，你可以将<strong>loU</strong>定得更高，比如说大于0.6或者更大的数字，但<strong>loU</strong>越高，边界框越精确。</p><p>所以这是衡量定位精确度的一种方式，你只需要统计算法正确检测和定位对象的次数，你就可以用这样的定义判断对象定位是否准确。再次，0.5是人为约定，没有特别深的理论依据，如果你想更严格一点，可以把阈值定为0.6。有时我看到更严格的标准，比如0.6甚至0.7，但很少见到有人将阈值降到0.5以下。</p><p>人们定义<strong>loU</strong>这个概念是为了评价你的对象定位算法是否精准，但更一般地说，<strong>loU</strong>衡量了两个边界框重叠地相对大小。如果你有两个边界框，你可以计算交集，计算并集，然后求两个数值的比值，所以这也可以判断两个边界框是否相似，我们将在下一个视频中再次用到这个函数，当我们讨论非最大值抑制时再次用到。</p><h3 id="3-7-非极大值抑制（Non-max-suppression）"><a href="#3-7-非极大值抑制（Non-max-suppression）" class="headerlink" title="3.7 非极大值抑制（Non-max suppression）"></a>3.7 非极大值抑制（Non-max suppression）</h3><p>到目前为止你们学到的对象检测中的一个问题是，你的算法可能对同一个对象做出多次检测，所以算法不是对某个对象检测出一次，而是检测出多次。非极大值抑制这个方法可以确保你的算法对每个对象只检测一次</p><p>所以这就是非极大值抑制，非最大值意味着你只输出概率最大的分类结果，但抑制很接近，但不是最大的其他预测结果，所以这方法叫做非极大值抑制。</p><h3 id="3-8-Anchor-Boxes"><a href="#3-8-Anchor-Boxes" class="headerlink" title="3.8 Anchor Boxes"></a>3.8 Anchor Boxes</h3><p>到目前为止，对象检测中存在的一个问题是每个格子只能检测出一个对象，如果你想让一个格子检测出多个对象，你可以这么做，就是使用<strong>anchor box</strong>这个概念</p><p>这就是<strong>anchor box</strong>的概念，我们建立<strong>anchor box</strong>这个概念，是为了处理两个对象出现在同一个格子的情况，实践中这种情况很少发生，特别是如果你用的是19×19网格而不是3×3的网格，两个对象中点处于361个格子中同一个格子的概率很低，确实会出现，但出现频率不高。也许设立<strong>anchor box</strong>的好处在于<strong>anchor box</strong>能让你的学习算法能够更有征对性，特别是如果你的数据集有一些很高很瘦的对象，比如说行人，还有像汽车这样很宽的对象，这样你的算法就能更有针对性的处理，这样有一些输出单元可以针对检测很宽很胖的对象，比如说车子，然后输出一些单元，可以针对检测很高很瘦的对象，比如说行人。</p><p>最后，你应该怎么选择<strong>anchor box</strong>呢？人们一般手工指定<strong>anchor box</strong>形状，你可以选择5到10个<strong>anchor box</strong>形状，覆盖到多种不同的形状，可以涵盖你想要检测的对象的各种形状。还有一个更高级的版本，我就简单说一句，你们如果接触过一些机器学习，可能知道后期<strong>YOLO</strong>论文中有更好的做法，就是所谓的<strong>k-平均算法</strong>，可以将两类对象形状聚类，如果我们用它来选择一组<strong>anchor box</strong>，选择最具有代表性的一组<strong>anchor box</strong>，可以代表你试图检测的十几个对象类别，但这其实是自动选择<strong>anchor box</strong>的高级方法。如果你就人工选择一些形状，合理的考虑到所有对象的形状，你预计会检测的很高很瘦或者很宽很胖的对象，这应该也不难做。</p><h3 id="3-9-YOLO-算法（Putting-it-together-YOLO-algorithm）"><a href="#3-9-YOLO-算法（Putting-it-together-YOLO-algorithm）" class="headerlink" title="3.9 YOLO 算法（Putting it together: YOLO algorithm）"></a>3.9 YOLO 算法（Putting it together: YOLO algorithm）</h3><p>你们已经学到对象检测算法的大部分组件了，在这个视频里，我们会把所有组件组装在一起构成<strong>YOLO</strong>对象检测算法。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103420.png" alt></p><p>我们先看看如何构造你的训练集，假设你要训练一个算法去检测三种对象，行人、汽车和摩托车，你还需要显式指定完整的背景类别。这里有3个类别标签，如果你要用两个<strong>anchor box</strong>，那么输出 $y$ 就是3×3×2×8，其中3×3表示3×3个网格，2是<strong>anchor box</strong>的数量，8是向量维度，8实际上先是5（$p_{c},b_{x},b_{y},b_{h},b_{w}$）再加上类别的数量（$c_{1},c_{2},c_{3}$）。你可以将它看成是3×3×2×8，或者3×3×16。要构造训练集，你需要遍历9个格子，然后构成对应的目标向量$y$。</p><p><img src="../../../%E6%9A%82%E5%AD%98/%E5%90%B4%E6%81%A9%E8%BE%BE/images/36ff927836cfcd7fee9413e2d34757d8.png" alt></p><p>所以先看看第一个格子（编号1），里面没什么有价值的东西，行人、车子和摩托车，三个类别都没有出现在左上格子中，所以对应那个格子目标$y$就是这样的，$y= \begin{bmatrix} 0 &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; 0 &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ?\\ \end{bmatrix}^{T}$，第一个<strong>anchor box</strong>的 $p_{c}$ 是0，因为没什么和第一个<strong>anchor box</strong>有关的，第二个<strong>anchor box</strong>的 $p_{c}$ 也是0，剩下这些值是<strong>don’t care-s</strong>。</p><p>现在网格中大多数格子都是空的，但那里的格子（编号2）会有这个目标向量$y$，$y =\begin{bmatrix} 0 &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; ? &amp; 1 &amp; b_{x} &amp; b_{y} &amp; b_{h} &amp;b_{w} &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}^{T}$，所以假设你的训练集中，对于车子有这样一个边界框（编号3），水平方向更长一点。所以如果这是你的<strong>anchor box</strong>，这是<strong>anchor box 1</strong>（编号4），这是<strong>anchor box 2</strong>（编号5），然后红框和<strong>anchor box 2</strong>的交并比更高，那么车子就和向量的下半部分相关。要注意，这里和<strong>anchor box 1</strong>有关的 $p_{c}$ 是0，剩下这些分量都是<strong>don’t care-s</strong>，然后你的第二个 $p_{c} =1$，然后你要用这些（$b_{x},b_{y},b_{h},b_{w}$）来指定红边界框的位置，然后指定它的正确类别是2($c_{1}= 0 ,c_{2} = 1,c_{3} = 0$)，对吧，这是一辆汽车。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103426.png" alt></p><p>所以你这样遍历9个格子，遍历3×3网格的所有位置，你会得到这样一个向量，得到一个16维向量，所以最终输出尺寸就是3×3×16。和之前一样，简单起见，我在这里用的是3×3网格，实践中用的可能是19×19×16，或者需要用到更多的<strong>anchor box</strong>，可能是19×19×5×8，即19×19×40，用了5个<strong>anchor box</strong>。这就是训练集，然后你训练一个卷积网络，输入是图片，可能是100×100×3，然后你的卷积网络最后输出尺寸是，在我们例子中是3×3×16或者3×3×2×8。</p><p>接下来我们看看你的算法是怎样做出预测的，输入图像，你的神经网络的输出尺寸是这个3×3×2×8，对于9个格子，每个都有对应的向量。对于左上的格子（编号1），那里没有任何对象，那么我们希望你的神经网络在那里（第一个$p_{c}$）输出的是0，这里（第二个$p_{c}$）是0，然后我们输出一些值，你的神经网络不能输出问号，不能输出<strong>don’t care-s</strong>，剩下的我输入一些数字，但这些数字基本上会被忽略，因为神经网络告诉你，那里没有任何东西，所以输出是不是对应一个类别的边界框无关紧要，所以基本上是一组数字，多多少少都是噪音（输出 $y$ 如编号3所示）。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103430.png" alt></p><p>和这里的边界框不大一样，希望$y$的值，那个左下格子（编号2）的输出$y$（编号4所示），形式是，对于边界框1来说（$p_{c}$）是0，然后就是一组数字，就是噪音（<strong>anchor box 1</strong>对应行人，此格子中无行人，$p_{c} = 0,b_{x} = ?,b_{y} = ?,b_{h} = ?,b_{w} = ?,c_{1} = ?c_{2} = ?,c_{3} =?$）。希望你的算法能输出一些数字，可以对车子指定一个相当准确的边界框（<strong>anchor box 2</strong>对应汽车，此格子中有车，$ p_{c} = 1,b_{x},b_{y},b_{h},b_{w},c_{1} = 0,c_{2}= 1,c_{3} = 0$），这就是神经网络做出预测的过程。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103438.png" alt></p><p>最后你要运行一下这个非极大值抑制，为了让内容更有趣一些，我们看看一张新的测试图像，这就是运行非极大值抑制的过程。如果你使用两个<strong>anchor box</strong>，那么对于9个格子中任何一个都会有两个预测的边界框，其中一个的概率$p_{c}$很低。但9个格子中，每个都有两个预测的边界框，比如说我们得到的边界框是是这样的，注意有一些边界框可以超出所在格子的高度和宽度（编号1所示）。接下来你抛弃概率很低的预测，去掉这些连神经网络都说，这里很可能什么都没有，所以你需要抛弃这些（编号2所示）。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103446.png" alt></p><p>最后，如果你有三个对象检测类别，你希望检测行人，汽车和摩托车，那么你要做的是，对于每个类别单独运行非极大值抑制，处理预测结果所属类别的边界框，用非极大值抑制来处理行人类别，用非极大值抑制处理车子类别，然后对摩托车类别进行非极大值抑制，运行三次来得到最终的预测结果。所以算法的输出最好能够检测出图像里所有的车子，还有所有的行人（编号3所示）。</p><p>这就是<strong>YOLO</strong>对象检测算法，这实际上是最有效的对象检测算法之一，包含了整个计算机视觉对象检测领域文献中很多最精妙的思路。</p><h3 id="3-10-候选区域（选修）（Region-proposals-Optional-）"><a href="#3-10-候选区域（选修）（Region-proposals-Optional-）" class="headerlink" title="3.10 候选区域（选修）（Region proposals (Optional)）"></a>3.10 候选区域（选修）（Region proposals (Optional)）</h3><p>如果你们阅读一下对象检测的文献，可能会看到一组概念，所谓的候选区域，这在计算机视觉领域是非常有影响力的概念。我把这个视频定为可选视频是因为我用到候选区域这一系列算法的频率没有那么高，但当然了，这些工作是很有影响力的，你们在工作中也可能会碰到，我们来看看。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103551.png" alt></p><p>你们还记得滑动窗法吧，你使用训练过的分类器，在这些窗口中全部运行一遍，然后运行一个检测器，看看里面是否有车辆，行人和摩托车。现在你也可以运行一下卷积算法，这个算法的其中一个缺点是，它在显然没有任何对象的区域浪费时间，对吧。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103559.png" alt></p><p>所以这里这个矩形区域（编号1）基本是空的，显然没有什么需要分类的东西。也许算法会在这个矩形上（编号2）运行，而你知道上面没有什么有趣的东西。</p><p>[<strong>Girshick R, Donahue J, Darrell T, et al. Rich feature hierarchies for accurate object detection and semantic segmentation[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2014: 580-587.</strong>]</p><p>所以<strong>Ross Girshick</strong>，<strong>Jeff Donahue</strong>，<strong>Trevor Darrell</strong>，<strong>Jitendra Malik</strong>，在本幻灯片底部引用到的论文中提出一种叫做<strong>R-CNN</strong>的算法，意思是带区域的卷积网络，或者说带区域的<strong>CNN</strong>。这个算法尝试选出一些区域，在这些区域上运行卷积网络分类器是有意义的，所以这里不再针对每个滑动窗运行检测算法，而是只选择一些窗口，在少数窗口上运行卷积网络分类器。</p><p>选出候选区域的方法是运行图像分割算法，分割的结果是下边的图像，为了找出可能存在对象的区域。比如说，分割算法在这里得到一个色块，所以你可能会选择这样的边界框（编号1），然后在这个色块上运行分类器，就像这个绿色的东西（编号2），在这里找到一个色块，接下来我们还会在那个矩形上（编号2）运行一次分类器，看看有没有东西。在这种情况下，如果在蓝色色块上（编号3）运行分类器，希望你能检测出一个行人，如果你在青色色块(编号4)上运行算法，也许你可以发现一辆车，我也不确定。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103602.png" alt></p><p>所以这个细节就是所谓的分割算法，你先找出可能2000多个色块，然后在这2000个色块上放置边界框，然后在这2000个色块上运行分类器，这样需要处理的位置可能要少的多，可以减少卷积网络分类器运行时间，比在图像所有位置运行一遍分类器要快。特别是这种情况，现在不仅是在方形区域（编号5）中运行卷积网络，我们还会在高高瘦瘦（编号6）的区域运行，尝试检测出行人，然后我们在很宽很胖的区域（编号7）运行，尝试检测出车辆，同时在各种尺度运行分类器。</p><p>这就是<strong>R-CNN</strong>或者<strong>区域CNN</strong>的特色概念，现在看来<strong>R-CNN</strong>算法还是很慢的。所以有一系列的研究工作去改进这个算法，所以基本的<strong>R-CNN</strong>算法是使用某种算法求出候选区域，然后对每个候选区域运行一下分类器，每个区域会输出一个标签，有没有车子？有没有行人？有没有摩托车？并输出一个边界框，这样你就能在确实存在对象的区域得到一个精确的边界框。</p><p>澄清一下，<strong>R-CNN</strong>算法不会直接信任输入的边界框，它也会输出一个边界框$b_{x}$，$b_{y}$，$b_{h}$和$b_{w}$，这样得到的边界框比较精确，比单纯使用图像分割算法给出的色块边界要好，所以它可以得到相当精确的边界框。</p><p>现在<strong>R-CNN</strong>算法的一个缺点是太慢了，所以这些年来有一些对<strong>R-CNN</strong>算法的改进工作，<strong>Ross Girshik</strong>提出了快速的<strong>R-CNN</strong>算法，它基本上是<strong>R-CNN</strong>算法，不过用卷积实现了滑动窗法。最初的算法是逐一对区域分类的，所以快速<strong>R-CNN</strong>用的是滑动窗法的一个卷积实现，这和你在本周第四个视频（3.4 卷积的滑动窗口实现）中看到的大致相似，这显著提升了<strong>R-CNN</strong>的速度。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628103607.png" alt></p><p>事实证明，<strong>Fast R-CNN</strong>算法的其中一个问题是得到候选区域的聚类步骤仍然非常缓慢，所以另一个研究组，<strong>任少卿</strong>（<strong>Shaoqing Ren</strong>）、<strong>何凯明</strong>（<strong>Kaiming He</strong>）、<strong>Ross Girshick</strong>和<strong>孙剑</strong>（<strong>Jiangxi Sun</strong>）提出了更快的<strong>R-CNN</strong>算法（<strong>Faster R-CNN</strong>），使用的是卷积神经网络，而不是更传统的分割算法来获得候选区域色块，结果比<strong>Fast R-CNN</strong>算法快得多。不过我认为大多数更快<strong>R-CNN</strong>的算法实现还是比<strong>YOLO</strong>算法慢很多。</p><p>候选区域的概念在计算机视觉领域的影响力相当大，所以我希望你们能了解一下这些算法，因为你可以看到还有人在用这些概念。对我个人来说，这是我的个人看法而不是整个计算机视觉研究界的看法，我觉得候选区域是一个有趣的想法，但这个方法需要两步，首先得到候选区域，然后再分类，相比之下，能够一步做完，类似于<strong>YOLO</strong>或者你只看一次（<strong>You only look once</strong>）这个算法，在我看来，是长远而言更有希望的方向。但这是我的个人看法，而不是整个计算机视觉研究界的看法，所以你们最好批判接受。但我想这个<strong>R-CNN</strong>概念，你可能会想到，或者碰到其他人在用，所以这也是值得了解的，这样你可以更好地理解别人的算法。</p><h2 id="第四周-特殊应用：人脸识别和神经风格转换（Special-applications-Face-recognition-amp-Neural-style-transfer）"><a href="#第四周-特殊应用：人脸识别和神经风格转换（Special-applications-Face-recognition-amp-Neural-style-transfer）" class="headerlink" title="第四周 特殊应用：人脸识别和神经风格转换（Special applications: Face recognition &amp;Neural style transfer）"></a>第四周 特殊应用：人脸识别和神经风格转换（Special applications: Face recognition &amp;Neural style transfer）</h2><h3 id="4-1-什么是人脸识别？"><a href="#4-1-什么是人脸识别？" class="headerlink" title="4.1 什么是人脸识别？"></a>4.1 什么是人脸识别？</h3><h3 id="4-2-One-Shot学习（One-shot-learning）"><a href="#4-2-One-Shot学习（One-shot-learning）" class="headerlink" title="4.2 One-Shot学习（One-shot learning）"></a>4.2 One-Shot学习（One-shot learning）</h3><p>所以要让人脸识别能够做到一次学习，为了能有更好的效果，你现在要做的应该是学习<strong>Similarity</strong>函数。详细地说，你想要神经网络学习这样一个用$d$表示的函数，$d(img1,img2) = degree\ of\ difference\ between\ images$，它以两张图片作为输入，然后输出这两张图片的差异值。如果你放进同一个人的两张照片，你希望它能输出一个很小的值，如果放进两个长相差别很大的人的照片，它就输出一个很大的值。所以在识别过程中，如果这两张图片的差异值小于某个阈值$\tau$，它是一个超参数，那么这时就能预测这两张图片是同一个人，如果差异值大于τ，就能预测这是不同的两个人，这就是解决人脸验证问题的一个可行办法。</p><h3 id="4-3-Siamese-网络（Siamese-network）"><a href="#4-3-Siamese-网络（Siamese-network）" class="headerlink" title="4.3 Siamese 网络（Siamese network）"></a>4.3 Siamese 网络（Siamese network）</h3><p>对于两个不同的输入，运行相同的卷积神经网络，然后比较它们，这一般叫做<strong>Siamese</strong>网络架构。这里提到的很多观点，都来自于<strong>Yaniv Taigman</strong>，<strong>Ming Yang</strong>，<strong>Marc’ Aurelio Ranzato</strong>，<strong>Lior Wolf</strong>的这篇论文，他们开发的系统叫做<strong>DeepFace</strong>。</p><p>怎么训练这个<strong>Siamese</strong>神经网络呢？不要忘了这两个网络有相同的参数，所以你实际要做的就是训练一个网络，它计算得到的编码可以用于函数$d$，它可以告诉你两张图片是否是同一个人。更准确地说，神经网络的参数定义了一个编码函数$f(x^{(i)})$，如果给定输入图像$x^{(i)}$，这个网络会输出$x^{(i)}$的128维的编码。你要做的就是学习参数，使得如果两个图片$x^{( i)}$和$x^{( j)}$是同一个人，那么你得到的两个编码的距离就小。前面几个幻灯片我都用的是$x^{(1)}$和$x^{( 2)}$，其实训练集里任意一对$x^{(i)}$和$x^{(j)}$都可以。相反，如果$x^{(i)}$和$x^{(j)}$是不同的人，那么你会想让它们之间的编码距离大一点。</p><h3 id="4-4-Triplet-损失"><a href="#4-4-Triplet-损失" class="headerlink" title="4.4 Triplet 损失"></a>4.4 Triplet 损失</h3><p>想通过学习神经网络的参数来得到优质的人脸图片编码，方法之一就是定义三元组损失函数然后应用梯度下降。</p><p>用三元组损失的术语来说，你要做的通常是看一个 <strong>Anchor</strong> 图片，你想让<strong>Anchor</strong>图片和<strong>Positive</strong>图片（<strong>Positive</strong>意味着是同一个人）的距离很接近。然而，当<strong>Anchor</strong>图片与<strong>Negative</strong>图片（<strong>Negative</strong>意味着是非同一个人）对比时，你会想让他们的距离离得更远一点。</p><p>这就是为什么叫做三元组损失，它代表你通常会同时看三张图片，你需要看<strong>Anchor</strong>图片、<strong>Postive</strong>图片，还有<strong>Negative</strong>图片，我要把<strong>Anchor</strong>图片、<strong>Positive</strong>图片和<strong>Negative</strong>图片简写成$A$、$P$、$N$。</p><p>把这些写成公式的话，你想要的是网络的参数或者编码能够满足以下特性，也就是说你想要$|| f(A) - f(P) ||^{2}$，你希望这个数值很小，准确地说，你想让它小于等$f(A)$和$f(N)$之间的距离，或者说是它们的范数的平方（即：$|| f(A) - f(P)||^{2} \leq ||f(A) - f(N)||^{2}$）。（$|| f(A) - f(P) ||^{2}$）当然这就是$d(A,P)$，（$|| f(A) - f(N) ||^{2}$）这是$d(A,N)$，你可以把$d$ 看作是距离(<strong>distance</strong>)函数，这也是为什么我们把它命名为$d$。</p><p>现在如果我把方程右边项移到左边，最终就得到：</p><p>$|| f(A) - f(P)||^{2} \leq ||f(A) - f(N)||^{2}$</p><p>现在我要对这个表达式做一些小的改变，有一种情况满足这个表达式，但是没有用处，就是把所有的东西都学成0，如果$f$总是输出0，即0-0≤0，这就是0减去0还等于0，如果所有图像的$f$都是一个零向量，那么总能满足这个方程。所以为了确保网络对于所有的编码不会总是输出0，也为了确保它不会把所有的编码都设成互相相等的。另一种方法能让网络得到这种没用的输出，就是如果每个图片的编码和其他图片一样，这种情况，你还是得到0-0。</p><p>为了阻止网络出现这种情况，我们需要修改这个目标，也就是，这个不能是刚好小于等于0，应该是比0还要小，所以这个应该小于一个$-a$值（即$|| f(A) - f(P)||^{2} -||f(A) - f(N)||^{2} \leq -a$），这里的$a$是另一个超参数，这个就可以阻止网络输出无用的结果。按照惯例，我们习惯写$+a$（即$|| f(A) - f(P)||^{2} -||f(A) - f(N)||^{2} +a\leq0$），而不是把$-a$写在后面，它也叫做间隔(<strong>margin</strong>)，这个术语你会很熟悉，如果你看过关于支持向量机 (<strong>SVM</strong>)的文献，没看过也不用担心。我们可以把上面这个方程（$|| f(A) - f(P)||^{2}  -||f(A) - f(N)||^{2}$）也修改一下，加上这个间隔参数。</p><p>接下来我们定义损失函数，这个例子的损失函数，它的定义基于三元图片组，我先从前一张幻灯片复制过来一些式子，就是$|| f( A) - f( P)||^{2} -||f( A) - f( N)||^{2} +a \leq0$。所以为了定义这个损失函数，我们取这个和0的最大值：</p><p>$L( A,P,N) = max(|| f( A) - f( P)||^{2} -|| f( A) - f( N)||^{2} + a,0)$</p><p>这个$max$函数的作用就是，只要这个$|| f( A) - f( P)||^{2} -|| f( A) - f( N)||^{2} + a\leq0$，那么损失函数就是0。只要你能使画绿色下划线部分小于等于0，只要你能达到这个目标，那么这个例子的损失就是0。</p><p>另一方面如果这个$|| f( A) - f( P)||^{2} -|| f( A) - f( N)||^{2} + a\leq0$，然后你取它们的最大值，最终你会得到绿色下划线部分（即$|| f(A) - f( P)||^{2} -|| f( A) - f( N)||^{2} +a$）是最大值，这样你会得到一个正的损失值。通过最小化这个损失函数达到的效果就是使这部分$|| f( A) - f( P)||^{2} -||f( A) - f( N)||^{2} +a$成为0，或者小于等于0。只要这个损失函数小于等于0，网络不会关心它负值有多大。</p><p>这是一个三元组定义的损失，整个网络的代价函数应该是训练集中这些单个三元组损失的总和。假如你有一个10000个图片的训练集，里面是1000个不同的人的照片，你要做的就是取这10000个图片，然后生成这样的三元组，然后训练你的学习算法，对这种代价函数用梯度下降，这个代价函数就是定义在你数据集里的这样的三元组图片上。</p><p>注意，为了定义三元组的数据集你需要成对的$A$和$P$，即同一个人的成对的图片，为了训练你的系统你确实需要一个数据集，里面有同一个人的多个照片。这是为什么在这个例子中，我说假设你有1000个不同的人的10000张照片，也许是这1000个人平均每个人10张照片，组成了你整个数据集。如果你只有每个人一张照片，那么根本没法训练这个系统。当然，训练完这个系统之后，你可以应用到你的一次学习问题上，对于你的人脸识别系统，可能你只有想要识别的某个人的一张照片。但对于训练集，你需要确保有同一个人的多个图片，至少是你训练集里的一部分人，这样就有成对的<strong>Anchor</strong>和<strong>Positive</strong>图片了。</p><p>所以为了构建一个数据集，你要做的就是尽可能选择难训练的三元组$A$、$P$和$N$。具体而言，你想要所有的三元组都满足这个条件（$d(A,P) + a \leq d(A,N)$），难训练的三元组就是，你的$A$、$P$和$N$的选择使得$d(A,P)$很接近$d(A,N)$，即$d(A,P) \approx d(A,N)$，这样你的学习算法会竭尽全力使右边这个式子变大（$d(A,N)$），或者使左边这个式子（$d(A,P)$）变小，这样左右两边至少有一个$a$的间隔。并且选择这样的三元组还可以增加你的学习算法的计算效率，如果随机的选择这些三元组，其中有太多会很简单，梯度算法不会有什么效果，因为网络总是很轻松就能得到正确的结果，只有选择难的三元组梯度下降法才能发挥作用，使得这两边离得尽可能远。</p><h3 id="4-5-人脸验证与二分类（Face-verification-and-binary-classification）"><a href="#4-5-人脸验证与二分类（Face-verification-and-binary-classification）" class="headerlink" title="4.5 人脸验证与二分类（Face verification and binary classification）"></a>4.5 人脸验证与二分类（Face verification and binary classification）</h3><p>总结一下，把人脸验证当作一个监督学习，创建一个只有成对图片的训练集，不是三个一组，而是成对的图片，目标标签是1表示一对图片是一个人，目标标签是0表示图片中是不同的人。利用不同的成对图片，使用反向传播算法去训练神经网络，训练<strong>Siamese</strong>神经网络。</p><h3 id="4-6-什么是神经风格迁移？（What-is-neural-style-transfer-）"><a href="#4-6-什么是神经风格迁移？（What-is-neural-style-transfer-）" class="headerlink" title="4.6 什么是神经风格迁移？（What is neural style transfer?）"></a>4.6 什么是神经风格迁移？（What is neural style transfer?）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628104629.png" alt></p><h3 id="4-7-CNN特征可视化（What-are-deep-ConvNets-learning-）"><a href="#4-7-CNN特征可视化（What-are-deep-ConvNets-learning-）" class="headerlink" title="4.7 CNN特征可视化（What are deep ConvNets learning?）"></a>4.7 CNN特征可视化（What are deep ConvNets learning?）</h3><h3 id="4-8-代价函数（Cost-function）"><a href="#4-8-代价函数（Cost-function）" class="headerlink" title="4.8 代价函数（Cost function）"></a>4.8 代价函数（Cost function）</h3><p>记住我们的问题，给你一个内容图像$C$，给定一个风格图片$S$，而你的目标是生成一个新图片$G$。为了实现神经风格迁移，你要做的是定义一个关于$G$的代价函数$J$用来评判某个生成图像的好坏，我们将使用梯度下降法去最小化$J(G)$，以便于生成这个图像。</p><p>怎么判断生成图像的好坏呢？我们把这个代价函数定义为两个部分。</p><p>$J_{\text{content}}(C,G)$</p><p>第一部分被称作内容代价，这是一个关于内容图片和生成图片的函数，它是用来度量生成图片$G$的内容与内容图片$C$的内容有多相似。</p><p>$J_{\text{style}}(S,G)$</p><p>然后我们会把结果加上一个风格代价函数，也就是关于$S$和$G$的函数，用来度量图片$G$的风格和图片$S$的风格的相似度。</p><p>$J( G) = a J_{\text{content}}( C,G) + \beta J_{\text{style}}(S,G)$</p><p>最后我们用两个超参数$a$和$\beta$来来确定内容代价和风格代价，两者之间的权重用两个超参数来确定。两个代价的权重似乎是多余的，我觉得一个超参数似乎就够了，但提出神经风格迁移的原始作者使用了两个不同的超参数，我准备保持一致。</p><p>关于神经风格迁移算法我将在接下来几段视频中展示的，是基于<strong>Leon Gatys</strong>， <strong>Alexandra Ecker</strong>和<strong>Matthias Bethge</strong>的这篇论文。这篇论文并不是很难读懂，如果你愿意，看完这些视频，我也非常推荐你去看看他们的论文。</p><p><strong>Leon A. Gatys, Alexander S. Ecker, Matthias Bethge, (2015). A Neural Algorithm of Artistic Style</strong> (<a href="https://arxiv.org/abs/1508.06576" target="_blank" rel="noopener">https://arxiv.org/abs/1508.06576</a>)</p><h3 id="4-9-内容代价函数（Content-cost-function）"><a href="#4-9-内容代价函数（Content-cost-function）" class="headerlink" title="4.9 内容代价函数（Content cost function）"></a>4.9 内容代价函数（Content cost function）</h3><p>现在你需要衡量假如有一个内容图片和一个生成图片他们在内容上的相似度，我们令这个$a^{[l][C]}$和$a^{[l][G]}$，代表这两个图片$C$和$G$的$l$层的激活函数值。如果这两个激活值相似，那么就意味着两个图片的内容相似。</p><p>我们定义这个</p><p>$J_{\text{content}}( C,G) = \frac{1}{2}|| a^{[l][C]} - a^{[l][G]}||^{2}$</p><h3 id="4-10-风格代价函数（Style-cost-function）"><a href="#4-10-风格代价函数（Style-cost-function）" class="headerlink" title="4.10 风格代价函数（Style cost function）"></a>4.10 风格代价函数（Style cost function）</h3><p>比如你有这样一张图片，你可能已经对这个计算很熟悉了，它能算出这里是否含有不同隐藏层。现在你选择了某一层$l$（编号1），比如这一层去为图片的风格定义一个深度测量，现在我们要做的就是将图片的风格定义为$l$层中各个通道之间激活项的相关系数。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105250.png" alt></p><h3 id="4-11-一维到三维推广（1D-and-3D-generalizations-of-models）"><a href="#4-11-一维到三维推广（1D-and-3D-generalizations-of-models）" class="headerlink" title="4.11 一维到三维推广（1D and 3D generalizations of models）"></a>4.11 一维到三维推广（1D and 3D generalizations of models）</h3><blockquote><p>一下就快到了晚上十点了，晚安早点睡。</p></blockquote><h1 id="第五门课-序列模型-Sequence-Models"><a href="#第五门课-序列模型-Sequence-Models" class="headerlink" title="第五门课 序列模型(Sequence Models)"></a>第五门课 序列模型(Sequence Models)</h1><h2 id="第一周-循环序列模型（Recurrent-Neural-Networks）"><a href="#第一周-循环序列模型（Recurrent-Neural-Networks）" class="headerlink" title="第一周 循环序列模型（Recurrent Neural Networks）"></a>第一周 循环序列模型（Recurrent Neural Networks）</h2><h3 id="1-1-为什么选择序列模型？（Why-Sequence-Models-）"><a href="#1-1-为什么选择序列模型？（Why-Sequence-Models-）" class="headerlink" title="1.1 为什么选择序列模型？（Why Sequence Models?）"></a>1.1 为什么选择序列模型？（Why Sequence Models?）</h3><p>要想了解到这个模型学到了什么，一种非正式的方法就是进行一次新序列采样</p><h3 id="1-2-数学符号（Notation）"><a href="#1-2-数学符号（Notation）" class="headerlink" title="1.2 数学符号（Notation）"></a>1.2 数学符号（Notation）</h3><p>如果你遇到了一个不在你词表中的单词，答案就是创建一个新的标记，也就是一个叫做<strong>Unknow Word</strong>的伪造单词，用\&lt;<strong>UNK</strong>&gt;作为标记，来表示不在词表中的单词</p><h3 id="1-3-循环神经网络模型（Recurrent-Neural-Network-Model）"><a href="#1-3-循环神经网络模型（Recurrent-Neural-Network-Model）" class="headerlink" title="1.3 循环神经网络模型（Recurrent Neural Network Model）"></a>1.3 循环神经网络模型（Recurrent Neural Network Model）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105640.png" alt="140529e4d7531babb5ba21778cd88bc3"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105707.png" alt></p><p>循环神经网络用的激活函数经常是<strong>tanh</strong>，不过有时候也会用<strong>ReLU</strong>，但是<strong>tanh</strong>是更通常的选择，我们有其他方法来避免梯度消失问题，我们将在之后进行讲述。选用哪个激活函数是取决于你的输出$y$，如果它是一个二分问题，那么我猜你会用<strong>sigmoid</strong>函数作为激活函数，如果是$k$类别分类问题的话，那么可以选用<strong>softmax</strong>作为激活函数。不过这里激活函数的类型取决于你有什么样类型的输出$y$，对于命名实体识别来说$y$只可能是0或者1，那我猜这里第二个激活函数$g$可以是<strong>sigmoid</strong>激活函数。</p><h3 id="1-4-通过时间的反向传播（Backpropagation-through-time）"><a href="#1-4-通过时间的反向传播（Backpropagation-through-time）" class="headerlink" title="1.4 通过时间的反向传播（Backpropagation through time）"></a>1.4 通过时间的反向传播（Backpropagation through time）</h3><p>在这个反向传播的过程中，最重要的信息传递或者说最重要的递归运算就是这个从右到左的运算，这也就是为什么这个算法有一个很别致的名字，叫做<strong>“通过（穿越）时间反向传播</strong>（<strong>backpropagation through time</strong>）”。取这个名字的原因是对于前向传播，你需要从左到右进行计算，在这个过程中，时刻$t$不断增加。而对于反向传播，你需要从右到左进行计算，就像时间倒流。“通过时间反向传播”，就像穿越时光，这种说法听起来就像是你需要一台时光机来实现这个算法一样。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105829.png" alt="nn_cell_backpro"></p><h3 id="1-5-不同类型的循环神经网络（Different-types-of-RNNs）"><a href="#1-5-不同类型的循环神经网络（Different-types-of-RNNs）" class="headerlink" title="1.5 不同类型的循环神经网络（Different types of RNNs）"></a>1.5 不同类型的循环神经网络（Different types of <strong>RNN</strong>s）</h3><p>这个视频的内容参考了<strong>Andrej Karpathy</strong>的博客，一篇叫做《循环神经网络的非理性效果》（“<strong>The Unreasonable Effectiveness of Recurrent Neural Networks</strong>”）的文章，我们看一些例子。</p><p>“<strong>多对多</strong>”、“<strong>多对一</strong>”、“<strong>一对一</strong>”和“<strong>一对多</strong>”的结构</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105923.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628105923.png" alt></p><h3 id="1-6-语言模型和序列生成（Language-model-and-sequence-generation）"><a href="#1-6-语言模型和序列生成（Language-model-and-sequence-generation）" class="headerlink" title="1.6 语言模型和序列生成（Language model and sequence generation）"></a>1.6 语言模型和序列生成（Language model and sequence generation）</h3><p>所以语言模型所做的就是，它会告诉你某个特定的句子它出现的概率是多少，根据我所说的这个概率，假设你随机拿起一张报纸，打开任意邮件，或者任意网页或者听某人说下一句话，并且这个人是你的朋友，这个你即将从世界上的某个地方得到的句子会是某个特定句子的概率是多少，例如“<strong>the apple and pear salad</strong>”。它是两种系统的基本组成部分，一个刚才所说的语音识别系统，还有机器翻译系统，它要能正确输出最接近的句子。而语言模型做的最基本工作就是输入一个句子，准确地说是一个文本序列，$y^{&lt;1&gt;}$，$y^{&lt;2&gt;}$一直到$y^{&lt;T_{y}&gt;}$。对于语言模型来说，用$y$来表示这些序列比用$x$来表示要更好，然后语言模型会估计某个句子序列中各个单词出现的可能性。</p><p>那么如何建立一个语言模型呢？为了使用<strong>RNN</strong>建立出这样的模型，你首先需要一个训练集，包含一个很大的英文文本语料库（<strong>corpus</strong>）或者其它的语言，你想用于构建模型的语言的语料库。语料库是自然语言处理的一个专有名词，意思就是很长的或者说数量众多的英文句子组成的文本。</p><h3 id="1-7-对新序列采样（Sampling-novel-sequences）"><a href="#1-7-对新序列采样（Sampling-novel-sequences）" class="headerlink" title="1.7 对新序列采样（Sampling novel sequences）"></a>1.7 对新序列采样（Sampling novel sequences）</h3><p>这些就是基础的<strong>RNN</strong>结构和如何去建立一个语言模型并使用它，对于训练出的语言模型进行采样。在之后的视频中，我想探讨在训练<strong>RNN</strong>时一些更加深入的挑战以及如何适应这些挑战，特别是梯度消失问题来建立更加强大的<strong>RNN</strong>模型。下节课，我们将谈到梯度消失并且会开始谈到<strong>GRU</strong>，也就是门控循环单元和<strong>LSTM</strong>长期记忆网络模型。</p><h3 id="1-8-循环神经网络的梯度消失（Vanishing-gradients-with-RNNs）"><a href="#1-8-循环神经网络的梯度消失（Vanishing-gradients-with-RNNs）" class="headerlink" title="1.8 循环神经网络的梯度消失（Vanishing gradients with RNNs）"></a>1.8 循环神经网络的梯度消失（Vanishing gradients with <strong>RNN</strong>s）</h3><p>你应该还记得之前讨论的训练很深的网络，我们讨论了梯度消失的问题。比如说一个很深很深的网络（上图编号4所示），100层，甚至更深，对这个网络从左到右做前向传播然后再反向传播。我们知道如果这是个很深的神经网络，从输出$\hat y$得到的梯度很难传播回去，很难影响靠前层的权重，很难影响前面层（编号5所示的层）的计算。</p><p>对于有同样问题的<strong>RNN</strong>，首先从左到右前向传播，然后反向传播。但是反向传播会很困难，因为同样的梯度消失的问题，后面层的输出误差（上图编号6所示）很难影响前面层（上图编号7所示的层）的计算。这就意味着，实际上很难让一个神经网络能够意识到它要记住看到的是单数名词还是复数名词，然后在序列后面生成依赖单复数形式的<strong>was</strong>或者<strong>were</strong>。而且在英语里面，这中间的内容（上图编号8所示）可以任意长，对吧？所以你需要长时间记住单词是单数还是复数，这样后面的句子才能用到这些信息。也正是这个原因，所以基本的<strong>RNN</strong>模型会有很多局部影响，意味着这个输出$\hat y^{&lt;3&gt;}$（上图编号9所示）主要受$\hat y^{&lt;3&gt;}$附近的值（上图编号10所示）的影响，上图编号11所示的一个数值主要与附近的输入（上图编号12所示）有关，上图编号6所示的输出，基本上很难受到序列靠前的输入（上图编号10所示）的影响，这是因为不管输出是什么，不管是对的，还是错的，这个区域都很难反向传播到序列的前面部分，也因此网络很难调整序列前面的计算。这是基本的<strong>RNN</strong>算法的一个缺点，我们会在下几节视频里处理这个问题。如果不管的话，<strong>RNN</strong>会不擅长处理长期依赖的问题。</p><p>尽管我们一直在讨论梯度消失问题，但是，你应该记得我们在讲很深的神经网络时，我们也提到了梯度爆炸，我们在反向传播的时候，随着层数的增多，梯度不仅可能指数型的下降，也可能指数型的上升。事实上梯度消失在训练<strong>RNN</strong>时是首要的问题，尽管梯度爆炸也是会出现，但是梯度爆炸很明显，因为指数级大的梯度会让你的参数变得极其大，以至于你的网络参数崩溃。所以梯度爆炸很容易发现，因为参数会大到崩溃，你会看到很多<strong>NaN</strong>，或者不是数字的情况，这意味着你的网络计算出现了数值溢出。如果你发现了梯度爆炸的问题，一个解决方法就是用梯度修剪。梯度修剪的意思就是观察你的梯度向量，如果它大于某个阈值，缩放梯度向量，保证它不会太大，这就是通过一些最大值来修剪的方法。所以如果你遇到了梯度爆炸，如果导数值很大，或者出现了<strong>NaN</strong>，就用梯度修剪，这是相对比较鲁棒的，这是梯度爆炸的解决方法。然而梯度消失更难解决，这也是我们下几节视频的主题。</p><h3 id="1-9-GRU单元（Gated-Recurrent-Unit（GRU））"><a href="#1-9-GRU单元（Gated-Recurrent-Unit（GRU））" class="headerlink" title="1.9 GRU单元（Gated Recurrent Unit（GRU））"></a>1.9 <strong>GRU</strong>单元（Gated Recurrent Unit（<strong>GRU</strong>））</h3><p>许多<strong>GRU</strong>的想法都来分别自于<strong>Yu Young Chang, Kagawa，Gaza Hera, Chang Hung Chu</strong>和<br><strong>Jose Banjo</strong>的两篇论文。我再引用上个视频中你已经见过的这个句子，“<strong>The cat, which already ate……, was full.</strong>”，你需要记得猫是单数的，为了确保你已经理解了为什么这里是<strong>was</strong>而不是<strong>were</strong>，“<strong>The cat was full.</strong>”或者是“<strong>The cats were full</strong>”。当我们从左到右读这个句子，<strong>GRU</strong>单元将会有个新的变量称为$c$，代表细胞（<strong>cell</strong>），即记忆细胞（下图编号1所示）。记忆细胞的作用是提供了记忆的能力，比如说一只猫是单数还是复数，所以当它看到之后的句子的时候，它仍能够判断句子的主语是单数还是复数。于是在时间$t$处，有记忆细胞$c^{<t>}$，然后我们看的是，<strong>GRU</strong>实际上输出了激活值$a^{<t>}$，$c^{<t>} = a^{<t>}$（下图编号2所示）。于是我们想要使用不同的符号$c$和$a$来表示记忆细胞的值和输出的激活值，即使它们是一样的。我现在使用这个标记是因为当我们等会说到<strong>LSTMs</strong>的时候，这两个会是不同的值，但是现在对于<strong>GRU</strong>，$c^{<t>}$的值等于$a^{<t>}$的激活值。</t></t></t></t></t></t></p><p>所以这些等式表示了<strong>GRU</strong>单元的计算，在每个时间步，我们将用一个候选值重写记忆细胞，即${\tilde{c}}^{<t>}$的值，所以它就是个候选值，替代了$c^{<t>}$的值。然后我们用<strong>tanh</strong>激活函数来计算，${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$，所以${\tilde{c}}^{<t>}$的值就是个替代值，代替表示$c^{<t>}$的值（下图编号3所示）。</t></t></t></t-1></t></t></t></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110301.png" alt></p><p>重点来了，在<strong>GRU</strong>中真正重要的思想是我们有一个门，我先把这个门叫做$\Gamma_{u}$（上图编号4所示），这是个下标为$u$的大写希腊字母$\Gamma$，$u$代表更新门，这是一个0到1之间的值。为了让你直观思考<strong>GRU</strong>的工作机制，先思考$\Gamma_{u}$，这个一直在0到1之间的门值，实际上这个值是把这个式子带入<strong>sigmoid</strong>函数得到的，$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$。我们还记得<strong>sigmoid</strong>函数是上图编号5所示这样的，它的输出值总是在0到1之间，对于大多数可能的输入，<strong>sigmoid</strong>函数的输出总是非常接近0或者非常接近1。在这样的直觉下，可以想到$\Gamma_{u}$在大多数的情况下非常接近0或1。然后这个字母<strong>u</strong>表示“<strong>update</strong>”，我选了字母$\Gamma$是因为它看起来像门。还有希腊字母<strong>G</strong>，<strong>G</strong>是门的首字母，所以<strong>G</strong>表示门。</t></t-1></p><p>然后<strong>GRU</strong>的关键部分就是上图编号3所示的等式，我们刚才写出来的用$\tilde{c}$更新$c$的等式。然后门决定是否要真的更新它。于是我们这么看待它，记忆细胞$c^{<t>}$将被设定为0或者1，这取决于你考虑的单词在句子中是单数还是复数，因为这里是单数情况，所以我们先假定它被设为了1，或者如果是复数的情况我们就把它设为0。然后<strong>GRU</strong>单元将会一直记住$c^{<t>}$的值，直到上图编号7所示的位置，$c^{<t>}$的值还是1，这就告诉它，噢，这是单数，所以我们用<strong>was</strong>。于是门，即$\Gamma_{u}$的作用就是决定什么时候你会更新这个值，特别是当你看到词组<strong>the cat</strong>，即句子的主语猫，这就是一个好时机去更新这个值。然后当你使用完它的时候，“<strong>The cat, which already ate……, was full.</strong>”，然后你就知道，我不需要记住它了，我可以忘记它了。</t></t></t></p><p>所以我们接下来要给<strong>GRU</strong>用的式子就是$c^{<t>} = \Gamma_{u}<em>{\tilde{c}}^{<t>} +\left( 1- \Gamma_{u} \right)</t></em>c^{<t-1>}$（上图编号1所示）。你应该注意到了，如果这个更新值$\Gamma_{u} =1$，也就是说把这个新值，即$c^{<t>}$设为候选值（$\Gamma_{u} =1$时简化上式，$c^{<t>} = {\tilde{c}}^{<t>}$）。将门值设为1（上图编号2所示），然后往前再更新这个值。对于所有在这中间的值，你应该把门的值设为0，即$\Gamma_{u}= 0$，意思就是说不更新它，就用旧的值。因为如果$\Gamma_{u} = 0$，则$c^{<t>} =c^{<t-1>}$，$c^{<t>}$等于旧的值。甚至你从左到右扫描这个句子，当门值为0的时候（上图编号3所示，中间$\Gamma_{u}=0$一直为0，表示一直不更新），就是说不更新它的时候，不要更新它，就用旧的值，也不要忘记这个值是什么，这样即使你一直处理句子到上图编号4所示，$c^{<t>}$应该会一直等$c^{<t-1>}$，于是它仍然记得猫是单数的。</t-1></t></t></t-1></t></t></t></t></t-1></t></p><p>让我再画个图来（下图所示）解释一下<strong>GRU</strong>单元，顺便说一下，当你在看网络上的博客或者教科书或者教程之类的，这些图对于解释<strong>GRU</strong>和我们稍后会讲的<strong>LSTM</strong>是相当流行的，我个人感觉式子在图片中比较容易理解，那么即使看不懂图片也没关系，我就画画，万一能帮得上忙就最好了。</p><p><strong>GRU</strong>单元输入$c^{<t-1>}$（下图编号1所示），对于上一个时间步，先假设它正好等于$a^{<t-1>}$，所以把这个作为输入。然后$x^{<t>}$也作为输入（下图编号2所示），然后把这两个用合适权重结合在一起，再用<strong>tanh</strong>计算，算出${\tilde{c}}^{<t>}$，${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$，即$c^{<t>}$的替代值。</t></t></t-1></t></t></t></t-1></t-1></p><p>再用一个不同的参数集，通过<strong>sigmoid</strong>激活函数算出$\Gamma_{u}$，$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$，即更新门。最后所有的值通过另一个运算符结合，我并不会写出公式，但是我用紫色阴影标注的这个方框（下图编号5所示，其所代表的运算过程即下图编号13所示的等式），代表了这个式子。所以这就是紫色运算符所表示的是，它输入一个门值（下图编号6所示），新的候选值（下图编号7所示），这再有一个门值（下图编号8所示）和$c^{<t>}$的旧值（下图编号9所示），所以它把这个（下图编号1所示）、这个（下图编号3所示）和这个（下图编号4所示）作为输入一起产生记忆细胞的新值$c^{<t>}$，所以$c^{<t>}$等于$a^{<t>}$。如果你想，你也可以也把这个代入<strong>softmax</strong>或者其他预测$y^{<t>}$的东西。</t></t></t></t></t></t></t-1></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110350.png" alt></p><p>这就是<strong>GRU</strong>单元或者说是一个简化过的<strong>GRU</strong>单元，它的优点就是通过门决定，当你从左（上图编号10所示）到右扫描一个句子的时候，这个时机是要更新某个记忆细胞，还是不更新，不更新（上图编号11所示，中间$\Gamma_{u}=0$一直为0，表示一直不更新）直到你到你真的需要使用记忆细胞的时候（上图编号12所示），这可能在句子之前就决定了。因为sigmoid的值，现在因为门很容易取到0值，只要这个值是一个很大的负数，再由于数值上的四舍五入，上面这些门大体上就是0，或者说非常非常非常接近0。所以在这样的情况下，这个更新式子（上图编号13所示的等式）就会变成$c^{<t>} = c^{<t-1>}$，这非常有利于维持细胞的值。因为$\Gamma_{u}$很接近0，可能是0.000001或者更小，这就不会有梯度消失的问题了。因为$\Gamma_{u}$很接近0，这就是说$c^{<t>}$几乎就等于$c^{<t-1>}$，而且$c^{<t>}$的值也很好地被维持了，即使经过很多很多的时间步（上图编号14所示）。这就是缓解梯度消失问题的关键，因此允许神经网络运行在非常庞大的依赖词上，比如说<strong>cat</strong>和<strong>was</strong>单词即使被中间的很多单词分割开。</t></t-1></t></t-1></t></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110347.png" alt></p><p>现在我想说下一些实现的细节，在这个我写下的式子中$c^{<t>}$可以是一个向量（上图编号1所示），如果你有100维的隐藏的激活值，那么$c^{<t>}$也是100维的，${\tilde{c}}^{<t>}$也是相同的维度（${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$），$\Gamma_{u}$也是相同的维度（$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$），还有画在框中的其他值。这样的话“*”实际上就是元素对应的乘积（$c^{<t>} = \Gamma_{u}<em>{\tilde{c}}^{<t>} +\left( 1- \Gamma_{u} \right)</t></em>c^{<t-1>}$），所以这里的$\Gamma_{u}$：（$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$），即如果门是一个100维的向量，$\Gamma_{u}$也就100维的向量，里面的值几乎都是0或者1，就是说这100维的记忆细胞$c^{<t>}$（$c^{<t>}=a^{<t>}$上图编号1所示）就是你要更新的比特。</t></t></t></t></t-1></t-1></t></t></t-1></t></t-1></t></t></t></t></p><p>当然在实际应用中$\Gamma_{u}$不会真的等于0或者1，有时候它是0到1的一个中间值（上图编号5所示），但是这对于直观思考是很方便的，就把它当成确切的0，完全确切的0或者就是确切的1。元素对应的乘积做的就是告诉<strong>GRU</strong>单元哪个记忆细胞的向量维度在每个时间步要做更新，所以你可以选择保存一些比特不变，而去更新其他的比特。比如说你可能需要一个比特来记忆猫是单数还是复数，其他比特来理解你正在谈论食物，因为你在谈论吃饭或者食物，然后你稍后可能就会谈论“<strong>The cat was full.</strong>”，你可以每个时间点只改变一些比特。</p><p>你现在已经理解<strong>GRU</strong>最重要的思想了，幻灯片中展示的实际上只是简化过的<strong>GRU</strong>单元，现在来描述一下完整的<strong>GRU</strong>单元。</p><p>对于完整的<strong>GRU</strong>单元我要做的一个改变就是在我们计算的第一个式子中给记忆细胞的新候选值加上一个新的项，我要添加一个门$\Gamma_{r}$（下图编号1所示），你可以认为$r$代表相关性（<strong>relevance</strong>）。这个$\Gamma_{r}$门告诉你计算出的下一个$c^{<t>}$的候选值${\tilde{c}}^{<t>}$跟$c^{<t-1>}$有多大的相关性。计算这个门$\Gamma_{r}$需要参数，正如你看到的这个，一个新的参数矩阵$W_{r}$，$\Gamma_{r}= \sigma(W_{r}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack + b_{r})$。</t></t-1></t-1></t></t></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110359.png" alt></p><p>正如你所见，有很多方法可以来设计这些类型的神经网络，然后我们为什么有$\Gamma_{r}$？为什么不用上一张幻灯片里的简单的版本？这是因为多年来研究者们试验过很多很多不同可能的方法来设计这些单元，去尝试让神经网络有更深层的连接，去尝试产生更大范围的影响，还有解决梯度消失的问题，<strong>GRU</strong>就是其中一个研究者们最常使用的版本，也被发现在很多不同的问题上也是非常健壮和实用的。你可以尝试发明新版本的单元，只要你愿意。但是<strong>GRU</strong>是一个标准版本，也就是最常使用的。你可以想象到研究者们也尝试了很多其他版本，类似这样的但不完全是，比如我这里写的这个。然后另一个常用的版本被称为<strong>LSTM</strong>，表示长短时记忆网络，这个我们会在下节视频中讲到，但是<strong>GRU</strong>和<strong>LSTM</strong>是在神经网络结构中最常用的两个具体实例。</p><p>还有在符号上的一点，我尝试去定义固定的符号让这些概念容易理解，如果你看学术文章的话，你有的时候会看到有些人使用另一种符号$\tilde{x}$，$u$，$r$和$h$表示这些量。但我试着在<strong>GRU</strong>和<strong>LSTM</strong>之间用一种更固定的符号，比如使用更固定的符号$\Gamma$来表示门，所以希望这能让这些概念更好理解。</p><p>所以这就是<strong>GRU</strong>，即门控循环单元，这是<strong>RNN</strong>的其中之一。这个结构可以更好捕捉非常长范围的依赖，让<strong>RNN</strong>更加有效。然后我简单提一下其他常用的神经网络，比较经典的是这个叫做<strong>LSTM</strong>，即长短时记忆网络，我们在下节视频中讲解。</p><h3 id="1-10-长短期记忆（LSTM（long-short-term-memory）unit）"><a href="#1-10-长短期记忆（LSTM（long-short-term-memory）unit）" class="headerlink" title="1.10 长短期记忆（LSTM（long short term memory）unit）"></a>1.10 长短期记忆（<strong>LSTM</strong>（long short term memory）unit）</h3><p>在上一个视频中你已经学了<strong>GRU</strong>（门控循环单元）。它能够让你可以在序列中学习非常深的连接。其他类型的单元也可以让你做到这个，比如<strong>LSTM</strong>即长短时记忆网络，甚至比<strong>GRU</strong>更加有效，让我们看看。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110433.png" alt></p><p>这里是上个视频中的式子，对于<strong>GRU</strong>我们有$a^{&lt; t &gt;} = c^{<t>}$。</t></p><p>还有两个门:</p><p>更新门$\Gamma_{u}$（<strong>the update gate</strong>）</p><p>相关门$\Gamma_{r}$（<strong>the relevance gate</strong>）</p><p>${\tilde{c}}^{<t>}$，这是代替记忆细胞的候选值，然后我们使用更新门$\Gamma_{u}$来决定是否要用${\tilde{c}}^{<t>}$ 更新$c^{<t>}$。</t></t></t></p><p><strong>LSTM</strong>是一个比<strong>GRU</strong>更加强大和通用的版本，这多亏了 <strong>Sepp Hochreiter</strong>和 <strong>Jurgen Schmidhuber</strong>，感谢那篇开创性的论文，它在序列模型上有着巨大影响。我感觉这篇论文是挺难读懂的，虽然我认为这篇论文在深度学习社群有着重大的影响，它深入讨论了梯度消失的理论，我感觉大部分的人学到<strong>LSTM</strong>的细节是在其他的地方，而不是这篇论文。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110438.png" alt></p><p>这就是<strong>LSTM</strong>主要的式子（上图编号2所示），我们继续回到记忆细胞<strong>c</strong>上面来，使用${\tilde{c}}^{<t>} = tanh(W_{c}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{c}$来更新它的候选值${\tilde{c}}^{<t>}$（上图编号3所示）。注意了，在<strong>LSTM</strong>中我们不再有$a^{<t>} = c^{<t>}$的情况，这是现在我们用的是类似于左边这个式子（上图编号4所示），但是有一些改变，现在我们专门使用$a^{<t>}$或者$a^{<t-1>}$，而不是用$c^{<t-1>}$，我们也不用$\Gamma_{r}$，即相关门。虽然你可以使用<strong>LSTM</strong>的变体，然后把这些东西（左边所示的<strong>GRU</strong>公式）都放回来，但是在更加典型的<strong>LSTM</strong>里面，我们先不那样做。</t-1></t-1></t></t></t></t></t></t-1></t></p><p>我们像以前那样有一个更新门$\Gamma_{u}$和表示更新的参数$W_{u}$，$\Gamma_{u}= \sigma(W_{u}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{u})$（上图编号5所示）。一个<strong>LSTM</strong>的新特性是不只有一个更新门控制，这里的这两项（上图编号6，7所示），我们将用不同的项来代替它们，要用别的项来取代$\Gamma_{u}$和$1-\Gamma_{u}$，这里（上图编号6所示）我们用$\Gamma_{u}$。</t></t-1></p><p>然后这里（上图编号7所示）用遗忘门（<strong>the forget gate</strong>），我们叫它$\Gamma_{f}$，所以这个$\Gamma_{f} =\sigma(W_{f}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{f})$（上图编号8所示）；</t></t-1></p><p>然后我们有一个新的输出门，$\Gamma_{o} =\sigma(W_{o}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +&gt;b_{o})$（上图编号9所示）；</t></t-1></p><p>于是记忆细胞的更新值$c^{<t>} =\Gamma_{u}<em>{\tilde{c}}^{<t>} + \Gamma_{f}</t></em>c^{<t-1>}$（上图编号10所示）；</t-1></t></p><p>所以这给了记忆细胞选择权去维持旧的值$c^{<t-1>}$或者就加上新的值${\tilde{c}}^{<t>}$，所以这里用了单独的更新门$\Gamma_{u}$和遗忘门$\Gamma_{f}$，</t></t-1></p><p>然后这个表示更新门（$\Gamma_{u}= \sigma(W_{u}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{u})$上图编号5所示）；</t></t-1></p><p>遗忘门（$\Gamma_{f} =\sigma(W_{f}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{f})$上图编号8所示）和输出门（上图编号9所示）。</t></t-1></p><p>最后$a^{<t>} = c^{<t>}$的式子会变成$a^{<t>} = \Gamma_{o}<em>c^{<t>}$。这就是<em>*LSTM</em></t></em>主要的式子了，然后这里（上图编号11所示）有三个门而不是两个，这有点复杂，它把门放到了和之前有点不同的地方。</t></t></t></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110444.png" alt></p><p>再提一下，这些式子就是控制<strong>LSTM</strong>行为的主要的式子了（上图编号1所示）。像之前一样用图片稍微解释一下，先让我把图画在这里（上图编号2所示）。如果图片过于复杂，别担心，我个人感觉式子比图片好理解，但是我画图只是因为它比较直观。这个右上角的图的灵感来自于<strong>Chris Ola</strong>的一篇博客，标题是《理解<strong>LSTM</strong>网络》（<strong>Understanding LSTM Network</strong>），这里的这张图跟他博客上的图是很相似的，但关键的不同可能是这里的这张图用了$a^{<t-1>}$和$x^{<t>}$来计算所有门值（上图编号3，4所示），在这张图里是用$a^{<t-1>}$， $x^{<t>}$一起来计算遗忘门$\Gamma_{f}$的值，还有更新门$\Gamma_{u}$以及输出门$\Gamma_{o}$（上图编号4所示）。然后它们也经过<strong>tanh</strong>函数来计算${\tilde{c}}^{<t>}$（上图编号5所示），这些值被用复杂的方式组合在一起，比如说元素对应的乘积或者其他的方式来从之前的$c^{<t-1>}$（上图编号6所示）中获得$c^{<t>}$（上图编号7所示）。</t></t-1></t></t></t-1></t></t-1></p><p>这里其中一个元素很有意思，如你在这一堆图（上图编号8所示的一系列图片）中看到的，这是其中一个，再把他们连起来，就是把它们按时间次序连起来，这里（上图编号9所示）输入$x^{&lt;1&gt;}$，然后$x^{&lt;2&gt;}$，$x^{&lt;3&gt;}$，然后你可以把这些单元依次连起来，这里输出了上一个时间的$a$，$a$会作为下一个时间步的输入，$c$同理。在下面这一块，我把图简化了一下（相对上图编号2所示的图有所简化）。然后这有个有意思的事情，你会注意到上面这里有条线（上图编号10所示的线），这条线显示了只要你正确地设置了遗忘门和更新门，<strong>LSTM</strong>是相当容易把$c^{&lt;0&gt;}$的值（上图编号11所示）一直往下传递到右边，比如$c^{&lt;3&gt;} = c^{&lt;0&gt;}$（上图编号12所示）。这就是为什么<strong>LSTM</strong>和<strong>GRU</strong>非常擅长于长时间记忆某个值，对于存在记忆细胞中的某个值，即使经过很长很长的时间步。</p><p>这就是<strong>LSTM</strong>，你可能会想到这里和一般使用的版本会有些不同，最常用的版本可能是门值不仅取决于$a^{<t-1>}$和$x^{<t>}$，有时候也可以偷窥一下$c^{<t-1>}$的值（上图编号13所示），这叫做“窥视孔连接”（<strong>peephole connection</strong>）。虽然不是个好听的名字，但是你想，“<strong>偷窥孔连接</strong>”其实意思就是门值不仅取决于$a^{<t-1>}$和$x^{<t>}$，也取决于上一个记忆细胞的值（$c^{<t-1>}$），然后“偷窥孔连接”就可以结合这三个门（$\Gamma_{u}$、$\Gamma_{f}$、$\Gamma_{o}$）来计算了。</t-1></t></t-1></t-1></t></t-1></p><p>如你所见<strong>LSTM</strong>主要的区别在于一个技术上的细节，比如这（上图编号13所示）有一个100维的向量，你有一个100维的隐藏的记忆细胞单元，然后比如第50个$c^{<t-1>}$的元素只会影响第50个元素对应的那个门，所以关系是一对一的，于是并不是任意这100维的$c^{<t-1>}$可以影响所有的门元素。相反的，第一个$c^{<t-1>}$的元素只能影响门的第一个元素，第二个元素影响对应的第二个元素，如此类推。但如果你读过论文，见人讨论“<strong>偷窥孔连接</strong>”，那就是在说$c^{<t-1>}$也能影响门值。</t-1></t-1></t-1></t-1></p><p><strong>LSTM</strong>前向传播图：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110500.png" alt="ST"></p><p><img src="../../../%E6%9A%82%E5%AD%98/%E5%90%B4%E6%81%A9%E8%BE%BE/images/LSTM_rnn.png" alt="STM_rn"></p><p><strong>LSTM</strong>反向传播计算：</p><p><strong>门求偏导：</strong></p><p>$d \Gamma_o^{\langle t \rangle} = da_{next}<em>\tanh(c_{next}) </em> \Gamma_o^{\langle t \rangle}*(1-\Gamma_o^{\langle t \rangle})\tag{1}$</p><p>$d\tilde c^{\langle t \rangle} = dc_{next}<em>\Gamma_i^{\langle t \rangle}+ \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> i_t <em> da_{next} </em> \tilde c^{\langle t \rangle} * (1-\tanh(\tilde c)^2) \tag{2}$</p><p>$d\Gamma_u^{\langle t \rangle} = dc_{next}<em>\tilde c^{\langle t \rangle} + \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> \tilde c^{\langle t \rangle} <em> da_{next}</em>\Gamma_u^{\langle t \rangle}*(1-\Gamma_u^{\langle t \rangle})\tag{3}$</p><p>$d\Gamma_f^{\langle t \rangle} = dc_{next}<em>\tilde c_{prev} + \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> c_{prev} <em> da_{next}</em>\Gamma_f^{\langle t \rangle}*(1-\Gamma_f^{\langle t \rangle})\tag{4}$</p><p><strong>参数求偏导 ：</strong></p><p>$ dW_f = d\Gamma_f^{\langle t \rangle} <em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{5} $<br>$ dW_u = d\Gamma_u^{\langle t \rangle} </em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{6} $<br> $ dW_c = d\tilde c^{\langle t \rangle} <em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{7} $<br>$ dW_o = d\Gamma_o^{\langle t \rangle} </em> \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{8}$</p><p>为了计算$db_f, db_u, db_c, db_o$ 需要各自对$d\Gamma_f^{\langle t \rangle}, d\Gamma_u^{\langle t \rangle}, d\tilde c^{\langle t \rangle}, d\Gamma_o^{\langle t \rangle}$ 求和。</p><p>最后，计算隐藏状态、记忆状态和输入的偏导数：</p><p>$ da_{prev} = W_f^T<em>d\Gamma_f^{\langle t \rangle} + W_u^T </em> d\Gamma_u^{\langle t \rangle}+ W_c^T <em> d\tilde c^{\langle t \rangle} + W_o^T </em> d\Gamma_o^{\langle t \rangle} \tag{9}$</p><p>$ dc_{prev} = dc_{next}\Gamma_f^{\langle t \rangle} + \Gamma_o^{\langle t \rangle} <em> (1- \tanh(c_{next})^2)</em>\Gamma_f^{\langle t \rangle}<em>da_{next} \tag{10}$<br>$ dx^{\langle t \rangle} = W_f^T</em>d\Gamma_f^{\langle t \rangle} + W_u^T <em> d\Gamma_u^{\langle t \rangle}+ W_c^T </em> d\tilde c_t + W_o^T * d\Gamma_o^{\langle t \rangle}\tag{11} $</p><p>这就是<strong>LSTM</strong>，我们什么时候应该用<strong>GRU</strong>？什么时候用<strong>LSTM</strong>？这里没有统一的准则。而且即使我先讲解了<strong>GRU</strong>，在深度学习的历史上，<strong>LSTM</strong>也是更早出现的，而<strong>GRU</strong>是最近才发明出来的，它可能源于<strong>Pavia</strong>在更加复杂的<strong>LSTM</strong>模型中做出的简化。研究者们在很多不同问题上尝试了这两种模型，看看在不同的问题不同的算法中哪个模型更好，所以这不是个学术和高深的算法，我才想要把这两个模型展示给你。</p><p><strong>GRU</strong>的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。</p><p>但是<strong>LSTM</strong>更加强大和灵活，因为它有三个门而不是两个。如果你想选一个使用，我认为<strong>LSTM</strong>在历史进程上是个更优先的选择，所以如果你必须选一个，我感觉今天大部分的人还是会把<strong>LSTM</strong>作为默认的选择来尝试。虽然我认为最近几年<strong>GRU</strong>获得了很多支持，而且我感觉越来越多的团队也正在使用<strong>GRU</strong>，因为它更加简单，而且还效果还不错，它更容易适应规模更加大的问题。</p><p>所以这就是<strong>LSTM</strong>，无论是<strong>GRU</strong>还是<strong>LSTM</strong>，你都可以用它们来构建捕获更加深层连接的神经网络。</p><p>（<strong>Hochreiter S, Schmidhuber J. Long Short-Term Memory[J]. Neural Computation, 1997, 9(8):1735-1780.</strong>）</p><h3 id="1-11-双向循环神经网络（Bidirectional-RNN）"><a href="#1-11-双向循环神经网络（Bidirectional-RNN）" class="headerlink" title="1.11 双向循环神经网络（Bidirectional RNN）"></a>1.11 双向循环神经网络（Bidirectional <strong>RNN</strong>）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110548.png" alt></p><h3 id="1-12-深层循环神经网络（Deep-RNNs）"><a href="#1-12-深层循环神经网络（Deep-RNNs）" class="headerlink" title="1.12 深层循环神经网络（Deep RNNs）"></a>1.12 深层循环神经网络（Deep <strong>RNN</strong>s）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110627.png" alt></p><p>对于像左边这样标准的神经网络，你可能见过很深的网络，甚至于100层深，而对于<strong>RNN</strong>来说，有三层就已经不少了。由于时间的维度，<strong>RNN</strong>网络会变得相当大，即使只有很少的几层，很少会看到这种网络堆叠到100层。但有一种会容易见到，就是在每一个上面堆叠循环层，把这里的输出去掉（上图编号1所示），然后换成一些深的层，这些层并不水平连接，只是一个深层的网络，然后用来预测$y^{&lt;1&gt;}$。同样这里（上图编号2所示）也加上一个深层网络，然后预测$y^{&lt;2&gt;}$。这种类型的网络结构用的会稍微多一点，这种结构有三个循环单元，在时间上连接，接着一个网络在后面接一个网络，当然$y^{&lt;3&gt;}$和$y^{&lt;4&gt;}$也一样，这是一个深层网络，但没有水平方向上的连接，所以这种类型的结构我们会见得多一点。通常这些单元（上图编号3所示）没必要非是标准的<strong>RNN</strong>，最简单的<strong>RNN</strong>模型，也可以是<strong>GRU</strong>单元或者<strong>LSTM</strong>单元，并且，你也可以构建深层的双向<strong>RNN</strong>网络。由于深层的<strong>RNN</strong>训练需要很多计算资源，需要很长的时间，尽管看起来没有多少循环层，这个也就是在时间上连接了三个深层的循环层，你看不到多少深层的循环层，不像卷积神经网络一样有大量的隐含层。</p><p>这就是深层<strong>RNN</strong>的内容，从基本的<strong>RNN</strong>网络，基本的循环单元到<strong>GRU</strong>，<strong>LSTM</strong>，再到双向<strong>RNN</strong>，还有深层版的模型。这节课后，你已经可以构建很不错的学习序列的模型了。</p><h2 id="第二周-自然语言处理与词嵌入（Natural-Language-Processing-and-Word-Embeddings）"><a href="#第二周-自然语言处理与词嵌入（Natural-Language-Processing-and-Word-Embeddings）" class="headerlink" title="第二周 自然语言处理与词嵌入（Natural Language Processing and Word Embeddings）"></a>第二周 自然语言处理与词嵌入（Natural Language Processing and Word Embeddings）</h2><h3 id="2-1-词汇表征（Word-Representation）"><a href="#2-1-词汇表征（Word-Representation）" class="headerlink" title="2.1 词汇表征（Word Representation）"></a>2.1 词汇表征（Word Representation）</h3><h3 id="2-2-使用词嵌入（Using-Word-Embeddings）"><a href="#2-2-使用词嵌入（Using-Word-Embeddings）" class="headerlink" title="2.2 使用词嵌入（Using Word Embeddings）"></a>2.2 使用词嵌入（Using Word Embeddings）</h3><p>尽管<strong>one-hot</strong>向量很快计算，而学到的用于词嵌入的300维的向量会更加紧凑。</p><h3 id="2-3-词嵌入的特性（Properties-of-Word-Embeddings）"><a href="#2-3-词嵌入的特性（Properties-of-Word-Embeddings）" class="headerlink" title="2.3 词嵌入的特性（Properties of Word Embeddings）"></a>2.3 词嵌入的特性（Properties of Word Embeddings）</h3><p>这是一系列你希望词嵌入可以捕捉的单词的特征表示，假如我提出一个问题，<strong>man</strong>如果对应<strong>woman</strong>，那么<strong>king</strong>应该对应什么？你们应该都能猜到<strong>king</strong>应该对应<strong>queen</strong>。能否有一种算法来自动推导出这种关系，下面就是实现的方法。</p><p>在之前我们谈到过用<strong>t-SNE</strong>算法来将单词可视化。<strong>t-SNE算法</strong>所做的就是把这些300维的数据用一种非线性的方式映射到2维平面上，可以得知<strong>t-SNE</strong>中这种映射很复杂而且很非线性。在进行<strong>t-SNE</strong>映射之后，你不能总是期望使等式成立的关系，会像左边那样成一个平行四边形，尽管在这个例子最初的300维的空间内你可以依赖这种平行四边形的关系来找到使等式成立的一对类比，通过<strong>t-SNE算法</strong>映射出的图像可能是正确的。但在大多数情况下，由于<strong>t-SNE</strong>的非线性映射，你就没法再指望这种平行四边形了，很多这种平行四边形的类比关系在<strong>t-SNE</strong>映射中都会失去原貌。</p><p>现在，再继续之前，我想再快速地列举一个最常用的相似度函数，这个最常用的相似度函数叫做余弦相似度。这是我们上个幻灯片所得到的等式（下图编号1所示），在余弦相似度中，假如在向量$u$和$v$之间定义相似度</p><p>在本节视频中，你见到了词嵌入是如何被用于类比推理的，可能你不会自己动手构建一个类比推理系统作为一项应用，不过希望在这些可学习的类特征的表示方式能够给你一些直观的感受。你还看知道了余弦相似度可以作为一种衡量两个词嵌入向量间相似度的办法，我们谈了许多有关这些嵌入的特性，以及如何使用它们。下节视频中，我们来讨论如何真正的学习这些词嵌入。</p><h3 id="2-4-嵌入矩阵（Embedding-Matrix）"><a href="#2-4-嵌入矩阵（Embedding-Matrix）" class="headerlink" title="2.4 嵌入矩阵（Embedding Matrix）"></a>2.4 嵌入矩阵（Embedding Matrix）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628110855.png" alt></p><p>，要记住的一件事就是我们的目标是学习一个嵌入矩阵$E$。在下节视频中你将会随机地初始化矩阵$E$，然后使用梯度下降法来学习这个300×10,000的矩阵中的各个参数，$E$乘以这个<strong>one-hot</strong>向量（上图编号1所示）会得到嵌入向量。再多说一点，当我们写这个等式（上图编号2所示）的时候，写出这些符号是很方便的，代表用矩阵$E$乘以<strong>one-hot</strong>向量$O_{j}$。但当你动手实现时，用大量的矩阵和向量相乘来计算它，效率是很低下的，因为<strong>one-hot</strong>向量是一个维度非常高的向量，并且几乎所有元素都是0，所以矩阵向量相乘效率太低，因为我们要乘以一大堆的0。所以在实践中你会使用一个专门的函数来单独查找矩阵$E$的某列，而不是用通常的矩阵乘法来做，但是在画示意图时（上图所示，即矩阵$E$乘以<strong>one-hot</strong>向量示意图），这样写比较方便。但是例如在<strong>Keras</strong>中就有一个嵌入层，然后我们用这个嵌入层更有效地从嵌入矩阵中提取出你需要的列，而不是对矩阵进行很慢很复杂的乘法运算。</p><h3 id="2-5-学习词嵌入（Learning-Word-Embeddings）"><a href="#2-5-学习词嵌入（Learning-Word-Embeddings）" class="headerlink" title="2.5 学习词嵌入（Learning Word Embeddings）"></a>2.5 学习词嵌入（Learning Word Embeddings）</h3><p>研究者发现，如果你真想建立一个语言模型，用目标词的前几个单词作为上下文是常见做法（上图编号9所示）。但如果你的目标是学习词嵌入，那么你就可以用这些其他类型的上下文（上图编号10所示），它们也能得到很好的词嵌入。</p><h3 id="2-6-Word2Vec"><a href="#2-6-Word2Vec" class="headerlink" title="2.6 Word2Vec"></a>2.6 Word2Vec</h3><p>在本视频中你会见到 <strong>Word2Vec</strong>算法，这是一种简单而且计算时更加高效的方式来学习这种类型的嵌入，让我们来看看。</p><p>本视频中的大多数的想法来源于<strong>Tomas Mikolov</strong>，<strong>Kai Chen</strong>，<strong>Greg Corrado</strong> 和 <strong>Jeff Dean</strong>。</p><p>（<strong>Mikolov T, Chen K, Corrado G, et al. Efficient Estimation of Word Representations in Vector Space[J]. Computer Science, 2013.</strong>）</p><p>假设在训练集中给定了一个这样的句子：“<strong>I want a glass of orange juice to go along with my cereal.</strong>”，在<strong>Skip-Gram</strong>模型中，我们要做的是抽取上下文和目标词配对，来构造一个监督学习问题。上下文不一定总是目标单词之前离得最近的四个单词，或最近的$n$个单词。我们要的做的是随机选一个词作为上下文词，比如选<strong>orange</strong>这个词，然后我们要做的是随机在一定词距内选另一个词，比如在上下文词前后5个词内或者前后10个词内，我们就在这个范围内选择目标词。可能你正好选到了<strong>juice</strong>作为目标词，正好是下一个词（表示<strong>orange</strong>的下一个词），也有可能你选到了前面第二个词，所以另一种配对目标词可以是<strong>glass</strong>，还可能正好选到了单词<strong>my</strong>作为目标词。</p><p>于是我们将构造一个监督学习问题，它给定上下文词，要求你预测在这个词正负10个词距或者正负5个词距内随机选择的某个目标词。显然，这不是个非常简单的学习问题，因为在单词<strong>orange</strong>的正负10个词距之间，可能会有很多不同的单词。但是构造这个监督学习问题的目标并不是想要解决这个监督学习问题本身，而是想要使用这个学习问题来学到一个好的词嵌入模型。</p><p>接下来说说模型的细节，我们继续假设使用一个10,000词的词汇表，有时训练使用的词汇表会超过一百万词。但我们要解决的基本的监督学习问题是学习一种映射关系，从上下文<strong>c</strong>，比如单词<strong>orange</strong>，到某个目标词，记为<strong>t</strong>，可能是单词<strong>juice</strong>或者单词<strong>glass</strong>或者单词<strong>my</strong>。延续上一张幻灯片的例子，在我们的词汇表中，<strong>orange</strong>是第6257个单词，<strong>juice</strong>是10,000个单词中的第4834个，这就是你想要的映射到输出$y$的输入$x$。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111137.png" alt></p><p>为了表示输入，比如单词<strong>orange</strong>，你可以先从<strong>one-hot</strong>向量开始，我们将其写作$O_{c}$，这就是上下文词的<strong>one-hot</strong>向量（上图编号1所示）。然后和你在上节视频中看到的类似，你可以拿嵌入矩阵$E$乘以向量$O_{c}$，然后得到了输入的上下文词的嵌入向量，于是这里$e_{c}=EO_{c}$。在这个神经网络中（上图编号2所示），我们将把向量$e_{c}$喂入一个<strong>softmax</strong>单元。我通常把<strong>softmax</strong>单元画成神经网络中的一个节点（上图编号3所示），这不是字母<strong>O</strong>，而是<strong>softmax</strong>单元，<strong>softmax</strong>单元要做的就是输出$\hat y$。然后我们再写出模型的细节，这是<strong>softmax</strong>模型（上图编号4所示），预测不同目标词的概率：</p><p>$Softmax:p\left( t \middle| c \right) = \frac{e^{\theta_{t}^{T}e_{c}}}{\sum_{j = 1}^{10,000}e^{\theta_{j}^{T}e_{c}}}$</p><p>这里$\theta_{t}$是一个与输出$t$有关的参数，即某个词$t$和标签相符的概率是多少。我省略了<strong>softmax</strong>中的偏差项，想要加上的话也可以加上。</p><p>最终<strong>softmax</strong>的损失函数就会像之前一样，我们用$y$表示目标词，我们这里用的$y$和$\hat y$都是用<strong>one-hot</strong>表示的，于是损失函数就会是：</p><p>$L\left( \hat y,y \right) = - \sum_{i = 1}^{10,000}{y_{i}\log \hat y_{i}}$</p><p>这是常用的<strong>softmax</strong>损失函数，$y$ 就是只有一个1其他都是0的<strong>one-hot</strong>向量，如果目标词是<strong>juice</strong>，那么第4834个元素就是1，其余是0（上图编号5所示）。类似的$\hat y$是一个从<strong>softmax</strong>单元输出的10,000维的向量，这个向量是所有可能目标词的概率。</p><p>总结一下，这大体上就是一个可以找到词嵌入的简化模型和神经网络（上图编号2所示），其实就是个<strong>softmax</strong>单元。矩阵$E$将会有很多参数，所以矩阵$E$有对应所有嵌入向量$e_{c}$的参数（上图编号6所示），<strong>softmax</strong>单元也有$\theta_{t}$的参数（上图编号3所示）。如果优化这个关于所有这些参数的损失函数，你就会得到一个较好的嵌入向量集，这个就叫做<strong>Skip-Gram</strong>模型。它把一个像<strong>orange</strong>这样的词作为输入，并预测这个输入词，从左数或从右数的某个词，预测上下文词的前面一些或者后面一些是什么词。</p><p>实际上使用这个算法会遇到一些问题，首要的问题就是计算速度。尤其是在<strong>softmax</strong>模型中，每次你想要计算这个概率，你需要对你词汇表中的所有10,000个词做求和计算，可能10,000个词的情况还不算太差。如果你用了一个大小为100,000或1,000,000的词汇表，那么这个分母的求和操作是相当慢的，实际上10,000已经是相当慢的了，所以扩大词汇表就更加困难了。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111141.png" alt></p><p>这里有一些解决方案，如分级（<strong>hierarchical</strong>）的<strong>softmax</strong>分类器和<strong>负采样</strong>（<strong>Negative Sampling</strong>）。</p><p>在文献中你会看到的方法是使用一个分级（<strong>hierarchical</strong>）的<strong>softmax</strong>分类器，意思就是说不是一下子就确定到底是属于10,000类中的哪一类。想象如果你有一个分类器（上图编号1所示），它告诉你目标词是在词汇表的前5000个中还是在词汇表的后5000个词中，假如这个二分类器告诉你这个词在前5000个词中（上图编号2所示），然后第二个分类器会告诉你这个词在词汇表的前2500个词中，或者在词汇表的第二组2500个词中，诸如此类，直到最终你找到一个词准确所在的分类器（上图编号3所示），那么就是这棵树的一个叶子节点。像这样有一个树形的分类器，意味着树上内部的每一个节点都可以是一个二分类器，比如逻辑回归分类器，所以你不需要再为单次分类，对词汇表中所有的10,000个词求和了。实际上用这样的分类树，计算成本与词汇表大小的对数成正比（上图编号4所示），而不是词汇表大小的线性函数，这个就叫做分级<strong>softmax</strong>分类器。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111144.png" alt></p><p>我要提一下，在实践中分级<strong>softmax</strong>分类器不会使用一棵完美平衡的分类树或者说一棵左边和右边分支的词数相同的对称树（上图编号1所示的分类树）。实际上，分级的<strong>softmax</strong>分类器会被构造成常用词在顶部，然而不常用的词像<strong>durian</strong>会在树的更深处（上图编号2所示的分类树），因为你想更常见的词会更频繁，所以你可能只需要少量检索就可以获得常用单词像<strong>the</strong>和<strong>of</strong>。然而你更少见到的词比如<strong>durian</strong>就更合适在树的较深处，因为你一般不需要到那样的深处，所以有不同的经验法则可以帮助构造分类树形成分级<strong>softmax</strong>分类器。所以这是你能在文献中见到的一个加速<strong>softmax</strong>分类的方法，但是我不会再花太多时间在这上面了，你可以从我在第一张幻灯片中提到的<strong>Tomas Mikolov</strong>等人的论文中参阅更多的细节，所以我不会再花更多时间讲这个了。因为在下个视频中，我们会讲到另一个方法叫做负采样，我感觉这个会更简单一点，对于加速<strong>softmax</strong>和解决需要在分母中对整个词汇表求和的问题也很有作用，下个视频中你会看到更多的细节。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111148.png" alt></p><p>但是在进入下个视频前，我想要你理解一个东西，那就是怎么对上下文<strong>c</strong>进行采样，一旦你对上下文<strong>c</strong>进行采样，那么目标词<strong>t</strong>就会在上下文<strong>c</strong>的正负10个词距内进行采样。但是你要如何选择上下文<strong>c</strong>？一种选择是你可以就对语料库均匀且随机地采样，如果你那么做，你会发现有一些词，像<strong>the</strong>、<strong>of</strong>、<strong>a</strong>、<strong>and</strong>、<strong>to</strong>诸如此类是出现得相当频繁的，于是你那么做的话，你会发现你的上下文到目标词的映射会相当频繁地得到这些种类的词，但是其他词，像<strong>orange</strong>、<strong>apple</strong>或<strong>durian</strong>就不会那么频繁地出现了。你可能不会想要你的训练集都是这些出现得很频繁的词，因为这会导致你花大部分的力气来更新这些频繁出现的单词的$e_{c}$（上图编号1所示），但你想要的是花时间来更新像<strong>durian</strong>这些更少出现的词的嵌入，即$e_{\text{durian}}$。实际上词$p(c)$的分布并不是单纯的在训练集语料库上均匀且随机的采样得到的，而是采用了不同的分级来平衡更常见的词和不那么常见的词。</p><p>这就是<strong>Word2Vec</strong>的<strong>Skip-Gram</strong>模型，如果你读过我之前提到的论文原文，你会发现那篇论文实际上有两个不同版本的<strong>Word2Vec</strong>模型，<strong>Skip-Gram</strong>只是其中的一个，另一个叫做<strong>CBOW</strong>，即连续词袋模型（<strong>Continuous</strong><br><strong>Bag-Of-Words Model</strong>），它获得中间词两边的的上下文，然后用周围的词去预测中间的词，这个模型也很有效，也有一些优点和缺点。</p><p>总结下：<strong>CBOW</strong>是从原始语句推测目标字词；而<strong>Skip-Gram</strong>正好相反，是从目标字词推测出原始语句。<strong>CBOW</strong>对小型数据库比较合适，而<strong>Skip-Gram</strong>在大型语料中表现更好。 （下图左边为<strong>CBOW</strong>，右边为<strong>Skip-Gram</strong>）</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111151.jpg" alt="bo">                                  <img src="../../../%E6%9A%82%E5%AD%98/%E5%90%B4%E6%81%A9%E8%BE%BE/images/skipgram.jpg" alt="kipgra"></p><p>而刚才讲的<strong>Skip-Gram</strong>模型，关键问题在于<strong>softmax</strong>这个步骤的计算成本非常昂贵，因为它需要在分母里对词汇表中所有词求和。通常情况下，<strong>Skip-Gram</strong>模型用到更多点。在下个视频中，我会展示给你一个算法，它修改了训练目标使其可以运行得更有效，因此它可以让你应用在一个更大的训练集上面，也可以学到更好的词嵌入。</p><h3 id="2-7-负采样（Negative-Sampling）"><a href="#2-7-负采样（Negative-Sampling）" class="headerlink" title="2.7 负采样（Negative Sampling）"></a>2.7 负采样（Negative Sampling）</h3><p>在上个视频中，你见到了<strong>Skip-Gram</strong>模型如何帮助你构造一个监督学习任务，把上下文映射到了目标词上，它如何让你学到一个实用的词嵌入。但是它的缺点就在于<strong>softmax</strong>计算起来很慢。在本视频中，你会看到一个改善过的学习问题叫做负采样，它能做到与你刚才看到的<strong>Skip-Gram</strong>模型相似的事情，但是用了一个更加有效的学习算法，让我们来看看这是怎么做到的。</p><p>我们在这个算法中要做的是构造一个新的监督学习问题，那么问题就是给定一对单词，比如<strong>orange</strong>和<strong>juice</strong>，我们要去预测这是否是一对上下文词-目标词（<strong>context-target</strong>）。</p><p>总结一下，生成这些数据的方式是我们选择一个上下文词（上图编号2所示），再选一个目标词（上图编号3所示），这（上图编号4所示）就是表的第一行，它给了一个正样本，上下文，目标词，并给定标签为1。然后我们要做的是给定几次，比如$K$次（上图编号5所示），我们将用相同的上下文词，再从字典中选取随机的词，<strong>king</strong>、<strong>book</strong>、<strong>the</strong>、<strong>of</strong>等，从词典中任意选取的词，并标记0，这些就会成为负样本（上图编号6所示）。出现以下情况也没关系，就是如果我们从字典中随机选到的词，正好出现在了词距内，比如说在上下文词<strong>orange</strong>正负10个词之内。</p><p>接下来我们将构造一个监督学习问题，其中学习算法输入$x$，输入这对词（上图编号7所示），要去预测目标的标签（上图编号8所示），即预测输出$y$。因此问题就是给定一对词，像<strong>orange</strong>和<strong>juice</strong>，你觉得它们会一起出现么？你觉得这两个词是通过对靠近的两个词采样获得的吗？或者你觉得我是分别在文本和字典中随机选取得到的？这个算法就是要分辨这两种不同的采样方式，这就是如何生成训练集的方法。</p><p>这个算法有一个重要的细节就是如何选取负样本，即在选取了上下文词<strong>orange</strong>之后，你如何对这些词进行采样生成负样本？一个办法是对中间的这些词进行采样，即候选的目标词，你可以根据其在语料中的经验频率进行采样，就是通过词出现的频率对其进行采样。但问题是这会导致你在<strong>like</strong>、<strong>the</strong>、<strong>of</strong>、<strong>and</strong>诸如此类的词上有很高的频率。另一个极端就是用1除以词汇表总词数，即$\frac{1}{\left|v\right|}$，均匀且随机地抽取负样本，这对于英文单词的分布是非常没有代表性的。所以论文的作者<strong>Mikolov</strong>等人根据经验，他们发现这个经验值的效果最好，它位于这两个极端的采样方法之间，既不用经验频率，也就是实际观察到的英文文本的分布，也不用均匀分布，他们采用以下方式：</p><p>$P\left( w_{i} \right) = \frac{f\left( w_{i} \right)^{\frac{3}{4}}}{\sum_{j = 1}^{10,000}{f\left( w_{j} \right)^{\frac{3}{4}}}}$</p><p>进行采样，所以如果$f(w_{i})$是观测到的在语料库中的某个英文词的词频，通过$\frac{3}{4}$次方的计算，使其处于完全独立的分布和训练集的观测分布两个极端之间。我并不确定这是否有理论证明，但是很多研究者现在使用这个方法，似乎也效果不错。</p><p>总结一下，你已经知道了在<strong>softmax</strong>分类器中如何学到词向量，但是计算成本很高。在这个视频中，你见到了如何通过将其转化为一系列二分类问题使你可以非常有效的学习词向量。如果你使用这个算法，你将可以学到相当好的词向量。当然和深度学习的其他领域一样，有很多开源的实现，当然也有预训练过的词向量，就是其他人训练过的然后授权许可发布在网上的，所以如果你想要在<strong>NLP</strong>问题上取得进展，去下载其他人的词向量是很好的方法，在此基础上改进。</p><h3 id="2-8-GloVe-词向量（GloVe-Word-Vectors）"><a href="#2-8-GloVe-词向量（GloVe-Word-Vectors）" class="headerlink" title="2.8 GloVe 词向量（GloVe Word Vectors）"></a>2.8 GloVe 词向量（GloVe Word Vectors）</h3><p><strong>GloVe</strong>代表用词表示的全局变量（<strong>global vectors for word representation</strong>）。在此之前，我们曾通过挑选语料库中位置相近的两个词，列举出词对，即上下文和目标词，<strong>GloVe</strong>算法做的就是使其关系开始明确化。假定$X_$是单词$i$在单词$j$上下文中出现的次数，那么这里$i$和$j$就和$t$和$c$的功能一样，所以你可以认为$X_$等同于$X_$。你也可以遍历你的训练集，然后数出单词$i$在不同单词$j$上下文中出现的个数，单词$t$在不同单词$c$的上下文中共出现多少次。根据上下文和目标词的定义，你大概会得出$X_$等于$X_{ji}$这个结论。事实上，如果你将上下文和目标词的范围定义为出现于左右各10词以内的话，那么就会有一种对称关系。如果你对上下文的选择是，上下文总是目标词前一个单词的话，那么$X_$和$X_{ji}$就不会像这样对称了。不过对于<strong>GloVe</strong>算法，我们可以定义上下文和目标词为任意两个位置相近的单词，假设是左右各10词的距离，那么$X_$就是一个能够获取单词$i$和单词$j$出现位置相近时或是彼此接近的频率的计数器。</p><p><strong>GloVe</strong>模型做的就是进行优化，我们将他们之间的差距进行最小化处理：</p><p>$\text{mini}\text{mize}\sum_{i = 1}^{10,000}{\sum_{j = 1}^{10,000}{f\left( X_ \right)\left( \theta_{i}^{T}e_{j} + b_{i} + b_{j}^{‘} - logX_ \right)^{2}}}$</p><p>其中$\theta_{i}^{T}e_{j}$，想一下$i$和$j$与$t$和$c$的功能一样，因此这就和你之前看的有些类似了，即$\theta_{t}^{T}e_{c}$。同时对于这个（$\theta_{t}^{T}e_{c}$，下图编号1所示）来说，你想要知道的是告诉你这两个单词之间有多少联系，$t$和$c$之间有多紧密，$i$和$j$之间联系程度如何，换句话说就是他们同时出现的频率是多少，这是由这个$X_$影响的。然后，我们要做的是解决参数$\theta$和$e$的问题，然后准备用梯度下降来最小化上面的公式，你只想要学习一些向量，这样他们的输出能够对这两个单词同时出现的频率进行良好的预测。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111610.png" alt></p><p>现在一些附加的细节是如果$X_$是等于0的话，那么$log0$就是未定义的，是负无穷大的，所以我们想要对$X_$为0时进行求和，因此要做的就是添加一个额外的加权项$f\left(X_\right)$（上图编号2所示）。如果$X_$等于0的话，同时我们会用一个约定，即$0log0= 0$，这个的意思是如果$X_ =0$，先不要进行求和，所以这个$log0$项就是不相关项。上面的求和公式表明，这个和仅是一个上下文和目标词关系里连续出现至少一次的词对的和。$f\left(X_\right)$的另一个作用是，有些词在英语里出现十分频繁，比如说<strong>this</strong>，<strong>is</strong>，<strong>of</strong>，<strong>a</strong>等等，有些情况，这叫做<strong>停止词</strong>，但是在频繁词和不常用词之间也会有一个连续统（<strong>continuum</strong>）。不过也有一些不常用的词，比如<strong>durion</strong>，你还是想将其考虑在内，但又不像那些常用词这样频繁。因此，这个加权因子$f\left(X_\right)$就可以是一个函数，即使是像<strong>durion</strong>这样不常用的词，它也能给予大量有意义的运算，同时也能够给像<strong>this</strong>，<strong>is</strong>，<strong>of</strong>，<strong>a</strong>这样在英语里出现更频繁的词更大但不至于过分的权重。因此有一些对加权函数f的选择有着启发性的原则，就是既不给这些词（<strong>this</strong>，<strong>is</strong>，<strong>of</strong>，<strong>a</strong>）过分的权重，也不给这些不常用词（<strong>durion</strong>）太小的权值。如果你想要知道f是怎么能够启发性地完成这个功能的话，你可以看一下我之前的幻灯片里引用的<strong>GloVe</strong>算法论文。</p><p>最后，一件有关这个算法有趣的事是$\theta$和$e$现在是完全对称的，所以那里的$\theta_{i}$和$e_{j}$就是对称的。如果你只看数学式的话，他们（$\theta_{i}$和$e_{j}$）的功能其实很相近，你可以将它们颠倒或者将它们进行排序，实际上他们都输出了最佳结果。因此一种训练算法的方法是一致地初始化$\theta$和$e$，然后使用梯度下降来最小化输出，当每个词都处理完之后取平均值，所以，给定一个词$w$，你就会有$e_{w}^{(final)}= \frac{e_{w} +\theta_{w}}{2}$。因为$\theta$和$e$在这个特定的公式里是对称的，而不像之前视频里我们了解的模型，$\theta$和$e$功能不一样，因此也不能像那样取平均。</p><p>这就是<strong>GloVe</strong>算法的内容，我认为这个算法的一个疑惑之处是如果你看着这个等式，它实在是太简单了，对吧？仅仅是最小化，像这样的一个二次代价函数（上图编号3所示）是怎么能够让你学习有意义的词嵌入的呢？但是结果证明它确实有效，发明者们发明这个算法的过程是他们以历史上更为复杂的算法，像是<strong>newer language</strong>模型，以及之后的<strong>Word2Vec</strong>、<strong>Skip-Gram</strong>模型等等为基础，同时希望能够简化所有之前的算法才发明的。</p><p>在我们总结词嵌入学习算法之前，有一件更优先的事，我们会简单讨论一下。就是说，我们以这个特制的表格作为例子来开始学习词向量，我们说，第一行的嵌入向量是来表示<strong>Gender</strong>的，第二行是来表示<strong>Royal</strong>的，然后是是<strong>Age</strong>，在之后是<strong>Food</strong>等等。但是当你在使用我们了解过的算法的一种来学习一个词嵌入时，例如我们之前的幻灯片里提到的<strong>GloVe</strong>算法，会发生一件事就是你不能保证嵌入向量的独立组成部分是能够理解的，为什么呢？</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628111647.png" alt></p><p>假设说有个空间，里面的第一个轴（上图编号1所示）是<strong>Gender</strong>，第二个轴（上图编号2所示）是<strong>Royal</strong>，你能够保证的是第一个嵌入向量对应的轴（上图编号3所示）是和这个轴（上面提到的第一和第二基轴，编号1，2所示）有联系的，它的意思可能是<strong>Gender</strong>、<strong>Royal</strong>、<strong>Age</strong>和<strong>Food</strong>。具体而言，这个学习算法会选择这个（上图编号3所示）作为第一维的轴，所以给定一些上下文词，第一维可能是这个轴（上图编号3所示），第二维也许是这个（上图编号4所示），或者它可能不是正交的，它也可能是第二个非正交轴（上图编号5所示），它可以是你学习到的词嵌入中的第二部分。当我们看到这个（上图编号6所示）的时候，如果有某个可逆矩阵$A$，那么这项（上图编号6所示）就可以简单地替换成$\left(A\theta_{i} \right)^{T}(A^{- T}e_{j})$，因为我们将其展开：</p><p>$\left( A\theta_{i} \right)^{T}\left( A^{- T}e_{j} \right) = \theta_{i}^{T}A^{T}A^{- T}e_{j} = \theta_{i}^{T}e_{j}$</p><p>不必担心，如果你没有学过线性代数的话会，和这个算法一样有一个简单证明过程。你不能保证这些用来表示特征的轴能够等同于人类可能简单理解的轴，具体而言，第一个特征可能是个<strong>Gender</strong>、<strong>Roya</strong>、<strong>Age</strong>、<strong>Food Cost</strong>和<strong>Size</strong>的组合，它也许是名词或是一个行为动词和其他所有特征的组合，所以很难看出独立组成部分，即这个嵌入矩阵的单行部分，然后解释出它的意思。尽管有这种类型的线性变换，这个平行四边形映射也说明了我们解决了这个问题，当你在类比其他问题时，这个方法也是行得通的。因此尽管存在特征量潜在的任意线性变换，你最终还是能学习出解决类似问题的平行四边形映射。</p><h3 id="2-9-情感分类（Sentiment-Classification）"><a href="#2-9-情感分类（Sentiment-Classification）" class="headerlink" title="2.9 情感分类（Sentiment Classification）"></a>2.9 情感分类（Sentiment Classification）</h3><h3 id="2-10-词嵌入除偏（Debiasing-Word-Embeddings）"><a href="#2-10-词嵌入除偏（Debiasing-Word-Embeddings）" class="headerlink" title="2.10 词嵌入除偏（Debiasing Word Embeddings）"></a>2.10 词嵌入除偏（Debiasing Word Embeddings）</h3><h2 id="第三周-序列模型和注意力机制（Sequence-models-amp-Attention-mechanism）"><a href="#第三周-序列模型和注意力机制（Sequence-models-amp-Attention-mechanism）" class="headerlink" title="第三周 序列模型和注意力机制（Sequence models &amp; Attention mechanism）"></a><strong>第三周 序列模型和注意力机制（</strong>Sequence models &amp; Attention mechanism<strong>）</strong></h2><p>在这一周，你将会学习<strong>seq2seq</strong>（<strong>sequence to sequence</strong>）模型，从机器翻译到语音识别，它们都能起到很大的作用，从最基本的模型开始。之后你还会学习集束搜索（<strong>Beam search</strong>）和注意力模型（<strong>Attention Model</strong>），一直到最后的音频模型，比如语音。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112232.png" alt></p><p>还有一个与此类似的结构被用来做图像描述，给出一张图片，比如这张猫的图片（上图编号1所示），它能自动地输出该图片的描述，一只猫坐在椅子上，那么你如何训练出这样的网络？通过输入图像来输出描述，像这个句子一样。</p><p>方法如下，在之前的卷积网络课程中，你已经知道了如何将图片输入到卷积神经网络中，比如一个预训练的<strong>AlexNet</strong>结构（上图编号2方框所示），然后让其学习图片的编码，或者学习图片的一系列特征。现在幻灯片所展示的就是<strong>AlexNet</strong>结构，我们去掉最后的<strong>softmax</strong>单元（上图编号3所示），这个预训练的<strong>AlexNet</strong>结构会给你一个4096维的特征向量，向量表示的就是这只猫的图片，所以这个预训练网络可以是图像的编码网络。现在你得到了一个4096维的向量来表示这张图片，接着你可以把这个向量输入到<strong>RNN</strong>中（上图编号4方框所示），RNN要做的就是生成图像的描述，每次生成一个单词，这和我们在之前将法语译为英语的机器翻译中看到的结构很像，现在你输入一个描述输入的特征向量，然后让网络生成一个输出序列，或者说一个一个地输出单词序列。</p><h3 id="3-2-选择最可能的句子（Picking-the-most-likely-sentence）"><a href="#3-2-选择最可能的句子（Picking-the-most-likely-sentence）" class="headerlink" title="3.2 选择最可能的句子（Picking the most likely sentence）"></a>3.2 选择最可能的句子（Picking the most likely sentence）</h3><p>条件语言模型（<strong>conditional language model</strong>）。相比语言模型，输出任意句子的概率，翻译模型会输出句子的英文翻译（上图编号5所示），这取决于输入的法语句子（上图编号6所示）。换句话说，你将估计一个英文翻译的概率，比如估计这句英语翻译的概率，”<strong>Jane is visiting Africa in September.</strong>“，这句翻译是取决于法语句子，”<strong>Jane visite I’Afrique en septembre.</strong>“，这就是英语句子相对于输入的法语句子的可能性，所以它是一个条件语言模型。</p><p>不过在了解束搜索之前，你可能会问一个问题，为什么不用贪心搜索(<strong>Greedy Search</strong>)呢？贪心搜索是一种来自计算机科学的算法，生成第一个词的分布以后，它将会根据你的条件语言模型挑选出最有可能的第一个词进入你的机器翻译模型中，在挑选出第一个词之后它将会继续挑选出最有可能的第二个词，然后继续挑选第三个最有可能的词，这种算法就叫做贪心搜索，但是你真正需要的是一次性挑选出整个单词序列，从$y^{&lt;1&gt;}$、$y^{&lt;2&gt;}$到$y^{&lt;T_{y}&gt;}$来使得整体的概率最大化。所以这种贪心算法先挑出最好的第一个词，在这之后再挑最好的第二词，然后再挑第三个，这种方法其实并不管用，为了证明这个观点，我们来考虑下面两种翻译。</p><h3 id="3-3-集束搜索（Beam-Search）"><a href="#3-3-集束搜索（Beam-Search）" class="headerlink" title="3.3 集束搜索（Beam Search）"></a>3.3 集束搜索（Beam Search）</h3><p>贪婪算法只会挑出最可能的那一个单词，然后继续。而集束搜索则会考虑多个选择，集束搜索算法会有一个参数<strong>B</strong>，叫做集束宽（<strong>beam width</strong>）。在这个例子中我把这个集束宽设成3，这样就意味着集束搜索不会只考虑一个可能结果，而是一次会考虑3个，比如对第一个单词有不同选择的可能性，最后找到<strong>in</strong>、<strong>jane</strong>、<strong>september</strong>，是英语输出的第一个单词的最可能的三个选项，然后集束搜索算法会把结果存到计算机内存里以便后面尝试用这三个词。如果集束宽设的不一样，如果集束宽这个参数是10的话，那么我们跟踪的不仅仅3个，而是10个第一个单词的最可能的选择。所以要明白，为了执行集束搜索的第一步，你需要输入法语句子到编码网络，然后会解码这个网络，这个<strong>softmax</strong>层（上图编号3所示）会输出10,000个概率值，得到这10,000个输出的概率值，取前三个存起来。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112523.png" alt></p><h3 id="3-4-改进集束搜索（Refinements-to-Beam-Search）"><a href="#3-4-改进集束搜索（Refinements-to-Beam-Search）" class="headerlink" title="3.4 改进集束搜索（Refinements to Beam Search）"></a>3.4 改进集束搜索（Refinements to Beam Search）</h3><p>长度归一化（<strong>Length normalization</strong>）就是对束搜索算法稍作调整的一种方式，帮助你得到更好的结果，下面介绍一下它。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112602.png" alt></p><p>这些符号看起来可能比实际上吓人，但这就是我们之前见到的乘积概率（<strong>the product probabilities</strong>）。如果计算这些，其实这些概率值都是小于1的，通常远小于1。很多小于1的数乘起来，会得到很小很小的数字，会造成数值下溢（<strong>numerical underflow</strong>）。数值下溢就是数值太小了，导致电脑的浮点表示不能精确地储存，因此在实践中,我们不会最大化这个乘积，而是取$log$值。如果在这加上一个$log$，最大化这个$log$求和的概率值，在选择最可能的句子$y$时，你会得到同样的结果。所以通过取$log$，我们会得到一个数值上更稳定的算法，不容易出现四舍五入的误差，数值的舍入误差（<strong>rounding errors</strong>）或者说数值下溢（<strong>numerical underflow</strong>）。因为$log$函数它是严格单调递增的函数，最大化$P(y)$，因为对数函数，这就是$log$函数，是严格单调递增的函数，所以最大化$logP(y|x)$和最大化$P(y|x)$结果一样。如果一个$y$值能够使前者最大，就肯定能使后者也取最大。所以实际工作中，我们总是记录概率的对数和（<strong>the sum of logs of the probabilities</strong>），而不是概率的乘积（<strong>the production of probabilities</strong>）。</p><p>对于目标函数（<strong>this objective function</strong>），还可以做一些改变，可以使得机器翻译表现的更好。如果参照原来的目标函数（<strong>this original objective</strong>），如果有一个很长的句子，那么这个句子的概率会很低，因为乘了很多项小于1的数字来估计句子的概率。所以如果乘起来很多小于1的数字，那么就会得到一个更小的概率值，所以这个目标函数有一个缺点，它可能不自然地倾向于简短的翻译结果，它更偏向短的输出，因为短句子的概率是由更少数量的小于1的数字乘积得到的，所以这个乘积不会那么小。顺便说一下，这里也有同样的问题，概率的$log$值通常小于等于1，实际上在$log$的这个范围内，所以加起来的项越多，得到的结果越负，所以对这个算法另一个改变也可以使它表现的更好，也就是我们不再最大化这个目标函数了，我们可以把它归一化，通过除以翻译结果的单词数量（<strong>normalize this by the number of words in your translation</strong>）。这样就是取每个单词的概率对数值的平均了，这样很明显地减少了对输出长的结果的惩罚（<strong>this significantly reduces the penalty for outputting longer translations.</strong>）。</p><p>在实践中，有个探索性的方法，相比于直接除$T_{y}$，也就是输出句子的单词总数，我们有时会用一个更柔和的方法（<strong>a softer approach</strong>），在$T_{y}$上加上指数$a$，$a$可以等于0.7。如果$a$等于1，就相当于完全用长度来归一化，如果$a$等于0，$T_{y}$的0次幂就是1，就相当于完全没有归一化，这就是在完全归一化和没有归一化之间。$a$就是算法另一个超参数（<strong>hyper parameter</strong>），需要调整大小来得到最好的结果。不得不承认，这样用$a$实际上是试探性的，它并没有理论验证。但是大家都发现效果很好，大家都发现实践中效果不错，所以很多人都会这么做。你可以尝试不同的$a$值，看看哪一个能够得到最好的结果。</p><p>总结一下如何运行束搜索算法。当你运行束搜索时，你会看到很多长度等于1的句子，很多长度等于2的句子，很多长度等于3的句子，等等。可能运行束搜索30步，考虑输出的句子可能达到，比如长度30。因为束宽为3，你会记录所有这些可能的句子长度，长度为1、2、 3、 4 等等一直到30的三个最可能的选择。然后针对这些所有的可能的输出句子，用这个式子（上图编号1所示）给它们打分，取概率最大的几个句子，然后对这些束搜索得到的句子，计算这个目标函数。最后从经过评估的这些句子中，挑选出在归一化的$log$ 概率目标函数上得分最高的一个（<strong>you pick the one that achieves the highest value on this normalized log probability objective.</strong>），有时这个也叫作<strong>归一化的对数似然目标函数</strong>（<strong>a normalized log likelihood objective</strong>）。这就是最终输出的翻译结果，这就是如何实现束搜索。</p><p>最后还有一些实现的细节，如何选择束宽<strong>B</strong>。<strong>B</strong>越大，你考虑的选择越多，你找到的句子可能越好，但是<strong>B</strong>越大，你的算法的计算代价越大，因为你要把很多的可能选择保存起来。最后我们总结一下关于如何选择束宽<strong>B</strong>的一些想法。接下来是针对或大或小的<strong>B</strong>各自的优缺点。如果束宽很大，你会考虑很多的可能，你会得到一个更好的结果，因为你要考虑很多的选择，但是算法会运行的慢一些，内存占用也会增大，计算起来会慢一点。而如果你用小的束宽，结果会没那么好，因为你在算法运行中，保存的选择更少，但是你的算法运行的更快，内存占用也小。在前面视频里，<strong>我们例子中用了束宽为3，所以会保存3个可能选择，在实践中这个值有点偏小</strong>。<strong>在产品中，经常可以看到把束宽设到10，</strong>我认为束宽为100对于产品系统来说有点大了，这也取决于不同应用。但是对科研而言，人们想压榨出全部性能，这样有个最好的结果用来发论文，也经常看到大家用束宽为1000或者3000，这也是取决于特定的应用和特定的领域。在你实现你的应用时，尝试不同的束宽的值，当B很大的时候，性能提高会越来越少。对于很多应用来说，从束宽1，也就是贪心算法，到束宽为3、到10，你会看到一个很大的改善。但是当束宽从1000增加到3000时，效果就没那么明显了。对于之前上过计算机科学课程的同学来说，如果你熟悉计算机科学里的搜索算法（<strong>computer science search algorithms</strong>）, 比如广度优先搜索（<strong>BFS, Breadth First Search algorithms</strong>），或者深度优先搜索（<strong>DFS, Depth First Search</strong>），你可以这样想束搜索，不像其他你在计算机科学算法课程中学到的算法一样。如果你没听说过这些算法也不要紧，但是如果你听说过广度优先搜索和深度优先搜索，不同于这些算法，这些都是精确的搜索算法（<strong>exact search algorithms</strong>），束搜索运行的更快，但是不能保证一定能找到<strong>argmax</strong>的准确的最大值。如果你没听说过广度优先搜索和深度优先搜索，也不用担心，这些对于我们的目标也不重要，如果你听说过，这就是束搜索和其他算法的关系。</p><p>好，这就是束搜索。这个算法广泛应用在多产品系统或者许多商业系统上，在深度学习系列课程中的第三门课中，我们讨论了很多关于误差分析（<strong>error analysis</strong>）的问题。事实上在束搜索上做误差分析是我发现的最有用的工具之一。有时你想知道是否应该增大束宽，我的束宽是否足够好，你可以计算一些简单的东西来指导你需要做什么，来改进你的搜索算法。</p><h3 id="3-5-集束搜索的误差分析（Error-analysis-in-beam-search）"><a href="#3-5-集束搜索的误差分析（Error-analysis-in-beam-search）" class="headerlink" title="3.5 集束搜索的误差分析（Error analysis in beam search）"></a>3.5 集束搜索的误差分析（Error analysis in beam search）</h3><p>束搜索算法是一种近似搜索算法（<strong>an approximate search algorithm</strong>），也被称作启发式搜索算法（<strong>a heuristic search algorithm</strong>），它不总是输出可能性最大的句子，它仅记录着<strong>B</strong>为前3或者10或是100种可能。那么如果束搜索算法出现错误会怎样呢?</p><p>记住，我们是要计算$P(y^*|x)$和$P(\hat y|x)$，然后比较这两个哪个更大，所以就会有两种情况。</p><p>第一种情况，<strong>RNN</strong>模型的输出结果$P(y^<em>|x)$ 大于$P(\hat y|x)$，这意味着什么呢?<br>束搜索算法选择了$\hat y$ ，对吧?<br>你得到$\hat y$的方式是，你用一个<strong>RNN</strong>模型来计算$P(y|x)$，然后束搜索算法做的就是尝试寻找使$P(y|x)$最大的$y$，不过在这种情况下，相比于$\hat y$，$y^</em>$的值更$P(y|x)$大，因此你能够得出束搜索算法实际上不能够给你一个能使$P(y|x)$最大化的$y$值，因为束搜索算法的任务就是寻找一个$y$的值来使这项更大，但是它却选择了$\hat y$，而$y^*$实际上能得到更大的值。因此这种情况下你能够得出是束搜索算法出错了。那另一种情况是怎样的呢?</p><p>第二种情况是$P(y^<em>|x)$小于或等于$P(\hat y|x)$对吧？这两者之中总有一个是真的。情况1或是情况2总有一个为真。情况2你能够总结出什么呢?<br>在我们的例子中，$y^</em>$ 是比 $\hat y$更好的翻译结果，不过根据RNN模型的结果，$P(y^<em>)$ 是小于$P(\hat y)$的，也就是说，相比于$\hat y$，$y^</em>$成为输出的可能更小。因此在这种情况下，看来是<strong>RNN</strong>模型出了问题。同时可能值得在<strong>RNN</strong>模型上花更多时间。这里我少讲了一些有关长度归一化（<strong>length normalizations</strong>）的细节。这里我略过了有关长度归一化的细节，如果你用了某种长度归一化，那么你要做的就不是比较这两种可能性大小，而是比较长度归一化后的最优化目标函数值。不过现在先忽略这种复杂的情况。第二种情况表明虽然$y^<em>$是一个更好的翻译结果，<strong>RNN</strong>模型却赋予它更低的可能性，是<em>*RNN</em></em>模型出现了问题。</p><p>所以误差分析过程看起来就像下面这样。你先遍历开发集，然后在其中找出算法产生的错误，这个例子中，假如说$P(y^<em>|x)$的值为2 x 10-10，而$P(\hat y|x)$的值为 1 x10-10，根据上页幻灯片中的逻辑关系，这种情况下我们得知束搜索算法实际上选择了比$y^</em>$可能性更低的$\hat y$，因此我会说束搜索算法出错了。我将它缩写为<strong>B</strong>。接着你继续遍历第二个错误，再来看这些可能性。也许对于第二个例子来说，你认为是<strong>RNN</strong>模型出现了问题，我会用缩写<strong>R</strong>来代表<strong>RNN</strong>。再接着你遍历了更多的例子，有时是束搜索算法出现了问题，有时是模型出现了问题，等等。通过这个过程，你就能够执行误差分析，得出束搜索算法和<strong>RNN</strong>模型出错的比例是多少。有了这样的误差分析过程，你就可以对开发集中每一个错误例子，即算法输出了比人工翻译更差的结果的情况，尝试确定这些错误，是搜索算法出了问题，还是生成目标函数(束搜索算法使之最大化)的<strong>RNN</strong>模型出了问题。并且通过这个过程，你能够发现这两个部分中哪个是产生更多错误的原因，并且只有当你发现是束搜索算法造成了大部分错误时，才值得花费努力增大集束宽度。相反地，如果你发现是<strong>RNN</strong>模型出了更多错，那么你可以进行更深层次的分析，来决定是需要增加正则化还是获取更多的训练数据，抑或是尝试一个不同的网络结构，或是其他方案。你在第三门课中，了解到各种技巧都能够应用在这里。</p><p>这就是束搜索算法中的误差分析，我认为这个特定的误差分析过程是十分有用的，它可以用于分析近似最佳算法(如束搜索算法)，这些算法被用来优化学习算法(例如序列到序列模型/<strong>RNN</strong>)输出的目标函数。</p><h3 id="3-6-Bleu-得分（选修）（Bleu-Score-optional-）"><a href="#3-6-Bleu-得分（选修）（Bleu-Score-optional-）" class="headerlink" title="3.6 Bleu 得分（选修）（Bleu Score (optional)）"></a>3.6 Bleu 得分（选修）（Bleu Score (optional)）</h3><p><strong>BLEU</strong>得分对于机器翻译来说，具有革命性的原因是因为它有一个相当不错的虽然不是完美的但是非常好的单一实数评估指标，因此它加快了整个机器翻译领域的进程，我希望这节视频能够让你了解<strong>BLEU</strong>得分是如何操作的。实践中，很少人会从零实现一个<strong>BLEU</strong>得分（<strong>implement a BLEU score from scratch</strong>），有很多开源的实现结果，你可以下载下来然后直接用来评估你的系统。不过今天，<strong>BLEU</strong>得分被用来评估许多生成文本的系统（<strong>systems that generate text</strong>），比如说机器翻译系统（<strong>machine translation systems</strong>），也有我之前简单提到的图像描述系统（<strong>image captioning systems</strong>）。也就是说你会用神经网络来生成图像描述，然后使用<strong>BLEU</strong>得分来看一下，结果在多大程度上与参考描述或是多个人工完成的参考描述内容相符。<strong>BLEU</strong>得分是一个有用的单一实数评估指标，用于评估生成文本的算法，判断输出的结果是否与人工写出的参考文本的含义相似。不过它并没有用于语音识别（<strong>speech recognition</strong>）。因为在语音识别当中，通常只有一个答案，你可以用其他的评估方法，来看一下你的语音识别结果，是否十分相近或是字字正确（<strong>pretty much, exactly word for word correct</strong>）。不过在图像描述应用中，对于同一图片的不同描述，可能是同样好的。或者对于机器翻译来说，有多个一样好的翻译结果，<strong>BLEU</strong>得分就给了你一个能够自动评估的方法，帮助加快算法开发进程。说了这么多，希望你明白了<strong>BLEU</strong>得分是怎么运行的。</p><h3 id="3-7-注意力模型直观理解（Attention-Model-Intuition）"><a href="#3-7-注意力模型直观理解（Attention-Model-Intuition）" class="headerlink" title="3.7 注意力模型直观理解（Attention Model Intuition）"></a>3.7 注意力模型直观理解（Attention Model Intuition）</h3><h3 id="3-8注意力模型（Attention-Model）"><a href="#3-8注意力模型（Attention-Model）" class="headerlink" title="3.8注意力模型（Attention Model）"></a>3.8注意力模型（Attention Model）</h3><p><strong>注意力模型如何让一个神经网络只注意到一部分的输入句子。当它在生成句子的时候，更像人类翻译</strong>。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112935.png" alt></p><p>跟上个视频一样，我们先假定有一个输入句子，并使用双向的<strong>RNN</strong>，或者双向的<strong>GRU</strong>或者双向的<strong>LSTM</strong>，去计算每个词的特征。实际上<strong>GRU</strong>和<strong>LSTM</strong>经常应用于这个，可能<strong>LSTM</strong>更经常一点。对于前向传播（<strong>the forward occurrence</strong>），你有第一个时间步的前向传播的激活值（<strong>a forward occurrence first time step</strong>），第一个时间步后向传播的激活值，后向的激活值，以此类推。他们一共向前了五个时间步，也向后了五个时间步，技术上我们把这里设置为0。我们也可以后向传播6次，设一个都是0的因子，实际上就是个都是0的因子。为了简化每个时间步的记号，即使你在双向<strong>RNN</strong>已经计算了前向的特征值和后向的特征值，我就用$a^{<t>}$来一起表示这些联系。所以$a^{<t>}$就是时间步$t$上的特征向量。<strong>但是为了保持记号的一致性，我们用第二个，也就是$t’$，实际上我将用$t’$来索引法语句子里面的词</strong>。接下来我们只进行前向计算，就是说这是个单向的<strong>RNN</strong>，用状态$S$表示生成翻译。所以第一个时间步，它应该生成$y^{&lt;1&gt;}$，当你输入上下文$C$的时候就会这样，如果你想用时间来索引它，你可以写$C^{&lt;1&gt;}$，但有时候我就写个$C$，就是没有上标的$C$，这个会取决于注意力参数，即$a^{&lt;1,1&gt;}$，$a^{&lt;1,2&gt;}$以此类推，告诉我们应该花多少注意力。同样的，这个$a$参数告诉我们上下文有多少取决于我们得到的特征，或者我们从不同时间步中得到的激活值。所以我们定义上下文的方式实际上来源于被注意力权重加权的不同时间步中的特征值。于是更公式化的注意力权重将会满足非负的条件，所以这就是个0或正数，它们加起来等于1。我们等会会见到我们如何确保这个成立，我们将会有上下文，或者说在$t=1$时的上下文，我会经常省略上标，这就会变成对$t’$的求和。这个权重的所有的$t’$值，加上这些激活值。所以这里的这项（上图编号1所示）就是注意力权重，这里的这项（上图编号2）来自于这里（上图编号3），于是$a^{&lt;t,t’&gt;}$就是$y^{<t>}$应该在$t’$时花在$a$上注意力的数量。换句话来说，当你在$t$处生成输出词，你应该花多少注意力在第$t’$个输入词上面，这是生成输出的其中一步。然后下一个时间步，你会生成第二个输出。于是相似的，你现在有了一个新的注意力权重集，再找到一个新的方式将它们相加，这就产生了一个新的上下文，这个也是输入，且允许你生成第二个词。只有现在才用这种方式相加，它会变成第二个时间步的上下文。即对$t’$的$a^{&lt;2,t’&gt;}$进行求和，于是使用这些上下文向量，$C^{&lt;1&gt;}$写到这里，$C^{&lt;2&gt;}$也同理。这里的神经网络看起来很像相当标准的<strong>RNN</strong>序列，这里有着上下文向量作为输出，我们可以一次一个词地生成翻译，我们也定义了如何通过这些注意力权重和输入句子的特征值来计算上下文向量。剩下唯一要做的事情就是定义如何计算这些注意力权重。让我们下张幻灯片看看。</t></t></t></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628112950.png" alt></p><p>回忆一下$a^{&lt;t,t’&gt;}$，是你应该花费在$a^{&lt;t’&gt;}$上的注意力的数量，当你尝试去生成第$t$个输出的翻译词，让我们先把式子写下来，再讨论它是怎么来的。这个式子你可以用来计算$a^{&lt;t,t’&gt;}$，在此之前我们要先计算$e^{&lt;t,t’&gt;}$，关键要用<strong>softmax</strong>，来确保这些权重加起来等于1。如果你对$t’$求和，比如每一个固定的$t$值，这些加起来等于1。如果你对$t’$求和，然后优先使用<strong>softmax</strong>，确保这些值加起来等于1。</p><p>现在我们如何计算这些$e$项，一种我们可以用的方式是用下面这样的小的神经网络，于是$s^{<t-1>}$就是神经网络在上个时间步的状态，于是这里我们有一个神经网络，如果你想要生成$y^{<t>}$，那么$s^{<t-1>}$就是上一时间步的隐藏状态，即$s^{<t>}$。这是给小神经网络的其中一个输入，也就是在神经网络中的一个隐藏层，因为你需要经常计算它们，然后$a^{&lt;t’&gt;}$，即上个时间步的的特征是另一个输入。直观来想就是，如果你想要决定要花多少注意力在$t’$的激活值上。于是，似乎它会很大程度上取决于你上一个时间步的的隐藏状态的激活值。你还没有当前状态的激活值，因为上下文会输入到这里，所以你还没计算出来，但是看看你生成上一个翻译的<strong>RNN</strong>的隐藏状态，然后对于每一个位置，每一个词都看向他们的特征值，这看起来很自然，即$a^{&lt;t,t’&gt;}$和$e^{&lt;t,t’&gt;}$应该取决于这两个量。但是我们不知道具体函数是什么，所以我们可以做的事情就是训练一个很小的神经网络，去学习这个函数到底是什么。相信反向传播算法，相信梯度下降算法学到一个正确的函数。这表示，如果你应用这整个的模型，然后用梯度下降来训练它，这是可行的。这个小型的神经网络做了一件相当棒的事情，告诉你$y^{<t>}$应该花多少注意力在$a^{<t>}$上面，然后这个式子确保注意力权重加起来等于1，于是当你持续地一次生成一个词，这个神经网络实际上会花注意力在右边的这个输入句子上，它会完全自动的通过梯度下降来学习。</t></t></t></t-1></t></t-1></p><p>这个算法的一个缺点就是它要花费三次方的时间，就是说这个算法的复杂是$O(n3)$的，如果你有$T_x$个输入单词和$T_y$个输出单词，于是注意力参数的总数就会是$T_x\times T_y$，所以这个算法有着三次方的消耗。但是在机器翻译的应用上，输入和输出的句子一般不会太长，可能三次方的消耗是可以接受，但也有很多研究工作，尝试去减少这样的消耗。那么讲解注意想法在机器翻译中的应用，就到此为止了。虽然没有讲到太多的细节，但这个想法也被应用到了其他的很多问题中去了，比如图片加标题（<strong>image captioning</strong>），图片加标题就是看一张图，写下这张图的标题。底下的这篇论文来源于<strong>Kevin Chu</strong>，<strong>Jimmy Barr</strong>, <strong>Ryan Kiros</strong>, <strong>Kelvin Shaw</strong>, <strong>Aaron Korver</strong>, <strong>Russell Zarkutnov</strong>, <strong>Virta Zemo</strong>, 和 <strong>Andrew Benjo</strong>。他们也显示了你可以有一个很相似的结构看图片，然后，当你在写图片标题的时候，一次只花注意力在一部分的图片上面。如果你感兴趣，那么我鼓励你，也去看看这篇论文，做一些编程练习。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113000.png" alt></p><p>因为机器翻译是一个非常复杂的问题，在之前的练习中，你应用了注意力，在日期标准化的问题（<strong>the date normalization problem</strong>）上面，问题输入了像这样的一个日期，这个日期实际上是阿波罗登月的日期，把它标准化成标准的形式，或者这样的日期。用一个序列的神经网络，即序列模型去标准化到这样的形式，这个日期实际上是威廉·莎士比亚的生日。一般认为是这个日期正如你之前联系中见到的，你可以训练一个神经网络，输入任何形式的日期，生成标准化的日期形式。其他可以做的有意思的事情是看看可视化的注意力权重（<strong>the visualizations of the attention weights</strong>）。这个一个机器翻译的例子，这里被画上了不同的颜色，不同注意力权重的大小，我不想在这上面花太多时间，但是你可以发现，对应的输入输出词，你会发现注意力权重，会变高，因此这显示了当它生成特定的输出词时通常会花注意力在输入的正确的词上面，包括学习花注意在哪。<br>在注意力模型中，使用反向传播时， 什么时候学习完成。</p><h3 id="3-9语音识别（Speech-recognition）"><a href="#3-9语音识别（Speech-recognition）" class="headerlink" title="3.9语音识别（Speech recognition）"></a>3.9语音识别（Speech recognition）</h3><p>现今，最令人振奋的发展之一，就是<strong>seq2seq</strong>模型（<strong>sequence-to-sequence models</strong>）在语音识别方面准确性有了很大的提升。这门课程已经接近尾声，现在我想通过剩下几节视频，来告诉你们，<strong>seq2seq</strong>模型是如何应用于音频数据的（<strong>audio data</strong>），比如语音（<strong>the speech</strong>）。</p><p>什么是语音视频问题呢？现在你有一个音频片段$x$（<strong>an audio clip,x</strong>），你的任务是自动地生成文本$y$。现在有一个音频片段，画出来是这样，该图的横轴是时间。一个麦克风的作用是测量出微小的气压变化，现在你之所以能听到我的声音，是因为你的耳朵能够探测到这些微小的气压变化，它可能是由你的扬声器或者耳机产生的，也就是像图上这样的音频片段，气压随着时间而变化。假如这个我说的音频片段的内容是：”<strong>the quick brown fox</strong>“(敏捷的棕色狐狸)，这时我们希望一个语音识别算法（<strong>a speech recognition algorithm</strong>），通过输入这段音频，然后输出音频的文本内容。考虑到人的耳朵并不会处理声音的原始波形，而是通过一种特殊的物理结构来测量这些，不同频率和强度的声波。音频数据的常见预处理步骤，就是运行这个原始的音频片段，然后生成一个声谱图（<strong>a spectrogram</strong>），就像这样。同样地，横轴是时间，纵轴是声音的频率（<strong>frequencies</strong>），而图中不同的颜色，显示了声波能量的大小（<strong>the amount of energy</strong>），也就是在不同的时间和频率上这些声音有多大。通过这样的声谱图，或者你可能还听过人们谈到过伪空白输出（<strong>the false blank outputs</strong>），也经常应用于预处理步骤，也就是在音频被输入到学习算法之前，而人耳所做的计算和这个预处理过程非常相似。语音识别方面，最令人振奋的趋势之一就是曾经有一段时间，语音识别系统是用音位（<strong>phonemes</strong>）来构建的，也就是人工设计的基本单元（<strong>hand-engineered basic units of cells</strong>），如果用音位来表示”<strong>the quick brown fox</strong>“，我这里稍微简化一些，”<strong>the</strong>“含有”<strong>th</strong>“和”<strong>e</strong>“的音，而”<strong>quick</strong>“有”<strong>k</strong>“ “<strong>w</strong>“ “<strong>i</strong>“ “<strong>k</strong>“的音，语音学家过去把这些音作为声音的基本单元写下来，把这些语音分解成这些基本的声音单元，而”<strong>brown</strong>“不是一个很正式的音位，因为它的音写起来比较复杂，不过语音学家（<strong>linguists</strong>）们认为用这些基本的音位单元（<strong>basic units of sound called phonemes</strong>）来表示音频（<strong>audio</strong>），是做语音识别最好的办法。不过在<strong>end-to-end</strong>模型中，我们发现这种音位表示法（<strong>phonemes representations</strong>）已经不再必要了，而是可以构建一个系统，通过向系统中输入音频片段（<strong>audio clip</strong>），然后直接输出音频的文本（<strong>a transcript</strong>），而不需要使用这种人工设计的表示方法。使这种方法成为可能的一件事就是用一个很大的数据集，所以语音识别的研究数据集可能长达300个小时，在学术界，甚至3000小时的文本音频数据集，都被认为是合理的大小。大量的研究，大量的论文所使用的数据集中，有几千种不同的声音，而且，最好的商业系统现在已经训练了超过1万个小时的数据，甚至10万个小时，并且它还会继续变得更大。在文本音频数据集中（<strong>Transcribe audio data sets</strong>）同时包含$x$和$y$，通过深度学习算法大大推进了语音识别的进程。那么，如何建立一个语音识别系统呢？</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113125.png" alt></p><p>在上一节视频中，我们谈到了注意力模型，所以，一件你能做的事就是在横轴上，也就是在输入音频的不同时间帧上，你可以用一个注意力模型，来输出文本描述，如”<strong>the quick brown fox</strong>“，或者其他语音内容。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113056.png" alt></p><p>还有一种效果也不错的方法，就是用<strong>CTC</strong>损失函数（<strong>CTC cost</strong>）来做语音识别。<strong>CTC</strong>就是<strong>Connectionist Temporal Classification</strong>，它是由<strong>Alex Graves</strong>、<strong>Santiago Fernandes</strong>, <strong>Faustino Gomez</strong>、和<strong>Jürgen Schmidhuber</strong>提出的。（<strong>Graves A, Gomez F. Connectionist temporal classification:labelling unsegmented sequence data with recurrent neural networks[C]// International Conference on Machine Learning. ACM, 2006:369-376.</strong>）</p><p>算法思想如下:</p><p>假设语音片段内容是某人说：”<strong>the quick brown fox</strong>“，这时我们使用一个新的网络，结构像这个样子，这里输入$x$和输出$y$的数量都是一样的，因为我在这里画的，只是一个简单的单向<strong>RNN</strong>结构。然而在实际中，它有可能是双向的<strong>LSTM</strong>结构，或者双向的<strong>GIU</strong>结构，并且通常是很深的模型。但注意一下这里时间步的数量，它非常地大。在语音识别中，通常输入的时间步数量（<strong>the number of input time steps</strong>）要比输出的时间步的数量（<strong>the number of output time steps</strong>）多出很多。举个例子，比如你有一段10秒的音频，并且特征（<strong>features</strong>）是100赫兹的，即每秒有100个样本，于是这段10秒的音频片段就会有1000个输入，就是简单地用100赫兹乘上10秒。所以有1000个输入，但可能你的输出就没有1000个字母了，或者说没有1000个字符。这时要怎么办呢？<strong>CTC</strong>损失函数允许<strong>RNN</strong>生成这样的输出：<strong>ttt</strong>，这是一个特殊的字符，叫做空白符，我们这里用下划线表示，这句话开头的音可表示为<strong>h_eee_ _ _</strong>，然后这里可能有个空格，我们用这个来表示空格，之后是<strong>_ _ _qqq__</strong>，这样的输出也被看做是正确的输出。下面这段输出对应的是”<strong>the q</strong>“。<strong>CTC损失函数的一个基本规则是将空白符之间的重复的字符折叠起来，再说清楚一些，我这里用下划线来表示这个特殊的空白符（a special blank character），它和空格（the space character）是不一样的</strong>。所以<strong>the</strong>和<strong>quick</strong>之间有一个空格符，所以我要输出一个空格，通过把用空白符所分割的重复的字符折叠起来，然后我们就可以把这段序列折叠成”<strong>the q</strong>“。这样一来你的神经网络因为有很多这种重复的字符，和很多插入在其中的空白符（<strong>blank characters</strong>），所以最后我们得到的文本会短上很多。于是这句”<strong>the quick brown fox</strong>“包括空格一共有19个字符，在这样的情况下，通过允许神经网络有重复的字符和插入空白符使得它能强制输出1000个字符，甚至你可以输出1000个$y$值来表示这段19个字符长的输出。这篇论文来自于<strong>Alex Grace</strong>以及刚才提到的那些人。我所参与的深度语音识别系统项目就使用这种思想来构建有效的语音识别系统。</p><p>希望这能给你一个粗略的理解，理解语音识别模型是如何工作的：注意力模型是如何工作的，以及<strong>CTC</strong>模型是如何工作的，以及这两种不同的构建这些系统的方法。现今，在生产技术中，构建一个有效语音识别系统，是一项相当重要的工作，并且它需要很大的数据集</p><h3 id="3-10触发字检测（Trigger-Word-Detection）"><a href="#3-10触发字检测（Trigger-Word-Detection）" class="headerlink" title="3.10触发字检测（Trigger Word Detection）"></a>3.10触发字检测（Trigger Word Detection）</h3><p>现在你已经学习了很多关于深度学习和序列模型的内容，于是我们可以真正去简便地描绘出一个触发字系统（<strong>a trigger word system</strong>），就像上节视频中你看到的那样。随着语音识别的发展，越来越多的设备可以通过你的声音来唤醒，这有时被叫做触发字检测系统（<strong>rigger word detection systems</strong>）。我们来看一看如何建立一个触发字系统。</p><p>有关于触发字检测系统的文献，还处于发展阶段。对于触发字检测，最好的算法是什么，目前还没有一个广泛的定论。我这里就简单向你介绍一个你能够使用的算法好了。现在有一个这样的<strong>RNN</strong>结构，<strong>我们要做的就是把一个音频片段（an audio clip）计算出它的声谱图特征（spectrogram features）得到特征向量</strong>$x^{&lt;1&gt;}$, $x^{&lt;2&gt;}$, $x^{&lt;3&gt;}$..，然后把它放到<strong>RNN</strong>中，最后要做的，就是定义我们的目标标签$y$。假如音频片段中的这一点是某人刚刚说完一个触发字，比如”<strong>Alexa</strong>“，或者”小度你好” 或者”<strong>Okay Google</strong>“，那么在这一点之前，你就可以在训练集中把目标标签都设为0，然后在这个点之后把目标标签设为1。假如在一段时间之后，触发字又被说了一次，比如是在这个点说的，那么就可以再次在这个点之后把目标标签设为1。这样的标签方案对于<strong>RNN</strong>来说是可行的，并且确实运行得非常不错。不过该算法一个明显的缺点就是它构建了一个很不平衡的训练集（<strong>a very imbalanced training set</strong>），0的数量比1多太多了。</p><p>这里还有一个解决方法，虽然听起来有点简单粗暴，但确实能使其变得更容易训练。比起只在一个时间步上去输出1，其实你可以在输出变回0之前，多次输出1，或说在固定的一段时间内输出多个1。这样的话，就稍微提高了1与0的比例，这确实有些简单粗暴。在音频片段中，触发字刚被说完之后，就把多个目标标签设为1，这里触发字又被说了一次。说完以后，又让<strong>RNN</strong>去输出1。在之后的编程练习中，你可以进行更多这样的操作，我想你应该会对自己学会了这么多东西而感到自豪。我们仅仅用了一张幻灯片来描述这种复杂的触发字检测系统。在这个基础上，希望你能够实现一个能有效地让你能够检测出触发字的算法，不过在编程练习中你可以看到更多的学习内容。这就是触发字检测，希望你能对自己感到自豪。因为你已经学了这么多深度学习的内容，现在你可以只用几分钟时间，就能用一张幻灯片来描述触发字能够实现它，并让它发挥作用。你甚至可能在你的家里用触发字系统做一些有趣的事情，比如打开或关闭电器，或者可以改造你的电脑，使得你或者其他人可以用触发字来操作它。</p><h3 id="3-11结论和致谢（Conclusion-and-thank-you）"><a href="#3-11结论和致谢（Conclusion-and-thank-you）" class="headerlink" title="3.11结论和致谢（Conclusion and thank you）"></a>3.11结论和致谢（Conclusion and thank you）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113224.png" alt></p><p>我们一起经历了一段很长的旅程，如果你已经学完了整个专业的课程，那么现在你已经学会了神经网络和深度学习，如何改进深度神经网络，如何结构化机器学习项目，和卷积神经网络。在最近的课程中还学了序列模型，我知道你为此非常努力，也希望你能对自己感到自豪，为你的努力，为你所做的这一切。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113243.png" alt></p><p>我想向你传达一个对你来说可能很重要的想法。就是我觉得深度学习是一种超能力，通过深度学习算法，你可以让计算机拥有”视觉”（<strong>make a computer see</strong>），可以让计算机自己合成小说（<strong>synthesize novel art</strong>），或者合成音乐（<strong>synthesized music</strong>），可以让计算机将一种语言翻译成另一种（<strong>translate from one language to another</strong>），或者对放射影像进行定位然后进行医疗诊断（<strong>Maybe have it located radiology image and render a medical diagnosis</strong>），或者构建自动驾驶系统（<strong>build pieces of a car that can drive itself</strong>）。如果说这还不是超能力的话，那还能是什么呢？当我们结束这一系列课程的时候，结束整个专业的时候，我希望你能够使用这些思想来发展你的事业，追逐你的梦想，但最重要的是，去做你认为最合适的能对人类有贡献的事。这个世界现在面临着诸多挑战，但是在这种力量下，在人工智能和深度学习的力量下，我觉得我们可以让世界变得更美好。现在这种超能力就掌握在你的手中，去突破障碍，让生活变得更好，这不单单是为自己，也是为了其他人。当然我也希望你能够对自己取得的成就以及你学到的一切感到自豪。当你完成这一系列课程的学习后，我想你可以把课程分享到社交媒体上，比如<strong>Twitter</strong>和<strong>Facebook</strong>，让你的朋友也能知道这门课程。</p><p>最后，我想告诉你的最后一件事，就是恭喜你完成了这门课程的学习，为自己所取得的成就欢呼吧！同时也非常感谢你们，因为我知道大家都很忙，即便如此你们还是花了很多时间来学习这些视频，可能还花了很多时间来做课堂测验还有编程练习，希望你们能够乐在其中，并学到很多算法流程。我很荣幸你们能够花费时间，付诸精力，来学习这些东西，非常感谢大家！</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20210628113305.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU智科大二夏季学期游戏开发</title>
      <link href="/2021/06/23/shugame/"/>
      <url>/2021/06/23/shugame/</url>
      
        <content type="html"><![CDATA[<h1 id="SHU智科大二夏季学期大作业"><a href="#SHU智科大二夏季学期大作业" class="headerlink" title="SHU智科大二夏季学期大作业"></a>SHU智科大二夏季学期大作业</h1><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1431351640&auto=1&height=66"></iframe></div><blockquote><p><strong>免费帮Wilson老师宣传一下他写的歌，开了自动播放</strong></p></blockquote><h2 id="关于课程"><a href="#关于课程" class="headerlink" title="关于课程"></a>关于课程</h2><h3 id="课程基本情况"><a href="#课程基本情况" class="headerlink" title="课程基本情况"></a>课程基本情况</h3><p>课程时间：2021.6.21~2021.7.16，共 4 周。</p><p>课程对象：以计算机工程与科学学院智能科学与技术专业 2019 级学生为主，学生共 82 人。</p><p>教学方式：课堂教学，上机实验。</p><p>指导教师：沈俊。</p><h3 id="课程目的"><a href="#课程目的" class="headerlink" title="课程目的"></a><strong>课程目的</strong></h3><p>《智能系统联合大作业》安排在夏季学期进行，是理论联系实际的重要实践性教学环节。通过课程学习</p><p>和实践，学生了解利用人工智能解决实际问题的过程。树立良好的设计方法，巩固有关深度学习的知识，加深专业知识的了解，扩大专业知识面，培养和提高发现问题、认识问题、分析问题及解决问题的能力以及表达能力和协作工作能力，为后续有关专业课程的学习奠定基础。</p><h3 id="课程内容与要求"><a href="#课程内容与要求" class="headerlink" title="课程内容与要求"></a><strong>课程内容与要求</strong></h3><p>《智能系统联合大作业》课程总共有 82 个学生，进行游戏开发理论与实践内容的学习、项目实训和比赛。最后完成大作业报告。</p><h3 id="大作业的实施安排和考核办法"><a href="#大作业的实施安排和考核办法" class="headerlink" title="大作业的实施安排和考核办法"></a><strong>大作业的实施安排和考核办法</strong></h3><p>《智能系统联合大作业》动员时间安排在 6 月 21 日上午 10：30-11：00，在计 J101 阶梯教室介绍《智能系统联合大作业》的主要目的、要求和内容。前三周的课程安排：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210623191923977.png" alt="满满四周到军训"></p><h3 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h3><h4 id="6-21"><a href="#6-21" class="headerlink" title="6.21"></a><strong>6.21</strong></h4><p>账号获取，密码：v9raYAJyL0</p><p>游戏引擎</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/1sdfa.png" alt="1s做一个游戏，还要压缩大小命名不重复图片才能上传"></p><p>视角qweasd，shift加速移动</p><p>快捷键，f查找对象，CTRL固定位置移动，布尔值（右上角蓝色图标）</p><p>Play，注意play状态下所做更改不保存</p><p>编辑栏，最上方，</p><p>物体属性</p><p>World Hierarchy，儿子跟着爸爸走</p><p>Coordinate 一个相对于爸爸一个相对于世界</p><p>Architype游戏原型库，你的背包，怪物们</p><h4 id="6-22"><a href="#6-22" class="headerlink" title="6.22"></a>6.22</h4><blockquote><p>休息一天，下午去听Intel宣讲会，后续怎么上课拿那个学分还是没说。怕是被骗了。</p></blockquote><h4 id="6-23"><a href="#6-23" class="headerlink" title="6.23"></a><strong>6.23</strong></h4><h5 id="LUA基础"><a href="#LUA基础" class="headerlink" title="LUA基础"></a>LUA基础</h5><p>举几个游戏逻辑的例子：被攻击掉血，拾取装备，获得buff等</p><blockquote><p>一句话总结：当某个情况发生时，某个对象的某个属性发生了某种<strong>变化</strong>。</p></blockquote><ul><li>找到某个对象</li></ul><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--</span><span class="token comment" spellcheck="true">--[[注释]]</span><span class="token keyword">local</span> B<span class="token operator">=</span>script<span class="token punctuation">.</span>Parent<span class="token keyword">local</span> UItext<span class="token operator">=</span> script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>SurfaceGUI<span class="token punctuation">.</span>Text<span class="token function">print</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>方法</th><th>具体代码</th><th>注意事项</th></tr></thead><tbody><tr><td>从外到内获取</td><td>local Object = world.cube</td><td>虽然在层级管理其中 World 的 W 是大写的，但是在脚本应用时，需要使用小写 w</td></tr><tr><td>从内到外获取</td><td>local Object = Script.Parent</td><td>如果物体之间没有层级关系，也可以用此方法获取。例如 Script.Parent.Parent.Sky 即可获取 Sky 节点</td></tr></tbody></table><ul><li>改变属性</li></ul><table><thead><tr><th>类型</th><th>属性例子</th><th>具体代码案例</th></tr></thead><tbody><tr><td>三维向量</td><td>Position/Size/LinearVelocity 等</td><td>节点.Position = Vector3(1,1,1)</td></tr><tr><td>二维向量</td><td>UI 组件的 Size/Pivot/Offset 等</td><td>节点.Offset = Vector2(1,1)</td></tr><tr><td>欧拉角度</td><td>Rotation</td><td>节点.Rotation = EulerDegree(1,1,1)</td></tr><tr><td>bool 开关</td><td>Visible/IsStatic/Block 等</td><td>节点.Visible = false</td></tr><tr><td>颜色</td><td>Color</td><td>节点.Color = Color(255,255,255,255)</td></tr><tr><td>String 字符串</td><td>Text</td><td>节点.Text = ‘Click Here’</td></tr><tr><td>列表枚举</td><td>HealthDisplayMode 等有下拉选项的属性</td><td>节点.HealthDisplayMode = Enum.HealthDisplayMode.Always</td></tr></tbody></table><pre class="line-numbers language-lua"><code class="language-lua">B<span class="token punctuation">.</span>Position<span class="token operator">=</span><span class="token function">Vector3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span>Rotation<span class="token operator">=</span><span class="token function">EulerDegree</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span>IsStatic <span class="token operator">=</span> <span class="token keyword">false</span>B<span class="token punctuation">.</span>Shape <span class="token operator">=</span> Enum<span class="token punctuation">.</span>ShapeType<span class="token punctuation">.</span>ConeB<span class="token punctuation">.</span>Color <span class="token operator">=</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>UIText<span class="token punctuation">.</span>Text<span class="token operator">=</span><span class="token string">'shanghaidaxue'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>检测某个情况发生</li></ul><pre class="line-numbers language-lua"><code class="language-lua"><span class="token keyword">local</span> Exp <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">if</span> Exp<span class="token operator">></span><span class="token number">100</span> <span class="token keyword">then</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"shenji"</span><span class="token punctuation">)</span><span class="token keyword">elseif</span> Exp<span class="token operator">>=</span><span class="token number">200</span> <span class="token keyword">then</span> <span class="token comment" spellcheck="true">--逻辑bug</span>    <span class="token function">print</span> <span class="token punctuation">(</span><span class="token string">"boss战斗"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token keyword">end</span><span class="token keyword">local</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token keyword">while</span> a<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">do</span>    <span class="token function">print</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>    a<span class="token operator">=</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token keyword">end</span><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token keyword">do</span>    <span class="token function">print</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">local</span> Tab <span class="token operator">=</span> <span class="token punctuation">{</span>Attack<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>Defence <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>Tab<span class="token punctuation">)</span> <span class="token keyword">do</span>    <span class="token comment" spellcheck="true">--print(k,v)</span>    <span class="token function">print</span><span class="token punctuation">(</span>k<span class="token operator">..</span><span class="token string">"is"</span><span class="token operator">..</span>v<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--function</span><span class="token keyword">function</span> <span class="token function">Double</span><span class="token punctuation">(</span>Arg1<span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Double"</span><span class="token punctuation">,</span>Arg1<span class="token punctuation">,</span><span class="token string">"="</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> Arg1 <span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">end</span><span class="token keyword">local</span> result<span class="token operator">=</span><span class="token function">Double</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--匿名函数</span><span class="token keyword">function</span> <span class="token function">testfun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span>fun<span class="token punctuation">)</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fun</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">end</span><span class="token keyword">end</span>tab<span class="token operator">=</span><span class="token punctuation">{</span>key1<span class="token operator">=</span><span class="token string">"val1"</span><span class="token punctuation">,</span>key2<span class="token operator">=</span><span class="token string">"val2"</span><span class="token punctuation">}</span><span class="token function">testfun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span>    <span class="token keyword">return</span> key<span class="token operator">..</span><span class="token string">"="</span><span class="token operator">..</span>val<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token punctuation">)</span>       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如何使用API</strong></p><pre class="line-numbers language-lua"><code class="language-lua">Obj<span class="token punctuation">.</span>OnCollisionBegin<span class="token punctuation">:</span>Connect<span class="token comment" spellcheck="true">--记录跟不上了，还是自己看文档吧</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://api.projectdavinci.com/Davinci_0.12.0.58352/index.md" target="_blank" rel="noopener">api文档</a></p><h5 id="模板地图"><a href="#模板地图" class="headerlink" title="模板地图"></a>模板地图</h5><p>一个素材库，之后会发给我们</p><h5 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h5><blockquote><p><strong>成功才是成功之母。</strong></p><p>——吴军(yyds)</p></blockquote><p>ps：《蚁》，Wilson老师写的歌，下课走的太快的可能没听到（笑）。</p><h4 id="6-24"><a href="#6-24" class="headerlink" title="6.24"></a>6.24</h4><p>老师：橙汁</p><p><strong>游戏引擎</strong></p><p>早期：只能制作单个游戏，缺点：硬编码数据，大量特例代码，逻辑耦合，可拓展性弱。</p><p>中期：mod形式开发，街机游戏</p><p>后期：商业游戏引擎（复用性）</p><p><strong>游戏工程结构</strong></p><p>DCC，digital computer creation，模型动画图片音频等。</p><p>文本资产，代码配置表等。</p><p>工程结构，场景结构icon其他文件等。</p><p><strong>游戏脚本</strong></p><p>两种脚本，数据定义语言，组件事件。运行时脚本语言。</p><p><strong>达芬奇引擎</strong></p><p>Bomberman工程解析</p><p>玩法调研：炸弹堂，平面地图，炸弹，可破坏方块，倒计时，周围玩家数据，有局的概念，缩圈</p><p>增加死亡计数</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--Player下增加了LifeWatcher</span><span class="token keyword">local</span> lifeRemain <span class="token operator">=</span> script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>lifeRemain<span class="token keyword">local</span> curLife <span class="token operator">=</span> lifeRemain<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--增加屏幕UI，左上角UI组件，加一个figure和text，双击加入视角，导入了一张外部资源图片，直接用pic替换figure，lifevalue设成Archetype，加到screenGUI</span>world<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>localPlayer<span class="token punctuation">.</span>Name <span class="token comment" spellcheck="true">--记得有点快</span><span class="token keyword">function</span> <span class="token function">ValueChangeEvent</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span>new<span class="token punctuation">)</span>    <span class="token keyword">if</span> new <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new <span class="token operator">></span> <span class="token number">3</span> <span class="token keyword">then</span>        <span class="token keyword">return</span>    <span class="token keyword">end</span>    world<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>new<span class="token keyword">end</span>    lifeRemain<span class="token punctuation">.</span>OnValueChanged<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>ValueChangeEvent<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--写错成OnValueChange</span><span class="token keyword">function</span> <span class="token function">onHit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   lifeRemain<span class="token punctuation">.</span>Value<span class="token operator">=</span>ligeRemain<span class="token punctuation">.</span>Value<span class="token operator">-</span><span class="token number">1</span><span class="token keyword">end</span>localPlayer<span class="token punctuation">.</span>OnDead<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>onHit<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--作业：</span><span class="token comment" spellcheck="true">--1、修改这个功能，使其可用</span><span class="token comment" spellcheck="true">--2、实现镜头抖动</span><span class="token comment" spellcheck="true">-- Tween：ShakeProperty()</span><span class="token comment" spellcheck="true">-- local MainCamera = world.CurrentCamera 官网了解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>达芬奇比赛报名（7.10截止，7.20开发，8.19提交）</p><p><a href="https://davinci.lilith.com/2021/" target="_blank" rel="noopener">报名链接</a></p><h4 id="6-25"><a href="#6-25" class="headerlink" title="6.25"></a>6.25</h4><h5 id="Lua语言"><a href="#Lua语言" class="headerlink" title="Lua语言"></a>Lua语言</h5><p>lua驱动c语言执行，小巧。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">-- 初始化表</span>mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">-- 指定值</span>mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"Lua"</span><span class="token comment" spellcheck="true">-- 移除引用</span>mytable <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token comment" spellcheck="true">-- lua 垃圾回收会释放内存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--数组</span>array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Lua"</span><span class="token punctuation">,</span> <span class="token string">"Tutorial"</span><span class="token punctuation">}</span><span class="token keyword">for</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">do</span>   <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--迭代器</span>array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Google"</span><span class="token punctuation">,</span> <span class="token string">"Runoob"</span><span class="token punctuation">}</span><span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token keyword">do</span>   <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--[[下面我们看看泛型 for 的执行过程：首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。第三，将迭代函数返回的值赋给变量列表。第四，如果返回的第一个值为nil循环结束，否则执行循环体。第五，回到第二步再次调用迭代函数]]</span><span class="token comment" spellcheck="true">-- 简单的 table</span>mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 的类型是 "</span><span class="token punctuation">,</span><span class="token function">type</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span><span class="token punctuation">)</span>mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"Lua"</span>mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"修改前"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 1 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- alternatetable和mytable的是指同一个 table</span>alternatetable <span class="token operator">=</span> mytable<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"alternatetable 索引为 1 的元素是 "</span><span class="token punctuation">,</span> alternatetable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> alternatetable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>alternatetable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"修改后"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 释放变量</span>alternatetable <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"alternatetable 是 "</span><span class="token punctuation">,</span> alternatetable<span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- mytable 仍然可以访问</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>mytable <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 用途</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>table.concat (table [, sep [, start [, end]]]):</strong>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td></tr><tr><td align="left">2</td><td align="left"><strong>table.insert (table, [pos,] value):</strong>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td></tr><tr><td align="left">3</td><td align="left"><strong>table.maxn (table)</strong>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</td></tr><tr><td align="left">4</td><td align="left"><strong>table.remove (table [, pos])</strong>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td></tr><tr><td align="left">5</td><td align="left"><strong>table.sort (table [, comp])</strong>对给定的table进行升序排序。</td></tr></tbody></table><pre class="line-numbers language-lua"><code class="language-lua">table<span class="token punctuation">.</span><span class="token function">sort</span> <span class="token punctuation">(</span>table<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>i<span class="token operator">></span>b<span class="token punctuation">,</span>i     <span class="token keyword">end</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--拆包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--Modelscript,在script中调用</span><span class="token keyword">local</span> module <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">--function module:foo()</span><span class="token comment" spellcheck="true">--    print('foo in module')</span><span class="token comment" spellcheck="true">--end</span><span class="token keyword">return</span> module<span class="token comment" spellcheck="true">--Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"&lt;模块名>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--require "&lt;模块名>"</span><span class="token comment" spellcheck="true">--执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个script去require，model相当于是单例，全局唯一。</p><h5 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h5><p>本地事件系统</p><p>游戏开始玩家进入。。。反正就是游戏流程</p><p>CollisionEvent</p><p>KeyBoardEvent，Booster</p><p>ps：test下local多玩家测试</p><p>物理检测，碰撞事件，射线检测</p><p>world.OnRenderStepped:Connect(Update)，按帧数检测，fps=60，16.67ms。</p><h5 id="游戏系统和框架"><a href="#游戏系统和框架" class="headerlink" title="游戏系统和框架"></a>游戏系统和框架</h5><p>脚本间通信，require(“MyAsset/ModuleAsset”)：foo()</p><p>Global:相当于library，全局</p><h4 id="第一周作业：炸弹人2-0"><a href="#第一周作业：炸弹人2-0" class="headerlink" title="第一周作业：炸弹人2.0"></a>第一周作业：炸弹人2.0</h4><h5 id="镜头抖动"><a href="#镜头抖动" class="headerlink" title="镜头抖动"></a><strong>镜头抖动</strong></h5><p>之前那个小作业别忘了。</p><p>直接在world下的script里写。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--服务器脚本，等它几秒构建好world之后加入角色（这时才加入相机，否则会print出nil，后面函数报错，不信可以试试）</span><span class="token keyword">local</span> MainCamera <span class="token operator">=</span> world<span class="token punctuation">.</span>CurrentCamera<span class="token comment" spellcheck="true">--print(MainCamera)</span><span class="token comment" spellcheck="true">--local Obj=MainCamera</span><span class="token keyword">local</span> ObjTweener <span class="token operator">=</span> Tween<span class="token punctuation">:</span><span class="token function">ShakeProperty</span><span class="token punctuation">(</span>MainCamera<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"Distance"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">--看api文档和教程，相机有很多参数</span><span class="token comment" spellcheck="true">--构造一个值插值器</span><span class="token comment" spellcheck="true">--local Middle = ObjTweener:GetValue(5)  </span><span class="token comment" spellcheck="true">--获得插值器在一个周期中，第5秒    PropertyDictionary的取值</span>ObjTweener<span class="token punctuation">:</span><span class="token function">Play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--播放这个动画</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>– Tween：ShakeProperty()<br>– local MainCamera = world.CurrentCamera 官网了解</p><p>看了也不会系列。。。。还是得问。。。。</p></blockquote><hr><p>Davinci编辑器为开发者提供了6种摄像机类型，不同的摄像机会以不同的视角观察游戏场景。</p><p><strong>ps:摄像机通用属性</strong></p><p>以下列表为所有类型的摄像机都拥有的属性：</p><table><thead><tr><th>属性名称</th><th>说明</th></tr></thead><tbody><tr><td>Order</td><td>数字越大的越在上层</td></tr><tr><td>Rotation</td><td>相机的旋转角度</td></tr><tr><td>ViewPortHeight</td><td>视角高度（只读）</td></tr><tr><td>ViewPortWidth</td><td>视角宽度（只读）</td></tr><tr><td>NearClip</td><td>最小视距，可视的最近距离</td></tr><tr><td>FarClip</td><td>最大视距，可视的最远距离</td></tr><tr><td>FieldofView</td><td>可视范围的角度大小</td></tr><tr><td>CameraMode</td><td>镜头的类型（总共有6种类型，下文章会细说）</td></tr><tr><td>CursorLock</td><td>是否锁定鼠标光标</td></tr><tr><td>Paues</td><td>打开后，此镜头下听到的音效将会全部停止播放</td></tr><tr><td>Volume</td><td>此镜头听到的音效大小</td></tr><tr><td>CollisionGroup</td><td>摄像机盒子的碰撞组</td></tr></tbody></table><h5 id="完成玩家生命与淘汰系统"><a href="#完成玩家生命与淘汰系统" class="headerlink" title="完成玩家生命与淘汰系统"></a><strong>完成玩家生命与淘汰系统</strong></h5><p>Player加一个lifeRemain的intvalue，初始值设为3。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210627205820.png" alt></p><p>world下建立一个LifeBoard的文件夹，放一个screenUI，先命名为P4,在P4下再加一张底图，底图下加两个Text，一个叫name1放名字，一个叫life接收生命值lifeRemain。最后改Player的script。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--Player的script下，只能改变自己的lifeboard，别人的还要多人测试，这个P4就有点难办，不懂玩家加入的原理，没想法，先留着</span><span class="token keyword">local</span> lifeRemain <span class="token operator">=</span> script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>lifeRemain<span class="token keyword">local</span> curLife <span class="token operator">=</span> lifeRemain<span class="token punctuation">.</span>Valueworld<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>Image<span class="token punctuation">.</span>name1<span class="token punctuation">.</span>Text<span class="token operator">=</span>localPlayer<span class="token punctuation">.</span>Nameworld<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>Image<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>curLife<span class="token keyword">function</span> <span class="token function">ValueChangeEvent</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span>new<span class="token punctuation">)</span>    <span class="token keyword">if</span> new <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new <span class="token operator">></span> <span class="token number">3</span> <span class="token keyword">then</span>        <span class="token comment" spellcheck="true">--localPlayer.bombRemain.Value=-1</span>        <span class="token comment" spellcheck="true">--不知道怎么设计淘汰，设定炸弹数为负，三条命死完，进入观战模式，不能放炸弹</span>        <span class="token keyword">return</span>    <span class="token keyword">end</span>    world<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>Image<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>new<span class="token keyword">end</span>    <span class="token function">print</span><span class="token punctuation">(</span>lifeRemain<span class="token punctuation">.</span>Value<span class="token punctuation">)</span>lifeRemain<span class="token punctuation">.</span>OnValueChanged<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>ValueChangeEvent<span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">onHit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   lifeRemain<span class="token punctuation">.</span>Value<span class="token operator">=</span>lifeRemain<span class="token punctuation">.</span>Value<span class="token operator">-</span><span class="token number">1</span><span class="token keyword">end</span>localPlayer<span class="token punctuation">.</span>OnDead<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>onHit<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决玩家重复扔炸弹的问题"><a href="#解决玩家重复扔炸弹的问题" class="headerlink" title="解决玩家重复扔炸弹的问题"></a><strong>解决玩家重复扔炸弹的问题</strong></h5><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--LocalScript</span><span class="token keyword">function</span> <span class="token function">PressFire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--设置一个叫bombRemain的value值限制player放炸弹数目</span>    <span class="token keyword">local</span> Bomb_num<span class="token operator">=</span>script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>bombRemain    <span class="token comment" spellcheck="true">--print (Bomb_num)</span>    <span class="token keyword">if</span> Bomb_num<span class="token punctuation">.</span>Value <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">then</span>        <span class="token function">DropBomb</span><span class="token punctuation">(</span>localPlayer<span class="token punctuation">.</span>Position<span class="token punctuation">)</span>        Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">=</span>Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">-</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">--print (Bomb_num.Value)</span>        <span class="token keyword">if</span> Bomb_num<span class="token punctuation">.</span>Value <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">=</span>Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true">--强行等3s后恢复</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--4:玩家不能无限放炸弹,所以要限制一下DropBomb函数的调用</span><span class="token comment" spellcheck="true">--放炸弹还要检测是否那个位置已经有炸弹了，但是不知道根据位置检测对象的函数是什么？</span><span class="token comment" spellcheck="true">--也许可以先往一个方向偏移一下，再往反方向Raycast检测</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://api.projectdavinci.com/Davinci_0.12.0.58352/Physics.md#luacastresult-raycast(vector3-startpos%2Cvector3-targetpos%2Cbool-debugdraw)" target="_blank" rel="noopener">Raycast API</a></p><h5 id="实现炸弹攻击距离"><a href="#实现炸弹攻击距离" class="headerlink" title="实现炸弹攻击距离"></a><strong>实现炸弹攻击距离</strong></h5><p>每个箱子增加可能掉落道具物品。</p><p>1、在Architect的Box下新建一个NodeObject，叫BoxBuff，再加一个model（cube或者胶囊体，随便什么都行），model下加一个CollisionEvent。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210627205859.png" alt></p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">---------------------------------------------------------------</span><span class="token comment" spellcheck="true">-- Collisionevent is triggered when script.Parent interact with a collision(enter, continue, leave)</span><span class="token comment" spellcheck="true">-- CollisionType : collision type</span><span class="token comment" spellcheck="true">--   Enum.CollisionEventType.Enter</span><span class="token comment" spellcheck="true">--   Enum.CollisionEventType.Leave</span><span class="token comment" spellcheck="true">-- HitObject : the other object that contact with script.Parent</span><span class="token comment" spellcheck="true">-- HitPoint : collision point </span><span class="token comment" spellcheck="true">-- HitNormal : collision normal</span><span class="token comment" spellcheck="true">---------------------------------------------------------------</span><span class="token keyword">if</span> CollisionType <span class="token operator">==</span> Enum<span class="token punctuation">.</span>CollisionEventType<span class="token punctuation">.</span>Enter <span class="token keyword">and</span> HitObject<span class="token punctuation">:</span><span class="token function">IsA</span><span class="token punctuation">(</span><span class="token string">"PlayerInstance"</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    script<span class="token punctuation">.</span>Parent<span class="token punctuation">:</span><span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token keyword">then</span>        <span class="token comment" spellcheck="true">-- 炸弹攻击距离有上限</span>        localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value<span class="token operator">=</span>localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在世界中创建folder: BoxBuff，存放待会加入的道具</p><p>3、修改木箱爆炸程序：Box-Box-Collider-BomHit</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--[BombHit]</span><span class="token comment" spellcheck="true">--加一句在同一位置创建一个buff</span><span class="token keyword">local</span> number<span class="token operator">=</span>math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 通过随机数设置是否爆道具</span><span class="token keyword">if</span> number <span class="token operator">&lt;</span><span class="token number">150</span> <span class="token keyword">then</span>     <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    <span class="token keyword">local</span> BB <span class="token operator">=</span> world<span class="token punctuation">:</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token string">"BoxBuff"</span><span class="token punctuation">,</span><span class="token string">"BoxBuff"</span><span class="token punctuation">,</span> world<span class="token punctuation">.</span>BoxBuff<span class="token punctuation">,</span> Root<span class="token punctuation">.</span>Position<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--删除木箱</span>Root<span class="token punctuation">:</span><span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、Player下新建数值AttackDistance，初始值设成1，修改炸弹的一生，让它从人物身上获取攻击值。</p><p>在Player-Local-BomberGameGUI-DropBomb-Localscript中修改对应部分为以下：</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--是谁放的炸弹</span><span class="token keyword">local</span> Owner <span class="token operator">=</span> BombRoot<span class="token punctuation">.</span>Owner<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--炸弹的攻击距离</span><span class="token comment" spellcheck="true">--local AttackDistance = BombRoot.AttackDistance.Value</span><span class="token keyword">local</span> AttackDistance <span class="token operator">=</span> localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--延迟时间</span><span class="token keyword">local</span> SafetyTime <span class="token operator">=</span> BombRoot<span class="token punctuation">.</span>SafetyTime<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--这样炸弹攻击值就只能从人物身上获取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错：原因是world.staticspace这个节点下对象是静态的，运行时不能移动或调用函数，一般放场景用，不知道我写在box里关checkboard什么事了。反正不影响功能实现，但是还有个小问题，就是人物在吃边缘道具的时候容易跳出地图，然后就跳不回来了。。。。懒得设计属性值了，就这样吧。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Snipaste_2021-06-27_19-55-10.png" alt></p><hr><p>限制玩家扔炸弹数量，实现道具：炸弹仓扩容，炸弹和特效使用对象池优化，设计自己的技能系统（可选）</p><blockquote><p>”今天的作业哦！！！！周日前同学们发到邮箱：<a href="mailto:irislan@lilith.com" target="_blank" rel="noopener">irislan@lilith.com</a>“——莉莉丝·喵莉丝</p><p>“建议大家全部做完”——莉莉丝·雪花</p><p>烦，没时间做啊，哪个好心人能拉我一把？</p><p>哦，原来还是我自己拉自己，那没事了。</p></blockquote><h5 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h5><p>游戏原型</p><h5 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h5><p>游戏策划</p><h5 id="6-30"><a href="#6-30" class="headerlink" title="6.30"></a>6.30</h5><p>组队</p><h5 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h5><p>张圣林，游戏策划，如何做游戏反拆</p><p><strong>游戏反拆目标</strong>，首先游戏是可拆的。</p><p>怎么反拆，错误反拆</p><p><strong>系统维度</strong></p><p>系统，体验和功能结合。</p><p>为什么背包有大小？为什么排行榜？</p><p>描述系统的具体要素，参与对象，游戏历程，成本，行为，评价规则，产出内容，反馈。</p><p><strong>数值维度</strong></p><p>数值本身就是一种体验。</p><p>一切电子游戏都可以拆解成桌面游戏。</p><p>基本数值，不可成为原因。塑造事实，机制加上基本数值。平衡事实，</p><p>经济数值，经验，货币，成长、创造。</p><p>WOW注册？</p><p>游戏货币没有使用价值。</p><p><strong>商业化</strong></p><p>用户付费购买</p><p><strong>同类产品对比</strong>，演化。</p><p> <strong>策划文案写作技巧</strong></p><h5 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h5><p>编辑器，美院上课</p><h5 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h5><p>美术设计</p><p>地形</p><h5 id="7-6"><a href="#7-6" class="headerlink" title="7.6"></a>7.6</h5><p>游戏美术的发展</p><p>游戏美术风格</p><p>原画定义，插画师和原画师（概念设计师）</p><p>场景策划</p><h5 id="7-7"><a href="#7-7" class="headerlink" title="7.7"></a>7.7</h5><p>摄像机，视锥体，透视/正交，FOV，旋转镜头抖动效果，</p><p>后处理，color，vignette，bloom，ambientOcclusion环境光遮蔽，</p><p>Tween</p><p>GUI，anchors工具设定位置，不同设备分辨率</p><h5 id="7-8"><a href="#7-8" class="headerlink" title="7.8"></a>7.8</h5><p>游戏角色</p><blockquote><p>魔神的呓语，坐在嘴皮子底下也听不清讲台上在说什么。</p></blockquote><h5 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h5><p>原型的验证。</p><h5 id="7-10-7-26"><a href="#7-10-7-26" class="headerlink" title="7.10-7.26"></a>7.10-7.26</h5><p>延迟一周时间，但是那周在军训。天气确实很热，但人都见不到，不是每个人都可以线上合作的。</p><p>后期体验很糟糕，只能说这种安排不太适合我吧。</p><h3 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h3><p><a href="https://www.projectdavinci.com/dev/1/Script" target="_blank" rel="noopener">Davici编辑器教程</a></p><p><a href="https://bbs.projectdavinci.com/" target="_blank" rel="noopener">论坛</a></p><p><a href="https://api.projectdavinci.com/Davinci_0.12.0.58352/index.md" target="_blank" rel="noopener">api文档</a></p><p><a href="https://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">LUA菜鸟教程</a></p><p><a href="https://davinci.lilith.com/2021/" target="_blank" rel="noopener">达芬奇游戏比赛报名链接</a></p><h2 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2><p>《生命3.0》，可能包含玄幻、科幻、哲学等元素。在Intel那个无聊的宣讲会上看那本《游戏改变世界》，突然来的灵感。欢迎头脑风暴。</p><blockquote><p><strong>“回到现在，找寻过去，拯救未来。”</strong></p></blockquote><p>时间太紧，美院同学说想做一个类似于Superhot的射击游戏，然后小组合作属实没弄好，有时间上的问题也有我的问题。几个人都不怎么玩游戏，最后拖到军训还在做，最后一天截止交了个差。</p><h2 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h2><p><a href="https://www.zhihu.com/question/20957940/answer/21415083" target="_blank" rel="noopener">知乎问题：为什么越来越多的大学生沉溺于游戏？</a></p><p>推荐看一下赞同数最高2.4w的回答，这里我也截取过来了。</p><blockquote><p>作者：迷踪<br>链接：<a href="https://www.zhihu.com/question/20957940/answer/21415083" target="_blank" rel="noopener">https://www.zhihu.com/question/20957940/answer/21415083</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>因为<strong>所有游戏的设计</strong>都是<strong>冲着“人性的弱点”</strong>来的。</p><p>1、即时反馈<br>你在游戏中的任何操作，都会立马<strong>视觉化</strong>、<strong>数据化</strong>地显示出来。</p><p>不要小看每次砍怪物头上飚出的数字，不要小看出招的音效，不要小看伤血的红字和加魔的蓝字，它们都给玩家提供了最最直观即时的反馈。<br>为什么即时反馈是有效的？因为，<strong>即时反馈提供给玩家一种可控感</strong>。（有个段子说：电梯里的关门键其实根本无效，但光是这个装饰用的按键却实实在在可以增加乘客的可控感，进而产生心理上的安抚效应，不易烦躁。——感谢</p><p><a href="http://www.zhihu.com/people/eb1ad61d75938cd3023387dfb610073d" target="_blank" rel="noopener">@地铁风</a></p><p>提供的信息：美国的电梯门规定必须是那样的，见<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Placebo_button" target="_blank" rel="noopener">Placebo button</a> 但中国的大部分电梯门按钮是实际有效的。）</p><p>对比现实生活中的学习——听课并不能让你直观看到经验值增长，看书也听不到书本被砍翻的惨叫，被游戏吊高胃口的学生自然觉得无聊、没劲。</p><p>2、多重系统，多样玩法，小目标渐进<br>相信你一定有这样的体验：哎呀，今天先玩到这样吧。但只差7%就升级了，要不就想打到升级吧！啊呀，打到稀有宝石，可以镶嵌武器了，赶紧去收集一下需要的素材。好朋友上线了，约了去打副本……打完了正好零点，又有新任务！……</p><p>无穷循环。</p><p>为了将玩家牢牢栓在游戏里，游戏不止提供升级体验，还提供各种全方位多角度的玩法。总能让你找到一个10分钟左右的小目标，不断去完成它，获得完成时的成就感。一旦得到这个成就感，为了维持这种欣快的感觉，玩家又迫不及待地投入了下一个小目标。</p><p>如此算来，平均10分钟一个小高潮，学习又怎么比得过它？</p><p>3、成就感</p><ul><li>内在激励</li></ul><p>内在激励简单来说，就是一种自我能力的确认——这件事我喜欢，我做了，我克服了困难，我完成，我开心。<br>为什么简单的小游戏，比如扫雷、连连看会让人上瘾一般一盘又一盘玩下去？<br>因为它设置了<strong>恰到好处的困难让你证明你有能力破解它</strong>。感受到这种力量，你就想一再体验。（还记得刚才那个电梯按钮的例子么？对，这也是一种可控感的体现。）</p><ul><li>称号</li></ul><p>完成了某种成就就会被记录。除了网游，现在还有谁会拼命找理由就为了给你发小红花？</p><ul><li>展示</li></ul><p>可能生活中一个普通小职员在游戏里就是一呼百应的公会老大。<br>这种权力和万众仰慕的感觉也是现实生活中的“稀缺资源”。<br>举个栗子：史玉柱在《我的营销心得》中提到，《征途》在情人节推出1元的虚拟玫瑰花，最后卖了可能有5000万。为什么？因为他提供了“展示”——只要送99朵以上，就上公告。</p><p>4、协作和献身<br>俗话说：人生有四铁——一起同过窗，一起扛过枪，一起嫖过娼，一起分过赃。说的就是，<strong>当人和人一起经历过情绪的大起伏，就会产生更亲密的关系</strong>。</p><p>但大学生活能提供的供人情绪起伏的活动太少，导致同窗关系质量严重下降。取而代之的，变成“<strong>一起上过网</strong>”，在游戏里组队、团战、城战、洗白、pvp……虽然所有活动都建立在虚拟的网络游戏上，但产生的<strong>情感联系</strong>却是真实的。<br>甚至，游戏还能提供现代社会稀缺的“庄严”和“意义”感。呵呵，为自己公会牺牲过的童鞋都懂的。</p><p>一边是活色生香的鲜活情感，一边按部就班的麻木生活，大学又怎么跟剑三或者魔兽比呢？</p><p>===============================================<br>另外再补充一点：</p><p>5、简化世界，路径清晰<br>据说现代的关键词是“迷茫”，游戏的设计就是为了<strong>解除“迷茫”</strong>。</p><p>游戏体系在不断的研究和发展演进中，已经形成一套<strong>将现实生活总结简化的图谱、话语体系</strong>。<br>你要做什么，怎么做，做到后有什么结果，全部都清楚地向你敞开。只需照着地图、攻略，就能达到你所期望的目标。</p><p>往大里说，所有人都追求“<strong>对世界的理解</strong>”，而这种欲望，在游戏中能得到最大限度的满足。甚至已经反过来影响现实。<br>请看下图，这是一张微博上流传滴现实职业进阶图，or技能树。</p><p><img src="https://pic2.zhimg.com/50/4e5807a47b1ec28661baa39a13c544d8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/4e5807a47b1ec28661baa39a13c544d8_720w.jpg?source=1940ef5c" alt="img"></p><p>有木有突然觉得“一切尽在掌握”？^++++^</p><p>=================================<br>以上，是我的粗浅分析。</p><p>如果对这个问题有兴趣，强烈推荐一本神书！<br>《<a href="https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10828002/" target="_blank" rel="noopener">游戏改变世界 (豆瓣)</a>》</p><p><img src="https://pic4.zhimg.com/80/1103272922f636cc05c7b8c2017da578_720w.jpg?source=1940ef5c" alt="img"></p><p>本书前言就提出：</p><blockquote><p>游戏满足了现实世界无法满足的真实人类需求，带来了现实世界提供不了的奖励，它们以现实世界做不到的方式教育我们，鼓励我们，打动我们，以现实世界实现不了的方式把我们联系在一起，我们很“饥渴”，游戏填饱了我们，对更满意工作的饥渴，对强烈族群感的饥渴以及对更有意义的人生的饥渴。</p></blockquote><p>书中的分析和例子都十分精彩，推荐阅读。</p><p>=====================================<br>本来看到</p><p><a href="http://www.zhihu.com/people/f385565c9ce9a5f852b0b6624732e69a" target="_blank" rel="noopener">@吴遇安</a></p><p>的答案，觉得已经不再需要回答了。</p><p>不过感觉对于提主提出的“心理学角度”有欠缺，斗胆补充了这篇答案。</p><p>十分感谢大家的点赞。</p><p>作为知乎新人能得到接近三位数的赞，实在是……太赞了！<del>(≧▽≦)/</del></p><p><del>下面是更新</del></p><p>一开始我读《游戏改变世界》，完全只是想了解一下游戏设计中针对人类心理机制的原理，没想到，读完后，发现这本书，其实是一本谈“如何用<strong>游戏设计中的珍贵经验</strong>来<strong>改造现实生活</strong>”的未来学著作。</p><p>也就是说，当我们分析完游戏针对“人性弱点”的设计原理后，并不是要唾弃一口“万恶的游戏”，然后就能认清它的“丑恶”面目从此幡然醒悟天天向上了。</p><p>我们应该从中学习，<strong>学习游戏设计的精神、精髓</strong>，将它应用在我们的生活、学习上，<strong>让生活、学习也借此变得让人上瘾</strong>——这才是我们做此长篇大论分析的原因所在！（下面这部分特别想写给评论中的</p><p><a href="http://www.zhihu.com/people/f31b277fa45e6b6c9b520e9d2dbf6df9" target="_blank" rel="noopener">@贺Cancy</a></p><p>童鞋，让我们一起奔向让人上瘾的学习生活吧！<del>(≧▽≦)/</del>）</p><p>书中作者举了个很有趣的栗子，我尽量用最简单的话描述一下：</p><p>作者在一次演讲中说：“要是在这场演讲中我每次冒出一个聪明设想，都能加1点智力就好了，或者至少在当众演讲方面能多加几点。哪怕我喜欢喜欢演讲，演讲本身还是一件让人精疲力竭的活动。要是能在这个时候，看到PPT上弹出一些“+1”的提示框，一定能带给我不少激励。”</p><p>几天后，作者收到了一份电子邮件。你猜上面写着什么？</p><blockquote><p>“你的一位朋友XX，承认你的一些强项，并为之+1点。具体来说，他们认可的是以下这些属性：<br>+1智力<br>+1公众演讲<br>+1启发<br>恭喜！日安。”</p></blockquote><p>原来是一位听众，受了作者的启发，在网上做了一个小程序，让每个人都可以为别人送上“+1”，还可以附上理由。你可以在网站上内建的37种不同的个人强项中选择一项或者几项“+1”，网站就会自动给对方发一封电子邮件。如果对方在网站上注册，别人赠送的分数就会累加。</p><p>看到这里我突然想到，如果腾讯把“朋友标签”改成这个“+1”系统该多么好玩？每个人都可以给自己的QQ好友打分。这样，当你听一个失恋的朋友打电话跟你哭诉1小时后，你就可以期待她会记得送你一个“爱心”的“+1”。</p><p>如此一来，在游戏之外，在现实之中，我们也可以通过游戏规则的设定和帮助来将我们的行动、成绩、效果可视化、数值化，建立即时反馈，形成一系列能满足成就感的小任务，建立联系……也就是说，能让现实变得跟游戏一样一样的！</p><p>事实上，知乎不已经成功地应用了“+1”这个系统吗？</p><p>如果没有知乎系统中提供的“+1赞同”，我想，我恐怕是无法静下心来花两三个小时梳理我对这个问题的看法，并将之系统表述出来的吧？<br>正是由于每个人点点鼠标，花时间阅读、评论，知乎才有游戏上瘾般的魔力，吸引大家来分享知识和见解，产生高质量的回答啊：）</p><p>但，我认为这还不是现实游戏化的最终形态。</p><p>还记得我一直在强调游戏提供给人“控制感”这一条吗？</p><p>是的，最终形态，就是：<strong>你来设计游戏，你来设计目标，你来设计进程、系统、称号、奖励，你来给自己发小红花，你来给自己“+1”。</strong></p><p>下面是我的一个尝试的企图，抛砖引玉一下哈：</p><p>——————</p><blockquote><p>【成为写作之神 游戏设计】</p></blockquote><blockquote><p>目标：攒够10000分，成为写作之神！</p></blockquote><blockquote><p>计分方式：</p></blockquote><blockquote><ul><li>写作书1000字5分</li><li>小说1000字5分</li><li>回答知乎问题2分</li><li>读书半个小时写笔记2分，光读书要一个小时1分</li><li>观影笔记，3分</li><li>一条原创微博1分</li><li>把最近总结的理论说给一个人听 2分</li><li>其他特殊任务，特殊计分（比如突然要写个书评、写个歌词什么的）</li><li>看电影看休闲小说要用分数来购买时间，1分半小时。</li></ul></blockquote><blockquote><p>每天基本分数是10分，达到就可以解锁成就。</p></blockquote><blockquote><p>每累计到100分，可抽奖一次，用两个骰子，抽到数字就是粉丝数，粉丝数代表地位称号。</p></blockquote><p>——————</p><p>在给自己设计游戏的时候，关键并不在于设计的系统有多完美，最关键的是，给自己另一种看待现实、掌握现实的方式。</p><p>写到这里，突然想起了一个故事：幼儿园老师发现一个小朋友在厕所门口憋着不肯进，老师很奇怪，就问小朋友怎么回事。小朋友脸涨得通红，委屈地说“在家里上完厕所，妈妈都会给我鼓掌。”老师怎么劝小朋友，都木有用，最后老师突然灵机一动说：“这里没有妈妈给你鼓掌，那你自己给自己鼓掌好吗？”小朋友一听，就高高兴兴进去了。出来后，自豪地给自己用力鼓了三下掌。</p><p>你是那个等着妈妈给你鼓掌，别人给你点赞的人呢？还是那个，学会用力给自己鼓掌的小朋友？<br>结果如何先不去管，做了就先给自己点个赞如何？</p><p>以上。<br>希望能带给大家一点启发。</p><p>===================</p><p>ps：哪怕只是改变一下词语系统，都可以让我们转换思维、调整心态——</p><p>我会告诉你，自从我们公司把去办公室请老板签字叫做“去刷boss”后，整个气氛都欢乐了很多、积极了很多吗？哈哈~</p><p>2014-1-6 修改</p><p>【增加一个课堂运用游戏化思维的案例，from《游戏化思维》p172-173，略有改写】<br>受到《魔兽世界》的启发，印第安纳大学的经济学教授爱德华·卡斯特纳瓦开始改革课程。<br>他宣布，所有来上课的学生都可以获得“经验值”，课堂陈述被称为“游戏任务”，考试被称为“打怪”，而家庭作业则变成了“锻造”。学生被分为不同的合作小组，简称“游戏公会”。</p><p>结果，这门课称为学校的明星课程，学生的出勤率和学习效果都得到了显著的提高。</p><p>学校的课程协调官员感慨道：“这门课程所包含的元素是学生们熟悉、喜爱并且更加容易接受的，它给平常的过程换上了崭新的面貌，可以说真正地做到了寓教于乐。作为教育工作者，你必须时刻提醒自己，<strong>你的学生是游戏的一代、社交媒体的一代</strong>。”</p><p>2014-7-25 修改</p><p>【2015-03-10 感谢知乎日报推荐，再补充一点】</p><p>6、随机性<br>为什么卡牌游戏风靡日本，抽卡已经变成了“氪金”？因为它运用了<strong>随机性。</strong></p><p>关于随机性的强大魔力，有个实验是这样的，具体资料恕我暂时没找到，全凭记忆写下，欢迎大家给我提供：<br>科学家给鸟一个按钮，只要它按下就能吃到饲料，而另外一只鸟得到的按钮，产生的结果是随机性的，也就是说，可能有饲料，也可能没饲料。结果，比起前者的淡定，后者完全对按钮<strong>上瘾</strong>了，不断去按按钮，甚至都不为了吃饲料。<br>仔细想想，从进化角度来说，对随机性上瘾也是符合逻辑的——对于生物延续来说，食物是非常重要的资源，一旦得到就意味着生命可以延续，因此，生命机制本身的首要命令就是要最大限度保证食物来源。随机性，就好比草原上的花豹去追羚羊，可能追得到也可能追不到，也好比猴子去果树上找果子，可能找得到也可能找不到，于是，就需要生命体付出更多努力，来确保最终获得食物。为了防止生物体太容易放弃努力，生物基因中直接刻印了对随机性的偏好，也就是上瘾机制，让生物对此乐此不疲——也成了现在游戏性中的一大杀手锏。<br>抽卡让人上瘾的原因中，隐藏着随机性这个杀手，同样的，在“开宝箱”“抽奖”“牌类”游戏中，无不隐藏着随机性的惊喜。<br>这也是游戏让人上瘾的重要原因之一。</p><p>ps：在这里推荐一下《创造力》这本书。本书中提到的创造过程中的“心流”概念，也很适合用在游戏上瘾的迷狂状态上。</p><p><img src="https://pic4.zhimg.com/50/80cf5a19223cbac41a9edd4f341cb68d_hd.jpg?source=1940ef5c" alt="img"></p><p>下面是书中提到的“心流”状态9个特征，也回答了“创造性为什么产生愉悦”这个问题，和我上面提出的5条游戏上瘾机制基本都能对应上，也附在这里，给大家做个参考。更具体的内容，欢迎大家自主阅读：</p><ol><li>每一步都有明确的目标。</li><li>对行动有迅速的反馈。</li><li>在挑战和技巧之间有一种平衡。</li><li>行动和意识相融合。即全神贯注，意识和行动都只有一个共同目标。</li><li>摒除杂念，只有当下，使我们摆脱了在日常生活中导致压抑和焦虑的害怕。</li><li>根本不担心失败。</li><li>自我意识消失。自我通过创造这种全神贯注进而遗忘自我的活动得到扩展。</li><li>时间感被歪曲。</li><li>行为具有自身的目的。做一件事最大的报酬就是做它时获得的体验。</li></ol><p>======这里是补充结束的分割线======</p></blockquote><p>《游戏改变世界》这本书我去年看了两三章英文版的，后来实在没有动力看下去，这次正好可以趁这个机会快速看完中文版，对游戏进行一次自己的思考。</p><h2 id="关于开源"><a href="#关于开源" class="headerlink" title="关于开源"></a>关于开源</h2><p>关于这次学校夏季大作业我有一个大胆的开源想法。。。。</p><p>还是算了，没什么意思，编辑器打开一下卡起码半分钟。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code01装机记</title>
      <link href="/2021/06/19/code01/"/>
      <url>/2021/06/19/code01/</url>
      
        <content type="html"><![CDATA[<h2 id="Code01"><a href="#Code01" class="headerlink" title="Code01"></a>Code01</h2><h3 id="装机流程"><a href="#装机流程" class="headerlink" title="装机流程"></a>装机流程</h3><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>浏览器：Chrome，自带的Microsoft Edge</p><p>社交通信：qq，tim，wechat</p><p>办公：WPS</p><p>笔记：幕布，Typora</p><p>安全：火绒</p><p>工具：桌面日历，Snipaste截屏，</p><p>其他：百度网盘，网易云音乐</p><p>vpn：clash装上后Chrome就可以同步了</p><p>编程：Github Desktop，Docker</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>VS2019</p><p>Anaconda3：打不开…………………………………………………..</p><p>Pycharm-&gt;tensorflow1.0</p><p>Android Studio</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上海大学ASC超算竞赛</title>
      <link href="/2021/06/17/asc2022/"/>
      <url>/2021/06/17/asc2022/</url>
      
        <content type="html"><![CDATA[<h1 id="ASC2022备战"><a href="#ASC2022备战" class="headerlink" title="ASC2022备战"></a>ASC2022备战</h1><h2 id="关于ASC"><a href="#关于ASC" class="headerlink" title="关于ASC"></a>关于ASC</h2><p><strong>ASC简介</strong></p><p>世界大学生超级计算机竞赛（ASC Student Supercomputer Challenge，简称ASC超算竞赛），是世界最大规模的超算竞赛，与德国ISC、美国SC并称世界三大超算竞赛。该竞赛由中国倡议成立，与日本、俄罗斯、韩国、新加坡、泰国等国家和地区的超算专家和机构共同发起并组织，并得到美国、欧洲等国家地区超算学者和组织的积极响应支持。ASC旨在通过大赛的平台，推动各国及地区间超算青年人才交流和培养，提升超算应用水平和研发能力，发挥超算的科技驱动力，促进科技与产业创新。</p><p>ASC 世界大学生超级计算机竞赛肇始发韧于 2012 年，至今已连续举行 7 届，累计有数千名大学师生参与该项赛事，经历了从中国到亚洲，再从亚洲到世界的规模升级，影响力不断攀升。ASC 旨在通过大赛的平台，推动各国及地区间超算青年人才交流和培养，提升超算应用水平和研发能力，发挥超算的科技驱动力，促进科技与产业创新。迄今为止，ASC 超算竞赛共吸引了全球超过 5500 名年轻人才，参赛队伍总数超过 1100 支，是目前全球规模最大、参与人数最多的大学生超算赛。在2018世界大学生超级计算机竞赛中，共有超300支高校队伍参赛，包括清华大学、台湾清华大学、上海交通大学、俄罗斯圣彼得堡大学等世界知名学府。最后进入总决赛的有来自中国、美国、俄罗斯、德国等20支队伍。</p><p><strong>上交大ASC21招新介绍</strong></p><p>ASC不仅是让大学生参加超算比赛深刻了解超算的平台，更为高校提供了人才培养机制，让高校从中获取高性能计算专业人才。带队老师廖秋承跟学生打比方，如果说戈登贝尔奖和Top500是超算届的达喀尔拉力赛和F1比赛，ASC就是超算界的卡丁车竞赛。一个车手想成长为F1赛车手，他从非常小的时候就要接受卡丁车专业训练，连续十几年的时间里一直接受各种各样的赛车训练知识，引擎的知识，如何掌控重力、牵引力，轮胎管理和底盘管理等等。超算竞赛就像卡丁车竞赛，教会学生如何管理一个复杂系统，从芯片微架构体系结构，到芯片间的互联，节点的互联，到操作系统，调优到建模，从来没有一个比赛像ASC比赛这样，把所有方面全部结合在一起，这也给学生带来非常大的挑战。</p><p>ASC不仅是播撒种子的平台，还是创新的平台，上海交通大学代表队在这几年比赛中干过疯狂的事情，2016年为DNN模型创建了18层的令牌环，达到了决赛中苛刻的精度和速度要求。2017年交大团队第一次在PCIE SSD上使用了并行文件系统BeeGFS。2018年交大团队打磨了散热器，更换了高性能的硅脂，改变服务器的散热策略，使得在南昌大学酷热的场地还能保持服务器的正常运行。2019年第一次在每一台服务器节点上用了两块Omni-Path 100G的网卡，从而实现了全场最快的CESM模拟，当然因为一些原因，CESM并没有拿到奖。</p><p>ASC不仅是一个播撒种子的平台，还是一个让学生发挥他们最大创造力的平台，可以有非常多在正式生产集群上无法用的技能技巧和奇思妙想。虽然在ASC的赛场上，这些技巧并不会扭转乾坤，甚至根据我的经验，它们大部分都失败了，但是最后这些技巧越来越成熟后，却有可能真正用在生产环境和高校的科研中。2019年π2.0帮助上海交通大学一位老师进行了北冰洋洋面和洋面下的气侯模拟，用的正是CESM的模型，他经过交大ASC竞赛团队队员帮助，在π2.0集群上非常高效的完成之前无法运行起来的模拟。</p><p>今年第一次以超算工程师和学科主要科学家合作的模式，从零开始研发一个内燃机摩擦学模拟程序，在研发成功后，这将是国际上摩擦学领域第一个二维滑动平面进行多尺度摩擦特性研究的程序。ASC比赛不仅仅是让学生玩的爽的比赛，还让算力应用到日常科研中，让高校和各领域学科的科学家都从中受益。</p><h2 id="招募要求（已完成）"><a href="#招募要求（已完成）" class="headerlink" title="招募要求（已完成）"></a><strong>招募要求</strong>（已完成）</h2><ol><li>上大全日制在读本科生，专业不限，对高性能计算、计算机体系结构、并行计算有浓厚兴趣；</li></ol><blockquote><p>目前队伍里已经有2位智科大三的同学，最好是有计科大三的同学能够加入互补。参加这个比赛主要学生来源专业是数学，计算机，软件，信息等。</p></blockquote><ol><li>有一定的自我学习能力和英文文档阅读能力，有刻苦专研学习精神，有相对富余的业余时间。</li><li>具有基本的C/C++或Fortran编程能力（至少能够使用一种语言），常用编程语言Python，Linux脚本语言，掌握基本的算法/数据结构知识。</li><li>了解Openmp，MPI并行编程，应用软件性能分析及优化能力</li><li>了解Pytorch等深度学习框架，以及OpenAcc、CUDA编程，或具备cv，nlp等相关知识，应用数学能力强者优先</li></ol><hr><p>ASC超算大赛迄今已举行至第9届，吸引超过8500名世界各国大学生参赛。本届比赛有380多支队伍参赛，设置一等奖20名，二等奖50名。一等奖占总参赛队伍的5%，二等奖占总参赛队伍的13%左右。</p><p>ASC19将采用”初赛+决赛”的赛制。2018年11月15日到2019年1月7日为高校报名阶段，以小组形式报名，每个参赛队伍由五名本科生和一名指导老师组成。2019年1-3月为初赛阶段，参赛队根据要求提交超算应用优化提案，组委会筛选出二十支队伍进入决赛。决赛将于4月21-25日在大连理工大学举行，参赛队基于大赛提供的硬件平台，在3000W功率下设计和搭建超算集群并实现指定应用的优化。</p><p>世界范围的各高等院校均可报名ASC竞赛，ASC20超算竞赛赛程分为三个阶段：</p><h2 id="竞赛章程"><a href="#竞赛章程" class="headerlink" title="竞赛章程"></a>竞赛章程</h2><blockquote><p>参照2020，一般每年都是如此。</p></blockquote><p>第一阶段：高校报名并组织参赛队伍，所有有意向参加的高校需要在2020年1月5日之前通过竞赛官网向组委会提交申请，每个高校可以有多个队伍，参赛队需要1名指导老师和5个在校本科生；</p><p>第二阶段：1月6日-2月28日期间进行<strong>初赛</strong>，各参赛队根据竞赛命题要求进行相关书面方案准备和应用优化，由评审委员会评选出前20名总分最高的队伍进入决赛；</p><blockquote><p>需要注意我们上大的三学期制，寒假后冬季学期返校马上就是期末考试（比赛开始其他学校应该刚考完期末），所以我们要在寒假里完成大部分工作，最好是能够留校</p></blockquote><p>第三阶段：4月25日-4月29日期间进行<strong>总决赛</strong>，20强队伍将在南方科技大学进行面对面比拼，角逐ASC20总决赛的各大奖项。总决赛时间为5天，参赛大学生队伍需在5天时间内现场组建一台运行功耗不高于3000W的超级计算机系统作为平台，优化完成近7道HPC与AI应用赛题。</p><h2 id="目标是星辰大海"><a href="#目标是星辰大海" class="headerlink" title="目标是星辰大海"></a>目标是星辰大海</h2><p>冲决赛！！！毕竟谁还没个能和清华大学一较高下的梦想，只要进了决赛就是一等奖，我们也才有机会去和更多优秀的选手交流学习。（保底就是冲个二等奖回来）</p><p>SHU的ASC超算之路从我们重新开始。</p><p>从现在九月到明年三月比赛结束大概半年时间，就当成是一个挑战自己以及共同学习的好机会，也不希望大家太功利，但是要付出十二分的努力。</p><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><p><strong>学习资料</strong></p><p><a href="https://blog.csdn.net/weixin_42819452/article/details/102807147" target="_blank" rel="noopener">CSDN上OpenMP、MPI、CUDA总结</a></p><hr><h3 id="Openmp"><a href="#Openmp" class="headerlink" title="Openmp"></a>Openmp</h3><p>OpenMP是由OpenMP Architecture Review Board牵头提出的，并已被广泛接受，用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案(Compiler Directive) 。</p><p>支持OpenMP的编程语言：C、C++和Fortran；</p><hr><h3 id="HPL"><a href="#HPL" class="headerlink" title="HPL"></a>HPL</h3><p><a href="https://blog.csdn.net/xuexi090610/article/details/51073087" target="_blank" rel="noopener">多机linpack</a></p><p><a href="https://blog.csdn.net/xuexi090610/article/details/51073087" target="_blank" rel="noopener">LINPACK测试</a></p><hr><h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h3><p>MPI 是什么？这里引用一段 <a href="https://link.zhihu.com/?target=https%3A//mpitutorial.com/tutorials/mpi-introduction/zh_cn/" target="_blank" rel="noopener">MPI 教程介绍</a> 中的内容：</p><blockquote><p> 在 90 年代之前，程序员可没我们这么幸运。对于不同的计算架构写并发程序是一件困难而且冗长的事情。当时，很多软件库可以帮助写并发程序，但是没有一个大家都接受的标准来做这个事情。<br> 在当时，大多数的并发程序只出现在科学和研究的领域。最广为接受的模型就是消息传递模型。什么是消息传递模型？它其实只是指程序通过在进程间传递消息（消息可以理解成带有一些信息和数据的一个数据结构）来完成某些任务。在实践中，并发程序用这个模型去实现特别容易。举例来说，主进程（master process）可以通过对从进程（slave process）发送一个描述工作的消息来把这个工作分配给它。另一个例子就是一个并发的排序程序可以在当前进程中对当前进程可见的（我们称作本地的，locally）数据进行排序，然后把排好序的数据发送的邻居进程上面来进行合并的操作。几乎所有的并行程序可以使用消息传递模型来描述。<br> 由于当时很多软件库都用到了这个消息传递模型，但是在定义上有些微小的差异，这些库的作者以及一些其他人为了解决这个问题就在 Supercomputing 1992 大会上定义了一个消息传递接口的标准，也就是 MPI。这个标准接口使得程序员写的并发程序可以在所有主流的并发框架中运行。并且允许他们可以使用当时已经在使用的一些流行库的特性和模型。<br> 到 1994 年的时候，一个完整的接口标准定义好了（MPI-1）。我们要记住 MPI 只是一个接口的定义而已。然后需要程序员去根据不同的架构去实现这个接口。很幸运的是，仅仅一年之后，一个完整的 MPI 实现就已经出现了。在第一个实现之后，MPI 就被大量地使用在消息传递应用程序中，并且依然是写这类程序的标准（de-facto）。</p></blockquote><p>这里十分推荐先阅读完 <a href="https://link.zhihu.com/?target=https%3A//mpitutorial.com/tutorials/" target="_blank" rel="noopener">MPI 教程</a> 的全部内容，它是我在互联网上能找到的所有关于 MPI 的公开材料中最为深入浅出的一个教程。</p><p>简单地来理解 MPI，它是一个定义了多个原语的消息传递接口，这一接口主要被用于多进程间的通信。它的竞品包括 RPC，Distributed Shared Memory 等。</p><p>作者：gaocegege<br>链接：<a href="https://zhuanlan.zhihu.com/p/158584571" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/158584571</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h3 id="HPL与High-Performance-Linpack"><a href="#HPL与High-Performance-Linpack" class="headerlink" title="HPL与High Performance Linpack"></a>HPL与High Performance Linpack</h3><p><strong>背景知识</strong></p><p>LINPACK全名Linear Equations Package，是近年来较为常用的一种计算机系统性能测试的线性方程程序包，内容包括求解稠密矩阵运算，带状的线性方程，求解最小平方问题以及其它各种矩阵运算。它最早由来自Tennessee 大学的超级计算专家Jack Dongarra提出。程序用FORTRAN编写，在此基础上还有C，JAVA等版本。Linpack使用线性代数方程组，利用选主元高斯消去法在分布式内存计算机上按双精度(64 bits)算法，测量求解稠密线性方程组所需的时间。Linpack的结果按每秒浮点运算次数（flops）表示。第一个Linpack测试报告出现在1979年的Linpack用户手册上，最初LINPACK包并不是要制订一个测试计算机性能的统一标准，而是提供了一些很常用的计算方法的实现程序，但是由于这一程序包被广泛使用，就为通过Linpack 例程来比较不同计算机的性能提供了可能，从而发展出一套完整的Linpack 测试标准。</p><p>HPL，即High Performance Linpack，目前已经成为国际标准的Linpack基准测试程序，其1.0版于2000年9月发布，是第一个标准的公开版本并行Linpack测试软件包，一般用于全世界TOP500超级计算机上的并行超级计算机排名。HPL测试标准的用户自由度要大很多，使用者可以选择矩阵的规模，分块大小，分解方法等等一系列的各种参数，都是按需要更改的。 </p><p>HPL软件包需要在配备了MPI环境下的系统中才能运行，还需要底层有线性代数子程序包BLAS的支持（或者有另一种向量信号图像处理库VSIPL也可）。</p><p>HPL软件包不仅提供了完整的Linpack测试程序，还进行了全面细致的计时工作，最后可以得到求解的精确性和计算所花费的总时间。该软件在系统上所能达到的最佳性能值适合很多因素有关的。</p><pre class="line-numbers language-text"><code class="language-text">下载必要的软件包： MPI，GotoBLAS库，HPL源码https://www.mpich.org/downloads/https://www.tacc.utexas.edu/research-development/tacc-software/gotoblas2http://www.netlib.org/benchmark/hpl/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://henryavery.cn/2020/11/28/shu-ji-zu/#toc-heading-9">机组实验四linpack安装</a></p><p>下面这个教程比较靠谱</p><p><a href="https://www.kclouder.cn/linpack-guide-1/" target="_blank" rel="noopener">Linpack安装、配置与运行</a></p><p><a href="https://blog.csdn.net/weixin_34087307/article/details/93305633" target="_blank" rel="noopener">Ubuntu安装MPICH3集群计算环境</a></p><hr><h3 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h3><p>CMake<strong>资料整理</strong> </p><p>gcc相关</p><p>见群文件 —《GCC编程简介》</p><hr><p>make相关:<br><a href="https://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">Make命令教程</a> </p><p><a href="https://literaryno4.github.io/makefile_tutorial.html/#1-%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">Makefile编写简明教程</a></p><hr><p>CMake相关: </p><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html" target="_blank" rel="noopener">CMake官方教程</a></p><p><a href="https://github.com/chaneyzorn/CMake-tutorial" target="_blank" rel="noopener">CMake官方教程中翻</a></p><p><a href="https://github.com/ttroy50/cmake-examples" target="_blank" rel="noopener">CMake具体示例</a></p><p><a href="https://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">CMake简单教程(适合快速入门)</a></p><hr><h3 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch(+)"></a>Pytorch(+)</h3><p><a href="https://zhuanlan.zhihu.com/p/87263048" target="_blank" rel="noopener">带你少走弯路：强烈推荐的Pytorch快速入门资料和翻译</a>（可下载） - 黄海广的文章 - 知乎 </p><p><a href="https://pytorch.zhangxiann.com/" target="_blank" rel="noopener">pytorch学习笔记-张贤同学，知乎1.7k赞</a></p><p>主要是看到所有代码均在 PyCharm 中通过测试，可以通过 git 克隆到本地运行。</p><hr><h3 id="TensorFlow（-）"><a href="#TensorFlow（-）" class="headerlink" title="TensorFlow（?）"></a>TensorFlow（?）</h3><p>同样是深度学习框架，不过之前ASC都没有用过，好像只用过Pytorch。但也应该要会用。</p><p><a href="https://henryavery.cn/2021/04/01/tensorflow/">TensorFlow学习笔记-个人整理资料</a></p><hr><h3 id="cuda（-）"><a href="#cuda（-）" class="headerlink" title="cuda（+）"></a>cuda（+）</h3><p><strong>统一计算设备架构</strong>（Compute Unified Device Architecture, <strong>CUDA</strong>），是由<strong>NVIDIA</strong>推出的通用并行计算架构。解决的是用更加廉价的设备资源，实现更高效的并行计算。</p><p>【CUDA教程】一、认识cuda - 刘冬煜的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/146431357" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/146431357</a></p><p>CUDA编程入门极简教程 - 小小将的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/34587739" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34587739</a></p><p>熬了几个通宵，我写了份CUDA新手入门代码 - godweiyang的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/360441891" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/360441891</a></p><blockquote><p>阳神！</p><p><a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">谭升的博客强推！！</a></p><p>我的cuda笔记</p></blockquote><h3 id="oneAPI"><a href="#oneAPI" class="headerlink" title="oneAPI(?)"></a>oneAPI(?)</h3><p><a href="https://www.oneapi.io/" target="_blank" rel="noopener">oneAPI官网</a></p><p><a href="https://blog.csdn.net/weixin_44506674/article/details/110990718?spm=1001.2101.3001.6650.19&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-19.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-19.no_search_link" target="_blank" rel="noopener">Intel oneAPI学习笔记之基本概念＆六大工具包一览</a></p><blockquote><p>Intel oneAPI 是一个跨行业、开放、基于标准的统一的编程模型，它为跨 CPU、GPU、FPGA、专用加速器的开发者提供统一的体验，包含两个组成部分∶ 一项行业计划和一款英特尔beta 产品。</p><p>oneAPI 开放规范基于行业标准和现有开发者编程模型，广泛适用于不同架构和来自不同供应商的硬件。oneAPI 行业计划鼓励生态系统内基于oneAPI规范的合作以及兼容 oneAPI的实践。</p><p>英特尔 oneAPI 产品是英特尔基于oneAPI 的实现，它包括了 oneAPI 标准组件如直接编程工具（Data Parallel C++）、含有一系列性能库的基于 API 的编程工具，以及先进的分析、调试工具等组件。开发人员从现在开始就可以在英特尔 DevCloud for oneAPI 上对基于多种英特尔架构（包括英特尔至强可扩展处理器、带集成显卡的英特尔酷睿处理器、英特尔 FPGA 如英特尔 Arria、Stratix 等）的代码和应用进行测试。</p><p>总的来说，单说 Intel oneAPI 只是一个编程模型、一个行业规范，二 Intel oneAPI 相关产品如 Intel oneAPI Base Toolkit、Intel oneAPI HPC Toolkit以及Intel AI Analytics Toolkit则是基于 Intel oneAPI 这一编程模型开发的产品，可以在这里下载<a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/all-toolkits.html" target="_blank" rel="noopener">https://software.intel.com/content/www/us/en/develop/tools/oneapi/all-toolkits.html</a><br>————————————————<br>版权声明：本文为CSDN博主「万古霉素(Vancomycin)」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_44506674/article/details/110990718" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44506674/article/details/110990718</a></p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/397581268" target="_blank" rel="noopener">知乎oneAPI安装</a></p><hr><h3 id="Spack"><a href="#Spack" class="headerlink" title="Spack(?)"></a>Spack(?)</h3><p>软件管理工具</p><p><a href="https://spack.readthedocs.io/en/latest/" target="_blank" rel="noopener">Spack官方文档</a></p><blockquote><p>Spack 是一种包管理工具，旨在支持各种平台和环境上的多个版本和软件配置。它是为大型超级计算中心设计的，在这些中心，许多用户和应用程序团队使用没有标准 ABI 的库在具有奇异架构的集群上共享软件的通用安装。Spack 是非破坏性的：安装新版本不会破坏现有安装，因此许多配置可以在同一系统上共存。</p><p>最重要的是，Spack 很<em>简单</em>。它提供了一个简单的<em>规范</em>语法，以便用户可以简洁地指定版本和配置选项。Spack 对于包作者来说也很简单：包文件是用纯 Python 编写的，规范允许包作者为同一包的许多不同构建维护一个文件。</p></blockquote><hr><h3 id="FPGA（-）"><a href="#FPGA（-）" class="headerlink" title="FPGA（-）"></a><strong>FPGA（-）</strong></h3><p>FPGA是一种可以重构电路的芯片，是一种硬件可重构的体系结构。它的英文全称是Field Programmable Gate Array，中文名是现场可编程门阵列。</p><p>通过编程，用户可以随时改变它的应用场景，它可以模拟CPU、GPU等硬件的各种并行运算。通过与目标硬件的高速接口互联，FPGA可以完成目标硬件运行效率比较低的部分，从而在系统层面实现加速。</p><hr><h3 id="IntelParallel-Studio-XE（-）"><a href="#IntelParallel-Studio-XE（-）" class="headerlink" title="IntelParallel Studio XE（-）"></a><strong>IntelParallel Studio XE（-）</strong></h3><p>parallel studio xe 2020是intel公司推出的一款软件开发工具合集，通过它可以有效帮助用户在C ++/ C和Fortran上的Windows、MacOS、Linux等平台上更快速的进行本地代码开发，从而提升在当前和未来英特尔平台上扩展的应用程序性能。软件简化了设计、开发、调试和代码的优化，并可以利用并行处理来提高应用程序的性能，利用兼容的Intel处理器和协同处理器可以更轻易地提高应用程序性能。同时软件的代码的构建和现代化变得更加简单，而且还采用全面的矢量化、多线程、多节点并行化和内存优化等最新技术，可以很好的满足你的编辑使用需求。<br><a href="https://blog.csdn.net/weixin_42487488/article/details/115066980?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link" target="_blank" rel="noopener">Intel学生许可过期后，安装 Intel® oneAPI Base Toolkit 和 Intel® oneAPI HPC来替代</a></p><blockquote><p>我参考了这篇<a href="https://blog.csdn.net/weixin_44506674/article/details/110413364?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control" target="_blank" rel="noopener">文章</a>和这篇<a href="https://blog.csdn.net/qq_40180414/article/details/114540317" target="_blank" rel="noopener">文章</a>，感谢两位的教程！！！</p><p>之前的Intel Parallel Studio XE用邮箱申请了学生许可，已经过期，发现不能再续期，官网竟然出了免费版本！！！真香！马上安装！！</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h3><p><strong>《超算竞赛导引》</strong>，黑色封皮很薄的一本书，卖的还挺贵，淘宝五六十块钱，而且是几年前出版的，但这是比赛官方出的，可以帮助选手快速且全面地了解整个比赛和超算。我相信，书籍就是最好的老师，在有限的条件下，这本书可以算是一个很不错的教练了。<strong>可以人手一本。</strong></p><h3 id="了解比赛"><a href="#了解比赛" class="headerlink" title="了解比赛"></a>了解比赛</h3><p><a href="https://mp.weixin.qq.com/s/A2jZdVLodqd-_-ADESNPlQ" target="_blank" rel="noopener">累成狗，但值得！超算新秀青海大学ASC经验分享</a></p><p><a href="https://mp.weixin.qq.com/s/NhjsHQdRS1cY8u9qOjfGMg" target="_blank" rel="noopener">ASC超算竞赛完整备战指南(ASC18华农队长呕心力作)</a></p><p><a href="https://blog.csdn.net/baoLidanyang/article/details/79868593?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162556639816780261990189%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162556639816780261990189&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79868593.first_rank_v2_pc_rank_v29&utm_term=ASC%E8%B6%85%E7%AE%97%E7%AB%9E%E8%B5%9B&spm=1018.2226.3001.4187" target="_blank" rel="noopener">CSDN2018预赛赛题介绍</a></p><p><strong>建议细看</strong></p><blockquote><p>ASC作为国际比赛，势必不会为难没有超算环境但持有积极态度的参赛选手，据我所知，历届比赛的评分方式大致分为两类：一，统一平台，分配环境相同的集群（例如，一个队伍一个节点），2017年的预赛就是要求在太湖之光的超算集群上搭建环境，这种情况下，后面的题目会进行横向的比较，比如说，你的HPL跑了800Gflops，然后其他队伍在相同的环境下跑了900Gflops，那么在这道题目上，前者就有可能得到更高的分数（不排除文档描述条例清晰然后反杀的情况）。二，不提供统一平台，今年的就是这种情况，此时，参赛队伍可以使用手中的可用资源完成任务，使用学校的超算集群或者租集群使用，同时，因为环境的不同，应该不会对同一题目进行横向比较（这一点在培训会上也有所说明），但是需要注意的是，题目明确说明根据结果评分的会做横向对此（例如，今年的机器学习就是根据最终的准确率评分）。</p></blockquote><h4 id="b站招新培训"><a href="#b站招新培训" class="headerlink" title="b站招新培训"></a>b站招新培训</h4><p><a href="https://www.bilibili.com/video/BV1Fp4y1973s?from=search&seid=11353549349186223479&spm_id_from=333.337.0.0" target="_blank" rel="noopener">THU培训视频</a></p><p><a href="https://www.bilibili.com/video/BV1Xb4y1q7ZG?from=search&seid=16229250316216011816&spm_id_from=333.337.0.0" target="_blank" rel="noopener">b站山西大学ASC招新培训</a></p><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><p><a href="http://www.asc-events.org/" target="_blank" rel="noopener">ASC官网</a></p><p><a href="http://www.asc-events.org/ASC20-21/Trainingcamp.php" target="_blank" rel="noopener">Trainingcamp</a></p><p><a href="http://www.asc-events.org/ASC20-21/" target="_blank" rel="noopener">报名时间</a></p><blockquote><p>今天看了一下THU的培训视频，内心很是触动，也不知道我们学校哪一年才有机会去参加SC，放个官网链接留待后人吧。</p><p><a href="https://studentclustercompetition.us/" target="_blank" rel="noopener">SC官网</a></p></blockquote><h4 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h4><p><strong>CSDN</strong></p><p><a href="https://blog.csdn.net/qq_42882717/article/details/112304216?ops_request_misc=&request_id=&biz_id=102&utm_term=2021ASC%E8%B5%9B%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-112304216.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187" target="_blank" rel="noopener">2021ASC超算竞赛QuEST配置与实战（量子计算）</a></p><p><a href="https://blog.csdn.net/qq_42882717/article/details/112304216?ops_request_misc=&request_id=&biz_id=102&utm_term=2021ASC%E8%B5%9B%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-112304216.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187" target="_blank" rel="noopener">ASC18世界大学生超算竞赛题目分析以及思路总结</a></p><p><strong>Github</strong></p><p><a href="https://github.com/SYSU-SCC/sysuasc19-wtdbg2" target="_blank" rel="noopener">Github中山大学ASC19</a></p><p><a href="https://github.com/lonelyprince7/Cloze_Test" target="_blank" rel="noopener">GithubAbout2020-2021年ASC世界大学生超级计算机竞赛第3题 使用ALBert模型完成完形填空的NLP任务</a></p><h4 id="参考获奖论文"><a href="#参考获奖论文" class="headerlink" title="参考获奖论文"></a><strong>参考获奖论文</strong></h4><p>见群文件</p><hr><h2 id="其他ASC相关"><a href="#其他ASC相关" class="headerlink" title="其他ASC相关"></a>其他ASC相关</h2><h4 id="兰州大学ASC"><a href="#兰州大学ASC" class="headerlink" title="兰州大学ASC"></a>兰州大学ASC</h4><p>由于没有找到我校之前的更多资料，只能参考一下其他学校发布的一些相关信息，还得靠大家一起搜集。</p><p><a href="http://news.lzu.edu.cn/c/201903/54480.html" target="_blank" rel="noopener">关于招募2020ASC世界大学生超级计算机竞赛兰州大学代表队参赛队员的通知</a></p><p><a href="https://mp.weixin.qq.com/s/qAOHkXy9r8b6l1ZIJPKQxQ" target="_blank" rel="noopener"><strong>兰州大学首次参赛斩获总决赛一等奖和最佳人气奖</strong></a></p><h4 id="上交大ASC"><a href="#上交大ASC" class="headerlink" title="上交大ASC"></a>上交大ASC</h4><p><a href="https://hpc.sjtu.edu.cn/Item/news/news20201029.htm" target="_blank" rel="noopener">上海交大 ASC 2021 超算竞赛招新啦</a></p><p><a href="https://hpc.sjtu.edu.cn/" target="_blank" rel="noopener">上交大高性能计算中心官网</a></p><h4 id="上大ASC历史"><a href="#上大ASC历史" class="headerlink" title="上大ASC历史"></a>上大ASC历史</h4><p><a href="https://www.baidu.com/link?url=20h5LvtLTQSKGYFi_PxdHbXCocaKs1F_R_6EHRt0j4WjHxD5mphv4pRMIW-EqQ_2I-6tY5QqcUVbLrmzfqwpha&wd=&eqid=c1ec4abc000b5150000000036128f617" target="_blank" rel="noopener">上海大学ASC2015</a></p><blockquote><p>学校ASC指导老师是沈文枫老师，以往我们好像都是三十几名，能够拿到二等奖。</p></blockquote><h4 id="博客ASC学习资料"><a href="#博客ASC学习资料" class="headerlink" title="博客ASC学习资料"></a>博客ASC学习资料</h4><p><a href="https://zhuanlan.zhihu.com/p/158584571" target="_blank" rel="noopener">MPI，OpenMPI 与深度学习</a></p><p>除了网页资料，更多其他资料会放在qq群文件，由于个人搜集能力有限，还请大家多多补充。</p><h2 id="加入我们"><a href="#加入我们" class="headerlink" title="加入我们"></a>加入我们</h2><p>欢迎所有学校的ASC参赛选手加入我们学校的超算交流群，上海大学2022ASC超算竞赛交流qq群:519047969</p><p>WeChat：HenryAvery</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASC竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5月复盘</title>
      <link href="/2021/05/28/2021-5/"/>
      <url>/2021/05/28/2021-5/</url>
      
        <content type="html"><![CDATA[<h1 id="五月复盘（5-29）"><a href="#五月复盘（5-29）" class="headerlink" title="五月复盘（5.29）"></a>五月复盘（5.29）</h1><h2 id="本月关键词：书生"><a href="#本月关键词：书生" class="headerlink" title="本月关键词：书生"></a>本月关键词：书生</h2><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/61B5F56593130168941A5433E69AE478.jpg" alt="上大日出"></p><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p>“<strong>我每晚入睡，就是死去。我每日醒来，就是重生。</strong>“</p><p><strong>——甘地</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>期末复习</strong></p><p>搞了一堆报告，还有一堆没去打印，也不想再写了，没意义。</p><p>比较有意义的大概是《禅与摩托车》的读书报告和人工智能历史的PPT，但也没什么大用。</p><p>五月末尾第九周开始认真复习，第八周周末好像除了一个六级口语以外基本上就荒废了。</p><p>整理离散和信息论的笔记，矩阵代数就算了。</p><p><strong>英语</strong></p><p>15h，大概做了不到两套卷子，剩下四五套估计做不完了，下个月最后还是想搏一把，把听力听完再把阅读练手，考完期末周末花一天是啊金复习，单词第十周过完。虽然六级也挺无所谓的，真正的重心还是得放在期末考试上，学累了就看会英语阅读。</p><p><strong>其他</strong></p><p>算法：待完成，买了个acwing的基础课，什么算法都没学。</p><p>基本上乱七八糟的任务都搞了个七七八八。一些无关轻重的东西，本来是想五一搞完，结果还是拖到了月底，主要是五一也太放松了。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>主要是打球，考试练习差不多了，但是发球还是不稳，没法给别人喂球，还是得练。跑步上个月一口气跑完30km要求之后就没怎么去跑，时间大概是花在了睡懒觉上，晚上睡不着早上起不来，其他时候又很热很热不适合跑步。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>当当云电子书阅读《不可能犯罪：完美嫌疑人》2h，25w字陈研一悬疑小说</p><p>重读江南《龙与少年游》3.5h，江南老贼真的适合写随笔，他笔下的青春离他可能很远，但离我们很近。</p><p>《天阿降临》《长夜余火》7h不知道哪来的时间看小说。一本乌贼一本烟雨江南，睡不着然后听着听着有困意才睡，无任何催眠效果，可能只是大脑觉得有人说话就会分散注意力，不会想东想西，就不会思考孤独。</p><p>漫画《镖人》180话，中午午休都看这些娱乐放松的东西，然后就没时间练习英语阅读了，很困就不会想看。</p><p><strong>写作</strong></p><p>读书报告</p><p>论文翻译</p><p>这学期所有报告。</p><p>今年读书笔记完成进度：2/5。</p><p><strong>观影</strong></p><p>《唐人街探案3》一直听说，都不太想特意去看的电影，在舅舅家打发时间。</p><p>《社交网络》关于Facebook起家之路，马克·扎克伯格的成长之路。这些天才的故事，天生具有神秘的吸引力，只需要一点点艺术加工，就能成为一部好的电影。</p><p>《你丫闭嘴》b站东北话版本，下饭片，好在不收费。</p><p>《模仿游戏》关于人工智能之父艾伦图灵在军情六处破解密码，卷福有点出戏，很喜欢一句话，往往是非凡之人能够成就非凡之事。</p><p>《她Her》关于人类与人工智能之间的孤独爱情，可能有点没头没尾的美国科幻。</p><p>《扫黑：决战》想看很久但最后还是没去电影院，网上有枪版，不如不看。</p><p>6h日剧《xx导演》</p><p>b站动漫，刃牙，打斗番。</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>好像基金这个月涨了小三百，不是很关注，之前一直小亏的状态，但是亏得也不多就没管。</p><p>吃饭开销有点大。买了个200大洋的床帘，改善睡眠质量，很贵但是效果奇好。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>我发现高年级研讨课这种东西可能就是屁用没有，真正的目的只是让你多认识点同专业的同学，但是如果有一个不会调动气氛的老师，就会起不到这个效果。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>早起看日出，调整作息，下半年要做到早起，早起是对自己人生的最大浪漫。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>无，这个月本来还想看两周算法，太懒了，没有动力，所以才买个课逼自己一把。</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于读研。美赛居然可以保研加分，虽然看上去我还是要在各方面继续努力才有可能有机会，不过一开始就是准备自己考研的，所以无所谓，还是跟随自己的本心去做，考研也还是准备着。魏晓老师说本科生没必要花大力气和时间就只为了发论文，发论文实验室把结果做出来几天就写好了，但是写代码和做项目基本功对于本科生来说更重要，什么时候就应该做什么事情，我觉得说的很对。而且之后不管是找工作还是说考研，代码和算法能力都很重要，更不要说以后要自己创业的话，代码必定是绕不开的，开始的时候也只能是自己一个人苦战，所以一定要有提高全栈能力的决心，毕竟创业就是一个人内心爆发全面的战争，除了自己没人能够帮自己。在和老舅交流之后，我读研的想法也是更坚定了一些，但是有些细节的东西反而边迷茫了，思考了一个月，确定了自己之后要在国内读研，不是北京就是上海，高中清北复交的目标还是得实现一下。上水课的时候看了看北大软微和人大高瓴，但是还是不确定自己要去读专硕还是读学硕。我读研的目标还不是很清晰，各个方面的原因都会有，我只知道要为自己将来创业做铺垫，因此平台也很重要。在上海读书这几年或许已经教会了我不少东西，也许也是时候该朝着北京前进了。</p><p>第二件事，关于作息。老实说这个月都没怎么休息好，早起打卡已经一年了，但是自己的状态远不如一年前开始所期望的那样好，感觉很迷茫。晚上睡不着所以早早躺下休息思考，第二天四点起床去看学校里的日出，回想起了自己想要早起的原因，就是那种早起把控时间的感觉，为了早起晚上下课回来后也抓紧时间的感觉，这会让我觉得很充实。因为室友都是很晚睡，老张甚至有的时候两三点才睡，下午他还会睡一两个小时，所以我突发奇想跟他们同步，第一次去了a楼通宵自习室自习，才发现原来十二点的校园居然比早上5点的校园还热闹。但是我发现这种作息还是不适合我，主要是晚上休息不好，早上也起不来，或许一个人外出租房的话会好一点，不然的话还是早睡早起适合我。</p><p>第三件事，关于生活。上海租房实在太贵了，之前室友咽炎晚上咳嗽很严重，就考虑了是不是能出去租房的问题，大半夜三点还没睡着，索性爬起床来，立马打开电脑查附近的租房房价，这一点我都不得不佩服自己的行动力，看完价格我就又躺回去了。虽然网上价格不是很贵但是不确定是否真实，第二天找了一个应该是中介的人咨询，学校附近房价在1500-3000，远一点的地方有更便宜的房源，但和网上标的有出入，价格超过我的预期，顿时感觉到了生活的压力，想想自己直到目前也没有一笔可靠的收入来源就很迷茫。想想目前搬出去的话也不是很有必要，而且也不方便，大三后面考研的话可能会和同学出去合租吧，到时候再说。也有可能是我自己想多了，哪怕自己再怎么吃穿不愁，习惯还是会让我小心翼翼。这种生活压力同样也是一种动力来源吧。突然想到那个人生如书的计划可以改个名字，就先叫“SHU生”好了，暑假要加紧把demo搞出来。</p><p>第四件事，关于良知。我的理解，良质就是佛，是道，是王阳明思想中的“良知”，它是对西方传统哲学中二分对立的反思，或者叫发展。<em>良质是一种思想和陈述的特质，我们不能经由思考的方式了解它，因为要给它定义是一种僵硬而正式的思考过程，良质是无法被界定的。</em><br><em>良质不会单独与主观或客观发生关系，而是只在这两者产生关系的时候才会出现，也就是说在主观和客观交会的那一刹那。</em>“他所提倡的良质就是这里所谓的道，是所有宗教的原创力，不管是东方或是欧美，不管是过去还是现在，是一切的知识，是所有的一切。”哲学就是研究人性最深处的东西，哲学因此也令人着迷。良知就是人的本心，是良知让人能够分辨善恶，所以人性本善和人性本恶都不对，暑假是时候翻出《中国哲学简史》好好思考一下了，可以再写一篇读书笔记。</p><p>第五件事，关于行为。网易云有一个随机生成性格报告，做到了一次很好的宣传。不得不说人的行为有时候真的很神奇，比如这种明明知道是利用了人类心理漏洞的操作只要再加上从众心理以及社会效应就能赶着人往坑里跳，以后要想办法利用这一点，留待思考。</p><p>第六件事，关于计划。今年的年计划做的很粗糙，甚至可以说没怎么认真设计，于是实施起来很困难，再加上每周复盘改成了每月复盘，周期或许有点太长，后面半年改成半月一次复盘。主要是不太愿意再像大一那样花费大量时间在写作各种东西上面了，这也是一个痛点。</p><p>第七件事，关于英语。自己英语口语好像一直都不太行，看b站一个up主和外国人对话的视频，发现好像说出口也没这么难，就在网上找了个omegle 全球随机匿名聊天的网站，遇到了一个非洲老哥，比我大五六岁人也很nice，和他聊得很久，体验还不错。后来还遇到了同样想在这个网站上学口语的中国学生，好像是在国外读书，也有韩国的小姐姐，在一边打工一边准备入学。不过上面女生还是比较少的，而且我好像口语还没好到能和那些母语英语的小姐姐胡吹乱侃。不得不说，这个世界真的很大，英语可以让人见识到更大的世界。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>ASC世界大学生超级计算机竞赛，6月去找沈文枫老师，好像之前开源社区的沈扬华学长15年参加过还拿过奖？得去问问他</p><p><a href="https://zhuanlan.zhihu.com/p/74028717" target="_blank" rel="noopener">OS:mit6.828</a></p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《禅与摩托车维修艺术》</title>
      <link href="/2021/05/14/shan-yu-mo-tuo-che/"/>
      <url>/2021/05/14/shan-yu-mo-tuo-che/</url>
      
        <content type="html"><![CDATA[<h2 id="《Zen-and-the-Art-of-Motorcycle-Maintenance》"><a href="#《Zen-and-the-Art-of-Motorcycle-Maintenance》" class="headerlink" title="《Zen and the Art of Motorcycle Maintenance》"></a>《Zen and the Art of Motorcycle Maintenance》</h2><blockquote><p>罗曼<strong>·</strong>罗兰曾经说过：<strong>这个世界上只有一种真正的英雄主义，就是认识了生活的真相之后依然热爱生活。</strong></p></blockquote><p>这本小说出版于1960年代，作者罗伯特<strong>·</strong>波西格（1928-2017 Robert M. Pirsig），15岁即考入明尼苏达大学，主修化学，并对哲学产生浓厚兴趣，后前往印度学习东方哲学。回国后，在当地大学担任写作课教师。1961年，他被诊断为偏执型精神分裂症和临床忧郁症，被多次送进精神病院，备受折磨，接受过28次电击疗法。1968年出院后，他带着儿子克里斯，进行了一次长途摩托车旅行。他把旅行的感受和思考，写成了这本《禅与摩托车维修艺术》（Zen and the Art of Motorcycle Maintenance）。</p><p>它曾被《时代》周刊评选为1970年代最有影响力的十本书之一，霍金、乔布斯等人对这本书倍加推崇。</p><p>在我看来，这本书的神奇之处在于它集小说、传记、哲学于一体，将风格、氛围完全迥异的两条故事线完美地融合在一起。</p><p>读后细想，感觉父子旅行的部分写得有点像《瓦尔登湖》——本书中也多次提到这部自然主义的文学名著。他们穿过广袤的沙漠和草原，沿途的高山和湖泊、经历过雨中露营，公路上修车……在远离市嚣中寻找内心的纯净和生活的真谛。有趣的是，它对摩托车构造和维修过程的详述，像极了梭罗在瓦尔登湖边挖垄种地，对各种昆虫、种子、生长过程、田间劳作极尽详细的描述，二者有异曲同工之妙。</p><p>而斐德洛的那条线，我觉得很像《月亮与六便士》里的情节，两个主人公的遭遇何其类似，那个为了追求崇高艺术理想的画家，即使穷困潦倒，无人肯定，依旧不为所动，锲而不舍，离群索居在太平洋的一座小岛上，最后终于开悟，达到至高境界，在墙壁上留下最伟大的画作之后，结束了一生。而斐德洛所追求的“良质（quality）”也是他对世界的终极解释。</p><p>何为良质？书中花了大量的篇幅来探讨。</p><p><em>良质是一种思想和陈述的特质，我们不能经由思考的方式了解它，因为要给它定义是一种僵硬而正式的思考过程，良质是无法被界定的。</em><br><em>良质不会单独与主观或客观发生关系，而是只在这两者产生关系的时候才会出现，也就是说在主观和客观交会的那一刹那。</em></p><p>我的理解，良质就是佛，是道，是王阳明思想中的“良知”，它是对西方传统哲学中二分对立的反思，或者叫发展。</p><p>仅此而已，说实话，以我目前所学所知，以及对生活本身的思考深度，对书中关于哲学部分的理解要达到1/3都挺难的，且要建立在多次研读的基础上。好在，它是将旅行中的现实困境和哲学的思考相互关联来写的，对理解会略有帮助。</p><hr><blockquote><p>上面这段转自知乎用户【老土】的介绍，我觉得很有共鸣，而且介绍的到位，也对我对此书的理解有所帮助,下面是我的阅读笔记。</p></blockquote><hr><blockquote><p>《禅与摩托车维修艺术》：“<strong>仓促本身就是最要不得的态度。当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。</strong>”</p><p><strong>“你必须先压制住自己的看法，否则你就无法读下去，它是一个比沟里的死水还要沉闷的东西，你会读到化油器、齿轮、压缩机等等，活塞、火花塞、进气等等，如果从浪漫的角度来看就会觉得非常沉闷、丑陋而且十分笨拙，浪漫的人很少能突破这一点。”</strong></p><p><strong>当你急着奔向未来的时候，说明你已经不喜欢现在了。</strong>——《禅与摩托车维修艺术》</p></blockquote><h3 id="关于哲学"><a href="#关于哲学" class="headerlink" title="关于哲学"></a>关于哲学</h3><p><strong>禅与摩托车维修艺术22节</strong></p><p>“斐德洛一句一句地念，一行一行地念，发现它们正符合他的意思，只不过他表达得很僵化，而《道德经》中却说得非常清楚而准确，这就是他一直想说的，只是此刻却从不同的背景，用不同的语言说出来。他从另一座山谷看到这一座山谷的景象，他所说的不是陌生人所讲的故事，他本身也是山谷的一部分。<br>他所提倡的良质就是这里所谓的道，是所有宗教的原创力，不管是东方或是欧美，不管是过去还是现在，是一切的知识，是所有的一切。”</p><p>在我看来，良质就是佛，是道，是王阳明思想中的“良知”，它是对西方传统哲学中二分对立的反思，或者叫发展。</p><p>在我第一次读冯友兰先生的《中国哲学简史》时，就曾被中国古代哲学中的道家思想所吸引。“道可道，非常道。名可名，非常名。”简简单单十二字，就使斐德洛立刻明白自己要说的，要找的恰恰就在这里。[1]</p><p>从书中提到良质开始一直读到这一段《道德经》，想到了《中国哲学简史》中对“道”的阐述，我才终于恍然大悟，对于“道生一，一生二，二生三，三生万物。”有了更深刻的理解，也总算知道了原来良质早就存在于我的思想之中。</p><p>虽然我没能读完过《传习录》，但结合王阳明知行合一的思想，更加确信书中良质与“良知”有着某种联系，这不是巧合，很可能译者在翻译时也和我一样认为良知和良质其实就是同一件事，因此才作此音译。王阳明说，每个人的心中都有良知，只不过有的人的良知可能被蒙蔽了。“不虑而知为良知”恰恰与斐德洛说的良质不可定义吻合，就好像二者之间的区别其实只不过是同一事物的中文名和英文名一样，名虽不同，实则相同。</p><p>说实话，以我目前所学所知，以及对生活本身的思考深度，对书中关于哲学部分的理解要达到三分之一都挺难的，且要建立在多次研读的基础上。好在，《禅与摩托车维修艺术》是将旅行中的现实困境和哲学的思考相互关联来写的，这对我的理解有所帮助。</p><h3 id="关于科学"><a href="#关于科学" class="headerlink" title="关于科学"></a>关于科学</h3><p><strong>禅与摩托车维修艺术20节</strong></p><p>“发明者的真实工作在于选择这些组合，以便减少无用者，或者设法避免制造它们的麻烦，而指引这选择的规则是极其精致讲究的。几乎不可能精确地描述它们: 它们必须被感觉而非被陈述。……彭加列说，“潜意识自我”注视着一个问题的一大串解决方案，但是只是有趣的可以闯进意识领域内。数学解答是由潜意识自我所选择的，是基于“数学之美”，数字与形式的和谐，以及几何学的优雅。彭加列说：“这是一种所有数学家都知道的真实的美感，可是世俗者对此是如此无知以至于经常想笑。”但是这和谐、这美丽，是它整个的核心。”</p><p>我们从小开始学习数学等自然科学，随着学历的提升，我们会愈发发现数学教学方法有一定的局限性。我们从课堂上学习了各种公理、定理、定律、法则，老师也会教我们各种做题的“小技巧”，但是考试结果出来，个人分数之间的差距还是非常明显。表面上来看原因很简单：即使上了同样的课，从课本上看到了同样的知识，面对一道同样的数学题，有人稍微想一想就有“好”的思路，有人笔头咬烂也无从下手。</p><p>这种现象在数学证明中尤为明显，本书中也提到了这个问题(22节)。我们需要把一些现象“伪装”成公理，然后以此为基础证明其他定理。如果选择的公理是片面的甚至是错误的，那么以此公理得出的其他定理也会是片面甚至错误的。比如欧几里得第五公设就是片面的，得出的几何学局限在平面。当放宽第五公设的约束时，我们可以得到全新的几何学——黎曼几何学。当数学家或学生做数学证明的时候，他们面对的是无数条可行的路线，在开始时他们无法准确知道哪一条路是“好”的，哪一条路会引向死胡同。优秀的数学家和学生往往可以精准的感知出可行的道路，选择“好”的公理，找到“好”的证明路线。这种对“好”的感知，也就是感受数学之美。</p><p>良质不仅存在于理科之中，工科的发展同样也需要良质。就比如我们计算机学科，哪些算法是好的，哪些设计是好的，其实一开始都没有人知道。冯·诺依曼之前仍有其他的计算机架构，今天计算机的组成也在不断地更新换代，根据摩尔定律每隔18个月硬件存储容量就会翻一番，而今天摩尔定律正在逐渐失效。就好像所有学科一样，计算机学科自身也在不断发展，而推动它发展的真是我们书中说的良质，或者说是美感。</p><h3 id="关于旅行与读书"><a href="#关于旅行与读书" class="headerlink" title="关于旅行与读书"></a>关于旅行与读书</h3><p><strong>禅与摩托车维修艺术4节</strong></p><p>“我想你可以称之为个性，每一部摩托车都有它自己的个性，也可称之为你对这一部车子所有直觉的总和。这种个性常会改变，多会变得更糟，但常常也会变得出人意料地好，培养这种车子的个性正是维修保养的真正目的。新的车子就好像美丽的陌生人，按照他们所受的待遇，要不就很快会退化成别扭的人或是跛子，要不就变成健康、脾气好、长久的朋友，而我这部车虽然遭受过那些所谓师傅的毒手，但是似乎已经完全修复了，而且愈来愈不需要修理。”</p><pre><code>其实作者所说的摩托车就好比人生，而每个人人生中两个最重要的组成部分——旅行和读书——也都有它们独特的个性。</code></pre><p>古语云：“读万卷书不如行万里路。”换成今天的话来说就是肉体与灵魂总有一个要在路上。每一个人都有它自己的个性，每一本书也有它自己的个性，而不同的人读不同的书，就是在陪着作者进行不同的旅行。同一个人从同一本书中读出来的内容也会是常读常新的，旧的思考会被新的思考所代替，可是读者仍然会继续重温这同一本书。就好像旅人的旅行接触到了很多，也失去了很多，但还是在继续，就好像电影的结尾，经历种种，还是会背上背包，骑上摩托车。毕竟还有没有去过的地方，毕竟还有那么多耗尽一生想看也看不完的书，有些地方不一定会再回去，但还有更多想去的地方，所以能出发的时候还是要出发。这也许就是为什么波西格愿意一直不停地走，并且能够耐心维修摩托车的原因之一吧。</p><p>要我说，书上文章是案头之山水，天下山水是地上之文章，都可以快人眼目，陶冶情操，尤其后者，白看不收钱，不看白不看。</p><h3 id="关于何为良质"><a href="#关于何为良质" class="headerlink" title="关于何为良质"></a>关于何为良质</h3><p>何为良质？我认为这是书中最重要的一个问题，而且书中也花了大量的篇幅来探讨。</p><p>“良质是一种思想和陈述的特质，我们不能经由思考的方式了解它，因为下定义是一种严格而规范的思考过程，所以良质无法被定义。”[6]</p><p>这是作者给出的回答，每位不同背景，不同文化，使用不同语言的读者可能都会得到不同的答案，然而这正是良质存在的意义，对于我而言，良质是存在于万物之中的“道”，也是存在于人心中的“良知”，除此之外，无法用更多的言语去给良质下定义。</p><p>可以这么说，良质就是良知，是是非之心，是每个人先天的判断力和道德感。它包含良心，又不止于良心。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这本小说出版于1960年代，作者罗伯特·波西格（1928-2017 Robert M. Pirsig），15岁即考入明尼苏达大学，主修化学，并对哲学产生浓厚兴趣，后前往印度学习东方哲学。回国后，在当地大学担任写作课教师。1961年，他被诊断为偏执型精神分裂症和临床忧郁症，被多次送进精神病院，备受折磨，接受过28次电击疗法。1968年出院后，他带着儿子克里斯，进行了一次长途摩托车旅行。他把旅行的感受和思考，写成了这本《禅与摩托车维修艺术》（Zen and the Art of Motorcycle Maintenance）。</p><p>它曾被《时代》周刊评选为1970年代最有影响力的十本书之一，霍金、乔布斯等人对这本书倍加推崇。</p><p>在我看来，这本书的神奇之处在于它集小说、传记、哲学于一体，将两条不同的故事线完美地融合在一起。</p><p>读后细想，感觉父子旅行的部分写得有点像《瓦尔登湖》——本书中也多次提到这部自然主义的文学名著。他们穿过广袤的沙漠和草原，沿途的高山和湖泊、经历过雨中露营，公路上修车……在远离城市喧嚣中寻找内心的纯净和生活的真谛。有趣的是，它对摩托车构造和维修过程的详述，像极了梭罗在瓦尔登湖边种地，对各种昆虫、种子、生长过程、田间劳作极尽详细的描述，二者有异曲同工之妙。</p><p>而斐德洛的那条线，我觉得很像《月亮与六便士》里的情节，两个主人公的遭遇何其类似，那个为了追求崇高艺术理想的画家，即使穷困潦倒，无人肯定，依旧不为所动，锲而不舍，离群索居在太平洋的一座小岛上，最后终于开悟，达到至高境界，在墙壁上留下最伟大的画作之后，结束了一生。而斐德洛所追求的“良质（quality）”也是他对世界的终极解释。</p><hr><p><strong>参考文献：</strong>（宋体加粗小四）</p><p>顺序要根据引用先后顺序排列，序码用[1][2]。格式如：</p><p>[1] 冯友兰.《中国哲学简史》[M]. 北京: 北京大学出版社，2010:1-209</p><p>[2] 吕峥. 《明朝一哥王阳明》[M]. 北京：中国友谊出版公司，2020：156-189</p><p>[3] 罗伯特·M·波西格. 《万里任禅游》[M]. 重庆: 重庆出版社，2006: 146</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《穷查理宝典》</title>
      <link href="/2021/05/05/poorchalie/"/>
      <url>/2021/05/05/poorchalie/</url>
      
        <content type="html"><![CDATA[<h2 id="《Poor-Charlie’s-Almanack》"><a href="#《Poor-Charlie’s-Almanack》" class="headerlink" title="《Poor Charlie’s Almanack》"></a>《Poor Charlie’s Almanack》</h2><p>![](C:/Users/ASUS/Documents/Tencent Files/849095098/Image/C2C/CCC959C92434111CDA1F65DBFB4BF837.jpg)</p><p>我第一次听说查理·芒格是在巴菲特的传记《滚雪球》里，于是两个年轻人就像命中注定一样相见，此后便开启了一段传奇。</p><p>最初，两人只是互相分享好的投资机会，直到蓝筹印花公司的投资奠定了二人的合作基础。这是一家经营折扣优惠券的公司，当时该公司已经过了发展黄金期，再加上管理层的保守，所以股价很低，而且由于公司内部改组导致当时的股东不能完全的控制公司。芒格关注到了蓝筹印花公司账面上充沛的现金，便推荐巴菲特极力关注该公司。后来，他们买入了大量的股票，直接进入了蓝筹印花公司的董事会，并开始为公司的浮存金寻找优良的投资渠道，开展了一系列投资并购。最终，他们大获成功，不仅赚到了不菲的收益而且逐步建立起了正向的现金循环。</p><p>如果说巴菲特像一团火，疾驰着卷席一切他所能得到的资源，那芒格就平静的像一汪水，无声无息，但一旦奔腾起来，就是无可阻挡的山洪。</p><p>而且就像巴菲特说的那样，芒格是个聪明人，透过《穷查理宝典》我也得以窥见他的智慧和思考。</p><p>特别是他谈到了多元思维模型的一章，话轻描淡的一句话都是一本书的内容。</p><p>举一个书中的例子：“如果你们懂得基本的心理学原理，就能理解人们做不到这一点的原因，其实很简单：大脑的神经系统是经过长期的基因和文化进化而来的。它并不是费马—帕斯卡的系统。”</p><p>看完这句话很有可能一头雾水，因为你还需要自行去理解心理学原理、大脑的神经系统、费马帕斯卡系统等。</p><p>这句话提及的3个原理，你都能找到相关的书籍去进行进一步理解。</p><p>这大概也是很多人看了这本书之后会觉得，看不懂说什么，也不看懂他的厉害之处。但就是莫名觉得很厉害的样子。</p><p>再举一个类似的例子就是《富爸爸穷爸爸》这本书，想要掌握这本书的精髓，必须要额外花时间理解会计、投资、法律、营销。</p><p>但是这些知识属于这本书的拓展，你不去补充，读这本书实际用途几乎不大，只能停留在思维上的一些改变，虽然这对第一次接触理财的我来说意义同样重大。</p><p>还有一处，书中写到：“巴菲特拥有许多优势，其中之一就是他能够自动地根据决策树理论和基本的排列组合原理来思考问题。而且它也并不难理解。”</p><p>但你必须对会计有足够的理解，才能明白它的局限——因为会计虽然是起点，但它只是一种粗略的估算。<br>而且其中还谈到了决策树理论、排列组合原理、会计等日常可能不太会接触到的知识面。</p><p>以上两句话信息量已经很大了，更可怕的是，这本书是由11个演讲集合而成，这也只是当中一讲的一小部分而已。</p><p>这本书更有说服力的地方在于，作者本人已经96岁了，而且特别有钱，他没有夹杂任何私人利益在书中，纯粹地把毕生所学分享出来而已，我们这个时代，又老又有钱又有智慧又低调的人，真心不多。</p><p>顺便一提，查理芒格本人掌握了100多种思维模型，书中提到了十多个比较重要的。</p><p>在具体谈思维模型之前，我觉得更加重要的是，要学会运用在生活中，直到发生某件事情后，脑海中能够瞬间想到这些思维模型，并加以运用，这样才会有用。</p><p>很多思维模型或多或少，我们从小的教育，或者经验的总结都顺便用过，但会比较模糊，造成你用起来不够快，还有信心不足。</p><p>比如物理学的临界质量概念。高中物理3-5的课本里我们就已经学过这个概念了，只是当时是为了应付高考，从没有想过还能用在生活中的哪些地方。</p><p>某些事物的改变并不是慢慢改变的，而是一旦达到一个临界点，他就会发生质变，就像是水到100度才会变成水蒸气一样。</p><p>这个理论有点像“一万小时定律”，一般人想要改变自己在某一方面取得成功，起码需要1万个小时的时间去训练。</p><p>生活中很多例子都是如此，例如学英语，前期学了很长时间都改变不大，但突然有一天就突然开窍了，对英语的掌握能力大大提升。</p><p>原本每天写作特别困难，我大一的时候就坚持一个月早起写作，想到什么写什么，突然有段日子发现，写作变得非常容易，一上来就起码能写个上千字，老师布置的小论文都是几个早上或者一个下午就能搞定，而且写作还成为了我思考的工具，通过写的方式，不断把学到的内容进行深入理解。</p><p>李笑来《把时间当作朋友》中也提出类似的概念「七年就是一辈子」，我们在7年中不断对一件事情持续努力，往往会有比较惊人的成绩。</p><p>这个理论和有一句话特别相似：人总是高估自己一年能做的事情，低估10年能做的事情。</p><p>我们一定要坚持做好一件事情，等待跳跃性的改变到来。</p><p>仔细想想我和芒格有着不少的共同爱好，或者说我向他学习到了不少东西，比如我们都是个人传记爱好者。从高中开始我就喜欢上了各种形形色色的人物传记。</p><p>比如我的精神导师和查理·芒格的偶像一样都是本杰明.富兰克林，我也是因为读过《富兰克林自传》所以才崇拜富兰克林并把他当为自己的精神楷模的。</p><p>而他不仅钦佩与崇拜这位伟大的人物，并且还以富兰克林为人生的标杆来指导自己的行为。富兰克林的职业生涯横跨多个领域，主张思考不同学科之间的联系以培养思维方式。查理·芒格也认为，投资者应该糅合来自各个传统学科的分析工具、方法公式，这些学科包括：历史、心理、生理、数学、工程、生物、物理、化学、统计、经济等。其理论基础是：几乎每个系统都受到多种因素的影响，所以若要理解这样的系统，就必须熟练地运用来自不同学科的多元思维方式，这样才能激发出lollapalooza。</p><p>关于查理·芒格我能写的实在太多太多，甚至根本停不下来，但是可以用查理最经典的一句话来总结——“我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的——没有，一个都没有。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。”</p><p>查理把大量时间都花费在了心无旁骛的阅读上，这大概就是查理卓越思维能力的来源，这也正是我从书中学到的最重要的一点。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4月复盘</title>
      <link href="/2021/04/30/2021-4/"/>
      <url>/2021/04/30/2021-4/</url>
      
        <content type="html"><![CDATA[<h1 id="四月复盘（4-30）"><a href="#四月复盘（4-30）" class="headerlink" title="四月复盘（4.30）"></a>四月复盘（4.30）</h1><h2 id="本月关键词：时间赛跑"><a href="#本月关键词：时间赛跑" class="headerlink" title="本月关键词：时间赛跑"></a>本月关键词：时间赛跑</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>我要和生活再死磕几年。</strong><br><strong>要么我就毁灭，要么我就注定铸就辉煌。</strong><br><strong>如果有一天，你发现我在平庸面前低了头，</strong><br><strong>请向我开炮。</strong><br>——凯鲁亚克《在路上》</p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>学习</strong></p><ul><li>英语</li></ul><p>大英赛C组初赛</p><p>备考六级：翻译20+，听力*6，作文还没开始，cloze有点难，阅读刷完无压力，四套真题，小阅读不能着急，时间够阅读没问题，听力认真看一遍能降低错误率，现在大概是在错4个左右。</p><p>下个月翻译要计时。真题阅读好好做，还剩四十天，再过三周考口语。</p><ul><li>数学</li></ul><p>复习线性代数，如果开卷考试的话矩阵也不难。信息论学得都能题目还得自己做一遍，反正好玩。</p><ul><li>CS</li></ul><p><a href="https://henryavery.cn/2021/04/17/docker2021/">Docker</a></p><p>wechaty聊天机器人，搞半天，认识到读文档的重要性，以及搞清一些基础原理才能实现代码跑起来，否则就是抓瞎。</p><p>错过了一次蓝桥杯，300块没时间准备，觉得这些比赛都好贵</p><p><strong>比赛</strong></p><p>美赛F奖</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7TZ3TR7S%5DNYLXM1O~~LGQ%0.png" alt="lucky"></p><p>美赛复盘还没写。。。。</p><p><strong>项目</strong></p><p>ocr文本抽取标题，大数据project。</p><p>创新创业项目无进展。找到一篇naacl2021相关的论文。逻辑推理问题模型。</p><p>标了十多个小时数据，一个周末直接没了，本来的计划冗余全用在这里了。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>40+km</p><p>考虑是不是能参加一次半马。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>《禅与摩托车维修艺术》读书报告待上传</p><p>《韦尔奇自传》英文版，50/557</p><p><strong>电影</strong></p><p>《超脱》一部国外关于老师的电影。男演员还演过《钢琴师》。</p><p>《流浪猫鲍勃》关于人的自救，人和猫的温馨故事。</p><p>《窃听风暴》完全没看懂。</p><p>《除暴》想看的，比较下饭。</p><p>一周一部电影，还算比较合适了。</p><p><strong>写作</strong></p><p>人工智能与认知科学1956-1970简史ppt</p><p>人工智能研讨ppt</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>基金不亏了，虽然没什么用。先存着，打算暑假换设备了。</p><p>投资150买衣服，150买书。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>每两周出去开一次小灶。</p><p>搜集出国留学以及读研相关信息。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2021-4.jpg" alt="2021-4"></p><p>每天睡7个小时ok，有三分之一赖床不应该。娱乐可以尝试缩减到15h，每天四小时的日常过久，午休正常，时间控制在20-30min。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>Docker学习</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于荣誉。</p><p>第二件事，关于攒劲。</p><p>第三件事，关于跑步。</p><p>第四件事，关于准备。</p><p>第五件事，关于选择。</p><p>第六件事，关于放假。</p><p>第七件事，关于拖拉。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>神经网络学习</p><p>算法学习</p><p>Flutter学习</p><p>把积压一大堆杂七杂八的作业消掉。</p><p><strong>作业</strong></p><p>数据结构：小组项目三，hash查找 </p><p><strong>ppt</strong></p><p><del>人工智能进展nlp研讨ppt</del></p><p>数据结构PPT</p><p><strong>项目报告Project</strong></p><p>大数据20p</p><p><strong>论文paper</strong></p><p><del>大数据10p</del></p><p><strong>阅读报告</strong></p><p><del>《穷查理》2k</del></p><p>《禅与摩托车维修艺术》3k</p><p><strong>调研报告</strong></p><p>投资与理财调查报告</p><p>思修实践</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker2021</title>
      <link href="/2021/04/17/docker2021/"/>
      <url>/2021/04/17/docker2021/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要学习Docker"><a href="#为什么要学习Docker" class="headerlink" title="为什么要学习Docker?"></a>为什么要学习Docker?</h2><p>为了解决环境配置问题</p><h2 id="怎样学习使用Docker"><a href="#怎样学习使用Docker" class="headerlink" title="怎样学习使用Docker?"></a>怎样学习使用Docker?</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网安装</a></p><p>Docker CE 的安装请参考官方文档。<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows版本</a></p><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><blockquote><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><p>——阮一峰</p></blockquote><p>就跟git一样，是为了方便我们程序员的powerful tools 之一。</p><hr><h2 id="Datawhale的组队学Docker"><a href="#Datawhale的组队学Docker" class="headerlink" title="Datawhale的组队学Docker"></a>Datawhale的组队学Docker</h2><h3 id="启航"><a href="#启航" class="headerlink" title="启航"></a>启航</h3><blockquote><p>通过本次docker的组队学习，我们希望你能学到以下几个方面的能力：</p></blockquote><ul><li>了解什么是docker</li><li>docker镜像是怎么构建的</li><li>如何运行一个docker容器</li><li>docker之间的网络通信是怎么样的</li><li>docker中的数据如何做持久化存储</li><li>如何通过docker compose管理自己的项目</li><li>如何将自己的个人项目打造成容器化部署的形式</li></ul><h3 id="简介与安装"><a href="#简介与安装" class="headerlink" title="简介与安装"></a>简介与安装</h3><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言 (opens new window)</a>进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup (opens new window)</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace (opens new window)</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">OverlayFS (opens new window)</a>类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS (opens new window)</a>等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术 (opens new window)</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC (opens new window)</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer (opens new window)</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC (opens new window)</a>和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd (opens new window)</a>。</p><p>比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><strong>虚拟机</strong>在宿主机(host)中的OS上面是hypervisor(hypervisor)，然后依次建立虚拟机，虚拟化的仓库，然后安装程序。但是对于<strong>Docker</strong>来说，在宿主机(host)中的OS上面是Docker Engine，然后直接在Doker Engine安装应用。</p><h3 id="Docker三大基本概念"><a href="#Docker三大基本概念" class="headerlink" title="Docker三大基本概念"></a>Docker三大基本概念</h3><ul><li><p><strong>镜像</strong>（<code>Image</code>）</p></li><li><p><strong>容器</strong>（<code>Container</code>）</p></li><li><p><strong>仓库</strong>（<code>Repository</code>）</p></li></ul><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h5 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h5><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS (opens new window)</a>的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的<strong>实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是<strong>进程</strong>，但与直接在宿主host执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间 (opens new window)</a>。</p><blockquote><p><strong>名称空间</strong>是<a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="noopener">Linux 内核</a>的一个特征，它划分了内核资源，使一组<a href="https://en.wikipedia.org/wiki/Process_(computing)" target="_blank" rel="noopener">过程</a>看到一组资源，而另一组进程看到一组不同的资源。该功能的工作原理是为一组资源和流程设置相同的命名空间，但这些命名空间是指不同的资源。资源可能存在于多个空间中。此类资源示例包括流程 ID、主机名、用户 ID、文件名称以及与网络访问相关的一些名称以及<a href="https://en.wikipedia.org/wiki/Interprocess_communication" target="_blank" rel="noopener">处理间通信</a>。</p></blockquote><p>因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://vuepress.mirror.docker-practice.com/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者 <a href="https://vuepress.mirror.docker-practice.com/data_management/bind-mounts.html" target="_blank" rel="noopener">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h4 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://vuepress.mirror.docker-practice.com/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h5 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h5><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器 (opens new window)</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器 (opens new window)</a>等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://vuepress.mirror.docker-practice.com/install/mirror.html" target="_blank" rel="noopener">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务 (opens new window)</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场 (opens new window)</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云镜像库 (opens new window)</a>等。</p><h5 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h5><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry (opens new window)</a>镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://vuepress.mirror.docker-practice.com/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><blockquote><p>开始学习前，我C盘已经不够10个G了，不知道能不能撑住。所以……</p><p>虚拟机的默认存储位置是C:\Users\Administrator.docker\machine\machines ，后期docke镜像文件会不断增加，为了给系统盘减负，最好将磁盘移动到其他位置。</p><p>ps:不想开虚拟机所以就在Windows上折腾了，能hello-world很开心</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210414201843575.png" alt="hello"></p><h4 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p><strong>获取镜像</strong></p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到</p><p>比如：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker pull ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>列出镜像</strong></p><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><p><strong>删除本地镜像</strong></p><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker image rm [选项] <镜像1> [<镜像2> ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Untagged 和 Deleted</strong></p><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210414202719907.png" alt="我这就是"></p><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><pre><code>$ docker image rm $(docker image ls -q redis)</code></pre><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><pre><code>$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></pre><blockquote><p>然而我并没有用Linux，而且也没看懂Linux命令</p></blockquote><p><strong>Dockerfile制作镜像</strong></p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><pre><code>$ mkdir mynginx$ cd mynginx$ touch Dockerfile</code></pre><blockquote><p>我打开了vm打算装个乌班图重新开始。或者再在Windows上尝试一下</p></blockquote><p><a href="https://blog.csdn.net/zzq060143/article/details/91050272?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">Windows上docker使用教程</a></p><blockquote><p>touch好像是Linux命令，我直接在mynginx创建一个文件然后记事本打开输入。这里你可以换成echo test&gt; Dockerfile，就会生成Dockerfile 文件。</p></blockquote><p>其内容为：</p><pre><code>FROM nginxRUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><p><strong>FROM 指定基础镜像</strong></p><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><pre><code>FROM scratch...</code></pre><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><p><strong>RUN 执行命令</strong></p><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><pre><code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><pre><code>FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install</code></pre><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><pre><code>FROM debian:stretchRUN set -x; buildDeps=&#39;gcc libc6-dev make wget&#39; \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \    &amp;&amp; mkdir -p /usr/src/redis \    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \    &amp;&amp; make -C /usr/src/redis \    &amp;&amp; make -C /usr/src/redis install \    &amp;&amp; rm -rf /var/lib/apt/lists/* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r /usr/src/redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><blockquote><p>Linux命令也能先看看，继续</p></blockquote><p><strong>构建镜像</strong></p><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><pre><code>$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kBStep 1 : FROM nginx ---&gt; e43d811ce2f4Step 2 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html ---&gt; Running in 9cdc27646c7b ---&gt; 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c</code></pre><blockquote><p>我在这遇到个小问题，ERROR [internal] load metadata for docker.io/library/nginx:latest，怀疑是挂了梯子的原因，关了代理之后就正常了。</p></blockquote><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><blockquote><p>wait for 4 minutes</p></blockquote><p><strong>镜像构建上下文（Context）</strong></p><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><pre><code>COPY ./package.json /app/</code></pre><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><pre><code>$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB...</code></pre><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><blockquote><p>更多关于Dockerfile的内容可以移步：<a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/" target="_blank" rel="noopener">Dockerfile详解</a>，不过更多的内容还是大家在实践中逐渐熟悉，这样才能更了解里面的含义。</p></blockquote><p><strong>跨平台构建镜像</strong></p><p>在日常的工作中，我们常常有需求将一个程序运行在不同架构CPU的设备上，尤其在嵌入式领域，我们常常接触的各种开发板、路由器往往都是使用ARM架构的芯片，而我们日常开发的设备都是在x86平台。我们在x86平台写的程序需要运行在使用ARM芯片的开发板上，这时候就需要跨CPU构建程序。</p><p>总的来说跨平台构建程序有以下几种方式。</p><ul><li>直接在目标硬件编译 这是最直接的方法</li><li>使用交叉编译器 交叉编译器是专门为在给定的系统平台上运行而设计的编译器，作用是可以在一种CPU架构上编译出另一个CPU架构的可执行文件。最普遍的例子，开发人员开发安卓应用的时候几乎都在X86的平台上开发构建，但安卓应用很明显是ARM架构的，这其中就是交叉编译器在起作用</li><li>模拟目标硬件 模拟目标硬件最常见的开源模拟器是QEMU，QEMU是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道</li><li>通过binfmt_misc模拟目标硬件的用户空间 QEMU 除了可以模拟完整的操作系统之外，还有另外一种模式叫用户态模式（User mod）。该模式下 QEMU 将通过 binfmt_misc 在 Linux 内核中注册一个二进制转换处理程序，并在程序运行时动态翻译二进制文件，根据需要将系统调用从目标 CPU 架构转换为当前系统的 CPU 架构。最终的效果看起来就像在本地运行目标 CPU 架构的二进制文件。 通过 QEMU 的用户态模式，我们可以创建轻量级的虚拟机（chroot 或容器），然后在虚拟机系统中编译程序，和本地编译一样简单轻松。</li></ul><blockquote><p>好像目前我没法实操</p></blockquote><p><strong>构建跨架构的Docker镜像</strong></p><p>先跳过了</p><p><strong>镜像存储位置</strong></p><p>在操作系统中(Linux)，默认情况下 Docker 容器的存放位置在 /var/lib/docker 目录下面，可以通过命令查看</p><pre><code>docker info | grep &quot;Docker Root Dir&quot;</code></pre><p>我们使用docker pull 下载的镜像，都会存在这个目录下，当下载的镜像过多，或容器运行过程中产生大量数据导致存储容量不足时，可以修改镜像储存的位置，有以下几种方式修改docker默认储存位置</p><p><strong>使用软链接</strong></p><ul><li>首先停止docker 进程</li><li>然后进行链接</li></ul><pre><code>#stop$ sudo systemctl stop docker#move$ mv /var/lib/docker /data/docker#ln$ ln -sf /data/docker /var/lib/docker</code></pre><ul><li>然后移动整个 /var/lib/docker 目录到空间比较大的目的路径。这时候启动 Docker 时发现存储目录依旧是 /var/lib/docker 目录，但是实际上是存储在数据盘 /data/docker 上了。</li></ul><p><strong>指定容器启动参数</strong></p><ul><li>在配置文件中指定容器启动的参数 –graph=/var/lib/docker 来指定镜像和容器存放路径。Docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致。在 Ubuntu 中的位置是 /etc/default/docker 文件，在 CentOS 中的位置是 /etc/sysconfig/docker 文件。</li></ul><pre><code>#Cent 7# 更改储存位置$ vi /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --graph /new-path/dockersudo systemctl restart docker </code></pre><ul><li>如果 Docker 的版本是 1.12 或以上的，可以修改或新建 daemon.json 文件。修改后会立即生效，不需重启 Docker 服务。</li></ul><pre><code># 修改配置文件$ vim /etc/docker/daemon.json{    &quot;registry-mirrors&quot;:        [&quot;http://7e61f7f9.m.daocloud.io&quot;],    &quot;graph&quot;: &quot;/new-path/docker&quot;}</code></pre><p><strong>System 下创建配置文件</strong></p><ul><li>在 /etc/systemd/system/docker.service.d 目录下创建一个 Drop-In 文件 docker.conf，默认 docker.service.d 文件夹不存在，必须先创建它。创建 Drop-In 文件的原因，是我们希望 Docker服务使用 docker.conf 文件中提到的特定参数，将默认服务所使用的位于 /lib/systemd/system/docker.service 文件中的参数进行覆盖。</li></ul><pre><code># 定义新的存储位置$ sudo vi /etc/systemd/system/docker.service.d/docker.conf[Service]ExecStart=/usr/bin/dockerd --graph=&quot;/data/docker&quot; --storage-driver=devicemapper# 重启$ sudo systemctl start docker</code></pre><ul><li>/data/docker 就是新的存储位置，而 devicemapper 是当前 Docker 所使用的存储驱动。如果你的存储驱动有所不同，请输入之前第一步查看并记下的值。现在，你可以重新加载服务守护程序，并启动 Docker 服务了，这将改变新的镜像和容器的存储位置。为了确认一切顺利，运行 docker info 命令检查 Docker 的根目录。</li></ul><blockquote><p>因为docker pull 太慢所以待到图书馆关门，保安叔叔来赶人</p></blockquote><h4 id="Docker容器-1"><a href="#Docker容器-1" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>容器是 Docker 又一核心概念。简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。</p><p>本节将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><p><strong>新建并启动容器</strong></p><p>所需要的命令主要为 <code>docker run</code>。其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><pre class="line-numbers language-c++"><code class="language-c++">docker run [-i -t -d -p -P -c] [--name]:在容器内运行一个应用程序 -t :在新容器内指定一个伪终端或终端 -i:允许你对容器内的标准输入进行交互 -d：以进程方式运行容器，让容器在后台运行 -p：设置端口 -P：将容器内部使用的网络端口映射到我们使用的主机，就是让我们访问我们使用的主机就等同于访问到容器内部 -c：command,后面接命令 --name container name：指定容器名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从registry下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>启动已终止的容器</strong></p><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><p><strong>停止容器</strong></p><p>docker stop可以停止运行的容器。理解：容器在docker host中实际上是一个进程，docker stop命令本质上是向该进程发送一个SIGTERM信号。如果想要快速停止容器，可使用docker kill命令，其作用是向容器进程发送SIGKILL信号。</p><p><strong>重启容器</strong></p><p>对于已经处于停止状态的容器，可以通过docker start重新启动。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker start bdf593fda8bebdf593fda8be<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>docker start会保留容器的第一次启动时的所有参数。docker restart可以重启容器，其作用就是依次执行docker stop和docker start。容器可能因某种错误而停止运行。对于服务类容器，通常希望它能够自动重启。启动容器时设置–restart就可以达到效果。–restart=always意味着无论容器因何种原因退出（包括正常退出），都立即重启；</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -it ubuntu:15.10 /bin/echo --restart=always -d "Hello world"--restart=always -d Hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>后台运行容器</strong></p><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。下面举两个例子来说明一下。</p><p><strong>如果不使用 <code>-d</code> 参数运行容器。</strong></p><pre><code>$ docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;hello worldhello worldhello worldhello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p><strong>如果使用了 <code>-d</code> 参数运行容器。</strong></p><pre><code>$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关，只要命令不结束，容器也就不会退出。上述命令中，while语句不会让bash退出，因此该容器就不会退出。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container lsCONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#39;while tr  2 minutes ago  Up 1 minute        agitated_wright</code></pre><p>使用-d启动容器后，会回到host终端；此时如果想要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进入容器</strong></p><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台，启动完容器之后会停在host端；某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><p><code>attach</code> 命令</p><p>下面示例如何使用 <code>docker attach</code> 命令。</p><pre><code>$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中exit回到host端，会导致容器的停止。</p><p><code>exec</code> 命令</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bashlsbinbootdev...$ docker exec -it 69d1 bashroot@69d137adef7a:/#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果从这个 stdin 中 exit回到host端，但不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p><strong>attach和exec的区别</strong></p><p>attach和exec的区别： （1）attach直接进入容器启动命令的终端，不会启动新的进程； （2）exec则是在容器中打开新的终端，并且可以启动新的进程； （3）如果想直接在终端中查看命令的输出，用attach，其他情况使用exec；</p><p><strong>暂停容器</strong></p><p>有时我们只是希望让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者docker host需要使用CPU，可以执行:docker pause CONTAINER [CONTAINER…]</p><p><strong>删除容器</strong></p><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code>$ docker container rm trusting_newtontrusting_newton</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><strong>清理所有处于终止状态的容器</strong></p><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre><code>$ docker container prune</code></pre><p>####批量删除所有已经退出的容器</p><pre><code>$ docker rm -v $(docker ps -aq -f status=exited)</code></pre><p><strong>导出容器</strong></p><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e > ubuntu.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样将导出容器快照到本地文件。</p><p><strong>导入容器</strong></p><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>cmd试一下用type替代，不行，直接导入，成功</p></blockquote><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker import http://example.com/exampleimage.tgz example/imagerepo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h3 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h3><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS (UNIX File System) ，可以提供很多有用的特性：</p><blockquote><p>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><p><strong>创建数据卷</strong></p><pre><code>$ docker volume create datawhale</code></pre><p>查看所有的数据卷</p><pre><code>$ docker volume ls</code></pre><p>在主机里使用以下命令可以查看指定数据卷的信息</p><pre><code>$ docker volume inspect datawhale</code></pre><p><strong>启动一个挂载数据卷的容器</strong></p><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将数据卷挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个数据卷到容器的 <code>/usr/share/nginx/html</code> 目录。</p><pre><code>$ docker run -d -P \    --name web \    --mount source=datawhale,target=/usr/share/nginx/html \    nginx:alpine</code></pre><blockquote><p>–-mount参数说明：<br>source ：数据卷<br>target ：是容器内文件系统挂载点</p></blockquote><blockquote><p>注意，可以不需要提前创建好数据卷，直接在运行容器的时候mount 这时如果不存在指定的数据卷，docker会自动创建，自动生成。</p></blockquote><p><strong>查看数据卷的具体信息</strong></p><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><pre><code>$ docker inspect web</code></pre><p><strong>删除数据卷</strong></p><pre><code>$ docker volume rm datawhale  #datawhale为卷名</code></pre><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>$ docker volume prune</code></pre><h4 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h4><p><strong>挂载一个主机目录作为数据卷</strong></p><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -d -P \    --name web \    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \    nginx:alpine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><blockquote><p>注意： 如果挂载的目录不存在，创建容器时，docker 不会自动创建，此时会报错</p></blockquote><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -d -P \    --name web \    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \    nginx:alpine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>源路径不存在，source是本地路径，然后前面启动了一个叫web的容器了，不能再启动</p></blockquote><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><pre class="line-numbers language-cmd"><code class="language-cmd">/usr/share/nginx/html # touch new.txttouch: new.txt: Read-only file system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>查看数据卷的具体信息</strong></p><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><pre><code>$ docker inspect web</code></pre><p><strong>挂载一个本地主机文件作为数据卷</strong></p><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run --rm -it \   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \   ubuntu:18.04 \   bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><h4 id="Docker-基础网络介绍"><a href="#Docker-基础网络介绍" class="headerlink" title="Docker 基础网络介绍"></a>Docker 基础网络介绍</h4><h5 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a><strong>外部访问容器</strong></h5><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过<code>-P</code>或<code>-p</code>参数来指定端口映射。</p><p>当使用<code>-P</code>标记时，<code>Docker</code>会随机映射一个端口到内部容器开放的网络端口。 使用<code>docker container ls</code>可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><p>同样的，可以通过<code>docker logs</code>命令来查看访问记录。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker logs [container name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cmd"><code class="language-cmd">D:\mynginx>docker logs 64a2/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d//docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh/docker-entrypoint.sh: Configuration complete; ready for start up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210417091738256.png" alt="成功"></p><p><code>-p</code>则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>.</p><p><strong>映射所有接口地址</strong></p><p>使用<code>hostPort:containerPort</code>格式本地的 80 端口映射到容器的 80 端口，可以执行</p><pre><code>$ docker run -d -p 80:80 nginx:alpine</code></pre><p>此时默认会绑定本地所有接口上的所有地址。</p><p><strong>映射到指定地址的指定端口</strong></p><p>可以使用<code>ip:hostPort:containerPort</code>格式指定映射使用一个特定地址，比如<code>localhost</code>地址127.0.0.1</p><pre><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code></pre><p><strong>映射到指定地址的任意端口</strong></p><p>使用<code>ip::containerPort</code>绑定<code>localhost</code>的任意端口到容器的80端口，本地主机会自动分配一个端口。</p><pre><code>$ docker run -d -p 127.0.0.1::80 nginx:alpine</code></pre><p>还可以使用<code>udp</code>标记来指定<code>udp</code>端口</p><pre><code>$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</code></pre><p><strong>查看映射端口配置</strong></p><p>使用<code>docker port</code>来查看当前映射的端口配置，也可以查看到绑定的地址</p><pre><code>$ docker port fa 800.0.0.0:32768</code></pre><p><strong>注意：</strong> 容器有自己的内部网络和 ip 地址（使用<code>docker inspect</code>查看，<code>Docker</code>还可以有一个可变的网络配置。） <code>-p</code>标记可以多次使用来绑定多个端口</p><p>例如</p><pre><code>$ docker run -d \    -p 80:80 \    -p 443:443 \    nginx:alpine</code></pre><h5 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a><strong>容器互联</strong></h5><p><strong>新建网络</strong></p><p>下面先创建一个新的 <code>Docker</code>网络。</p><pre><code>$ docker network create -d bridge my-net</code></pre><p><code>-d</code>参数指定<code>Docker</code>网络类型，有<code>bridge overlay</code>,其中<code>overlay</code>网络类型用于<code>Swarm mode</code>，在本小节中你可以忽略它。</p><p><strong>连接容器</strong></p><p>运行一个容器并连接到新建的<code>my-net</code>网络</p><pre><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code></pre><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code>网络</p><pre><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh</code></pre><blockquote><p>-rm是退出后删除了容器，所以我要开两个终端</p></blockquote><p>再打开一个新的终端查看容器信息</p><pre><code>$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESb47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox28720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</code></pre><blockquote><p>能互相ping通证明，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p></blockquote><p><code>Docker Compose</code> 如果你有多个容器之间需要互相连接，推荐使用<code>Docker</code>Compose。</p><h5 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h5><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是<code>Docker</code>利用<strong>虚拟文件</strong>来挂载容器的 3个相关配置文件。</p><p><strong>在容器中</strong>使用 <code>mount</code>命令可以看到挂载信息：</p><pre><code>$ mount/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 .../dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...tmpfs on /etc/resolv.conf type tmpfs ...</code></pre><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有<code>Docker</code>容器的 DNS 配置通过 <code>/etc/resolv.conf</code>文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><pre><code>{  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]}</code></pre><p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和8.8.8.8。使用以下命令来证明其已经生效。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>cat是Linux连接文件并打印到标准输出设备上的命令，win上可以好像用type命令</p></blockquote><p>如果用户想要<strong>手动指定容器的配置</strong>，可以在使用<code>docker run</code>命令启动容器时加入如下参数： <code>-h HOSTNAME</code>或者<code>--hostname=HOSTNAME</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname 和 /etc/hosts</code>。但它在容器外部看不到，既不会在<code>docker container ls</code>中显示，也不会在其他的容器的<code>/etc/hosts</code>看到。</p><p><code>--dns=IP_ADDRESS</code>添加 DNS 服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code>中的主机名。</p><p><code>--dns-search=DOMAIN</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS 不仅搜索 <code>host</code>，还会搜索<code>host.example.com</code>。</p><blockquote><p>关于DNS还有一些不明白</p></blockquote><p><strong>注意：</strong>如果在容器启动时没有指定最后两个参数，<code>Docker</code>会默认用主机上的<code>/etc/resolv.conf</code>来配置容器。</p><h4 id="Docker的网络模式"><a href="#Docker的网络模式" class="headerlink" title="Docker的网络模式"></a>Docker的网络模式</h4><p>可以通过<code>docker network ls</code>查看网络</p><p>常见网络的含义：</p><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Bridge</td><td>为每一个容器分配、设置 IP 等，并将容器连接到一个 <code>docker0</code> 虚拟网桥，默认为该模式。</td></tr><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</td></tr><tr><td>None</td><td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。</td></tr><tr><td>Container</td><td>新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</td></tr></tbody></table><blockquote><p>上学期机组课上虚拟机间通网老师让我们看过各种桥接模式，当时没看懂，之后要好好看看计算机网络了，现在先把看不懂的名词记下来</p></blockquote><p>Bridge 模式</p><p>虚拟网桥是什么？网卡？</p><p>二层网络？子网分配ip？虚拟网卡两端放在容器和主机？</p><p>守护进程？</p><p>对于每个容器的 IP 地址和 Gateway 信息，可以通过 <code>docker inspect 容器名称|ID</code> 进行查看</p><p>可以通过 <code>docker network inspect bridge</code> 查看所有 <code>bridge</code> 网络模式下的容器，在 <code>Containers</code> 节点中可以看到容器名称</p><p>关于 <code>bridge</code> 网络模式的使用，只需要在创建容器时通过参数 <code>--net bridge</code> 或者 <code>--network bridge</code> 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。</p><p><code>iptables</code>做了<code>DNAT</code>规则，实现端口转发功能？</p><pre class="line-numbers language-cmd"><code class="language-cmd">以使用iptables -t nat -vnL查看。演示：$ docker run -tid --net=bridge --name docker_bri1 \            ubuntu-base:v3            docker run -tid --net=bridge --name docker_bri2 \            ubuntu-base:v3 $ brctl show$ docker exec -ti docker_bri1 /bin/bash$ ifconfig –a$ route –n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>还有一些细节不明白，命令完全不明白在干嘛,暂时用不上所以先放放</p></blockquote><hr><p>Host 模式</p><p>通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定</p><p>可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；</p><blockquote><p>是不是说我把container扔到服务器上去就可以直接用服务器ip的意思？</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/host.png" alt="看不明白"></p><p>不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个<code>Network Namespace</code></p><p>None 模式</p><p>通过参数 <code>--net none</code> 或者 <code>--network none</code> 指定；</p><p>只有 lo 接口 local 的简写，代表 127.0.0.1</p><p>localhost 本地环回接口？loopback 网络设备？</p><p>需要自己为 <code>Docker</code> 容器添加网卡、配置 IP 等</p><p><strong>“少即是多”</strong></p><hr><p>Container 模式</p><p>在创建容器时通过参数 <code>--net container:已运行的容器名称|ID</code> 或者 <code>--network container:已运行的容器名称|ID</code> 指定；</p><p>共享一个网络栈？</p><p>这样两个容器之间可以使用 localhost 高效快速通信。</p><p><strong>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等</strong>。</p><h4 id="Docker高级网络配置"><a href="#Docker高级网络配置" class="headerlink" title="Docker高级网络配置"></a>Docker高级网络配置</h4><p><strong>快速配置指南</strong></p><p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p><ul><li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li><li><code>--bip=CIDR</code>定制 <code>docker0</code> 的掩码</li><li><code>-H SOCKET...</code> 或 <code>--host=SOCKET... Docker</code> 服务端接收命令的通道</li><li><code>--icc=true|false</code> 是否支持容器之间进行通信</li><li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li><li><code>--iptables=true|false</code> 是否允许 Docker 添加 <code>iptables</code> 规则</li><li><code>--mtu=BYTES</code> 容器网络中的 <code>MTU</code></li></ul><p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p><ul><li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li><li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li></ul><p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p><ul><li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li><li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li><li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li><li><code>-p SPEC</code> 或 –publish=SPEC` 映射容器端口到宿主主机</li><li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li></ul><p><strong>容器访问控制</strong></p><p><code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。机组课上用过。</p><p>容器要想<strong>访问外部网络</strong>，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p><pre><code>$sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1</code></pre><p>如果为 0，说明没有开启转发，则需要手动打开。</p><pre><code>$sysctl -w net.ipv4.ip_forward=1</code></pre><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p><p><strong>容器之间相互访问</strong>，需要两方面的支持。</p><ul><li>容器的<strong>网络拓扑</strong>是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li><li>本地系统的防火墙软件 <code>-- iptables</code> 是否允许通过。</li></ul><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条<strong>转发策略</strong>到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p><p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p><p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来<strong>访问容器的开放端口</strong>。</p><p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p><p>启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p><p><strong>端口映射实现</strong></p><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p><p>查看主机的 NAT 规则。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo iptables -t nat -nL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态<strong>伪装</strong>为从系统网卡发出</p><p><strong>端口映射实现</strong></p><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><blockquote><p>开放端口</p></blockquote><p>其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p><ul><li>永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</li></ul><pre><code>{  &quot;ip&quot;: &quot;0.0.0.0&quot;}</code></pre><p><strong>配置docker0网桥</strong></p><p>它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p><p>MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p><ul><li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</li><li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li></ul><p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo brctl show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注</strong>：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p><p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p><p><strong>自定义网桥</strong></p><p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p><p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p><pre><code>$ sudo systemctl stop docker$ sudo ip link set dev docker0 down$ sudo brctl delbr docker0</code></pre><blockquote><p>都没法在Windows上实现一遍了</p></blockquote><p>然后创建一个网桥 <code>bridge0</code>。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo brctl addbr bridge0$ sudo ip addr add 192.168.5.1/24 dev bridge0$ sudo ip link set dev bridge0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看确认网桥创建并启动。</p><p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p><pre><code>{  &quot;bridge&quot;: &quot;bridge0&quot;,}</code></pre><p>启动 Docker 服务。</p><p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p><p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p><hr><p><strong>工具和示例</strong></p><p>pipework，shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p><p>playground，一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p><p><strong>编辑网络配置文件</strong></p><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p><p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p><p>实例：<strong>创建一个点到点连接</strong></p><p>首先启动 2 个容器：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -i -t --rm --net=none base /bin/bashroot@1f1f4c1f931a:/#$ docker run -i -t --rm --net=none base /bin/bashroot@12e343489d2f:/#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在两个终端启动吗？</p></blockquote><p>找到进程号，然后创建网络命名空间的<strong>跟踪文件</strong>。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker inspect -f '{{.State.Pid}}' 1f1f4c1f931a2989$ docker inspect -f '{{.State.Pid}}' 12e343489d2f3004$ sudo mkdir -p /var/run/netns$ sudo ln -s /proc/2989/ns/net /var/run/netns/2989$ sudo ln -s /proc/3004/ns/net /var/run/netns/3004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>绿色的是端口号？ln用于硬连接 ln -s软连接？什么是创建接口？</p></blockquote><p>创建一对 <code>peer</code> 接口，然后配置路由</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo ip link add A type veth peer name B$ sudo ip link set A netns 2989$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A$ sudo ip netns exec 2989 ip link set A up$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A$ sudo ip link set B netns 3004$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B$ sudo ip netns exec 3004 ip link set B up$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p><p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p><p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p><blockquote><p>后面完全是因为基本功没到位看不懂了</p></blockquote><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>先手资料</p><hr><p><a href="https://vuepress.mirror.docker-practice.com/compose/install/" target="_blank" rel="noopener">docker compose安装与卸载</a></p><p><strong><a href="https://github.com/docker/awesome-compose" target="_blank" rel="noopener">awesome-compose</a></strong>这个项目也非常推荐。</p><blockquote><p>推荐大家多看看一些项目的docker-compose.yml文件是怎么写的，慢慢模仿着去写很多就越来越熟练清晰了。</p></blockquote><p><strong>什么是</strong>docker compose</p><p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p><p><strong>如何使用</strong>docker compose</p><p>在<code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个<strong>应用的容器</strong>，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个<strong>完整业务单元</strong>，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><strong>web应用</strong></p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><strong>启动服务</strong></p><pre><code>docker-compose up</code></pre><p>命令后会自动接一个默认值<code>-f docker-compose.yml</code>，也就是默认是使用docker-compose.yml文件的。我们也可以给文件起名为<code>docke-test.yml</code>，这样在使用时指定文件名，但是为了符合规范，还是统一为<code>docker-compose.yml</code>。</p><pre><code>docker-compose up -f docer-test.yml</code></pre><p>-d参数让启动时的输出不会打印到终端</p><p><strong>查看服务状态</strong></p><pre><code>docker-compose ps</code></pre><p>要是想要查看所有service的状态可以使用-a参数</p><p><strong>停止或删除服务</strong></p><pre><code>docker-compose stopdocker-compose down</code></pre><p>其中stop是直接停止services，而down则会停止并删除创建的service，volume和network。</p><p><strong>进入服务</strong></p><pre><code>docker-compose exec mysql bash</code></pre><p><strong>查看服务输出日志</strong></p><pre><code>docker-compose logs</code></pre><hr><p>Compose<strong>模板文件</strong></p><p><em><a href="https://vuepress.mirror.docker-practice.com/compose/compose_file/#cap-add-cap-drop" target="_blank" rel="noopener">Compose模板文件</a></em></p><p>文件格式为 YAML 格式。</p><pre class="line-numbers language-yml"><code class="language-yml">version: "3"services:  webapp:    image: examples/web    ports:      - "80:80"    volumes:      - "/data"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p><strong>build</strong></p><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><p><code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><p>使用 <code>cache_from</code> 指定构建镜像的缓存。</p><p><strong>depends_on</strong></p><p>解决容器的依赖、启动先后的问题。</p><p><strong>environment</strong></p><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔 (opens new window)</a>含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><pre><code>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</code></pre><p><strong>expose</strong></p><p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数</p><p><strong>ports</strong></p><p>暴露端口信息。使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><p><strong>secrets</strong>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><p><strong>image</strong>指定为镜像名称或镜像 ID。</p><p><strong>labels</strong>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><p><strong>network_mode</strong>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><p><strong>networks</strong>配置容器连接的网络。</p><p><strong>volumes</strong></p><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。该指令中路径支持相对路径。</p><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><hr><p>Compose<strong>命令</strong></p><p><code>docker-compose</code> 命令的基本的使用格式是</p><pre><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre><ul><li><code>f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><table><thead><tr><th>命令</th><th align="center">作用</th></tr></thead><tbody><tr><td>build</td><td align="center">格式为 <code>docker-compose build [options] [SERVICE...]</code>。构建（重新构建）项目中的服务容器。</td></tr><tr><td>config</td><td align="center">验证 Compose 文件格式是否正确</td></tr><tr><td>down</td><td align="center">此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</td></tr><tr><td>exec</td><td align="center">进入指定的容器。</td></tr><tr><td>help</td><td align="center">帮助</td></tr><tr><td>image</td><td align="center">列出 Compose 文件中包含的镜像</td></tr><tr><td>kill</td><td align="center">格式为 <code>docker-compose kill [options] [SERVICE...]</code>。通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。支持通过 <code>-s</code> 参数来指定发送的信号</td></tr><tr><td>logs</td><td align="center">查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。该命令在调试问题的时候十分有用。</td></tr><tr><td>pause</td><td align="center">暂停一个服务容器。</td></tr><tr><td>port</td><td align="center">打印某个容器端口所映射的公共端口。</td></tr><tr><td>ps</td><td align="center">列出项目中目前的所有容器。</td></tr><tr><td>pull</td><td align="center">拉取服务依赖的镜像。–ignore-pull-failures忽略拉取镜像过程中的错误。</td></tr><tr><td>push</td><td align="center">推送服务</td></tr><tr><td>restart</td><td align="center">重启项目中的服务。</td></tr><tr><td>rm</td><td align="center">删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。<code>-f, --force</code> 强制直接删除 -v删除容器所挂载的数据卷</td></tr><tr><td>start</td><td align="center">启动</td></tr><tr><td>stop</td><td align="center">停止已经处于运行状态的容器，但不删除它</td></tr><tr><td>top</td><td align="center">查看各个服务容器内运行的进程</td></tr><tr><td>unpause</td><td align="center">恢复处于暂停状态中的服务</td></tr><tr><td>up</td><td align="center">尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。<code>-d</code>，将会在后台启动并运行所有的容器</td></tr></tbody></table><p>up选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><hr><p><strong>扩缩容</strong></p><pre><code>docker-compose up --scale web=3 -d</code></pre><blockquote><p>理想情况下这三个web会同时对外提供服务，以减轻访问单个容器的压力。但是我们在上面也看到了因为大家都是绑定的5000端口，这样端口就冲突了，导致新创建的两个web服务都是Exit的状态，对于这个问题我们可以通过HAProxy来解决。</p></blockquote><p>HAProxy？等我学完网络再来看能不能PR好了</p><h3 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a>综合实践</h3><h4 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h4><p>看github上的教程没搞懂这次打卡具体要做什么，如果自己写dockfile估计时间不够了，所以参照阮一峰的docker实战尝试在服务器上做点东西出来好了。</p><p>在服务器上装docker，见参考资料</p><p>首先还要更新一下yum，遇到点小问题，csdn解决。</p><p><a href="https://blog.csdn.net/haohaoxuexiyai/article/details/111027692" target="_blank" rel="noopener">yum更新失败：rpmdb: BDB0113 Thread/process 2673/140126198814528 failed: BDB1507 Thread died…</a></p><p>服务器一边还在进行一些其他任务，所以在本地同时开工。</p><p>由于时间关系这次就不自建WordPress容器了，直接采取最简单的方法，使用官方提供的容器。</p><p>首先，新建并启动 MySQL 容器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container run \  -d \  --rm \  --name wordpressdb \  --env MYSQL_ROOT_PASSWORD<span class="token operator">=</span>123456 \  --env MYSQL_DATABASE<span class="token operator">=</span>wordpress \  mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container run \  -d \  --rm \  --name wordpress \  --env WORDPRESS_DB_PASSWORD<span class="token operator">=</span>123456 \  --link wordpressdb:mysql \  wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p><p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container inspect wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。</p><p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p><p>然而我打不开<code>172.17.0.3</code>，不知道是不是打开方式不对。</p><p>到了上一步，官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p><blockquote><ul><li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li><li>WordPress 安装在容器里面，本地无法修改文件。</li></ul></blockquote><p>解决这两个问题很容易，只要新建容器的时候，加两个命令行参数就可以了。</p><p>先把刚才启动的 WordPress 容器终止（容器文件会自动删除）。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>然后，使用下面的命令新建并启动 WordPress 容器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash"> $ docker container run \  -d \  -p 127.0.0.2:8080:80 \  --rm \  --name wordpress \  --env WORDPRESS_DB_PASSWORD<span class="token operator">=</span>123456 \  --link wordpressdb:mysql \  --volume <span class="token string">"<span class="token variable">$PWD</span>/wordpress"</span>:/var/www/html \  wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>上面的命令跟前面相比，命令行参数只多出了两个。</p><blockquote><ul><li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li><li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li></ul></blockquote><p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p><p>最后，终止这两个容器（容器文件会自动删除）。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop wordpress wordpressdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="第一次实际实用docker"><a href="#第一次实际实用docker" class="headerlink" title="第一次实际实用docker"></a><strong>第一次实际实用docker</strong></h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/1836012?qq-pf-to=pcqq.group" target="_blank" rel="noopener">教你用AI Studio+wechaty+阿里云白嫖一个智能微信机器人</a></p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰的docker教程</a></p><p><a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener">Docker 从入门到实践</a></p><p><a href="https://github.com/datawhalechina/team-learning-program/tree/master/Docker" target="_blank" rel="noopener">github组队学习</a></p><p><a href="https://blog.csdn.net/zzq060143/article/details/91050272?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">Windows上docker使用教程</a></p><p><a href="https://www.cnblogs.com/linjj/p/5606911.html" target="_blank" rel="noopener">Windows创建自己的镜像</a></p><p>关于安装问题</p><p><a href="https://blog.csdn.net/LFxiaosu/article/details/112214780" target="_blank" rel="noopener">docker的安装及卸载不干净造成的问题</a></p><p><a href="https://blog.csdn.net/lazy_ting/article/details/106375737" target="_blank" rel="noopener">乌班图配网</a></p><p>关于服务器装docker</p><p><a href="https://cloud.tencent.com/document/product/213/46000#.E5.AE.89.E8.A3.85-docker" target="_blank" rel="noopener">我用的腾讯云centos7</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语学习</title>
      <link href="/2021/04/11/ying-yu-xue-xi/"/>
      <url>/2021/04/11/ying-yu-xue-xi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/v2-70663faaf7ff2ad7f5c034b58c1cd9e5_b.jpg" alt="小天爷学英语"></p><h3 id="2021英语学习计划1-0"><a href="#2021英语学习计划1-0" class="headerlink" title="2021英语学习计划1.0"></a>2021英语学习计划1.0</h3><blockquote><p>ᵀʰᵉʳᵉ ⁱˢ ᵐᵒʳᵉ ᵗᵒ ᶜᵒᵐᵉ</p><p>于未来有更多期许。</p></blockquote><p><strong>六级备考(距离考试只有80天不到)</strong></p><p>十周计划前期每天一篇翻译，一套阅读，一三五早上一套听力，每周五一次套题，周日早整理复习，二四六早写作。</p><p><strong>目前进度</strong></p><p>4.1前六级词汇已过，刷完</p><p><strong>第一周（4.4）</strong></p><p>翻译*6</p><p>阅读*5</p><p>听力*3</p><p>一套历年真题（缺）偷懒了，后面要补上。</p><p>单词：雅思2768</p><p><strong>第二周（4.11）</strong></p><p>翻译*4</p><p>阅读*6</p><p>听力*1</p><p>杂七杂八的事情太多，这周又没做真题，不过估计能在第四周前把各个题型刷完，目前已经差不多刷完听力和阅读了，后面有时间可以刷真题。</p><p>这周复习雅思单词</p><p><strong>第三周（4.18）</strong></p><p>翻译*4</p><p>阅读？做完了好像，可以开始做六级真题了。</p><p>一套英语真题，好像错了五个</p><p>又是没刷真题套卷的一周，还剩七周，应该能刷完吧？</p><p>单词：雅思3112，下周不背单词了，努力刷题，有空还是要看一看大英赛的题目的。</p><blockquote><p>这周没做多少练习，倒是读了一些英语原文，所以没有总结。</p></blockquote><p><strong>第四周4.25</strong></p><p>完成大英赛初赛，写作翻译能力果然还是很需要提升，特别是英文写作，最近基本上没怎么写过英文作文，之后要多练习使用英语，多尝试输出，而不仅仅是阅读输入。</p><p>翻译*3</p><p>两套CET-6真题，除作文翻译。听力错四五个，阅读第一篇cloze好久没做过了，很吃力，根本选不出来。时间上也比较紧张，之前以为没有cloze了。好在阅读都不觉得有太大问题。</p><p>2019.6第一套和第二套</p><p>剩下精力要攻克听力和写作翻译了。</p><p>还剩四周口语，也得准备准备。</p><p>单词还是3112，这周复习，大英赛断了一天。</p><p><strong>第五周4.30</strong></p><p><strong>使用书目</strong></p><p>语法：重点推荐剑桥校友张满胜的《英语语法新思维》</p><p>初级教程-走近语法结果买错成张道真《实用英语语法（最新版）》</p><p>《华研外语六级真题》</p><p><strong>参考资料</strong></p><p><a href="https://www.zhihu.com/search?type=content&q=大学英语自学书" target="_blank" rel="noopener">大学英语自学书 - 搜索结果 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 外语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow学习笔记</title>
      <link href="/2021/04/01/tensorflow/"/>
      <url>/2021/04/01/tensorflow/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="关于TensorFlow"><a href="#关于TensorFlow" class="headerlink" title="关于TensorFlow"></a>关于TensorFlow</h3><blockquote><p>TenrFlow 是一个开源的、基于 Python 的机器学习框架，它由 Google 开发，并在图形分类、音频处理、推荐系统和自然语言处理等场景下有着丰富的应用，是目前最热门的机器学习框架。</p><p>除了 Python，TensorFlow 也提供了 C/C++、Java、Go、R 等其它编程语言的接口。</p></blockquote><p>个人配置：电脑上已经安装好了anaconda，python版本3.7.6</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>国内直接下载TensorFlow速度慢，直接换清华源，清华园也挂了，再换豆瓣源，配置到pycharm，Spyder先不配置了。</p><h1 id="TensorFlow学习笔记"><a href="#TensorFlow学习笔记" class="headerlink" title="TensorFlow学习笔记"></a>TensorFlow学习笔记</h1><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p>可以用<code>get_weights()</code>和<code>set_weights()</code>方法，获取神经层的所有参数。对于紧密层，参数包括连接权重和偏置项</p><p><code>fit()</code>方法会返回<code>History</code>对象，包含：训练参数（<code>history.params</code>）、周期列表（<code>history.epoch</code>）、以及最重要的包含训练集和验证集的每个周期后的损失和指标的字典（<code>history.history</code>）。如果用这个字典创建一个 pandas 的<code>DataFrame</code>，然后使用方法<code>plot()</code>，就可以画出学习曲线</p><p>可以看到，训练准确率和验证准确率稳步提高，训练损失和验证损失持续下降。另外，验证曲线和训练曲线靠的很近，意味着没有什么过拟合。在这个例子中，在训练一开始时，模型在验证集上的表现由于训练集。但实际情况是，验证误差是在每个周期结束后算出来的，而训练误差在每个周期期间，用流动平均误差算出来的。所以训练曲线（译者注，图中橙色的那条）实际应该向左移动半个周期。移动之后，就可以发现在训练开始时，训练和验证曲线几乎是完美重合起来的。</p><p>本章末尾还会调节超参数。当对验证准确率达到满意之后，就可以用测试集评估泛化误差。只需使用<code>evaluate()</code>方法（<code>evaluate()</code>方法包含参数<code>batch_size</code>和<code>sample_weight</code>）：</p><p>测试集的表现通常比验证集上低一点，这是因为超参数根据验证集而不是测试集调节的（但是在这个例子中，我们没有调节过超参数，所以准确率下降纯粹是运气比较差而已）。一定不要在测试集上调节超参数，否则会影响泛化误差。</p><p>使用顺序 API 是很方便的。但是，尽管<code>Sequential</code>十分常见，但用它搭建复杂拓扑形态或多输入多输出的神经网络还是不多。所以，Keras 还提供了函数式 API。</p><p><a href="https://hands1ml.apachecn.org/#/docs/10?id=使用函数式-api-搭建复杂模型" target="_blank" rel="noopener">使用函数式 API 搭建复杂模型</a></p><p>每个输出都要有自己的损失函数。因此在编译模型时，需要传入损失列表（如果只传入一个损失，Keras 会认为所有输出是同一个损失函数）。Keras 默认计算所有损失，将其求和得到最终损失用于训练。主输出比辅助输出更值得关心，所以要提高它的权重</p><p>对<code>Model</code>类划分子类，在构造器中创建需要的层，调用<code>call()</code>进行计算。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">WideAndDeepModel</span><span class="token punctuation">(</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> units<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">"relu"</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># handles standard args (e.g., name)</span>        self<span class="token punctuation">.</span>hidden1 <span class="token operator">=</span> keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>units<span class="token punctuation">,</span> activation<span class="token operator">=</span>activation<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>hidden2 <span class="token operator">=</span> keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>units<span class="token punctuation">,</span> activation<span class="token operator">=</span>activation<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>main_output <span class="token operator">=</span> keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>aux_output <span class="token operator">=</span> keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        input_A<span class="token punctuation">,</span> input_B <span class="token operator">=</span> inputs        hidden1 <span class="token operator">=</span> self<span class="token punctuation">.</span>hidden1<span class="token punctuation">(</span>input_B<span class="token punctuation">)</span>        hidden2 <span class="token operator">=</span> self<span class="token punctuation">.</span>hidden2<span class="token punctuation">(</span>hidden1<span class="token punctuation">)</span>        concat <span class="token operator">=</span> keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>input_A<span class="token punctuation">,</span> hidden2<span class="token punctuation">]</span><span class="token punctuation">)</span>        main_output <span class="token operator">=</span> self<span class="token punctuation">.</span>main_output<span class="token punctuation">(</span>concat<span class="token punctuation">)</span>        aux_output <span class="token operator">=</span> self<span class="token punctuation">.</span>aux_output<span class="token punctuation">(</span>hidden2<span class="token punctuation">)</span>        <span class="token keyword">return</span> main_output<span class="token punctuation">,</span> aux_outputmodel <span class="token operator">=</span> WideAndDeepModel<span class="token punctuation">(</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>保存和恢复模型</strong></p><p>Keras 使用 HDF5 格式保存模型架构（包括每层的超参数）和每层的所有参数值（连接权重和偏置项）。还保存了优化器（包括超参数和状态）。</p><p>通常用脚本训练和保存模型，一个或更多的脚本（或 web 服务）来加载模型和做预测。</p><pre class="line-numbers language-python"><code class="language-python">model<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">"my_keras_model.h5"</span><span class="token punctuation">)</span> model <span class="token operator">=</span> keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>load_model<span class="token punctuation">(</span><span class="token string">"my_keras_model.h5"</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>警告</strong>：这种加载模型的方法只对顺序 API 或函数式 API 有用，不适用于子类化 API。对于后者，可以用<code>save_weights()</code>和<code>load_weights()</code>保存参数，其它的就得手动保存恢复了。</p><p><strong>使用调回</strong></p><p><code>fit()</code>方法接受参数<code>callbacks</code>，可以让用户指明一个 Keras 列表，让 Keras 在训练开始和结束、每个周期开始和结束、甚至是每个批次的前后调用。</p><pre class="line-numbers language-python"><code class="language-python">checkpoint_cb <span class="token operator">=</span> keras<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>ModelCheckpoint<span class="token punctuation">(</span><span class="token string">"my_keras_model.h5"</span><span class="token punctuation">)</span> history <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> callbacks<span class="token operator">=</span><span class="token punctuation">[</span>checkpoint_cb<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">''</span><span class="token string">''</span><span class="token string">''</span>checkpoint_cb <span class="token operator">=</span> keras<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>ModelCheckpoint<span class="token punctuation">(</span><span class="token string">"my_keras_model.h5"</span><span class="token punctuation">,</span>                                                save_best_only<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>history <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>                    validation_data<span class="token operator">=</span><span class="token punctuation">(</span>X_valid<span class="token punctuation">,</span> y_valid<span class="token punctuation">)</span><span class="token punctuation">,</span>                    callbacks<span class="token operator">=</span><span class="token punctuation">[</span>checkpoint_cb<span class="token punctuation">]</span><span class="token punctuation">)</span>model <span class="token operator">=</span> keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>load_model<span class="token punctuation">(</span><span class="token string">"my_keras_model.h5"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># roll back to best model </span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span>early_stopping_cb <span class="token operator">=</span> keras<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>EarlyStopping<span class="token punctuation">(</span>patience<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>                                                  restore_best_weights<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>history <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>                    validation_data<span class="token operator">=</span><span class="token punctuation">(</span>X_valid<span class="token punctuation">,</span> y_valid<span class="token punctuation">)</span><span class="token punctuation">,</span>                    callbacks<span class="token operator">=</span><span class="token punctuation">[</span>checkpoint_cb<span class="token punctuation">,</span> early_stopping_cb<span class="token punctuation">]</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，如果训练时使用了验证集，可以在创建检查点时设定<code>save_best_only=True</code>，只有当模型在验证集上取得最优值时才保存模型。这么做可以不必担心训练时间过长和训练集过拟合：只需加载训练好的模型，就能保证是在验证集上表现最好的模型。</p><p>另一种实现早停的方法是使用<code>EarlyStopping</code>调回。当检测到经过几个周期（周期数由参数<code>patience</code>确定），验证集表现没有提升时，就会中断训练，还能自动滚回到最优模型。可以将保存检查点（避免宕机）和早停（避免浪费时间和资源）结合起来</p><hr><p><a href="https://hands1ml.apachecn.org/#/docs/10?id=使用-tensorboard-进行可视化" target="_blank" rel="noopener">使用 TensorBoard 进行可视化</a></p><p>ensorBoard 是一个强大的交互可视化工具，使用它可以查看训练过程中的学习曲线、比较每次运行的学习曲线、可视化计算图、分析训练数据、查看模型生成的图片、可视化投射到 3D 的多维数据，等等。TensorBoard 是 TensorFlow 自带的。</p><p>要使用 TensorBoard，必须修改程序，将要可视化的数据输出为二进制的日志文件<code>event files</code>。每份二进制数据称为摘要<code>summary</code>，TensorBoard 服务器会监测日志文件目录，自动加载更新并可视化：这样就能看到实时数据（稍有延迟），比如训练时的学习曲线。通常，将 TensorBoard 服务器指向根日志目录，程序的日志写入到它的子目录，这样一个 TensorBoard 服务就能可视化并比较多次运行的数据，而不会将其搞混。</p><p>我们先定义 TensorBoard 的根日志目录，还有一些根据当前日期生成子目录的小函数。你可能还想在目录名中加上其它信息，比如超参数的值，方便知道查询的内容：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">get_run_logdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">import</span> time        run_id <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"run_%Y_%m_%d-%H_%M_%S"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>root_logdir<span class="token punctuation">,</span> run_id<span class="token punctuation">)</span>    run_logdir <span class="token operator">=</span> get_run_logdir<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># e.g., './my_logs/run_2019_06_07-15_15_22'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次运行都会创建一个目录，每个目录都有一个包含训练日志和验证日志的子目录。两者都包括事件文件，训练日志还包括分析追踪信息：它可以让 TensorBoard 展示所有设备上的模型的各个部分的训练时长，有助于定位性能瓶颈。</p><p>然后就可以启动 TensorBoard 服务了。一种方式是通过运行命令行。如果是在虚拟环境中安装的 TensorFlow，需要激活虚拟环境。接着，在根目录（也可以是其它路径，但一定要指向日志目录）运行下面的命令：</p><pre class="line-numbers language-py"><code class="language-py">$ tensorboard --logdir=./my_logs --port=6006<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还可以对全图、权重（投射到 3D）或其它信息做可视化。<code>TensorBoard()</code>调回还有选项可以记录其它数据的日志，比如嵌入（见第 13 章）。另外，TensorBoard 在<code>tf.summary</code>包中还提供了低级 API。下面的代码使用方法<code>create_file_writer()</code>创建了<code>SummaryWriter</code>，TensorBoard 使用<code>SummaryWriter</code>作为记录标量、柱状图、图片、音频和文本的上下文，所有这些都是可以可视化的！</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247484633&idx=1&sn=adf2dfee2bf09e6dab0a67d329bd0c50&chksm=97048f65a073067365daa419808913b50872a18ef9bb16a5011f90967eb89c335fb204c027d2&scene=21#wechat_redirect" target="_blank" rel="noopener">带你少走弯路：强烈推荐的TensorFlow快速入门资料和翻译（可下载）</a></p><p><a href="https://hands1ml.apachecn.org/" target="_blank" rel="noopener">《机器学习实战：基于Scikit-Learn和TensorFlow》</a></p><blockquote><ul><li>本书作者公开了配套的源代码：</li></ul><p><a href="https://github.com/ageron/handson-ml" target="_blank" rel="noopener">https://github.com/ageron/handson-ml</a></p><ul><li>国内一个公益组织对原版英文书进行了翻译，制作成markdown文件（md文件推荐使用typora阅读），可以在github下载：</li></ul><p><a href="https://github.com/apachecn/hands-on-ml-zh" target="_blank" rel="noopener">https://github.com/apachecn/hands-on-ml-zh</a></p><p>针对国内下载速度慢，本站对两个资源进行打包，可以在百度云下载：</p><p>链接：</p><p><a href="https://pan.baidu.com/s/1jihUZrXblxhrVA5FBGU3RQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1jihUZrXblxhrVA5FBGU3RQ</a></p><p>提取码：0xye</p><p>若被和谐请留言。</p><p>——黄海广老师</p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="关于Python的其他常见操作"><a href="#关于Python的其他常见操作" class="headerlink" title="关于Python的其他常见操作"></a>关于Python的其他常见操作</h2><p><a href="https://www.cnblogs.com/an-ning0920/p/10037790.html" target="_blank" rel="noopener">python路径拼接os.path.join()函数的用法</a></p><p>os.path.join()函数：连接两个或更多的路径名组件</p><ol><li><p>如果各组件名首字母不包含’/’，则函数会自动加上</p></li><li><p>如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃</p></li><li><p>如果最后一个组件为空，则生成的路径以一个’/’分隔符结尾</p></li></ol><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://c.biancheng.net/tensorflow/" target="_blank" rel="noopener">TensorFlow教程：TensorFlow快速入门教程（非常详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/110980436?utm_source=wechat_session" target="_blank" rel="noopener">tensorflow安装全解(全解萌新向/CPU/下载快/自选新旧版本/GPU安装简述/报错解决)</a></p><p><a href="https://blog.csdn.net/qq_43211132/article/details/94426458?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328767.234.16172629286554925&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">win10中anaconda安装tensorflow时报错Traceback (most recent call last): File “E:\Anaconda3\lib\site-packag</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3月复盘</title>
      <link href="/2021/03/28/2021-3/"/>
      <url>/2021/03/28/2021-3/</url>
      
        <content type="html"><![CDATA[<h1 id="三月复盘（4-3）"><a href="#三月复盘（4-3）" class="headerlink" title="三月复盘（4.3）"></a>三月复盘（4.3）</h1><h2 id="本月关键词：看开"><a href="#本月关键词：看开" class="headerlink" title="本月关键词：看开"></a>本月关键词：看开</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“凡事应该简单到不能再简单为止。”</strong></p><p><strong>——奥克海姆剃刀</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>考试</strong></p><p>大二冬季期末，虽然有想过要好好利用考试周复习各科专业课，但还是浪费了不少时间，看了70多个小时的b站，还看人家送外卖</p><p><strong>学习</strong></p><p>复习考试科目</p><p>提前预习信息论，《信息论基础》20h</p><p>六级英语计划重启</p><p><a href="https://zhuanlan.zhihu.com/p/359945906" target="_blank" rel="noopener">小天爷学英语</a></p><p><strong>比赛</strong></p><p>计算机应用能力大赛最后截止是在考试周结束前一天，导致最后概率论的复习计划被打乱，生活一遍又一遍地提醒我，不确定性无法完全避免。</p><p>得知美赛论文发错版本，那天心情很不好，但也已经是过去了。</p><p>或许我对比赛拿奖本来就不该有多少期待，喜欢的事情就拿十二分努力去做，结果什么的都让老天去考虑吧。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>这次考试以后重新找回自己的状态，最后一周12km，更改一年的计划为500km。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p>阅读</p><p>《蔡康永学说话》作者有一句话说的很好，一本书总是作者有话想对读者说，并且抱着极大的热情才能写出来的，所以哪怕书里的这些看起来很浅显得道理也值得读者花上一点时间。看这些书的时候，我们更多可能是在反思自己，回忆自己的过去并且总结经验，从而对未来做好一定准备。</p><p>《搏击俱乐部》在图书馆复习，下午在书架上看到这本书然后就拿下来看了两个小时，看书和看电影的感觉还是不太一样的，不得不佩服导演的才华。</p><p>《傲慢与偏见》</p><p>《赢》</p><p>《禅与摩托车维修艺术》</p><p>写作</p><p><a href="https://henryavery.cn/2021/03/25/da-er-dong-ji-xue-qi-zong-jie/">SHU智科大二冬季学期总结</a></p><p>观影</p><p>《守护解放西》1和2刚开学就疯狂看完了，然后停不下来又看了《巡查2018》和《现场2019》，看热闹真的是刻在人类基因里的。看纪录片并不能减少我对b站的使用时间。</p><p>《罪恶王冠》一部看了浪费时间浪费感情的老动漫。</p><p>《无人区》一部没什么意思的片子，每周周末放松打发时间</p><p>《建国大业》看看我们的历史，瞬间恢复斗志</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>这个月最大的投资是买了个吹风机。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>考完试溜出学校到外滩骑自行车放松心情，从外滩到豫园再到南京东路和大学同学一起去吃晚饭。校招去凑热闹认识了一些优秀的学长。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>一周168h，每天8h那就是睡56小时，然后每天2h花在路上，可用的时间只有100个小时不到。每天平均上课6h，一周30h在上课。还剩60h，拿出一半用来完成课后作业，就只有30h可以自己把握，这30h要想好怎么使用。</p><p>比如可以用在学英语上，翻译和单词1h，阅读和听力轮流1h。还有15小时，可以拿5个小时来运动，还剩十个小时花在自己想学的东西上面，可以阅读，可以学数学，也可以是某样技术。</p><p>希望下个月的30*24=720小时里，我能有120小时要用在课后学习，另外有120h在上课，60小时学英语，30小时在运动，40小时在学自己想学的东西，比如一门计算机网络的课和一门操作系统课。或者一门深度学习的课。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/362B696CD4CF2B4D05B120B8FA081C08.jpg" alt="其实没有睡足8小时"></p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>英语学习计划</p><p>算法学习计划</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于考试。备考就像黑屋子里洗衣服，你不知道洗干净没有，只能一遍一遍去洗。等到上了考场的那一刻，灯光亮了。你发现只要你认真洗过，那件衣服光亮如新，而你以后每次穿上那件衣服都会想起那段岁月。</p><p>第二件事，关于数学。伽利略说，惟有数学才能揭示科学的真实面貌，因为数学似乎是上帝的语言。我希望能掌握全面的知识，让我能够熟练掌握我将来用得到的一切知识。对于微积分，线性代数，概率论及统计学中最重要的内容不管是否喜欢都要熟练掌握，并且花大量时间去训练，起码不应该少于花在英语上的时间。</p><p>第三件事，关于英语。如果想要提升英语的一个阶段，也需要时间和决心，而且学英语如同逆水行舟，不进则退。<strong>习惯化是非常重要的，把一次正确的实践变成习惯，把理论内在化，把这个东西变成你身体的一个部分，当你去使用它的时候你甚至可以不用思考。这也是文化社会学家Bourdieu所谓的文化惯习（Habitus）</strong></p><p><a href="https://www.zhihu.com/question/22808635/answer/258783880" target="_blank" rel="noopener">怎样才能从英语很糟糕的人变成英语很厉害的人？</a></p><p>第四件事，关于算法。想想自己这个月都没认真敲过代码，就好像一个作家不提笔，一个钢琴家不摸琴一样。专业是自己喜欢的专业，写代码也是一件很艺术的事情，我也很想去写，但是为什么会这样呢？是时候开始着手潜下心来学习算法了，打算花一年时间学习不难的《算法导论》，把这修炼成一项自己的吃饭本领。</p><p>第五件事，关于学习。永远要有两周学完一门课的勇气。把每天的第一个小时，用来完成最困难的任务，并在这段时间内消除所有干扰，只专注于一项任务，这就是动力小时。—— 卡尔·纽波特《深度工作》ps：在图书馆坐一天会比在寝室做一天舒服，只有睡觉才需要回寝室的床上，因为趴在桌上睡对眼睛不好。</p><p>第六件事，关于心态。对于已经过去的事情，没法改变的事实和历史就不用再纠结，继续做手头上的事情，未来的计划没有大的改变可以继续按部就班执行。比赛，重在参与，感兴趣就去勇敢报名，结果让老天爷去决定，但是不打无准备之战。</p><p>第七件事，关于未来。读研，出国还是留在上海亦或者一路北上。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU智科大二冬季学期总结</title>
      <link href="/2021/03/25/da-er-dong-ji-xue-qi-zong-jie/"/>
      <url>/2021/03/25/da-er-dong-ji-xue-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="课程总览"><a href="#课程总览" class="headerlink" title="课程总览"></a>课程总览</h3><p>这个学期一共十周，寒假前八周，五周寒假之后再上两周课，然后是两周的考试周。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210325094224653.png" alt="一开始选了35分"></p><p>我选课的习惯是在第一轮和第二轮选课把35学分选满，因为基本上不会被踢课，不选白不选，所以就想等第三轮的时候再把不想去的课推掉。这个习惯好像是有点拖延症，一方面其实是犹豫不决，另一方面也确实是为了给自己留出余地。</p><p>但是，这次第三轮选课我给忘了，导致我直接课表上直接多了三门英语课（原本只用上一门）课表直接被塞满成有三天都是白天晚上连轴转，四门英语课我实在是吃不消而且也没必要，如果真的硬上估计这学期挂科的概率会直线上升，所以就只好去找学院教务处的老师退课。</p><p>第一周还不能退课，没办法，怕到时候万一退不了课所以第一次课这四门英语课我都去上了，正好更多地了解了一下每门课老师的要求，因为最后还是要留一门的（最后是因为商务英语入门时间比较合适就留了这门）。然后这一周我室友白天基本上就没在寝室里看到过我。</p><p>为了退课，我跑了好几次教务处找教务处的老师说要退课，那个坐办公室的老师一开始满脸不情愿，不耐烦而且推三阻四，还会用退课情况太多机房老师不一定允许退课，她还说我这个情况不符合退课条件（只有时间冲突和有先修课没上或者是其他一些什么特殊情况才能退）虽然说实话我好像确实不符合这些情况，但我还是不想就这么过一个学期，绞尽脑汁想办法怎么才能说服她给我开个退课单。经过我一番的<strong>动之以情晓之以理</strong>之后，教务处老师<strong>无动于衷</strong>。</p><p>眼看我就要失败，打算再进行一轮进攻过后如果失败就接受现实的时候，教务处办公室里又走进来一个兄弟说要退课，他说他也是选了两门英语课结果忘了退，我看着他也在教务处老师面前<strong>无可奈何的样子</strong>像极了我刚来的时候。（此时教务处老师已经坐在电脑前极度不耐烦并喝起了茶）</p><p>他的理由几乎和我一样，不同的是他最多只用每周多上两小时的课，而且如果这个学期上午下个学期就不用再多选一门英语课了，虽然我如果要是一学期上四门英语课之后也一样不用再选英语课，而且还多出4学分可以充当任选学分，但这学期人非不得发疯了。</p><p>这个时候我灵机一动，既然我说服不了教务处老师，那就<strong>逆向思维</strong>，不如帮着教务处老师劝那个来退课的兄弟放弃，告诉他如果这个学期多上一门课也没关系，相当于下学期不用上而已，也没多大关系。好在这兄弟也是真实诚，就这样在我的劝说下高高兴兴地回去了。</p><p>教务处老师眼看着来退课的学生就这么轻松的走了也是<strong>露出了欣慰的笑容</strong>，我眼看有机会，立即再次发动我的七寸不烂之舌，我说老师你看，刚刚那个同学他是只是多选了一门英语课，而我是真的不小心多选了三门课，这个学期实在是没有这么多时间和精力去上这么多课了，如果不能退课的话那非不得挂科，您高抬贵手放我一马。</p><p>此时她好像才第一次被动摇，我就知道有戏了。说巧也是真巧，前那个来退课的兄弟前脚刚走后脚又办公室又来了一个退伍回来的同学签退课单（有正当理由），教务处老师可能是看我实在可怜，又或者是因为嫌我太碍眼，看在我帮她”送走”了一个麻烦的份上（不好意思了前面来退课的兄弟）就同意顺手帮我和那位退伍同学一起把退课单签了，让我和他一起上楼盖章，我是真没想到她的态度还能反转的那么快，所以立马也是千恩万谢，感恩戴德，不过临走她还是吓我说到机房最后能不能退课还得看机房老师的意思。</p><p>只是既然我都已经签好退课单了，退课这个大问题基本上也就解决了，果然，到机房后一看负责登录选课网站操作退课的除了机房老师以外还有我们学院的学长，等排队到我了我就直接到学长那边，直接和他说了我要退的那三门英语课，退课单上的理由问都没问就完成了退课。</p><p>不得不说，<strong>退完课之后我的心情极好，就好像这个学期的生活又重新充满了光明。</strong></p><h3 id="课程学习心得"><a href="#课程学习心得" class="headerlink" title="课程学习心得"></a>课程学习心得</h3><p><strong>数据结构</strong></p><p>还是选的zjq老师，推荐一本《大话数据结构》，很有意思，开始上课前花几个小时可以看完，大概知道这门课学什么。</p><p>虽然觉得数据结构1也没太大难度，但是做题好像是另外一回事，写代码也只是时间问题。</p><p>刷题还是建议买本王道的考研书，提早做作业，我后悔买的晚了，边上课边做效果最好。</p><p>寒假返校后一个月基本不怎么敲代码，会有点手生。</p><p>组队没找到认识的组员会有一定的麻烦，果然建议找认识的人是没有错的，可惜我还是太年轻不信邪，不信邪就很容易会撞邪。</p><p><strong>计算机组成原理与体系结构</strong></p><p>这门课有的实验做起来真的很麻烦，我边做边记录最后写成了一份<strong>实验攻略</strong>，最后复习的笔记也上传到了另一篇博客上。</p><p><a href="https://henryavery.cn/2020/11/28/shu-ji-zu/">SHU智科机组</a></p><p>虽然这门课计科学两个学期智科只学一个学期，但我觉得也没什么大不了的，问了问计科的同学，他们机组好像也没多讲什么内容，我们课时短内容好像反而还更多。强烈建议自己买本王道考研的书做题，提前预习，一边上课一边做题无压力，考前突击要靠背，背完大概会觉得自己考研问题都不大了，但是考试范围还是会出乎意料，因为老师会搞偷袭。</p><p>swf老师是好老师，讲的很多东西都很有道理，能从他的机组课上学到不少思想。比如二八定理就很有用，打个比方，一般考试有80%是简单的题目或者说是重复的问题，只有20%是难题。所以如果想要拿高分，与其花九成的精力攻克20%的难题，不如用这个时间确保能拿下另外80%的基础题。再比如很多计算机体系里的思想仔细思索都会觉得很有意思。</p><p>另外，他上课还经常会讲他当辅导员的时候去查寝的例子，印象中他起码讲了三遍以上。</p><p><strong>概率论</strong></p><p>hhp，感觉比机组简单，但是要多刷题，寒假回来要小测验我忘了，被打了个措手不及。</p><p>概率论和实际生活有很多联系，在机器学习中也是非常有用的工具，在美赛建模里会用到数理统计，是一门值得花时间好好学的科目。</p><p>推荐买《考研数学复习全书》和《张宇数学1000题》，别和我一样傻傻的把数学一买成了数学二就行。</p><p><strong>离散数学</strong></p><p>wp，老师很好也讲的很慢，跟上就能听懂。而且离散1不难。考试选择题多选，坑，要克服<strong>人的思维惯性</strong>，有一些概念得自己梳理，这让我看清自己的学习方式和复习习惯在<strong>梳理</strong>和<strong>区分</strong>这里还有不足，希望日后能够完善。</p><p>离散数学顾名思义讲的就是“离散”的数学知识。</p><p><strong>商务英语入门</strong></p><p>hl，很有特色的老师，会开玩笑，而且上她的课还是比较放松的，可以带零食</p><p>这门课要求很少，没有作业，有一次额外的案例分析，一次可选的任务（起码她是这么说的）</p><p>关于如何卖出一瓶高端水，当时我是想做的，很认真的开了一篇博客打算开写，但是时间比较急没来得及写完，我是觉得如果为了敷衍而去完成任务那还不如不交，其实这种思维就有问题，可我总是后知后觉，然后直到现在都还没填这个坑。<a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于如何卖出一瓶高端水</a></p><p>课上讲了很多商务案例以及职场关系的内容，有不少课堂讨论，还有很多有趣的东西，考试也不算太难（相对于新闻听力和口译来说）</p><p><strong>演讲艺术</strong>（强推）</p><p>wx，经历很丰富思想也很丰富的老师，北大法学院转学播音主持，做过主持人、配音，课讲得也很好，这门课能学到很多东西，我觉得个人收获很大。</p><p>期末作业是寒假里录一次限定主题的三分半演讲视频，要求正装，半身，最后一次课要把演讲内容写下来交给教务处留档。我是第一次认真看自己说话的视频，一个人从上午录到下午录了快一百遍，主要是很多时候一开始没准备好，两三秒那种不能剪辑只好重新来过。</p><p>建议认真对待，不然运气不好的话可能会在课上被”公开处刑“，脸皮厚点也无所谓。</p><p>另外如果课程期间在校内或者校外参加演讲比赛拿奖告诉老师他会直接给4.0。</p><p>关于演讲有本《TED演讲的力量》推荐。</p><p><strong>毛概</strong></p><p>一学期可以选完两门毛概，考试时间不冲突，而且反正都是开卷。考研要考，我一开始还想好好学一下，实在是学不进多少。</p><p>红课要选就选xjp</p><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><p>知乎上看到一段话觉得形容的特别合适。</p><blockquote><p><strong>备考就像黑屋子里洗衣服，你不知道洗干净没有，只能一遍一遍去洗。等到上了考场的那一刻，灯光亮了。你发现只要你认真洗过，那件衣服光亮如新，而你以后每次穿上那件衣服都会想起那段岁月。</strong></p></blockquote><p>特别是这次复习机组，其实光说大学的某次考试的话，是可以不用再像高中那样去想那么多的，一次考试考完了就考完了。考试的题目是老师出的，对这门课的考察其实一定科学合理吗？考试的分数在某种程度上或许可以说明你对这门课的学习态度是否认真，它处在一个置信度不明的置信区间内，仅此而已。</p><p>而考试周的意义则更像是给了我们一段时间，可以好好整理复习我们一个学期学过的内容，最后的考试成绩不是我们的收获，在这短短两周不到的时间内自己复习过的，整理出来的知识和经验才是我们真正能收获到的。考试中某个题目的答案或许这辈子都不会再用到，无论是做对还是做错，都只不过是在一定程度上反映出你在这次考试之前的准备是否充分。</p><p>我相信等将来真正要用到曾经学过的知识时，那些复习过程中真正学到的东西都会是有用的，而考试时某个做错或者做对的题目早就会被大脑遗忘了。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月复盘</title>
      <link href="/2021/03/05/2021-2/"/>
      <url>/2021/03/05/2021-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2月复盘（3-5）"><a href="#2月复盘（3-5）" class="headerlink" title="2月复盘（3.5）"></a>2月复盘（3.5）</h1><h2 id="本月关键词：寒假"><a href="#本月关键词：寒假" class="headerlink" title="本月关键词：寒假"></a>本月关键词：寒假</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“哪有什么很忙，只是你觉得当下选择做某件事，而非另一件而已。说白了，一切都是你自己的选择。“</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><a href="https://henryavery.cn/2021/01/22/2021-han-jia-ji-hua/">寒假计划</a></p><p><a href="https://henryavery.cn/2020/09/11/mei-sai-qi-hang/">美赛四天</a></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113407044" target="_blank" rel="noopener">吴恩达机器学习</a></p><p><a href="https://henryavery.cn/2021/01/22/flutter/">Flutter</a></p><p>英语：六级单词2000，四级成绩567，马上就要报名六级了，考完期末备战600+</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>就出门打了一次球，散了一次步，自己在家只做俯卧撑，下定决心要在毕业前改变自己的形象，回学校后重新开始健身。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><h5 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a><strong>阅读</strong></h5><p>《第五项修炼》速读，打发时间</p><p>《自私的基因》有空单独写书评</p><p>看了几天的网络小说</p><h5 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h5><p>《蛮荒世界》一部由六个小故事组成的电影，揭露人性，下饭片</p><p>《宿醉》神作，适合下饭</p><p>《神探》很久以前有印象的一部片子，只记得一个片段，当时看不懂</p><p>《拆弹专家2》下饭</p><p>《算死草》在b站上找到一部星爷主演的片子，居然没看过</p><p><strong>写作</strong>（有待完成）</p><p><a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于如何卖出一瓶水</a></p><p>社交圈和社交软件推荐算法的小研究</p><h3 id="4-人际交往副本"><a href="#4-人际交往副本" class="headerlink" title="4 人际交往副本"></a>4 人际交往副本</h3><p>寒假里和高中的一些朋友出去聚餐，然后除了几个比赛开会以外好像和外界的交流就比较少了，过年走亲戚不算交流，基本上说不上话，两三天是正常，连续走亲戚一周纯属浪费是啊金。然后主要可能还是因为忙比赛，所以也没精力组织其他活动。读书会今年也不了了之。</p><p>明年可以把新年祝福留到初一的时候再发，元旦不如过年有空，正好可以整理一下人机关系。</p><p>发现自己原来偶尔也会思考关于合群的问题。</p><p>关于社交圈和社交软件推荐算法的小研究还在继续，希望可以写有意思的东西出来。</p><h3 id="5-生活习惯副本"><a href="#5-生活习惯副本" class="headerlink" title="5 生活习惯副本"></a>5 生活习惯副本</h3><p>刚回家一周就急性肠胃炎，瘫了整整一周，吃了一些药，好在美赛之前好的差不多了。作息太重要了，回家最重要的就是能克服这些阻碍，假期质量受到严重影响。</p><p>生病几天日记断了，什么也不想干。</p><p><strong>时间</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20212.jpg" alt="2月时间统计"></p><p>这个假期过的很放纵，慢慢习惯用块时间，但是每周的计划就全废了，记录得倒是很清楚，甚至可以看出自己在拜年走亲戚上花的时间可能不像自己想的那么多，有很多时间其实是可以转换到有意义的事情上的。</p><p>距离完全记录还差了一些，下个月的目标是记录80%，也就是576h。可以看到自己的复习时间，上课的时间。</p><p>考虑入手一个GoPro或者其他记录摄像头，美团小哥那种就不错，可以试着记录一下自己的一天。</p><h3 id="6-其他计划副本"><a href="#6-其他计划副本" class="headerlink" title="6 其他计划副本"></a>6 其他计划副本</h3><p><a href="https://henryavery.cn/2021/02/10/2021-nian-ji-hua/">2021年度计划</a></p><p><a href="https://henryavery.cn/2021/02/10/2020-nian-zhong-zong-jie/">2020年终总结</a></p><p>未完成</p><p><a href="https://henryavery.cn/2021/01/22/processing/">Processing</a></p><p><a href="https://henryavery.cn/2021/01/02/docker/">Docker</a></p><p><a href="https://henryavery.cn/2021/01/22/java/">Java学习笔记</a></p><p><a href="https://henryavery.cn/2021/01/01/ren-ji-gong-sheng/">人机共生</a></p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于日记。可能是刚开始使用电子日记，不太习惯写很多，没有那种纸笔写起来的顺畅，可以回忆的东西也少了很多。</p><p>第二件事，关于学习。我又发现一个适合自己的学习方法，那就是把学习计划压缩在一个比较密集的时间里，比如有空就花三天看完机器学习课，但这需要极度集中的精神，除了长假以外真的很难还有这样的时间完全投入到一件事情上面。</p><p>第三件事，关于演讲。“但凡有面对两个或以上的人说话，就是在演讲。”第一次记录自己演讲的样子，一遍又一遍地看，发现自己身上存在的问题。只有了解自己，才能改变自己。一共录了九十多遍，中午连饭都没吃，一直录到下午结束，不得回家收拾行李，很认真的去做一件自己以前好像从来没认真做过的事情。</p><p>第四件事，关于阅读。看了太多的网络小说，明明自己有那么多书可以看，结果都只看了一本《自私的基因》。这个寒假的阅读量很少，阅读计划里的另外五本书其中两本刚买到手，另外三本打算去图书馆借。</p><p>第五件事，关于计划。这个月过的很没有章法的原因还是自己么有按照计划去执行。可能要从根源上去找原因，究竟是什么让自己不能面对现实。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视时app</title>
      <link href="/2021/02/16/shi-shi-app/"/>
      <url>/2021/02/16/shi-shi-app/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>一款用于记录命运的APP。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>从github仓库拉取到本地，Android要求路径不能有中文</p><h2 id="暂存资料"><a href="#暂存资料" class="headerlink" title="暂存资料"></a>暂存资料</h2><p><a href="http://hukai.me/android-training-course-in-chinese/input/gestures/multi.html" target="_blank" rel="noopener">处理多点触控手势</a></p><p><a href="http://hukai.me/android-training-course-in-chinese/" target="_blank" rel="noopener">Android官方培训课程中文版(v0.9.7)</a></p><p>mvvm</p><p>sqlite</p><p>viewmode</p>]]></content>
      
      
      <categories>
          
          <category> 开发项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021的百日阅读计划1.0</title>
      <link href="/2021/02/10/2-4-yue-yue-du-ji-hua/"/>
      <url>/2021/02/10/2-4-yue-yue-du-ji-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="《CS：APP》"><a href="#《CS：APP》" class="headerlink" title="《CS：APP》"></a>《CS：APP》</h3><p>看了一下网络编程</p><h3 id="《傲慢与偏见》"><a href="#《傲慢与偏见》" class="headerlink" title="《傲慢与偏见》"></a>《傲慢与偏见》</h3><p>主人公是谁？达西？宾利？简？</p><h3 id="《维特根斯坦传》"><a href="#《维特根斯坦传》" class="headerlink" title="《维特根斯坦传》"></a>《维特根斯坦传》</h3><h3 id="《图解HTTP》"><a href="#《图解HTTP》" class="headerlink" title="《图解HTTP》"></a>《图解HTTP》</h3><p>第二章</p><h3 id="《算法导论》"><a href="#《算法导论》" class="headerlink" title="《算法导论》"></a>《算法导论》</h3><h3 id="《自私的基因》"><a href="#《自私的基因》" class="headerlink" title="《自私的基因》"></a>《自私的基因》</h3><p>2月已一刷，对ESS理论有了进一步的理解</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年度计划</title>
      <link href="/2021/02/10/2021-nian-ji-hua/"/>
      <url>/2021/02/10/2021-nian-ji-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="2021年度计划"><a href="#2021年度计划" class="headerlink" title="2021年度计划"></a>2021年度计划</h1><p><strong>关键词：自由</strong></p><blockquote><p><strong>”凡事应该尽可能使其简单到不能再简单为止。“</strong></p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/v2-3edd43e2e69739a0c4be482bfa263602_720w.jpg" alt></p><h2 id="大二夏季学期计划"><a href="#大二夏季学期计划" class="headerlink" title="大二夏季学期计划"></a><strong>大二夏季学期计划</strong></h2><p>ASC超算竞赛</p><p>Flutter开发app</p><p>NLP神经网络</p><p>Deep Learning吴恩达深度学习</p><p>ACwing算法</p><p>CSAPP专业书籍阅读</p><p>王道计网、OS</p><p>小程序比赛</p><p>创新项目</p><p>2021阅读清单2.0</p><p><strong>待办</strong></p><p>nlp跑代码</p><p>Python教程修订</p><p><strong>心有余而力不足</strong></p><p>Datawhale开源之Web开发</p><p>Datawhale开源之《统计学习方法》编写组</p><p>Linux</p><h3 id="日程"><a href="#日程" class="headerlink" title="日程"></a><strong>日程</strong></h3><table><thead><tr><th>日期</th><th>任务1（早上+上午）</th><th>任务2（周末+晚上）</th><th>阅读计划（其他时间）</th><th>额外任务（挤时间）</th><th>完成度</th></tr></thead><tbody><tr><td>第一周6.21-6.27</td><td>暑期大作业：游戏开发</td><td>吴恩达深度学习</td><td>《游戏改变世界》</td><td></td><td>1</td></tr><tr><td>第二周6.28-7.4</td><td>flutter</td><td></td><td>健身</td><td>paper；nlp</td><td>0.5</td></tr><tr><td>第三周7.5-7.11</td><td>flutter</td><td>ACwing</td><td>健身</td><td>策划</td><td>0.25</td></tr><tr><td>第四周7.12-7.18</td><td>游戏项目收官</td><td></td><td></td><td></td><td></td></tr><tr><td>第五周7.19-7.25</td><td>7.16<strong>开始军训</strong></td><td></td><td>《穷查理宝典》</td><td></td><td></td></tr><tr><td>第六周7.26-8.1</td><td></td><td></td><td>《CS：APP》</td><td></td><td></td></tr><tr><td><strong>7.29</strong></td><td><strong>暑假开始</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>第七周8.2-8.8</td><td>flutter</td><td>王道计网和OS</td><td>课本</td><td></td><td></td></tr><tr><td>第八周8.9-8.15</td><td>flutter</td><td></td><td>《CS：APP》</td><td></td><td></td></tr><tr><td>第九周8.16-8.22</td><td>flutter</td><td></td><td></td><td></td><td></td></tr><tr><td>第十周8.23-8.29</td><td>flutter</td><td></td><td></td><td></td><td></td></tr><tr><td>第十一周8.30-9.5</td><td>ASC</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>9.6</strong></td><td><strong>大三开学</strong></td><td></td><td>《labuladong算法小抄》</td><td></td><td></td></tr></tbody></table><blockquote><p>简单说一下自己一直想做的时间管理app。先自学一下flutter，把app做出来，起码页面逻辑和主要功能实现都要想好，这样数据可以直接本地展示，demo做好之后再复习一下Django开发后端的Web，最后考虑flutter开发Web端，把功能完善起来，形成一个闭环。之后就可以不停打磨，先不要加复杂的功能，第一步是把最主要最简单的东西弄好。</p><p>接着是比较重要的ASC超算竞赛，想先提前自学完王道的计网和操作系统，然后看一遍原版的《CS：APP》（学过机组之后再看其实内容也不难，主要是熟悉专业英语词汇，所以快速先看完网课，等开学再后自己刷刷题），接着一边继续深入了解ASC相关的知识实践。同时，这些计算机专业基础知识到app后端开发必定都会需要用到。</p><p>另一方面算法肯定也很重要，因为在ASC里也会用到算法优化，而且忍痛买了AcWing的算法基础课就要上完。夏季程序设计竞赛也得稍微准备准备。</p><p>然后ASC也会有机器学习相关的题目，nlp和cv的深度学习基本都要了解，偏重nlp方向，所以项目也要自己动手实践去做，这样才能学会东西。</p><p>如此看来，其实游戏开发课程是最不相关也是重要程度最低的了，莉莉丝公司那个比赛参加也就是重在参与，可不知道为什么就是不愿意水掉这门课，要对得起交的那300多块学费。</p></blockquote><h3 id="个人计划"><a href="#个人计划" class="headerlink" title="个人计划"></a><strong>个人计划</strong></h3><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a><strong>运动</strong></h4><p>500km，<strong>健身计划</strong></p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a><strong>阅读</strong></h4><p><a href="https://henryavery.cn/2021/02/10/2-4-yue-yue-du-ji-hua/">2021的百日阅读计划1.0</a></p><h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a><strong>写作</strong></h4><p>五篇认真的书评或者读书笔记</p><h4 id="专业学习"><a href="#专业学习" class="headerlink" title="专业学习"></a><strong>专业学习</strong></h4><p><strong>CS</strong></p><p>《算法导论》</p><p>操作系统</p><p>计算机网络</p><p><del>Flutter</del></p><p>Java</p><p>Linux</p><p><del>Docker</del></p><p>MySQL</p><p>Go</p><p>NLP</p><p><del>吴恩达《深度学习》</del></p><p><strong>数学</strong></p><p>吴军博士在《数学之美》中这样描述：</p><blockquote><p>牛顿曾经说过，“真理在形式上从来都是简单的，而不是复杂和含混不清的”，数学之美也体现在这里。如果你能拿数学工具来解决问题，那么不管你的方法多复杂，这里面的基本思想都应格是简单的。</p></blockquote><p>查理芒格也说过：</p><blockquote><p>最好且最实用的智慧是最基本的学术智慧，但有一个相当重要的前提：必须从多元学科的角度来思考。在生活中应时常运用大学一年级基础学科中所有易学好懂的概念，如果达到自如运用的境界，就能提出解决问题的多种方法。</p></blockquote><p>实变函数与泛函分析</p><p>复习线性代数</p><h4 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a><strong>课外学习</strong></h4><p>《微观经济学原理》</p><p>《宏观经济学原理》</p><h4 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a><strong>英语学习</strong></h4><p><a href="https://zhuanlan.zhihu.com/p/359945906" target="_blank" rel="noopener">小天爷学英语</a></p><h4 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a><strong>兴趣</strong></h4><p>视频剪辑</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a><strong>资源</strong></h3><p><strong>bilibili大学</strong></p><p><a href="https://www.bilibili.com/video/BV1kE411E7HX?from=search&seid=1448930925957729165" target="_blank" rel="noopener">b站信息论</a></p><p><strong>关于考研</strong></p><p><a href="https://www.hackslog.com/blog/Life/about-PG-entrance-exam.html#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">关于考研灰熊的博客</a></p><p>清北复交</p><p><strong>信息管理</strong></p><p>了解GSOC相关信息</p><h2 id="大二春季学期计划"><a href="#大二春季学期计划" class="headerlink" title="大二春季学期计划"></a><strong>大二春季学期计划</strong></h2><p><strong>比赛or考试</strong></p><p>大英赛</p><p>英语六级600+</p><h3 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h3><h5 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a><strong>专业课</strong></h5><hr><p><strong>数据结构2</strong></p><p>46开</p><p><strong>离散数学2</strong></p><p>28开</p><p><strong>矩阵代数与应用</strong></p><p>37开，开卷考试（？）</p><p><strong>信息论</strong></p><p>37开，闭卷考试</p><h5 id="专业选修"><a href="#专业选修" class="headerlink" title="专业选修"></a><strong>专业选修</strong></h5><hr><p>大数据：从理论到实践</p><p>第五周reading paper（10p），第九周pre，考试周term paper（20p）</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210402203942530.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210402204108831.png" alt="image-20210402204108831"></p><h5 id="通选课"><a href="#通选课" class="headerlink" title="通选课"></a><strong>通选课</strong></h5><hr><p>人工智能与认知科学</p><p>《禅与摩托车维修艺术》读书笔记</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203134.jpg" alt></p><p>投资与理财</p><p>《穷查理宝典》读书笔记</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203032.jpg" alt></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h5><hr><p>人工智能进展</p><p>个人报告＋小组研讨</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203122.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203131.jpg" alt></p><p>欧洲文化入门</p><p>考试和上课无关，书前两章，背题库</p><p>乒乓球</p><p>左推侧身右攻，30km，五次课外，第二周开始</p><p>思政实践</p><p>略</p><h3 id="其他计划"><a href="#其他计划" class="headerlink" title="其他计划"></a>其他计划</h3><p>创新项目</p>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年终总结</title>
      <link href="/2021/02/10/2020-nian-zhong-zong-jie/"/>
      <url>/2021/02/10/2020-nian-zhong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年终总结（2-15）"><a href="#2020年终总结（2-15）" class="headerlink" title="2020年终总结（2.15）"></a>2020年终总结（2.15）</h1><p><strong>关键词：原点</strong></p><h2 id="一、结语"><a href="#一、结语" class="headerlink" title="一、结语"></a>一、结语</h2><blockquote><p><strong>“如果一个人和同伴的步调不一致，也许因为他听到的是不同的鼓点。让他跟着他听到的音乐前行吧，不管节奏是迟缓还是激越。”</strong></p><p>——<strong>梭罗</strong></p></blockquote><h2 id="二、年度计划及目标"><a href="#二、年度计划及目标" class="headerlink" title="二、年度计划及目标"></a>二、年度计划及目标</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><p>专业学习：选择专业，智能科学与技术，进入大二，开始正式学习专业课程，找到适合自己的学习方法，课前预习，课上刷题自学，总的来说还是自己还是很喜欢这个专业。能在大学学习自己喜欢的专业真的很美好。</p><p>课外学习：YC创业课20h，边练英语听力边学完。乐理课没上，但是在校内上了一门外国经典音乐，算是半只脚入门了古典，很喜欢莫扎特。地理知识还是没能补上，应该和科幻概论配套写作一起，主要是却写作素材，但是由于写作中断了所以这门课也不了了之。</p><p>科幻概论上了几次就没看了，也不是没时间，也不是不感兴趣，本来打算休闲的时候看一看，结果课外时间都浪费在了其他地方。</p><p>英语学习：练习口语以及思考学习英语的目的，制订了大学四年出国的英语学习计划，但是因为种种原因，只能先搁置，另辟蹊径，着眼于当下，半年之中仍未找到完整且可行的英语学习计划。所幸大一一年结束后仍在不同方面有巨大收获。百词斩上把六级托福考研单词也过了一遍，就是背完就忘了，真的不如墨墨背单词，单词主要还是要有复习和口头记忆。《新概念3》背一背也还不错，用得好的话是不错的英语资料，可惜后半年就没有再碰过了。</p><p>后半年重新开始使用app背单词，考过了一次四级，大二在学校里每天中午还经常做点阅读练习，可惜早上没有再坚持去食堂早读，冬天太冷了，返校四个月一眨眼就过了，这让我明白了一个道理，假如你么有一个良好的学习习惯，那就只能眼睁睁地虚度光阴。</p><h4 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h4><p>史蒂芬·柯维博士的《高效能人士的七个习惯》就是今年对我影响最大的书，没有之一。当然今年还有很多其他新读的书籍可能也一样重要，比如《原则》和《穷查理宝典》，可是最终都落在了这本书上，如果用一本书来代表我上半年来读的大部分书，那一定是《高效能人士的七个习惯》，因为我从一月份读到这本书，到了六月份仍在读这本书，并且依照此书开始制订出了我的人生系统1.0并且改进到了2.0。</p><h5 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h5><p>《一路向前》关于星巴克，卖咖啡的霍华德·舒尔茨，书中叙述了2007~2010年舒尔茨回归期间，在<em>星巴克</em>内外的一系列令人叹为观止的变革以及<em>星巴克</em>如何一如既往地坚守价值观以重新实现赢利和可持续发展的故事。</p><p>《考拉小巫的英语学习日记》学英语的，鸡汤味有点重，但确实有用，高中第一次读到这本书的还是同桌带到学校来的，让我和他一样对英语学习有了一种自信和执念。</p><p>《创意实现》创新创意的，帮助我写了大一的新研论文，属于用完即弃。</p><p><strong>《高效能人士的七个习惯》这半年最具有代表性的书</strong></p><p>《写给大家看的设计书》关于设计，生活中处处都有设计，我喜欢创作，但对于设计并不上心，直到有一天我真的用得上这些简单又实用的设计理念，需要别人告诉我什么样的设计才是好设计的时候，我才幡然醒悟自己居然忘记了这些简单的设计原则。</p><p>《原则》关于原则，每个人其实都有他们的原则，有一些成功的人会写下自己的原则，还有一些人会帮那些成功的人总结原则，但是古往今来，总有一些普世的原则需要遵守，结合《高效能人士的七个习惯》看完了前半部分，大概能够理解书中意而不用去记住书中具体细节，所以我一直觉得后半部分现在不需要花时间去读，如果哪天真的需要了，它一定再会出现在我的手边。</p><p>精读：</p><p>《滚雪球》关于股神巴菲特，我觉得这个世界上成功的人也分几种，一种是像巴菲特、比尔盖茨他们这样的，而另一种则是像富兰克林、曾国藩这样的。写了一篇书评，拿人物传记练习写书评，其实要写好难度也很大。我读传记有个小习惯，喜欢人物代入，揣摩人物心理变化，并且会关注书中出现的那些对于人的描写和形容词，一般褒义的形容词以后就可以记下来以后拿去夸别人，学习如何对他人给出评价并且称赞也很有意思。</p><p>《如何阅读一本书》关于阅读，每个人阅读之前应该阅读的第一本书，可能每一个喜欢阅读的人都会读过这本书，有时候共同语言就是这么来的，其实过完一年很容易就忘了书中的那些具体方法，但是大致的轮廓心中还是有的。</p><p>而且我发现如果要训练自己的阅读能力，换一种语言也是不错的尝试，比如阅读英文原版书，然后再按照《如何阅读一本书》的方法去进行阅读，可以感受到使用中文阅读时完全不同的阅读体会，而且我从今年开始对照译本阅读英文原版的时候，也会发现自己学习英语的乐趣增加了不少，所以决定在之后的阅读计划，除了由于我的英语能力还不足以进行原文阅读的原因外，不会再只读翻译的书籍了，读原版书一边也是在学英语，所以阅读速度慢一点也无所谓，但是要有方法地进行阅读。</p><p>重读：</p><p>《富兰克林自传》关于美国国父，通才，我的精神导师之一。一遍又一遍地重读这本不厚的自传，恨不得早点读过，但同时又会想假如真的在很小的年纪就阅读到这本传记，缺少了自己如今的思考，很可能不是一件好事，这点让我很矛盾。</p><p>《财务自由之路》关于赚钱，书的封面是7年赚到1000万，假如一个人18岁总的资产是10万，包括各种资源算进去，那么只要他的资产每年翻一番，7年就是128倍，等他25岁资产就能到一千万。</p><h5 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h5><p>略读：</p><p>《写给大家看的设计书》关于设计，设计的四个基本原则，从这本书学习一些简单的设计理念，还有“知其名”的意义。不管是一个概念还是一个人，只有你知道他的名字，你才能记住他。</p><p>《创业维艰》关于创业，大致翻了翻，主要是看本·霍洛维茨的创业故事，哪些具体的建议现在不打算看，等以后配上Stanford的创业课一起看，里面有一章“一对一沟通交流”，之前有问题找人沟通的时候确实有用到，就是一个提问指南，要用的时候才有用，用过了就记住了，用不上的话很快就忘了。就是这样的。</p><p>《鼠疫》因为这次肺炎流感才又找出来看的，很久没看这种文学书了，自己写作之后读文学能感觉到作者更多的东西，后面还听了文学院教授关于《鼠疫》的线上讲座，受益不少，虽然中午听睡着了。</p><p>《剑来》说好了和网络小说绝交，想了想这本书可能和其他网络小说还是有些不同的地方。主要是作者把传统哲学理念融入进了小说，我以前从没想过能把心学写进小说里，所以喜欢这种叙述方式，还有书中人物的知行合一和一些简单却深入人心的道理。但网络小说真的挺荼毒人的，都2021了还在更，虽然陈振华一个月也就写那么点，不像其他网络作家，每个月花两三个小时就能看完。但是每天早上起来追着看也真没啥意思，不如等他写完再看好了，从年初追到年尾不值得。</p><p>精读：</p><p>《海盗、囚徒与麻风病人：关于正义的十二堂课》，关于正义，读的第一本和法律有关的书，作者是一位宾夕法尼亚的刑法学教授，讨论在各种极端情况下生存与正义的平衡，除了法律和道德，我还从中了解了很多中国以外的历史，以及维根特斯坦的哲学理念，虽然还不是很懂，有点类似心学的知行合一。ps：喜欢Henry Avery这个英文名，所以就拿来自己用了。</p><p>《我跑步的时候谈什么》关于跑步，一本不是自传的自传，讲了一个跑步小说家对跑步和写作的一些看法，村上春树说出了写作和跑步的共同点。我也一样喜欢写作和跑步，所以从他那里学到不少。可惜今年后半年跑步运动少的可怜，比前半年还要少。</p><p>《沉默的大多数》关于写作，最喜欢的中国作家还是王小波，仿写波哥的杂文，喜欢这种幽默又带点讽刺的文风。</p><p>《鞋狗》关于Nike，奈特卖鞋发家的故事。对于这个人人熟知的品牌有了新的全面认识，从此Nike在我心里不再仅仅是一双鞋那么简单了。</p><p>重读：《如何阅读一本书》</p><h5 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h5><p>略读：《剑来》《我有一座恐怖屋》</p><p>想阅读这种无脑小说，就跟打游戏差不多，会导致各个方面的衰退，听有声书也有可能向小说发展，所以不能三心二意，该做什么就做什么，给自己点放松当奖励没问题，只是不要再边做其他事边学习了，这个原则和某条人生宪法一样，需要花大力气去克服。在学校每天都靠着耳机催眠入睡，十几二十分钟的也不是不行，只是自己很烦这种不算好的小习惯，索性下定决心慢慢戒掉。</p><p>精读：《中华帝国的衰落》书评</p><p>少了一篇书评，原因是没看完，睡前阅读的好习惯，读累了就睡，早上起不来就提醒一下早十分钟睡，睡不着就看书，起不来就早睡。</p><p>重读：《富兰克林自传》《三体》关于科幻，从小就很喜欢科幻小说，长大了也想写科幻小说，听说科学家的想象力不输科幻小说家，我觉得是真的，所以也想当一个能写科幻小说的科学家。</p><h5 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h5><p>略读：《诡秘之主》完结了，没啥看的。</p><p>精读：《邓小平时代》关于时代，对当代中国影响巨大的伟人，有一副脑图聚沙成塔就差这一点了。</p><p>重读：《浪潮之巅》《智能时代》选择专业，行业分析，吴军老师是影响我青年时期最大的作家之一，高中买了很多他的书，大学又买了他在得到APP上的课程，是一笔不小的投资，但是我觉得真的很值得。</p><h5 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h5><p>略读：《中国哲学简史》关于中国哲学，从某种意义上来说，中国哲学替代了宗教的作用。平时我们在写作和交流中也会聊到哲学，而我作为一个理工科的学生，在这一块的通识教育上还是又些欠缺的，要自己补上，这一点也是向吴军老师学到的。</p><p>精读：《今日简史》关于历史，世界历史以及应对今日危机。微信读书APP上看完的第一本电子书，用起来做笔记也很方便，只是不如第一次读《人类简史》那么震撼了，可能是边际效应递减了吧。</p><p>重读：《剑来》小说</p><h5 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h5><p>略读：《守夜者3》无聊，想起高考考数学前几天晚上好像还在看秦明写的《守夜者2》，这些中国的推理小说我真的不喜欢。</p><p>《白夜行》一年都只看这一本东野圭吾的书，日本人对于人心复杂社会黑暗的深刻描写，自己之前评价得好像还挺中二的，但我也不是很认真地评论，说实话，这本书打分高还是又理由的，只是我说不出一二三来了，读过也就读过了。</p><p>《洛克菲勒自传》又是传记，窥探上帝秘密的男人，还有他写给儿子的二十八封信。</p><h5 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h5><p>《Python从入门到实践》关于编程，对于专业相关的书在我没有达到一定的水平前不作任何评价，仅做简单的阅读记录和收获。</p><p>《钢铁枪炮与病菌》关于世界，世界为什么会是这个样子？探讨“终极”——地理决定论，一洲文运与武运。第一遍粗浅的阅读，还想尝试一下英文原版，没有多读几遍还是不要乱来，单词量太大了。</p><p>《创新者》专业素养，计算机技术发展史，创新者是一群什么样的人呢？</p><p>《围城》关于比喻之美，听说中国人不能不读，不然和别人沟通都会有困难，放假有空才可以多读点经典的文学书。</p><h5 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h5><p>略读：沃尔特·艾萨克森写的《富兰克林传》，进一步了解富兰克林本人。思考他传与自传，客观与主观。美国精神领袖之一，我比较想通过这本书了解他不曾在自传中提到的后半生。通过艾萨克森写的传记更加全面地了解他的一生，又或者是说，从别人的角度来看他的一生。</p><p>《剑来》小说，用典极多，前二十章人物及人心刻画及其传神，或情节略有网络小说特色，然仍有可取之处。</p><p>《中国哲学简史》关于儒释道，或许有人说冯友兰先生写的这本书全是抄的，但天下文章一“大”抄，怎么抄也是一门“大”学问。这本书最后一页有一句话让我印象深刻“<strong>人必须先说很多话，然后保持静默。</strong>”这本书带我初步认识了道家，了解道家思想，对比儒家思想，思考人类的未来，计算机的未来。</p><p>《旅行与读书》闲暇时翻阅，寥寥数语触动人心，旅行与读书，于人生的意义，于一个书呆子的意义。</p><p>《穷查理宝典》关于那个没有哪一天不读书的聪明人，查理·芒格的智慧。虽是相见恨晚，仍不愿快速读完。</p><p>《徐霞客游记》《夜航船》都是因为《剑来》所以才有兴趣动力去略读一二，不然就算接触到了也不会去找来看。</p><h5 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h5><p>略读：</p><p>《激荡三十年（上下）》关于商业，吴晓波作为财经作家的经历也很励志，书是借的反正看不坏，看多看少都是赚，刚回到学校没什么压力看书也很随意。</p><p>《上海早晨》关于上海大学的前世今生，还是社团发的书，不得不说很用心。</p><p>《通信之道》（专业需求）信号处理课带上不怕课听不懂，当初差点因为这本书想选通信专业。</p><p>精读：《人性的弱点》</p><p>重读：《数学之美》关于专业，可能正是因为在高中时读吴军老师这本书读的一知半解，所以我才有了今天这样的专业选择。</p><h5 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h5><p>《奇特的一生》讲述了一个将自己一生时间用来做计划的人。前苏联的柳比歇夫从26岁起便树立起自己在科学领域要完成的目标，并且此后一生都在为此计划。这一计划就是56年，直到他82岁去世，没有一天间歇。</p><p>柳比歇夫的自律和他的时间统计法可能不由得会让人想起曾国藩，他们也许从骨子里是同一种人，或者说他们身上都有着某种共性，又或许这就是人性的一部分，在我们每个人身上都存在着。我们会对他们奇特或伟大的一生产生共鸣，是因为我们也想过好自己的一生……</p><p>想起来自从回学校之后就没怎么用过番茄TODO统计时间，觉得没有必要记录每分钟，只要做好该做的事情就好了，但其实都只是自己找的借口。结果是不会骗人的，自己的计划有没有完成自己知道。所以这四十几天过的很快，就好像是时间推着我走，而我却抓不住时间。</p><p>《毛泽东传》罗斯，不评。</p><p>每周都说看书的时间来看论文，结果就是啥也没看啊。</p><h5 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h5><p>由于一个月没认真读书（课本倒是看得不算慢），所以半夜做梦都会惊醒。好好反思。</p><h5 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h5><p>同上，没怎么认真看书，看得比较随便，没有笔记也没有方法和计划，跟大一状态完全相反。</p><h4 id="写作计划"><a href="#写作计划" class="headerlink" title="写作计划"></a>写作计划</h4><p>搁置</p><h4 id="健身计划"><a href="#健身计划" class="headerlink" title="健身计划"></a>健身计划</h4><p>上半年还算正常，下半年运动量少的可怜，虽然真要花时间认真健身还是很难，但我还是想要在大学本科毕业的时候让自己焕然一新，彻头彻尾地改变一下。400km大半都是上半年跑的，冬天明显发现跑起来体力有些不如春天了。健身房还是可以每周去的。</p><h4 id="公益计划"><a href="#公益计划" class="headerlink" title="公益计划"></a>公益计划</h4><p>寒假和暑假完成了几次读书会，虽然因为疫情的原因没有达到预期，但是这部分计划可以算是额外加分项目，而且志愿者也参与了一次，对于志愿活动我也有自己的思考。</p><h4 id="投资计划"><a href="#投资计划" class="headerlink" title="投资计划"></a>投资计划</h4><p>说是投资计划，其实还是重在理性消费以及对于学习的投资，本来计划的学习内容像一些经济学和投资理论的书都没时间去看，其实想想不浪费时间是可以看完一遍的。把时间投资在有意义的地方，这就是我的投资计划。</p><h4 id="生活计划"><a href="#生活计划" class="headerlink" title="生活计划"></a>生活计划</h4><p>早睡早起不知道多少天，还是要早上五点起来比较适合我的习惯，到了计算机学院发现大家很多都是夜猫子类型，我不想改变自己的作息。</p><p>每次在家都会感冒一次，真的一病傻仨月。</p><p>一些小习惯还需要改掉。</p><h3 id="目标完成度"><a href="#目标完成度" class="headerlink" title="目标完成度"></a>目标完成度</h3><p>学业计划90%,绩点还差一些，需要提高目标。</p><p>阅读计划经调整变为专业书籍和英语原版书导向，总的来说可以达到70%的满意度，可以根据实际情况再调整。</p><p>写作计划20%，基本上完全搁置，不过有了自己的博客，对于写作的本身理解仍需要加深，早起写作和练英语可以尝试交替进行。</p><p>运动计划30%，同上，还是需要把运动当成爱好和习惯，可以不用太关注太高的目标和要求，但是要坚持，直到运动成为吃饭和喝水一样正常的习惯。</p><p>课外学习50%，还是少了点意思，制定计划的时候没考虑结合专业，由于专业特殊，课外可以学一点有用的专业技能。</p><p>人际关系50%，更改了一开始制定的计划，留待以后完成。</p><p>投资计划，不太好衡量，才发现这个okr一开始设计的时候就没考虑周全。</p><p>工作计划，同上。</p><h3 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h3><p>前半年时间记录用的番茄TODO，发现不太适合在校使用，索性换成块时间，在家记录起来也很方便，另外自己也在准备开发复盘和时间信息记录的APP工具了，等自己学会开发之后就打造一款自己专属的时间管理工具。</p><p>一年花了365h在b站上还是很恐怖，使用b站还是因为居家学习开始的，不知不觉成了重度使用者，每天大概有一个小时花在了屏幕上看一些没意义的视频，这让我自己都很难接受。在上面看电影也看的有点多，电影对于我来说基本上也只是打发时间的东西。</p><h2 id="三、每月复盘"><a href="#三、每月复盘" class="headerlink" title="三、每月复盘"></a>三、每月复盘</h2><p>一月：原则</p><p>二月：自律</p><p>三月：分心</p><p>四月：愚人</p><p>五月：断片</p><p>六月：考试</p><p>七月：蜕变</p><p>八月：散人</p><p>九月：CS</p><p>十月：时停</p><p>十一：刷番</p><p>十二：惜时</p><h2 id="四、角色扮演消化"><a href="#四、角色扮演消化" class="headerlink" title="四、角色扮演消化"></a>四、角色扮演消化</h2><p>大二学生：</p><p>专业：</p><h2 id="五、总结反思"><a href="#五、总结反思" class="headerlink" title="五、总结反思"></a>五、总结反思</h2><p>2020对我来说是关键的一年，但我收获的不是更多的喜悦，而是很多很多“正确的失败”。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021一月复盘</title>
      <link href="/2021/01/30/2021-1/"/>
      <url>/2021/01/30/2021-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一月复盘（1-30）"><a href="#一月复盘（1-30）" class="headerlink" title="一月复盘（1.30）"></a>一月复盘（1.30）</h1><h2 id="本月关键词：原点"><a href="#本月关键词：原点" class="headerlink" title="本月关键词：原点"></a>本月关键词：原点</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“物来顺应，未来不迎，当事不杂，过往不恋。”</strong></p><p><strong>——曾国藩</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>上课</strong></p><p>数据结构：这次小组作业真是太让人不放心了，好像多学点算法啊!!</p><p>机组：王道的书真好用，上课听不懂多刷题就完事了，有空刷刷csapp就当课外书看</p><p>概率论：刷题真有意思</p><p>离散数学：希望多学一点</p><p>英语：每周练一次听力，最后一周回来了忘了少了一次，后面补上。本来按计划是每天做一篇翻译题，到了一月底都还没开始做过。但是发现在阅读英语原版书的对照中文书阅读也可以训练翻译，觉得很多地方真的翻译的特别巧妙，在这之中体会到学习语言并使用的乐趣。养成了每天背英语单词的习惯，重新开始使用墨墨背单词app，从一百个加到两百再到三百，现在每天大概用四十分钟去复习两百个单词并且学一百个新词，<strong>一个月坚持下来能感受到效果</strong>，在看TED，做阅读或者听英语的时候经常碰到新学的六级单词，这种“眼熟”的感觉非常好，要继续努力学英语，争取大二过完六级前再准备一下雅思，以考促学。</p><p>六级阅读题，做了一周，被打断暂停了，下个月重启刷题，每天学两个小时英语。下个月英语单词应该也到了复习阶段了，可以多做点阅读使用起来。单词规划了3700个，平均每天100个寒假结束应该能到6k才对。那样返校之后正好就可以开始雅思的单词副本了。</p><p><strong>学习</strong></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113446714" target="_blank" rel="noopener">SHU机组实验</a></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113407044" target="_blank" rel="noopener">吴恩达机器学习</a></p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>30km，2021年运动副本预热，放假前后没有怎么运动，寒假里过年要加强锻炼了。1km居然跑了三分五十秒，比起去年还要慢了，没能用上全力，大冬天的嗓子还是不太舒服，小命要紧。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>《穷查理宝典》现学现用。</p><p>《TED演讲》一边上吴笑老师的演讲课一边看书加深记忆，我一直觉得光上课不算学习，必须自己动手写一写，起码也得有本书在手上划一划才算是自己的学习。</p><p>《自私的基因》，一本不可多得的好书，目前还没读完，希望可以慢点读，同时找来了英文原版书也是很好的阅读材料，从今年开始正式开始阅读英文的原版书开始，渐渐喜欢上了这种原汁原味的阅读。</p><p>《游戏改变世界》，完整的去读这种畅销书已经没有意思了，读一点英文正好可以训练关键信息提取，感觉有意思的地方也可以读久一点，就当做英语阅读。 </p><p>或许我也该调整自己的阅读计划了：一个月挑选两本书比较合适，而且必须有一本是和专业有关的。</p><p><strong>写作</strong></p><p>开了巨多篇博客的坑，等着2021去填，比如2021新年计划</p><p><a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于一瓶水</a></p><p><a href="https://henryavery.cn/2021/01/01/ren-ji-gong-sheng/">《人机共生》</a></p><p>每个周日的晚上都是想着第二天早点起床好写博客，结果就都是起不来，要么就是起来了做其他事情去了。</p><p><strong>观影</strong></p><p>看了一下自己这个月居然花了43个小时在娱乐上，其中一半是在b站看电影，之所以在b站是因为不小心冲了个流量送的大会员，然后另一半时间可能也都是在b站上看动漫了。统计一下看的电影，下个月要收敛一点，有更重要的事情要做。</p><p>《我和我的祖国》《动物世界》《魔鬼代言人》2021元旦第一天，放松一下充充电可以理解，完全就是静不下心复盘总结，总来想找件事来分散一下精力和精神，打发一下时间。最起码别伊始就像无头苍蝇一样乱撞，等自己慢慢缓过来。</p><p>《黑客帝国2》《黑客帝国3》很老的片子了，把计算机系统变成科幻电影脑洞真的大，计算机专业看这部电影真的时不时会心一笑。</p><p>《达拉斯买家俱乐部》也是很好的一部片子，重温了一遍《我不是药神》（发现自己第一次看的时候太感动了最后结尾没看明白，错过了不少细节）看到有人评论说这部电影，发现两部电影主题其实都是类似的，关于人性主题的电影往往都很复杂，但是拍出来也更容易打动人心。</p><p>《入侵华尔街》下饭片，没有英文字幕，不太好练英语，以后不看没字幕的片子。</p><p>《我不是传奇》《僵尸世界大战》无脑片，而且还不下饭，这种末世片我是真的不想再看了，但是每次过一段时间无聊了又会想找这种电影来打发时间，其实还不如看书有意思。</p><p>《传染病》回家高铁路上看的，看电影果然是打发时间的好方式，两个小时在车上读书是很累的，看电影就很轻松了，而且由于和现实有重叠部分，看这部片子也不会无聊。</p><p>《姜子牙》下饭，点了个外卖看了一中午，其实我觉得再好的电影也都是用来打发时间的，就跟有时候刷b站一样，本来就是抱着打发时间的目的去的，所以也要有所把控。</p><blockquote><p>好家伙，这四十个小时都够我看完三四本书了，要是把时间利用起来看一遍《CSAPP》该有多好</p></blockquote><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>还真是不如拿着钱买一台新电脑，买点新软件也行，比如MarginNote3。</p><p>认识一个喜欢炒币的朋友，从他那里了解了一些关于比特币和区块链的知识，也是第一次在现实中看到有人炒比特币。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>新年还是花点心思群发一下祝福好了，想闲聊一下的正好也可以聊聊最近发生的事情，不要忘了积极主动的原则。也正好可以趁着新的开始梳理一下以前的人际关系，加的好友越来越多，反而更加需要上心，就当是另一种历练了。</p><p>研究关于社交网络的推荐算法，从量变引起质变，但我对线上社交的看法仍旧没有改变，除了扩大我们的社交圈以外没有更多的实际意义，人类的基因只允许我们和148个人有交集，因此对越是交往密切的人越应该保持慎重的态度。</p><p>这个月有很多比赛都在准备当中，因此花了不少时间在和同学讨论，放假以后更是一到周末晚上就得准备开线上会议。我不喜欢等到晚上再来讨论或者开会，因为白天时间其实更加充裕一些，晚上总是会有自己的事情要做，而且让大家为了会议去熬夜得不偿失</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>早睡早起，偶尔出现打卡不起的情况，特别是回家以后，每天睡眠时长长达8个多小时，放松一周就差不多了，接下来的一年都要按照十点半早睡，五点早起的作息来完成早睡早起的flag。</p><p>每天起床做俯卧撑，微习惯。</p><p>每天看一个TED，时长无所谓，短一点五六分钟，长一点十七八分钟都可以，重要的是每天接触一些没有接触过的信息，我认为TED演讲是一个很好的思想传播平台。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210130215234.jpg" alt="每天睡足8小时"></p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>2021年的新年计划1.0</p><p>对后面的大学学习做出了计划，分别对考研和保研做出了大致的规划和相应的了解。考虑再多加一条出国的路子备用，作为一个男人一定要小心，永远不能大意，给自己留后路就是要留一手准备。</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于“日记”。时间信息管理，简称“日记”。新年新气象，开始使用新的工具——块时间app——记录自己的时间，整理信息，日记也开始尝试用电子日记，甚至开始考虑自己开发软件帮助自己管理时间和信息，寒假里正好和同学开发移动应用，学习一下如何使用flutter，前端和数据库，希望能学以致用，知行合一。</p><p>奥卡姆剃刀：如无必要，勿增实体。</p><p>KISS：keep it simple and stupid</p><p>第二件事，关于阅读。原汁原味的英语阅读打开的一扇新的门，换一种语言反而能从基础开始训练自己的阅读能力。做一下100天的阅读计划，挑选六本书，不一定要每本都看完，提前计划，临时调整。我对于今年的阅读计划有一个简单的期望，就是多读一点专业书，其他的杂书如果要读那就读英语，但是不可以完全替代掉做英语阅读题，起码的刷题训练还是要的，希望自己可以喜欢上英语阅读。</p><p>第三件事，关于计划。对于2021有一个简单的启动计划，掏出一页纸总结去年的大目标，再根据大学四年的计划看看有哪些出入需要调整，写下2021年的几个大的目标，这就是我的新年仪式。等过年几天有空抽时间再整理一下，做成一年的计划。寒假也一样有寒假的计划，由于寒假时间太短，能够做的其实也不多，考试复习计划是其中重要的一部分。大学后面两年的学习计划也已经大致规划好了，接下来可以全力朝着一个方向努力，慢慢完成计划中的每一个环节。</p><p>第四件事，关于作息。睡了250个小时，好家伙，真就每天睡到8小时。施瓦辛格说过，如果你说你每天要睡8h，那就请睡“快”一点吧。其实我完全可以每天睡六小时就够了，回到家之后每天睡到超过早上五点半起床反而更困难，第一天回来睡到五点自然醒状态就很不错。我理想中的时间规划就是这样的，每天24h，工作或者说上课学习花去10h（其实每天平均两三堂课最多不过6h），路上花去两小时，那么如果睡六个小时的话，每天就能够有六个小时自己安排：2小时运动，2小时学英语（包括阅读和口语），1小时阅读，1小时写作。</p><p>第五件事，关于成长。我想说的成长是指专业学习上的成长，在大学里总有一种错觉，就是自己会怀疑自己是不是学的东西太少，学的还不够深，不够多，转而觉得时间不够用。其实这是一个很没有意义的事情，还不如去想想要怎么才能更好地利用时间。这一年里自己的成长好像也不是很大，有一部分原因可能是在家里蹲太久了，我一直觉得人只要呆在学校里就会受到教育，然而疫情导致我家里蹲的半年过的很没有章法，就好像成长的高速公路上突然堵得车水马龙了一样，这大概是我一辈子都不会忘记的经历。因为它带给了我惨痛的教训。</p><p>第六件事，关于思考。思考是训练大脑中的模型和框架，将参数调优。但是思考只是思考，没有输入有就没有输出，模型再优秀也是要拿来解决问题的。只有知行合一，才是真正的思考。</p><p>第七件事，关于人生。人生宪法是一个很神奇的东西，它会在某一个瞬间提醒我什么事情该做什么事情不改做，往往就是一个难以抉择的瞬间，它给我带来了启示和方向。一个人一辈子会读很多书，遇见很多人，很多事，但是每次遇到新的选择时都会需要进行新的抉择，而不是照搬过去的经验。就好像机器学习中的线上学习模型一样，会不断根据最近的输入去调整数学模型，然后去给出当前问题的答案。有时候我真的很需要人生宪法，它就像是老师，不经意地给我带来只言片语，却能帮助我找到自己的前进的方向。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p><a href="https://henryavery.cn/2021/01/22/2021/">寒假计划</a></p><p>100天阅读计划</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达的机器学习课程笔记</title>
      <link href="/2021/01/25/ml/"/>
      <url>/2021/01/25/ml/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习"><a href="#吴恩达机器学习" class="headerlink" title="吴恩达机器学习"></a>吴恩达机器学习</h1><blockquote><p><strong>几乎每一个和我讨论过的人都同意，人生的最糟糕时期是在11岁到14岁。——《黑客与画家》</strong></p></blockquote><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>课程</p><p><a href="https://www.bilibili.com/video/BV164411b7dx?p=1" target="_blank" rel="noopener">b站[中英字幕]吴恩达机器学习系列课程</a></p><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习</a></p><p><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera深度学习</a></p><blockquote><p>主成分数据选择那里有一节课没有字幕，建议移步Coursera</p></blockquote><p>黄海广笔记</p><p><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener"><strong>Coursera深度学习教程中文笔记</strong></a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>斯坦福大学2014（吴恩达）机器学习教程中文笔记</strong></a></p><h1 id="第0天"><a href="#第0天" class="headerlink" title="第0天"></a>第0天</h1><p>搜集信息，注册Coursera，申请奖学金，安排学习计划。（2h）</p><h2 id="引言-Introduction"><a href="#引言-Introduction" class="headerlink" title="引言(Introduction)"></a>引言(Introduction)</h2><h3 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1.1 欢迎"></a>1.1 欢迎</h3><p>参考视频: 1 - 1 - Welcome (7 min).mkv</p><p>第一个视频主要讲了什么是机器学习，机器学习能做些什么事情。</p><h3 id="1-2-机器学习是什么？"><a href="#1-2-机器学习是什么？" class="headerlink" title="1.2 机器学习是什么？"></a>1.2 机器学习是什么？</h3><p>第一个机器学习的定义来自于<strong>Arthur Samuel</strong>。他定义机器学习为，在进行特定编程的情况下，给予计算机学习能力的领域。<strong>Samuel</strong>的定义可以回溯到50年代，他编写了一个西洋棋程序。</p><p>另一个年代近一点的定义，由<strong>Tom Mitchell</strong>提出，来自卡内基梅隆大学，<strong>Tom</strong>定义的机器学习是，一个好的学习问题定义如下，他说，一个程序被认为能从经验<strong>E</strong>中学习，解决任务<strong>T</strong>，达到性能度量值<strong>P</strong>，当且仅当，有了经验<strong>E</strong>后，经过<strong>P</strong>评判，程序在处理T时的性能有所提升。我认为经验<strong>E</strong> 就是程序上万次的自我练习的经验而任务<strong>T</strong> 就是下棋。性能度量值<strong>P</strong>呢，就是它在与一些新的对手比赛时，赢得比赛的概率。</p><p>目前存在几种不同类型的学习算法。主要的两种类型被我们称之为<strong>监督学习和无监督学习</strong>。此外你将听到诸如，强化学习和推荐系统等各种术语。这些都是机器学习算法的一员，以后我们都将介绍到，但学习算法最常用两个类型就是监督学习、无监督学习。我会在接下来的两个视频中给出它们的定义。本课中，我们将花费最多的精力来讨论这两种学习算法。而另一个会花费大量时间的任务是了解应用学习算法的实用建议。</p><h3 id="1-3-监督学习"><a href="#1-3-监督学习" class="headerlink" title="1.3 监督学习"></a>1.3 监督学习</h3><p>监督学习指的就是我们给学习算法一个数据集。这个数据集由“正确答案”组成。</p><p>回归这个词的意思是，我们在试着推测出这一系列连续值属性。</p><p>分类指的是，我们试着推测出离散的输出值：0或1良性或恶性，而事实上在分类问题中，输出可能不止两个值。</p><h3 id="1-4-无监督学习"><a href="#1-4-无监督学习" class="headerlink" title="1.4 无监督学习"></a>1.4 无监督学习</h3><p>所以这个就是无监督学习，因为我们没有提前告知算法一些信息，比如，这是第一类的人，那些是第二类的人，还有第三类，等等。我们只是说，是的，这是有一堆数据。我不知道数据里面有什么。我不知道谁是什么类型。我甚至不知道人们有哪些不同的类型，这些类型又是什么。但你能自动地找到数据中的结构吗？就是说你要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。</p><p>鸡尾酒宴问题</p><h1 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h1><h2 id="单变量线性回归-Linear-Regression-with-One-Variable"><a href="#单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="单变量线性回归(Linear Regression with One Variable)"></a>单变量线性回归(Linear Regression with One Variable)</h2><h3 id="2-1-模型表示"><a href="#2-1-模型表示" class="headerlink" title="2.1 模型表示"></a>2.1 模型表示</h3><h3 id="2-2-代价函数"><a href="#2-2-代价函数" class="headerlink" title="2.2 代价函数"></a>2.2 代价函数</h3><p>接下来我们会引入一些术语我们现在要做的便是为我们的模型选择合适的<strong>参数</strong>（<strong>parameters</strong>）</p><p>我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是<strong>建模误差</strong>（<strong>modeling error</strong>）。</p><p>我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。</p><p>代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。</p><h3 id="2-3-代价函数的直观理解I"><a href="#2-3-代价函数的直观理解I" class="headerlink" title="2.3 代价函数的直观理解I"></a>2.3 代价函数的直观理解I</h3><h3 id="2-4-代价函数的直观理解II"><a href="#2-4-代价函数的直观理解II" class="headerlink" title="2.4 代价函数的直观理解II"></a>2.4 代价函数的直观理解II</h3><h3 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h3><p>梯度下降是一个用来求函数最小值的算法</p><p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到找到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。</p><p>批量梯度下降（<strong>batch gradient descent</strong>）算法的公式为：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7da5a5f635b1eb552618556f1b4aac1a.png" alt="7da5a5f635b1eb552618556f1b4aac1a"></p><p>其中是学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/ef4227864e3cabb9a3938386f857e938.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/13176da01bb25128c91aca5476c9d464.png" alt></p><p>在梯度下降算法中，这是正确实现<strong>同时更新</strong>的方法。我不打算解释为什么你需要同时更新，同时更新是梯度下降中的一种常用方法。我们之后会讲到，同步更新是更自然的实现方法。当人们谈到梯度下降时，他们的意思就是同步更新。</p><h3 id="2-6-梯度下降的直观理解"><a href="#2-6-梯度下降的直观理解" class="headerlink" title="2.6 梯度下降的直观理解"></a>2.6 梯度下降的直观理解</h3><p>学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p><p>如果太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</p><p>如果太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果太大，它会导致无法收敛，甚至发散。</p><h3 id="2-7-梯度下降（gradient-descent）的线性回归"><a href="#2-7-梯度下降（gradient-descent）的线性回归" class="headerlink" title="2.7 梯度下降（gradient descent）的线性回归"></a>2.7 梯度下降（gradient descent）的线性回归</h3><p>实际上，在机器学习中，通常不太会给算法起名字，但这个名字”<strong>批量梯度下降</strong>”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有m个训练样本求和。</p><h2 id="线性代数回顾-Linear-Algebra-Review"><a href="#线性代数回顾-Linear-Algebra-Review" class="headerlink" title="线性代数回顾(Linear Algebra Review)"></a>线性代数回顾(Linear Algebra Review)</h2><p><strong>matlab</strong>中矩阵转置：直接打一撇，<code>x=y&#39;</code>。</p><h2 id="多变量线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多变量线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多变量线性回归(Linear Regression with Multiple Variables)"></a>多变量线性回归(Linear Regression with Multiple Variables)</h2><h3 id="4-1-多维特征"><a href="#4-1-多维特征" class="headerlink" title="4.1 多维特征"></a>4.1 多维特征</h3><h3 id="4-2-多变量梯度下降"><a href="#4-2-多变量梯度下降" class="headerlink" title="4.2 多变量梯度下降"></a>4.2 多变量梯度下降</h3><p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和</p><p>我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。 </p><p><strong>Python</strong> 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">computeCost</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">:</span>    inner <span class="token operator">=</span> np<span class="token punctuation">.</span>power<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">*</span> theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>inner<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-梯度下降法实践1-特征缩放"><a href="#4-3-梯度下降法实践1-特征缩放" class="headerlink" title="4.3 梯度下降法实践1-特征缩放"></a>4.3 梯度下降法实践1-特征缩放</h3><p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。</p><h3 id="4-4-梯度下降法实践2-学习率"><a href="#4-4-梯度下降法实践2-学习率" class="headerlink" title="4.4 梯度下降法实践2-学习率"></a>4.4 梯度下降法实践2-学习率</h3><p>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。</p><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率a过小，则达到收敛所需的迭代次数会非常高；如果学习率a过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p><h3 id="4-5-特征和多项式回归"><a href="#4-5-特征和多项式回归" class="headerlink" title="4.5 特征和多项式回归"></a>4.5 特征和多项式回归</h3><p>注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。</p><h3 id="4-6-正规方程Normal-Equation"><a href="#4-6-正规方程Normal-Equation" class="headerlink" title="4.6 正规方程Normal Equation"></a>4.6 正规方程Normal Equation</h3><h2 id="Octave教程-Octave-Tutorial"><a href="#Octave教程-Octave-Tutorial" class="headerlink" title="Octave教程(Octave Tutorial)"></a>Octave教程(Octave Tutorial)</h2><p>现在大家都用python了，octave不想再浪费时间去搞了，反正作业可以用matlab一样可以做。5.6向量化看一下，当你使用向量化地实现线性回归，通常运行速度就会比你以前用你的<strong>for循环</strong>快的多，也就是自己写代码更新。</p><h1 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h1><h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h2><h3 id="6-1-分类问题"><a href="#6-1-分类问题" class="headerlink" title="6.1 分类问题"></a>6.1 分类问题</h3><p>我们将学习一种叫做逻辑回归 (<strong>Logistic Regression</strong>) 的算法，这是目前最流行使用最广泛的一种学习算法。</p><p>我们从二元的分类问题开始讨论。</p><p>我们将因变量(<strong>dependent variable</strong>)可能属于的两个类分别称为负向类（<strong>negative class</strong>）和正向类（<strong>positive class</strong>），则因变量，其中 0 表示负向类，1 表示正向类。</p><p>顺便说一下，<strong>逻辑回归算法是分类算法</strong>，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上是一种分类算法</p><h3 id="6-2-假说表示"><a href="#6-2-假说表示" class="headerlink" title="6.2 假说表示"></a>6.2 假说表示</h3><p>逻辑回归模型的假设</p><h3 id="6-3-判定边界"><a href="#6-3-判定边界" class="headerlink" title="6.3 判定边界"></a>6.3 判定边界</h3><p>现在讲下决策边界(<strong>decision boundary</strong>)的概念。这个概念能更好地帮助我们理解逻辑回归的假设函数在计算什么。</p><p>我们可以用非常复杂的模型来适应非常复杂形状的判定边界。</p><h3 id="6-4-代价函数"><a href="#6-4-代价函数" class="headerlink" title="6.4 代价函数"></a>6.4 代价函数</h3><p>定义用来拟合参数的优化目标或者叫代价函数，这便是监督学习问题中的逻辑回归模型的拟合问题。</p><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将h()带入到这样定义了的代价函数中时，我们得到的代价函数将是一个非凸函数（<strong>non-convexfunction</strong>）。</p><p>这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p><p>我们重新定义逻辑回归的代价函数为</p><p>在得到这样一个代价函数以后，我们便可以用梯度下降算法来求得能使代价函数最小的参数了。算法为：</p><p>在这个视频中，我们定义了单训练样本的代价函数，凸性分析的内容是超出这门课的范围的，但是可以证明我们所选的代价值函数会给我们一个凸优化问题。代价函数会是一个凸函数，并且没有局部最优值。</p><p>注：虽然得到的梯度下降算法表面上看上去与线性回归的梯度下降算法一样，但是这里的${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$与线性回归中不同，所以实际上是不一样的。另外，在运行梯度下降算法之前，进行特征缩放依旧是非常必要的。</p><p>一些梯度下降算法之外的选择： 除了梯度下降算法以外，还有一些常被用来令代价函数最小的算法，这些算法更加复杂和优越，而且通常不需要人工选择学习率，通常比梯度下降算法要更加快速。这些算法有：<strong>共轭梯度</strong>（<strong>Conjugate Gradient</strong>），<strong>局部优化法</strong>(<strong>Broyden fletcher goldfarb shann,BFGS</strong>)和<strong>有限内存局部优化法</strong>(<strong>LBFGS</strong>) ，<strong>fminunc</strong>是 <strong>matlab</strong>和<strong>octave</strong> 中都带的一个最小值优化函数，使用时我们需要提供代价函数和每个参数的求导，下面是 <strong>octave</strong> 中使用 <strong>fminunc</strong> 函数的代码示例</p><h3 id="6-5-简化的成本函数和梯度下降"><a href="#6-5-简化的成本函数和梯度下降" class="headerlink" title="6.5 简化的成本函数和梯度下降"></a>6.5 简化的成本函数和梯度下降</h3><p>找出一种稍微简单一点的方法来写代价函数，来替换我们现在用的方法。同时我们还要弄清楚如何运用梯度下降法，来拟合出逻辑回归的参数。。因此，听了这节课，你就应该知道如何实现一个完整的逻辑回归算法。</p><p>最小化代价函数的方法，是使用<strong>梯度下降法</strong>(<strong>gradient descent</strong>)。这是我们的代价函数：</p><p>如果我们要最小化这个关于$\theta$的函数值，这就是我们通常用的梯度下降法的模板。</p><p>因此，即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p><p>在先前的视频中，当我们在谈论线性回归的梯度下降法时，我们谈到了如何监控梯度下降法以确保其收敛，我通常也把同样的方法用在逻辑回归中，来监测梯度下降，以确保它正常收敛。</p><p>最后还有一点，我们之前在谈线性回归时讲到的特征缩放，我们看到了特征缩放是如何提高梯度下降的收敛速度的，这个特征缩放的方法，也适用于逻辑回归。如果你的特征范围差距很大的话，那么应用特征缩放的方法，同样也可以让逻辑回归中，梯度下降收敛更快。</p><p>就是这样，现在你知道如何实现逻辑回归，这是一种非常强大，甚至可能世界上使用最广泛的一种分类算法。</p><h3 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h3><p>使通过梯度下降，进行逻辑回归的速度大大提高，而这也将使算法更加适合解决大型的机器学习问题</p><p>这三种算法有许多优点：</p><h3 id="6-7-多类别分类：一对多"><a href="#6-7-多类别分类：一对多" class="headerlink" title="6.7 多类别分类：一对多"></a>6.7 多类别分类：一对多</h3><p>如何使用逻辑回归 (<strong>logistic regression</strong>)来解决多类别分类问题，具体来说，我想通过一个叫做”一对多” (<strong>one-vs-all</strong>) 的分类算法。</p><p>我们先从用三角形代表的类别1开始，实际上我们可以创建一个，新的”伪”训练集，类型2和类型3定为负类，类型1设定为正类，我们创建一个新的训练集，如下图所示的那样，我们要拟合出一个合适的分类器。</p><p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。</p><h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化(Regularization)"></a>正则化(Regularization)</h2><h3 id="7-1-过拟合的问题-over-fitting"><a href="#7-1-过拟合的问题-over-fitting" class="headerlink" title="7.1 过拟合的问题(over-fitting)"></a>7.1 过拟合的问题(<strong>over-fitting</strong>)</h3><p>如果我们发现了过拟合问题，应该如何处理？</p><ol><li>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li><li>正则化。 保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）。</li></ol><h3 id="7-2-代价函数"><a href="#7-2-代价函数" class="headerlink" title="7.2 代价函数"></a>7.2 代价函数</h3><p>正则化参数（<strong>Regularization Parameter</strong>）。 </p><h3 id="7-3-正则化线性回归"><a href="#7-3-正则化线性回归" class="headerlink" title="7.3 正则化线性回归"></a>7.3 正则化线性回归</h3><p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程。</p><p>我们同样也可以利用正规方程来求解正则化线性回归模型</p><h3 id="7-4-正则化的逻辑回归模型"><a href="#7-4-正则化的逻辑回归模型" class="headerlink" title="7.4 正则化的逻辑回归模型"></a>7.4 正则化的逻辑回归模型</h3><p>针对逻辑回归问题，我们在之前的课程已经学习过两种优化算法：我们首先学习了使用梯度下降法来优化代价函数$J\left( \theta \right)$，接下来学习了更高级的优化算法，这些高级优化算法需要你自己设计代价函数$J\left( \theta \right)$。</p><p>自己计算导数同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数：</p><h2 id="神经网络：表述-Neural-Networks-Representation"><a href="#神经网络：表述-Neural-Networks-Representation" class="headerlink" title="神经网络：表述(Neural Networks: Representation)"></a>神经网络：表述(Neural Networks: Representation)</h2><h3 id="8-1-非线性假设"><a href="#8-1-非线性假设" class="headerlink" title="8.1 非线性假设"></a>8.1 非线性假设</h3><p>我们之前学的，无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p><p>普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要神经网络。</p><h3 id="8-2-神经元和大脑"><a href="#8-2-神经元和大脑" class="headerlink" title="8.2 神经元和大脑"></a>8.2 神经元和大脑</h3><p>神经网络是一种很古老的算法，它最初产生的目的是制造能模拟大脑的机器。</p><h3 id="8-3-模型表示1"><a href="#8-3-模型表示1" class="headerlink" title="8.3 模型表示1"></a>8.3 模型表示1</h3><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？每一个神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>）。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被称为权重（<strong>weight</strong>）。</p><p>神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。下图为一个3层的神经网络，第一层成为输入层（<strong>Input Layer</strong>），最后一层称为输出层（<strong>Output Layer</strong>），中间一层成为隐藏层（<strong>Hidden Layers</strong>）。我们为每一层都增加一个偏差单位（<strong>bias unit</strong>）：</p><p>（我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )）</p><h3 id="8-4-模型表示2"><a href="#8-4-模型表示2" class="headerlink" title="8.4 模型表示2"></a>8.4 模型表示2</h3><p>( <strong>FORWARD PROPAGATION</strong> ) 相对于使用循环来编码，利用向量化的方法会使得计算更为简便。</p><h3 id="8-5-特征和直观理解1"><a href="#8-5-特征和直观理解1" class="headerlink" title="8.5 特征和直观理解1"></a>8.5 特征和直观理解1</h3><p><strong>OR</strong>与<strong>AND</strong>整体一样，区别只在于的取值不同。</p><h3 id="8-6-样本和直观理解II"><a href="#8-6-样本和直观理解II" class="headerlink" title="8.6 样本和直观理解II"></a>8.6 样本和直观理解II</h3><p>二元逻辑运算符（<strong>BINARY LOGICAL OPERATORS</strong>）当输入特征为布尔值（0或1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。</p><h3 id="8-7-多类分类"><a href="#8-7-多类分类" class="headerlink" title="8.7 多类分类"></a>8.7 多类分类</h3><h2 id="神经网络的学习-Neural-Networks-Learning"><a href="#神经网络的学习-Neural-Networks-Learning" class="headerlink" title="神经网络的学习(Neural Networks: Learning)"></a>神经网络的学习(Neural Networks: Learning)</h2><h3 id="9-1-代价函数"><a href="#9-1-代价函数" class="headerlink" title="9.1 代价函数"></a>9.1 代价函数</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/8f7c28297fc9ed297f42942018441850.jpg" alt></p><h3 id="9-2-反向传播算法"><a href="#9-2-反向传播算法" class="headerlink" title="9.2 反向传播算法"></a>9.2 反向传播算法</h3><h3 id="9-3-反向传播算法的直观理解"><a href="#9-3-反向传播算法的直观理解" class="headerlink" title="9.3 反向传播算法的直观理解"></a>9.3 反向传播算法的直观理解</h3><h3 id="9-4-实现注意：展开参数"><a href="#9-4-实现注意：展开参数" class="headerlink" title="9.4 实现注意：展开参数"></a>9.4 实现注意：展开参数</h3><h3 id="9-5-梯度检验"><a href="#9-5-梯度检验" class="headerlink" title="9.5 梯度检验"></a>9.5 梯度检验</h3><p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。</p><p>为了避免这样的问题，我们采取一种叫做梯度的数值检验（<strong>Numerical Gradient Checking</strong>）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。</p><h3 id="9-6-随机初始化"><a href="#9-6-随机初始化" class="headerlink" title="9.6 随机初始化"></a>9.6 随机初始化</h3><p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为0，这将意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非0的数，结果也是一样的。</p><p>我们通常初始参数为正负ε之间的随机值</p><h3 id="9-7-综合起来"><a href="#9-7-综合起来" class="headerlink" title="9.7 综合起来"></a>9.7 综合起来</h3><p>我们真正要决定的是隐藏层的层数和每个中间层的单元数。</p><p>训练神经网络：</p><ol><li><p>参数的随机初始化</p></li><li><p>利用正向传播方法计算所有的h</p></li><li><p>编写计算代价函数 J的代码</p></li><li><p>利用反向传播方法计算所有偏导数</p></li><li><p>利用数值检验方法检验这些偏导数</p></li><li><p>使用优化算法来最小化代价函数</p></li></ol><h3 id="9-8-自主驾驶"><a href="#9-8-自主驾驶" class="headerlink" title="9.8 自主驾驶"></a>9.8 自主驾驶</h3><p>这就是基于神经网络的自动驾驶技术。当然，我们还有很多更加先进的试验来实现自动驾驶技术。在美国，欧洲等一些国家和地区，他们提供了一些比这个方法更加稳定的驾驶控制技术。但我认为，使用这样一个简单的基于反向传播的神经网络，训练出如此强大的自动驾驶汽车，的确是一次令人惊讶的成就。</p><h2 id="应用机器学习的建议-Advice-for-Applying-Machine-Learning"><a href="#应用机器学习的建议-Advice-for-Applying-Machine-Learning" class="headerlink" title="应用机器学习的建议(Advice for Applying Machine Learning)"></a>应用机器学习的建议(Advice for Applying Machine Learning)</h2><h3 id="10-1-决定下一步做什么"><a href="#10-1-决定下一步做什么" class="headerlink" title="10.1 决定下一步做什么"></a>10.1 决定下一步做什么</h3><p>当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？</p><ol><li><p>获得更多的训练样本——通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。</p></li><li><p>尝试减少特征的数量</p></li><li><p>尝试获得更多的特征</p></li><li><p>尝试增加多项式特征</p></li><li><p>尝试减少正则化程度</p></li><li><p>尝试增加正则化程度</p></li></ol><p>我们不应该随机选择上面的某种方法来改进我们的算法，而是运用一些机器学习诊断法来帮助我们知道上面哪些方法对我们的算法是有效的。</p><h3 id="10-2-评估一个假设"><a href="#10-2-评估一个假设" class="headerlink" title="10.2 评估一个假设"></a>10.2 评估一个假设</h3><p>为了检验算法是否过拟合，我们将数据分成训练集和测试集，通常用70%的数据作为训练集，用剩下30%的数据作为测试集。很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行“洗牌”，然后再分成训练集和测试集。</p><p>测试集评估在通过训练集让我们的模型学习得出其参数后，对测试集运用该模型，我们有两种方式计算误差：</p><ol><li>对于线性回归模型，我们利用测试集数据计算代价函数J</li><li>对于逻辑回归模型，我们除了可以利用测试数据集来计算代价函数外：</li></ol><p>误分类的比率，对于每一个测试集样本，计算：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/751e868bebf4c0bf139db173d25e8ec4.png" alt></p><p>然后对计算结果求平均。</p><h3 id="10-3-模型选择和交叉验证集"><a href="#10-3-模型选择和交叉验证集" class="headerlink" title="10.3 模型选择和交叉验证集"></a>10.3 模型选择和交叉验证集</h3><p>适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用交叉验证集来帮助选择模型。</p><p>即：使用60%的数据作为训练集，使用 20%的数据作为交叉验证集，使用20%的数据作为测试集</p><p>模型选择的方法为：</p><ol><li><p>使用训练集训练出10个模型</p></li><li><p>用10个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</p></li><li><p>选取代价函数值最小的模型</p></li><li><p>用步骤3中选出的模型对测试集计算得出推广误差（代价函数的值）</p></li></ol><h3 id="10-4-诊断偏差和方差"><a href="#10-4-诊断偏差和方差" class="headerlink" title="10.4 诊断偏差和方差"></a>10.4 诊断偏差和方差</h3><p>训练集误差和交叉验证集误差近似时：偏差/欠拟合</p><p>交叉验证集误差远大于训练集误差时：方差/过拟合</p><h3 id="10-5-正则化和偏差-方差"><a href="#10-5-正则化和偏差-方差" class="headerlink" title="10.5 正则化和偏差/方差"></a>10.5 正则化和偏差/方差</h3><p>选择$\lambda$的方法为：</p><ol><li>使用训练集训练出12个不同程度正则化的模型</li><li>用12个模型分别对交叉验证集计算的出交叉验证误差</li><li>选择得出交叉验证误差<strong>最小</strong>的模型</li><li>运用步骤3中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与λ的值绘制在一张图表上：</li></ol><p>• 当 $\lambda$ 较小时，训练集误差较小（过拟合）而交叉验证集误差较大</p><p>• 随着 $\lambda$ 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</p><h3 id="10-6-学习曲线"><a href="#10-6-学习曲线" class="headerlink" title="10.6 学习曲线"></a>10.6 学习曲线</h3><p>学习曲线就是一种很好的工具，我经常使用学习曲线来判断某一个学习算法是否处于偏差、方差问题。学习曲线是学习算法的一个很好的<strong>合理检验</strong>（<strong>sanity check</strong>）。学习曲线是将训练集误差和交叉验证集误差作为训练集样本数量的函数绘制的图表。</p><p>如何利用学习曲线识别高偏差/欠拟合：作为例子，我们尝试用一条直线来适应下面的数据，可以看出，无论训练集有多么大误差都不会有太大改观：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/4a5099b9f4b6aac5785cb0ad05289335.jpg" alt></p><p>也就是说在高偏差/欠拟合的情况下，增加数据到训练集不一定能有帮助。</p><p>如何利用学习曲线识别高方差/过拟合：假设我们使用一个非常高次的多项式模型，并且正则化非常小，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2977243994d8d28d5ff300680988ec34.jpg" alt></p><p>也就是说在高方差/过拟合的情况下，增加更多数据到训练集可能可以提高算法效果。</p><h3 id="10-7-决定下一步做什么"><a href="#10-7-决定下一步做什么" class="headerlink" title="10.7 决定下一步做什么"></a>10.7 决定下一步做什么</h3><p>哪些方法可能有助于改进学习算法的效果，而哪些可能是徒劳的呢？</p><p>回顾 1.1 中提出的六种可选的下一步，让我们来看一看我们在什么情况下应该怎样选择：</p><ol><li><p>获得更多的训练样本——解决高方差</p></li><li><p>尝试减少特征的数量——解决高方差</p></li><li><p>尝试获得更多的特征——解决高偏差</p></li><li><p>尝试增加多项式特征——解决高偏差</p></li><li><p>尝试减少正则化程度λ——解决高偏差</p></li><li><p>尝试增加正则化程度λ——解决高方差</p></li></ol><p>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。</p><p>对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络，<br>然后选择交叉验证集代价最小的神经网络。</p><h1 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h1><h2 id="机器学习系统的设计-Machine-Learning-System-Design"><a href="#机器学习系统的设计-Machine-Learning-System-Design" class="headerlink" title="机器学习系统的设计(Machine Learning System Design)"></a>机器学习系统的设计(Machine Learning System Design)</h2><h3 id="11-1-首先要做什么"><a href="#11-1-首先要做什么" class="headerlink" title="11.1 首先要做什么"></a>11.1 首先要做什么</h3><p>以一个垃圾邮件分类器算法为例进行讨论。</p><p>为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量$x$。我们可以选择一个由100个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否有在邮件中出现，来获得我们的特征向量（出现为1，不出现为0），尺寸为100×1。</p><p>为了构建这个分类器算法，我们可以做很多事，例如：</p><ol><li><p>收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件的样本</p></li><li><p>基于邮件的路由信息开发一系列复杂的特征</p></li><li><p>基于邮件的正文信息开发一系列复杂的特征，包括考虑截词的处理</p></li><li><p>为探测刻意的拼写错误（把<strong>watch</strong> 写成<strong>w4tch</strong>）开发复杂的算法</p></li></ol><h3 id="11-2-误差分析"><a href="#11-2-误差分析" class="headerlink" title="11.2 误差分析"></a>11.2 误差分析</h3><p>误差分析（<strong>Error Analysis</strong>）的概念。这会帮助你更系统地做出决定。如果你准备研究机器学习的东西，或者构造机器学习应用程序，最好的实践方法不是建立一个非常复杂的系统，拥有多么复杂的变量；而是构建一个简单的算法，这样你可以很快地实现它。</p><p>构建一个学习算法的推荐方法为：</p><p>1.从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法</p><p>2.绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</p><p>3.进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的样本，看看这些样本是否有某种系统化的趋势</p><h3 id="11-3-类偏斜的误差度量"><a href="#11-3-类偏斜的误差度量" class="headerlink" title="11.3 类偏斜的误差度量"></a>11.3 类偏斜的误差度量</h3><p>类偏斜情况表现为我们的训练集中有非常多的同一种类的样本，只有很少或没有其他类的样本。</p><p><strong>查准率</strong>（<strong>Precision</strong>）和<strong>查全率</strong>（<strong>Recall</strong>） 我们将算法预测的结果分成四种情况：</p><p>1.<strong>正确肯定</strong>（<strong>True Positive,TP</strong>）：预测为真，实际为真</p><p>2.<strong>正确否定</strong>（<strong>True Negative,TN</strong>）：预测为假，实际为假</p><p>3.<strong>错误肯定</strong>（<strong>False Positive,FP</strong>）：预测为真，实际为假</p><p>4.<strong>错误否定</strong>（<strong>False Negative,FN</strong>）：预测为假，实际为真</p><p>则：查准率=<strong>TP/(TP+FP)</strong>。例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。</p><p>查全率=<strong>TP/(TP+FN)</strong>。例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p><p>这样，对于我们刚才那个总是预测病人肿瘤为良性的算法，其查全率是0。</p><table><thead><tr><th></th><th></th><th><strong>预测值</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td><strong>Positive</strong></td><td><strong>Negtive</strong></td></tr><tr><td><strong>实际值</strong></td><td><strong>Positive</strong></td><td><strong>TP</strong></td><td><strong>FN</strong></td></tr><tr><td></td><td><strong>Negtive</strong></td><td><strong>FP</strong></td><td><strong>TN</strong></td></tr></tbody></table><h3 id="11-4-查准率和查全率之间的权衡"><a href="#11-4-查准率和查全率之间的权衡" class="headerlink" title="11.4 查准率和查全率之间的权衡"></a>11.4 查准率和查全率之间的权衡</h3><p>我们希望有一个帮助我们选择这个阀值的方法。一种方法是计算<strong>F1 值</strong>（<strong>F1 Score</strong>），其计算公式为：</p><p>我们选择使得<strong>F1</strong>值最高的阀值。</p><h3 id="11-5-机器学习的数据"><a href="#11-5-机器学习的数据" class="headerlink" title="11.5 机器学习的数据"></a>11.5 机器学习的数据</h3><p>在一定的条件下，得到大量的数据并在某种类型的学习算法中进行训练，可以是一种有效的方法来获得一个具有良好性能的学习算法。</p><h2 id="支持向量机-Support-Vector-Machines"><a href="#支持向量机-Support-Vector-Machines" class="headerlink" title="支持向量机(Support Vector Machines)"></a>支持向量机(Support Vector Machines)</h2><h3 id="12-1-优化目标"><a href="#12-1-优化目标" class="headerlink" title="12.1 优化目标"></a>12.1 优化目标</h3><p>与逻辑回归和神经网络相比，支持向量机，或者简称<strong>SVM</strong>，在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p><h3 id="12-2-大边界的直观理解"><a href="#12-2-大边界的直观理解" class="headerlink" title="12.2 大边界的直观理解"></a>12.2 大边界的直观理解</h3><p>这就相当于在支持向量机中嵌入了一个额外的安全因子，或者说安全的间距因子。</p><p>支持向量机将会选择这个黑色的决策边界，相较于之前我用粉色或者绿色画的决策界。这条黑色的看起来好得多，黑线看起来是更稳健的决策界。在分离正样本和负样本上它显得的更好。数学上来讲，这是什么意思呢？这条黑线有更大的距离，这个距离叫做间距(<strong>margin</strong>)。</p><p>这个距离叫做支持向量机的间距，而这是支持向量机具有<strong>鲁棒性</strong>的原因，因为它努力用一个最大间距来分离样本。因此支持向量机有时被称为<strong>大间距分类器</strong></p><p>关于大间距分类器，我想讲最后一点：我们将这个大间距分类器中的正则化因子常数$C$设置的非常大，我记得我将其设置为了100000，因此对这样的一个数据集，也许我们将选择这样的决策界，从而最大间距地分离开正样本和负样本。那么在让代价函数最小化的过程中，我们希望找出在$y=1$和$y=0$两种情况下都使得代价函数中左边的这一项尽量为零的参数。如果我们找到了这样的参数，则我们的最小化问题便转变成：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f4b6dee99cfb4352b3cac5287002e8de.png" alt></p><p>事实上，支持向量机现在要比这个大间距分类器所体现得更成熟，尤其是当你使用大间距分类器的时候，你的学习算法会受异常点(outlier) 的影响。比如我们加入一个额外的正样本。</p><p>C 较大时，相当于 lambda​ 较小，可能会导致过拟合，高方差。</p><p>C​ 较小时，相当于lambda较大，可能会导致低拟合，高偏差。</p><h3 id="12-3-大边界分类背后的数学（选修）"><a href="#12-3-大边界分类背后的数学（选修）" class="headerlink" title="12.3 大边界分类背后的数学（选修）"></a>12.3 大边界分类背后的数学（选修）</h3><p>因此支持向量机做的全部事情，就是<strong>极小化参数向量</strong>范数的平方，或者说长度的平方。</p><h3 id="12-4-核函数1"><a href="#12-4-核函数1" class="headerlink" title="12.4 核函数1"></a>12.4 核函数1</h3><p>给定一个训练样本$x$，我们利用$x$的各个特征与我们预先选定的<strong>地标</strong>(<strong>landmarks</strong>)的近似程度来选取新的特征。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2516821097bda5dfaf0b94e55de851e0.png" alt></p><h3 id="12-5-核函数2"><a href="#12-5-核函数2" class="headerlink" title="12.5 核函数2"></a>12.5 核函数2</h3><p>如何选择地标？</p><h3 id="12-6-使用支持向量机"><a href="#12-6-使用支持向量机" class="headerlink" title="12.6 使用支持向量机"></a>12.6 使用支持向量机</h3><p>在高斯核函数之外我们还有其他一些选择，如：</p><p>多项式核函数（<strong>Polynomial Kerne</strong>l）</p><p>字符串核函数（<strong>String kernel</strong>）</p><p>卡方核函数（ <strong>chi-square kernel</strong>）</p><p>直方图交集核函数（<strong>histogram intersection kernel</strong>）</p><p>等等…</p><p>这些核函数的目标也都是根据训练集和地标之间的距离来构建新特征，这些核函数需要满足Mercer’s定理，才能被支持向量机的优化软件正确处理。</p><p><strong>多类分类问题</strong></p><p>尽管你不去写你自己的<strong>SVM</strong>的优化软件，但是你也需要做几件事：</p><p>1、是提出参数的选择。我们在之前的视频中讨论过误差/方差在这方面的性质。</p><p>2、你也需要选择内核参数或你想要使用的相似函数，其中一个选择是：我们选择不需要任何内核参数，没有内核参数的理念，也叫线性核函数。因此，如果有人说他使用了线性核的<strong>SVM</strong>（支持向量机），这就意味这他使用了不带有核函数的<strong>SVM</strong>（支持向量机）。</p><p>从逻辑回归模型，我们得到了支持向量机模型，在两者之间，我们应该如何选择呢？</p><p><strong>下面是一些普遍使用的准则：</strong></p><h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类(Clustering)"></a>聚类(Clustering)</h2><h3 id="13-1-无监督学习：简介"><a href="#13-1-无监督学习：简介" class="headerlink" title="13.1 无监督学习：简介"></a>13.1 无监督学习：简介</h3><p>在一个典型的监督学习中，我们有一个有标签的训练集，我们的目标是找到能够区分正样本和负样本的决策边界，在这里的监督学习中，我们有一系列标签，我们需要据此拟合一个假设函数。与此不同的是，在非监督学习中，我们的数据没有附带任何标签</p><h3 id="13-2-K-均值算法"><a href="#13-2-K-均值算法" class="headerlink" title="13.2 K-均值算法"></a>13.2 K-均值算法</h3><p><strong>K-均值</strong>是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。</p><p><strong>K-均值</strong>是一个迭代算法，假设我们想要将数据聚类成n个组，其方法为:</p><h3 id="13-3-优化目标"><a href="#13-3-优化目标" class="headerlink" title="13.3 优化目标"></a>13.3 优化目标</h3><p>K-均值最小化问题，是要最小化所有的数据点与其所关联的聚类中心点之间的距离之和，因此<br>K-均值的代价函数（又称<strong>畸变函数</strong> <strong>Distortion function</strong>）为：</p><h3 id="13-4-随机初始化"><a href="#13-4-随机初始化" class="headerlink" title="13.4 随机初始化"></a>13.4 随机初始化</h3><p>在运行K-均值算法的之前，我们首先要随机初始化所有的聚类中心点，下面介绍怎样做：</p><h3 id="13-5-选择聚类数"><a href="#13-5-选择聚类数" class="headerlink" title="13.5 选择聚类数"></a>13.5 选择聚类数</h3><p>没有所谓最好的选择聚类数的方法，通常是需要根据不同的问题，人工进行选择的。选择的时候思考我们运用<strong>K-均值</strong>算法聚类的动机是什么，然后选择能最好服务于该目的标聚类数。</p><h2 id="降维-Dimensionality-Reduction"><a href="#降维-Dimensionality-Reduction" class="headerlink" title="降维(Dimensionality Reduction)"></a>降维(Dimensionality Reduction)</h2><h3 id="14-1-动机一：数据压缩"><a href="#14-1-动机一：数据压缩" class="headerlink" title="14.1 动机一：数据压缩"></a>14.1 动机一：数据压缩</h3><p>第二种类型的无监督学习问题，称为降维。有几个不同的的原因使你可能想要做降维。一是数据压缩，后面我们会看了一些视频后，数据压缩不仅允许我们压缩数据，因而使用较少的计算机内存或磁盘空间，但它也让我们加快我们的学习算法。</p><h3 id="14-2-动机二：数据可视化"><a href="#14-2-动机二：数据可视化" class="headerlink" title="14.2 动机二：数据可视化"></a>14.2 动机二：数据可视化</h3><p>在许多及其学习问题中，如果我们能将数据可视化，我们便能寻找到一个更好的解决方案，降维可以帮助我们。</p><p>这样做的问题在于，降维的算法只负责减少维数，新产生的特征的意义就必须由我们自己去发现了。</p><h3 id="14-3-主成分分析问题"><a href="#14-3-主成分分析问题" class="headerlink" title="14.3 主成分分析问题"></a>14.3 主成分分析问题</h3><p>主成分分析(<strong>PCA</strong>)是最常见的降维算法。</p><p>在<strong>PCA</strong>中，我们要做的是找到一个方向向量（<strong>Vector direction</strong>），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。</p><p>面给出主成分分析问题的描述：</p><p>主成分分析与线性回归是两种不同的算法。主成分分析最小化的是投射误差（<strong>Projected Error</strong>），而线性回归尝试的是最小化预测误差。线性回归的目的是预测结果，而主成分分析不作任何预测。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7e1389918ab9358d1432d20ed20f8142.png" alt="7e1389918ab9358d1432d20ed20f8142"></p><p>左边的是线性回归的误差（垂直于横轴投影），右边则是主要成分分析的误差（垂直于红线投影）。</p><p><strong>PCA</strong>将n个特征降维到k个，可以用来进行数据压缩，如果100维的向量最后可以用10维来表示，那么压缩率为90%。同样图像处理领域的<strong>KL变换</strong>使用<strong>PCA</strong>做图像压缩。但<strong>PCA</strong> 要保证降维后，还要保证数据的特性损失最小。</p><p><strong>PCA</strong>技术的一大好处是对数据进行降维的处理。我们可以对新求出的“主元”向量的重要性进行排序，根据需要取前面最重要的部分，将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息。</p><p><strong>PCA</strong>技术的一个很大的优点是，它是完全无参数限制的。在<strong>PCA</strong>的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。</p><p>但是，这一点同时也可以看作是缺点。如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。</p><h3 id="14-4-主成分分析算法"><a href="#14-4-主成分分析算法" class="headerlink" title="14.4 主成分分析算法"></a>14.4 主成分分析算法</h3><p>第一步是均值归一化。</p><p>第二步是计算<strong>协方差矩阵</strong>（<strong>covariance matrix</strong>)</p><p>第三步是计算协方差矩阵的<strong>特征向量</strong>（<strong>eigenvectors</strong>）:</p><h3 id="14-5-选择主成分的数量"><a href="#14-5-选择主成分的数量" class="headerlink" title="14.5 选择主成分的数量"></a>14.5 选择主成分的数量</h3><p>主要成分分析是减少投射的平均均方误差：</p><blockquote><p>方差越大，表明这个特征里数据分布的离散程度就越大，特征所包含的信息量就越大；反之，如果特征里数据的方差小，分布集中，则表明其包含的信息量就小。那么，我们自然选择保留信息量大的那个特征了。</p></blockquote><h3 id="14-6-重建的压缩表示"><a href="#14-6-重建的压缩表示" class="headerlink" title="14.6 重建的压缩表示"></a>14.6 重建的压缩表示</h3><h3 id="14-7-主成分分析法的应用建议"><a href="#14-7-主成分分析法的应用建议" class="headerlink" title="14.7 主成分分析法的应用建议"></a>14.7 主成分分析法的应用建议</h3><pre><code>  1. 第一步是运用主要成分分析将数据压缩至1000个特征  2. 然后对**训练集**运行学习算法  3. 在预测时，采用之前学习而来的U将输入的特征x转换成特征向量z，然后再进行预测</code></pre><p>错误的主要成分分析情况：一个常见错误使用主要成分分析的情况是，将其用于减少过拟合（减少了特征的数量）。这样做非常不好，不如尝试正则化处理。原因在于主要成分分析只是近似地丢弃掉一些特征，它并不考虑任何与结果变量有关的信息，因此可能会丢失非常重要的特征。然而当我们进行正则化处理时，会考虑到结果变量，不会丢掉重要的数据。</p><p>另一个常见的错误是，默认地将主要成分分析作为学习过程中的一部分，这虽然很多时候有效果，最好还是从所有原始特征开始，只在有必要的时候（算法运行太慢或者占用太多内存）才考虑采用主要成分分析。</p><h2 id="异常检测-Anomaly-Detection"><a href="#异常检测-Anomaly-Detection" class="headerlink" title="异常检测(Anomaly Detection)"></a>异常检测(Anomaly Detection)</h2><h3 id="15-1-问题的动机"><a href="#15-1-问题的动机" class="headerlink" title="15.1 问题的动机"></a>15.1 问题的动机</h3><p>异常检测(<strong>Anomaly detection</strong>)问题。这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于：它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。</p><p>异常检测主要用来识别欺骗。例如在线采集而来的有关用户的数据，一个特征向量中可能会包含如：用户多久登录一次，访问过的页面，在论坛发布的帖子数量，甚至是打字速度等。尝试根据这些特征构建一个模型，可以用这个模型来识别那些不符合该模式的用户。</p><h3 id="15-2-高斯分布"><a href="#15-2-高斯分布" class="headerlink" title="15.2 高斯分布"></a>15.2 高斯分布</h3><p>回顾高斯分布的基本知识。</p><h3 id="15-3-算法"><a href="#15-3-算法" class="headerlink" title="15.3 算法"></a>15.3 算法</h3><p>异常检测算法：</p><h3 id="15-4-开发和评价一个异常检测系统"><a href="#15-4-开发和评价一个异常检测系统" class="headerlink" title="15.4 开发和评价一个异常检测系统"></a>15.4 开发和评价一个异常检测系统</h3><p>具体的评价方法如下：</p><h3 id="15-5-异常检测与监督学习对比"><a href="#15-5-异常检测与监督学习对比" class="headerlink" title="15.5 异常检测与监督学习对比"></a>15.5 异常检测与监督学习对比</h3><table><thead><tr><th>异常检测</th><th>监督学习</th></tr></thead><tbody><tr><td>非常少量的正向类（异常数据 ）, 大量的负向类（）</td><td>同时有大量的正向类和负向类</td></tr><tr><td>许多不同种类的异常，非常难。根据非常 少量的正向类数据来训练算法。</td><td>有足够多的正向类实例，足够用于训练 算法，未来遇到的正向类实例可能与训练集中的非常近似。</td></tr><tr><td>未来遇到的异常可能与已掌握的异常、非常的不同。</td><td></td></tr><tr><td>例如： 欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况</td><td>例如：邮件过滤器 天气预报 肿瘤分类</td></tr></tbody></table><h3 id="15-6-选择特征"><a href="#15-6-选择特征" class="headerlink" title="15.6 选择特征"></a>15.6 选择特征</h3><p>对于异常检测算法，我们使用的特征是至关重要的，下面谈谈如何选择特征：</p><p>异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布</p><p>误差分析：</p><p>我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小），例如，在检测数据中心的计算机状况的例子中，我们可以用<strong>CPU</strong>负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。</p><h3 id="15-7-多元高斯分布（选修）"><a href="#15-7-多元高斯分布（选修）" class="headerlink" title="15.7 多元高斯分布（选修）"></a>15.7 多元高斯分布（选修）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/598db991a7c930c9021cec5f6ab9beb9.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/29df906704d254f18e92a63173dd51e7.jpg" alt></p><p>上图是5个不同的模型，从左往右依次分析：</p><ol><li><p>是一个一般的高斯分布模型</p></li><li><p>通过协方差矩阵，令特征1拥有较小的偏差，同时保持特征2的偏差</p></li><li><p>通过协方差矩阵，令特征2拥有较大的偏差，同时保持特征1的偏差</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的正相关性</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的负相关性</p></li></ol><p>多元高斯分布模型与原高斯分布模型的关系：</p><p>可以证明的是，原本的高斯分布模型是多元高斯分布模型的一个子集，即像上图中的第1、2、3，3个例子所示，如果协方差矩阵只在对角线的单位上有非零的值时，即为原本的高斯分布模型了。</p><p>原高斯分布模型和多元高斯分布模型的比较：</p><table><thead><tr><th>原高斯分布模型</th><th>多元高斯分布模型</th></tr></thead><tbody><tr><td>不能捕捉特征之间的相关性 但可以通过将特征进行组合的方法来解决</td><td>自动捕捉特征之间的相关性</td></tr><tr><td>计算代价低，能适应大规模的特征</td><td>计算代价较高 训练集较小时也同样适用</td></tr><tr><td></td><td>必须要有 m&gt;n​，不然的话协方差矩阵不可逆的，通常需要 m&gt;10n​另外特征冗余也会导致协方差矩阵不可逆</td></tr></tbody></table><p>原高斯分布模型被广泛使用着，如果特征之间在某种程度上存在相互关联的情况，我们可以通过构造新新特征的方法来捕捉这些相关性。</p><p>如果训练集不是太大，并且没有太多的特征，我们可以使用多元高斯分布模型。</p><h3 id="15-8-使用多元高斯分布进行异常检测（可选）"><a href="#15-8-使用多元高斯分布进行异常检测（可选）" class="headerlink" title="15.8 使用多元高斯分布进行异常检测（可选）"></a>15.8 使用多元高斯分布进行异常检测（可选）</h3><p>原始模型和多元高斯分布比较如图：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f4585239738f2b5149608879fa166889.png" alt></p><h2 id="推荐系统-Recommender-Systems"><a href="#推荐系统-Recommender-Systems" class="headerlink" title="推荐系统(Recommender Systems)"></a>推荐系统(Recommender Systems)</h2><h3 id="16-1-问题形式化"><a href="#16-1-问题形式化" class="headerlink" title="16.1 问题形式化"></a>16.1 问题形式化</h3><blockquote><p>机器学习中的大思想</p></blockquote><p>我们从一个例子开始定义推荐系统的问题。</p><p>假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。</p><h3 id="16-2-基于内容的推荐系统"><a href="#16-2-基于内容的推荐系统" class="headerlink" title="16.2 基于内容的推荐系统"></a>16.2 基于内容的推荐系统</h3><h3 id="16-3-协同过滤"><a href="#16-3-协同过滤" class="headerlink" title="16.3 协同过滤"></a>16.3 协同过滤</h3><h3 id="16-4-协同过滤算法"><a href="#16-4-协同过滤算法" class="headerlink" title="16.4 协同过滤算法"></a>16.4 协同过滤算法</h3><h3 id="16-5-向量化：低秩矩阵分解"><a href="#16-5-向量化：低秩矩阵分解" class="headerlink" title="16.5 向量化：低秩矩阵分解"></a>16.5 向量化：低秩矩阵分解</h3><p>实现一种选择的方法，写出协同过滤算法的预测情况。</p><p>通过这个方法，希望你能知道，如何进行一个向量化的计算来对所有的用户和所有的电影进行评分计算。同时希望你也能掌握，通过学习特征参数，来找到相关电影和产品的方法。</p><h3 id="16-6-推行工作上的细节：均值归一化"><a href="#16-6-推行工作上的细节：均值归一化" class="headerlink" title="16.6 推行工作上的细节：均值归一化"></a>16.6 推行工作上的细节：均值归一化</h3><p>如果我们新增一个用户 <strong>Eve</strong>，并且 <strong>Eve</strong> 没有为任何电影评分，那么我们以什么为依据为<strong>Eve</strong>推荐电影呢？</p><p>我们首先需要对结果矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9ec5cb55e14bd1462183e104f8e02b80.png" alt></p><p>然后我们利用这个新的Y矩阵来训练算法。<br>如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，对于<strong>Eve</strong>，我们的新模型会认为她给每部电影的评分都是该电影的平均分。</p><h2 id="大规模机器学习-Large-Scale-Machine-Learning"><a href="#大规模机器学习-Large-Scale-Machine-Learning" class="headerlink" title="大规模机器学习(Large Scale Machine Learning)"></a>大规模机器学习(Large Scale Machine Learning)</h2><h3 id="17-1-大型数据集的学习"><a href="#17-1-大型数据集的学习" class="headerlink" title="17.1 大型数据集的学习"></a>17.1 大型数据集的学习</h3><p>如果我们有一个低方差的模型，增加数据集的规模可以帮助你获得更好的结果。我们应该怎样应对一个有100万条记录的训练集？</p><p>首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用1000个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。</p><h3 id="17-2-随机梯度下降法"><a href="#17-2-随机梯度下降法" class="headerlink" title="17.2 随机梯度下降法"></a>17.2 随机梯度下降法</h3><p>如果我们一定需要一个大规模的训练集，我们可以尝试使用随机梯度下降法来代替批量梯度下降法。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9710a69ba509a9dcbca351fccc6e7aae.jpg" alt></p><h3 id="17-3-小批量梯度下降"><a href="#17-3-小批量梯度下降" class="headerlink" title="17.3 小批量梯度下降"></a>17.3 小批量梯度下降</h3><p>小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数b次训练实例，便更新一次参数</p><h3 id="17-4-随机梯度下降收敛"><a href="#17-4-随机梯度下降收敛" class="headerlink" title="17.4 随机梯度下降收敛"></a>17.4 随机梯度下降收敛</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/76fb1df50bdf951f4b880fa66489e367.png" alt></p><h3 id="17-5-在线学习"><a href="#17-5-在线学习" class="headerlink" title="17.5 在线学习"></a>17.5 在线学习</h3><p>在这个视频中，讨论一种新的大规模的机器学习机制，叫做在线学习机制。在线学习机制让我们可以模型化问题。</p><p>今天，许多大型网站或者许多大型网络公司，使用不同版本的在线学习机制算法，从大批的涌入又离开网站的用户身上进行学习。特别要提及的是，如果你有一个由连续的用户流引发的连续的数据流，进入你的网站，你能做的是使用一个在线学习机制，从数据流中学习用户的偏好，然后使用这些信息来优化一些关于网站的决策。</p><p>一个算法来从中学习的时候来模型化问题在线学习算法指的是对数据流而非离线的静态数据集的学习。许多在线网站都有持续不断的用户流，对于每一个用户，网站希望能在不将数据存储到数据库中便顺利地进行算法学习。</p><p>在线学习的算法与随机梯度下降算法有些类似，我们对单一的实例进行学习，而非对一个提前定义的训练集进行循环。</p><p>一旦对一个数据的学习完成了，我们便可以丢弃该数据，不需要再存储它了。这种方式的好处在于，我们的算法可以很好的适应用户的倾向性，算法可以针对用户的当前行为不断地更新模型以适应该用户。</p><p><strong>每次交互事件并不只产生一个数据集</strong>，例如，我们一次给用户提供3个物流选项，用户选择2项，我们实际上可以获得3个新的训练实例，因而我们的算法可以一次从3个实例中学习并更新模型。</p><p>在线学习的一个优点就是，如果你有一个变化的用户群，又或者你在尝试预测的事情，在缓慢变化，就像你的用户的品味在缓慢变化，这个在线学习算法，可以慢慢地调试你所学习到的假设，将其调节更新到<strong>最新的用户行为</strong>。</p><h3 id="17-6-映射化简和数据并行"><a href="#17-6-映射化简和数据并行" class="headerlink" title="17.6 映射化简和数据并行"></a>17.6 映射化简和数据并行</h3><p>映射化简和数据并行对于大规模机器学习问题而言是非常重要的概念。</p><p>如果我们能够将我们的数据集分配给不多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计所的结果汇总在求和。这样的方法叫做映射简化。</p><p>具体而言，如果任何学习算法能够表达为，对训练集的函数的求和，那么便能将这个任务分配给多台计算机（或者同一台计算机的不同<strong>CPU</strong> 核心），以达到加速处理的目的。</p><h2 id="应用实例：图片文字识别-Application-Example-Photo-OCR"><a href="#应用实例：图片文字识别-Application-Example-Photo-OCR" class="headerlink" title="应用实例：图片文字识别(Application Example: Photo OCR)"></a>应用实例：图片文字识别(Application Example: Photo OCR)</h2><h3 id="18-1-问题描述和流程图Problem-Description-and-Pipeline"><a href="#18-1-问题描述和流程图Problem-Description-and-Pipeline" class="headerlink" title="18.1 问题描述和流程图Problem Description and Pipeline"></a>18.1 问题描述和流程图Problem Description and Pipeline</h3><p>图像文字识别应用所作的事是，从一张给定的图片中识别文字。这比从一份扫描文档中识别文字要复杂的多。</p><p>为了完成这样的工作，需要采取如下步骤：</p><ol><li><p>文字侦测（<strong>Text detection</strong>）——将图片上的文字与其他环境对象分离开来</p></li><li><p>字符切分（<strong>Character segmentation</strong>）——将文字分割成一个个单一的字符</p></li><li><p>字符分类（<strong>Character classification</strong>）——确定每一个字符是什么<br>可以用任务流程图来表达这个问题，每一项任务可以由一个单独的小队来负责解决：</p></li></ol><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/610fffb413d8d577882d6345c166a9fb.png" alt></p><h3 id="18-2-滑动窗口"><a href="#18-2-滑动窗口" class="headerlink" title="18.2 滑动窗口"></a>18.2 滑动窗口</h3><p>滑动窗口是一项用来从图像中抽取对象的技术。假使我们需要在一张图片中识别行人，首先要做的是用许多固定尺寸的图片来训练一个能够准确识别行人的模型。然后我们用之前训练识别行人的模型时所采用的图片尺寸在我们要进行行人识别的图片上进行剪裁，然后将剪裁得到的切片交给模型，让模型判断是否为行人，然后在图片上滑动剪裁区域重新进行剪裁，将新剪裁的切片也交给模型进行判断，如此循环直至将图片全部检测完。</p><p>滑动窗口技术也被用于文字识别，首先训练模型能够区分字符与非字符，然后，运用滑动窗口技术识别字符，一旦完成了字符的识别，我们将识别得出的区域进行一些扩展，然后将重叠的区域进行合并。接着我们以宽高比作为过滤条件，过滤掉高度比宽度更大的区域（认为单词的长度通常比高度要大）。</p><p>模型训练完后，我们仍然是使用滑动窗口技术来进行字符识别。</p><p>以上便是字符切分阶段。</p><p>最后一个阶段是字符分类阶段，利用神经网络、支持向量机或者逻辑回归算法训练一个分类器即可。</p><h3 id="18-3-获取大量数据和人工数据"><a href="#18-3-获取大量数据和人工数据" class="headerlink" title="18.3 获取大量数据和人工数据"></a>18.3 获取大量数据和人工数据</h3><p>如果我们的模型是低方差的，那么获得更多的数据用于训练模型，是能够有更好的效果的。问题在于，我们怎样获得数据，数据不总是可以直接获得的，我们有可能需要人工地创造一些数据。</p><p>有关获得更多数据的几种方法：</p><pre><code>1. 人工数据合成2. 手动收集、标记数据3. 众包</code></pre><h3 id="18-4-上限分析：哪部分管道的接下去做"><a href="#18-4-上限分析：哪部分管道的接下去做" class="headerlink" title="18.4 上限分析：哪部分管道的接下去做"></a>18.4 上限分析：哪部分管道的接下去做</h3><p>在机器学习的应用中，我们通常需要通过几个步骤才能进行最终的预测，我们如何能够知道哪一部分最值得我们花时间和精力去改善呢？这个问题可以通过上限分析来回答。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f1ecee10884098f98032648da08f8937.jpg" alt></p><h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结(Conclusion)"></a>总结(Conclusion)</h2><p>作为这门课的结束时间，那么我们学到了些什么呢？在这门课中，我们花了大量的时间介绍了诸如<strong>线性回归、逻辑回归、神经网络、支持向量机</strong>等等一些<strong>监督学习算法</strong>，这类算法具有带标签的数据和样本.</p><p>然后我们也花了很多时间介绍<strong>无监督学习</strong>。例如 <strong>K-均值聚类</strong>、<strong>用于降维的主成分分析</strong>，以及当你只有一系列无标签数据时的<strong>异常检测算法</strong>。</p><p>当然，有时带标签的数据，也可以用于异常检测算法的评估。此外，我们也花时间讨论了一些特别的应用或者特别的话题，比如说<strong>推荐系统</strong>。以及<strong>大规模机器学习系统</strong>，包括<strong>并行系统和映射化简方法，</strong>还有其他一些特别的应用。比如，用于计算机视觉技术的<strong>滑动窗口分类</strong>算法。</p><p>最后，我们还提到了很多关于<strong>构建机器学习系统的实用建议</strong>。这包括了怎样理解某个机器学习算法是否正常工作的原因，所以我们谈到了<strong>偏差和方差</strong>的问题，也谈到了解决<strong>方差问题的正则化</strong>，同时我们也讨论了怎样决定接下来<strong>怎么做</strong>的问题，也就是说当你在开发一个机器学习系统时，什么工作才是接下来应该优先考虑的问题。因此我们讨论了学习算法的<strong>评价法</strong>。介绍了评价矩阵，比如：<strong>查准率、召回率以及F1分数，还有评价学习算法比较实用的训练集、交叉验证集和测试集</strong>。我们也介绍了<strong>学习算法</strong>的调试，以及如何确保学习算法的正常运行，于是我们介绍了一些诊断法，比如<strong>学习曲线</strong>，同时也讨论了<strong>误差分析、上限分析</strong>等等内容。</p><p>所有这些工具都能有效地指引你决定接下来应该怎样做，让你把宝贵的时间用在刀刃上。现在你已经掌握了很多机器学习的工具，包括监督学习算法和无监督学习算法等等。</p><p>但除了这些以外，我更希望你现在不仅仅只是认识这些工具，更重要的是掌握怎样有效地利用这些工具来建立强大的机器学习系统。所以，以上就是这门课的全部内容。如果你跟着我们的课程一路走来，到现在，你应该已经感觉到自己已经成为机器学习方面的专家了吧？</p><p>我们都知道，机器学习是一门对科技、工业产生深远影响的重要学科，而现在，你已经完全具备了应用这些机器学习工具来创造伟大成就的能力。我希望你们中的很多人都能在相应的领域，应用所学的机器学习工具，构建出完美的机器学习系统，开发出无与伦比的产品和应用。并且我也希望你们通过应用机器学习，不仅仅改变自己的生活，有朝一日，还要让更多的人生活得更加美好！</p><p>我也想告诉大家，教这门课对我来讲是一种享受。所以，谢谢大家！</p><p>最后，在结束之前，我还想再多说一点：那就是，也许不久以前我也是一个学生，即使是现在，我也尽可能挤出时间听一些课，学一些新的东西。所以，我深知要坚持学完这门课是很需要花一些时间的，我知道，也许你是一个很忙的人，生活中有很多很多事情要处理。正因如此，你依然挤出时间来观看这些课程视频。我知道，很多视频的时间都长达数小时，你依然花了好多时间来做这些复习题。你们中好多人，还愿意花时间来研究那些编程练习，那些又长又复杂的编程练习。我对你们表示衷心的感谢！我知道你们很多人在这门课中都非常努力，很多人都在这门课上花了很多时间，很多人都为这门课贡献了自己的很多精力。所以，我衷心地希望你们能从这门课中有所收获！</p><p>最后我想说！再次感谢你们选修这门课程！</p><p><strong>Andew Ng</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>申请Coursera奖学金拿证书</p><blockquote><p>I am a Master student at Shang Hai  University which located in China，I’m so sorry I’m so poor to afford the cost in China All my income is just enough to cover my living expense, so I don’t have extra money to register the class. Furthermore, I want to save money for my family Since my parents have been working so hard to support me.For nowadays ，machine learning is so hot not only in China but also in the world I request Coursera for financial aid, and I promise I will finish the course in time. I think Coursera is a very good platform for people to learn something they need, and sincerely hoping to learn something. This program provided by Coursera is a great opportunity for a poor student like me to pursue the course, and I hope I can get the chance. Thank you for your consideration. I hope you can agree with my application. I look forward to your reply.Thank you so much</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Processing</title>
      <link href="/2021/01/22/processing/"/>
      <url>/2021/01/22/processing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter七天入门</title>
      <link href="/2021/01/22/flutter/"/>
      <url>/2021/01/22/flutter/</url>
      
        <content type="html"><![CDATA[<h2 id="七天学习Flutter"><a href="#七天学习Flutter" class="headerlink" title="七天学习Flutter"></a>七天学习Flutter</h2><h3 id="入门资料"><a href="#入门资料" class="headerlink" title="入门资料"></a>入门资料</h3><p><a href="https://blog.csdn.net/qq_41976613/article/details/91432304" target="_blank" rel="noopener">android studio的安装，史上最详细(超多图)！！</a></p><p><a href="http://hukai.me/android-training-course-in-chinese/basics/index.html" target="_blank" rel="noopener">Android入门基础：从这里开始</a></p><p><a href="https://www.cnblogs.com/ztpark/p/7698640.html" target="_blank" rel="noopener">Android Studio 运行 React Native 开发手机App 起步和踩坑</a></p><p><a href="http://laomengit.com/guide/introduction/mobile_system.html" target="_blank" rel="noopener">Flutter实战</a></p><p><a href="https://www.wolai.com/gfDRYkDNaCU1eg9anNvZay" target="_blank" rel="noopener">Flutter资源整理</a></p><p><a href="https://flutter.cn/docs/development/ui/widgets-intro" target="_blank" rel="noopener">Widgets 介绍</a></p><p><a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/declarative" target="_blank" rel="noopener">状态管理中的声明式编程思维</a></p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p><a href="https://blog.csdn.net/yechaoa/article/details/89150852" target="_blank" rel="noopener">Flutter环境配置</a></p><p><a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=windows" target="_blank" rel="noopener">Flutter SDK releases</a></p><p><a href="https://www.mockplus.cn/?home=1" target="_blank" rel="noopener">慕客</a></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ul><li><p>运行flutter doctor 命令报错</p><p>解决的时候注意使用管理员权限运行bat文件</p></li><li><p>Android studio 升级到4.1之后出现 flutter dart 插件找不到问题</p></li></ul><p>  其实也可以不管，项目可以正常运行。</p><p><a href="https://blog.csdn.net/wwp9527/article/details/113120829?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">Android studio4.1之后Flutter更新</a></p><p><a href="https://blog.csdn.net/tw2496907023/article/details/111243230" target="_blank" rel="noopener">【flutter环境问题】Downloading Dart SDK Flutter engine时卡着不动</a></p><p><strong>注意</strong>：现在Flutter只能用<strong>JDK8</strong>！！！ 否则会报错说：Exception in thread “main” java.lang.NoclassDefFoundError</p><p>配置镜像源</p><p>FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a> PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210216201127115.png" alt="image-20210216201127115"></p><h2 id="学习过程记录"><a href="#学习过程记录" class="headerlink" title="学习过程记录"></a>学习过程记录</h2><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>花了四个多小时安装环境配置</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9AF67F88167620FD8454AA888AE2E4A4.jpg" alt></p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p><a href="http://laomengit.com/guide/introduction/%E5%88%9B%E5%BB%BAFlutter%E9%A1%B9%E7%9B%AE%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D.html" target="_blank" rel="noopener">创建Flutter项目及默认代码介绍</a></p><p>Flutter 的构建模式选择</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/5C3B096E6AE10D8EFD1771E5EE2D73C8.jpg" alt="第一款练手app"></p><h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/UI_.png" alt="UI_"></p><p>什么是声明式UI?</p><h3 id="暂时放弃"><a href="#暂时放弃" class="headerlink" title="暂时放弃"></a>暂时放弃</h3><p><a href="https://juejin.cn/post/6930508768983646216" target="_blank" rel="noopener">Flutter 路由与导航</a></p><p><a href="https://juejin.cn/post/6844904178863587336" target="_blank" rel="noopener">使用 Flutter 绘制图表（一）柱状图</a></p><p><a href="https://juejin.cn/post/6844903996923052040" target="_blank" rel="noopener">flutter - sqlite数据库小白入门，看不懂打死我</a></p><p><a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/intro" target="_blank" rel="noopener">https://flutter.cn/docs/development/data-and-backend/state-mgmt/intro</a></p><p><a href="https://flutter.cn/docs/cookbook/persistence/sqlite#example" target="_blank" rel="noopener">https://flutter.cn/docs/cookbook/persistence/sqlite#example</a></p><p><a href="https://blog.csdn.net/u010940300/article/details/43909509?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">.android占C盘空间解决方案</a></p><h2 id="重启6-17"><a href="#重启6-17" class="headerlink" title="重启6.17"></a>重启6.17</h2><p>应以实用为导向目标，因为终点是做出产品。</p><p>之前感觉教程看起来不太容易理解，还需要找更多资料，这次希望先找Android开发看一下，花点时间了解开发app的一些细节。</p><h3 id="目标6-18"><a href="#目标6-18" class="headerlink" title="目标6.18"></a>目标6.18</h3><p>认认真真写下项目策划。（6.18）</p><p>关于时间管理以及如何掌握自己的时间，很多的思考都是来源于彼得·德鲁克，《The Effective Executive》。第二章开头就告诉了我们，“关于管理者任务的讨论，一般都从如何做计划说起……可惜的是管理者的工作计划，很少真正发生作用。计划通常只是纸上谈兵，或只是良好的意愿而已，很少能够真正实现。”</p><p>就比如我很早以前就想自己写一个app，但是一直没有明确的计划，所以也被卡在同一个地方很久，直到现在也没有太大的进展。</p><p>根据德鲁克的观察，有效的管理者不会一开始就着手工作，他们往往会从时间入手。就像很多人一样，那些富有创造力并且成功打造出产品的人也有着不同程度的拖延症，比如达芬奇。</p><p>所以，他们并不以计划为起点，<strong>认清楚自己的时间用在什么地方才是起点</strong>。</p><p>然后他们<strong>管理自己的时间</strong>，减少非生产性工作所占用的时间。就好像《穿普拉达的女王》中BOSS老板把所有小事情，包括挂衣服背宴会人员名单等都扔给下属的小助理去做，自己则更多专注于时尚和各种活动。</p><p>最后，再将“<strong>可自由运用的时间</strong>”，由零星而集中成大块连续的时段。</p><p>因此可以总结出Executive Effective的基础：</p><ul><li>记录时间</li><li>管理时间</li><li>统一安排时间</li></ul><p>记录时间是最简单也最重要的，这符合奥卡姆剃刀法则。如果完全靠记忆，我们恐怕都说不清自己昨天或者前天的时间是怎么打发的，一个月或者一年就更难了，随着时间拉长，记录的时间信息可能就会越来越多，要持续不间断地记录下每一天的时间信息对我们来说也是非常困难的，事实上，任何一件小事坚持的时间只要变的足够长，难度都会超过起初的想象。</p><p>而为了后续更好地管理和安排时间，如何记录时间信息就是基础，在这个数据为王的时代，有了足够的数据支撑，就能根据数据做出有效的决策。</p><p>如此看来，记录时间有两个难点：</p><p><strong>一是知</strong>，即对记录<strong>时间信息的理解和思考</strong>，为了对市面上存在的几款时间管理工具做比较，我曾向朋友们了解过他们的使用体验以及对时间管理的看法。当然我自己也使用过很长时间的番茄TODO和块时间这两款APP，有很多想法大家都是不谋而合的。</p><p><strong>二是行</strong>，即<strong>记录方法和实践</strong>，如何方便地记录时间，必须尽量减少记录者的麻烦。又比如应该以什么样的形式记录信息？是提前写下计划任务的时间再临时修改、等完成某一工作后记录、还是必须在处理某一工作<strong>“当时“</strong>立即加一记录，而不能时候凭记忆补充呢？</p><p>所谓管理时间，可以先简单对应到数据结构课中的AOV网络，就是对所有任务进行拓扑排序。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021寒假计划</title>
      <link href="/2021/01/22/2021-han-jia-ji-hua/"/>
      <url>/2021/01/22/2021-han-jia-ji-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="2021寒假计划1-0"><a href="#2021寒假计划1-0" class="headerlink" title="2021寒假计划1.0"></a>2021寒假计划1.0</h1><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210124214306736.png" alt></p><blockquote><p><strong>“哪有什么很忙，只是你觉得当下选择做某件事，而非另一件而已。说白了，一切都是你自己的选择。“</strong></p></blockquote><p>从1.25开始放寒假到2.28刚好是整整五周时间（35天840个小时）</p><p>虽然目前不好说3.1能不能正常返校开学，但是这个寒假还是很短暂的，要利用好时间。</p><h2 id="课内学习"><a href="#课内学习" class="headerlink" title="课内学习"></a>课内学习</h2><h3 id="寒假作业"><a href="#寒假作业" class="headerlink" title="寒假作业"></a>寒假作业</h3><p>数据结构</p><ul><li><input checked disabled type="checkbox"> 实验四</li><li><input disabled type="checkbox"> 小组作业四</li></ul><p>组成原理</p><ul><li><input checked disabled type="checkbox"> linkpac实验</li><li><input disabled type="checkbox"> 第五章到第八章课本作业题</li></ul><p>概率论</p><ul><li><input checked disabled type="checkbox"> 假设检验作业题</li></ul><p>离散数学</p><ul><li><input checked disabled type="checkbox"> 第四章课后练习</li></ul><h2 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h2><h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>美赛（2.4-2.8）</p><p>计赛（2月底收尾）</p><p>创赛（5月底）</p><h3 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h3><ul><li><input disabled type="checkbox"> 计算机网络</li><li><input disabled type="checkbox"> 操作系统</li><li><input disabled type="checkbox"> 数据结构</li><li><input disabled type="checkbox"> 离散数学</li><li><input disabled type="checkbox"> 复变函数</li></ul><h3 id="温习"><a href="#温习" class="headerlink" title="温习"></a>温习</h3><ul><li><input disabled type="checkbox"> 线性代数</li><li><input disabled type="checkbox"> 微积分</li></ul><h3 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h3><p><strong>完成部分</strong></p><h4 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h4><p>7天</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《西瓜书》</p><h4 id="英语CET-6"><a href="#英语CET-6" class="headerlink" title="英语CET-6"></a>英语CET-6</h4><p>单词已背完</p><p>没刷题</p><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>3天</p><hr><p><strong>未完成部分</strong></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>3天</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>3天</p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>1天</p><h4 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h4><h4 id="NLP自然语言处理"><a href="#NLP自然语言处理" class="headerlink" title="NLP自然语言处理"></a>NLP自然语言处理</h4><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>1天</p><h4 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h4><p>1天</p><h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><p>四门专业课考试+毛概</p><p>体育乒乓球</p><h2 id="时间安排表"><a href="#时间安排表" class="headerlink" title="时间安排表"></a>时间安排表</h2><table><thead><tr><th>时间阶段</th><th>具体任务安排</th></tr></thead><tbody><tr><td>第一阶段1.25-2.9(前两周)</td><td>1.25-2.1知识准备（2.4-2.8）正式比赛</td></tr><tr><td>第二阶段2.10-2.14</td><td>拜年修整</td></tr><tr><td>第三阶段2.15-2.21</td><td>Flutter</td></tr><tr><td>第四阶段2.22-2.28</td><td>考试复习</td></tr><tr><td>未知阶段3.1-？</td><td></td></tr></tbody></table><h2 id="资料整理归档"><a href="#资料整理归档" class="headerlink" title="资料整理归档"></a>资料整理归档</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><strong>asoc</strong></p><p><strong>gsoc</strong></p>]]></content>
      
      
      <categories>
          
          <category> 假期计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2021/01/22/java/"/>
      <url>/2021/01/22/java/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Java学习之路"><a href="#我的Java学习之路" class="headerlink" title="我的Java学习之路"></a>我的Java学习之路</h1><blockquote><p>工欲善其事必先利其器。</p></blockquote><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>Jdk:可以理解为就是java本身，你写的java程序必须要Jdk才能执行。</p><p>Eclipse：是写Java代码的地方，它集成了调试、运行、管理等功能于一体。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210123093843490.png" alt="Hello World"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何卖出一瓶水</title>
      <link href="/2021/01/15/guan-yu-yi-ping-shui/"/>
      <url>/2021/01/15/guan-yu-yi-ping-shui/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/v2-569c7994e7598714d44790fbacbf065a_b.jpg" alt="看看这些水"></p><p>作为一个卖水的二道贩子，我们也要学会自己使用思维框架了。</p><p>现在我要提出五个观念，并且使用它们来解决这个在推销中极难的问题——如何卖出一瓶水。</p><p>这个问题实际上是这样的：假设你作为HFDP公司商务部门的一员，你要如何重新策划并在上海引入Kristal这种高端水（玻璃瓶装，国外售价3$/L）</p><p>接下来，我会利用查理芒格有用的普遍观念来尝试解决这个问题。</p><blockquote><p><strong>The first helpful notion is that it is usually best to simplify problems by deciding big “no-brainer” questions first.</strong></p><p><strong>The second helpful notion mimics Galileo’s conclusion that scientific realiry is often revealed only by math as if math was the language of God. Galileo’s attitude also works well in messy, practical life.</strong></p><p><strong>The third helpful norion is that it is not enough to think problems through forward.</strong> You must also think in reverse, much like the rustic who wanted ro know where he was going to die so that he’d never go there. </p><p><strong>The fourth helpful noion is that the best and most pracrical wisdom is elementary academic wisdom.</strong> But there is one extremely important qualification: You must think in a multidisciplinary manner. </p><p><strong>The fifth helpful noion is that really big effects, lollapalooza effects, will often come only from large combinations of factors.</strong></p></blockquote><hr><p><a href="https://zhuanlan.zhihu.com/p/36708872" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 商务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人机共生》</title>
      <link href="/2021/01/01/ren-ji-gong-sheng/"/>
      <url>/2021/01/01/ren-ji-gong-sheng/</url>
      
        <content type="html"><![CDATA[<p><strong>Man-Computer Symbiosis</strong></p><p><strong>J. C. R. Licklider</strong><br>IRE Transactions on Human Factors in Electronics,<br>volume HFE-1, pages 4-11, March 1960</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote><p>Man-computer symbiosis is an expected development in cooperative interaction between men and electronic computers. It will involve very close coupling between the human and the electronic members of the partnership. The main aims are 1) to let computers facilitate formulative thinking as they now facilitate the solution of formulated problems, and 2) to enable men and computers to cooperate in making decisions and controlling complex situations without inflexible dependence on predetermined programs. In the anticipated symbiotic partnership, men will set the goals, formulate the hypotheses, determine the criteria, and perform the evaluations. Computing machines will do the routinizable work that must be done to prepare the way for insights and decisions in technical and scientific thinking. Preliminary analyses indicate that the symbiotic partnership will perform intellectual operations much more effectively than man alone can perform them. Prerequisites for the achievement of the effective, cooperative association include developments in computer time sharing, in memory components, in memory organization, in programming languages, and in input and output equipment.</p></blockquote><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><h2 id="1-1-Symbiosis"><a href="#1-1-Symbiosis" class="headerlink" title="1.1 Symbiosis"></a>1.1 Symbiosis</h2><p>The fig tree is pollinated only by the insect <em>Blastophaga grossorun</em>. The larva of the insect lives in the ovary of the fig tree, and there it gets its food. The tree and the insect are thus heavily interdependent: the tree cannot reproduce wit bout the insect; the insect cannot eat wit bout the tree; together, they constitute not only a viable but a productive and thriving partnership. This cooperative “living together in intimate association, or even close union, of two dissimilar organisms” is called symbiosis [27].</p><p>“Man-computer symbiosis is a subclass of man-machine systems. There are many man-machine systems. At present, however, there are no man-computer symbioses. The purposes of this paper are to present the concept and, hopefully, to foster the development of man-computer symbiosis by analyzing some problems of interaction between men and computing machines, calling attention to applicable principles of man-machine engineering, and pointing out a few questions to which research answers are needed. The hope is that, in not too many years, human brains and computing machines will be coupled together very tightly, and that the resulting partnership will think as no human brain has ever thought and process data in a way not approached by the information-handling machines we know today.</p><h2 id="1-2-Between-“Mechanically-Extended-Man”-and-“Artificial-Intelligence”"><a href="#1-2-Between-“Mechanically-Extended-Man”-and-“Artificial-Intelligence”" class="headerlink" title="1.2 Between “Mechanically Extended Man” and “Artificial Intelligence”"></a>1.2 Between “Mechanically Extended Man” and “Artificial Intelligence”</h2><p>As a concept, man-computer symbiosis is different in an important way from what North [21] has called “mechanically extended man.” In the man-machine systems of the past, the human operator supplied the initiative, the direction, the integration, and the criterion. The mechanical parts of the systems were mere extensions, first of the human arm, then of the human eye. These systems certainly did not consist of “dissimilar organisms living together…” There was only one kind of organism-man-and the rest was there only to help him.</p><p>In one sense of course, any man-made system is intended to help man, to help a man or men outside the system. If we focus upon the human operator within the system, however, we see that, in some areas of technology, a fantastic change has taken place during the last few years. “Mechanical extension” has given way to replacement of men, to automation, and the men who remain are there more to help than to be helped. In some instances, particularly in large computer-centered information and control systems, the human operators are responsible mainly for functions that it proved infeasible to automate. Such systems (“humanly extended machines,” North might call them) are not symbiotic systems. They are “semi-automatic” systems, systems that started out to be fully automatic but fell short of the goal.</p><p>Man-computer symbiosis is probably not the ultimate paradigm for complex technological systems. It seems entirely possible that, in due course, electronic or chemical “machines” will outdo the human brain in most of the functions we now consider exclusively within its province. Even now, Gelernter’s IBM-704 program for proving theorems in plane geometry proceeds at about the same pace as Brooklyn high school students, and makes similar errors.[12] There are, in fact, several theorem-proving, problem-solving, chess-playing, and pattern-recognizing programs (too many for complete reference [1, 2, 5, 8, 11, 13, 17, 18, 19, 22, 23, 25]) capable of rivaling human intellectual performance in restricted areas; and Newell, Simon, and Shaw’s [20] “general problem solver” may remove some of the restrictions. In short, it seems worthwhile to avoid argument with (other) enthusiasts for artificial intelligence by conceding dominance in the distant future of cerebration to machines alone. There will nevertheless be a fairly long interim during which the main intellectual advances will be made by men and computers working together in intimate association. A multidisciplinary study group, examining future research and development problems of the Air Force, estimated that it would be 1980 before developments in artificial intelligence make it possible for machines alone to do much thinking or problem solving of military significance. That would leave, say, five years to develop man-computer symbiosis and 15 years to use it. The 15 may be 10 or 500, but those years should be intellectually the most creative and exciting in the history of mankind.</p><h1 id="2-Aims-of-Man-Computer-Symbiosis"><a href="#2-Aims-of-Man-Computer-Symbiosis" class="headerlink" title="2 Aims of Man-Computer Symbiosis"></a>2 Aims of Man-Computer Symbiosis</h1><p>Present-day computers are designed primarily to solve preformulated problems or to process data according to predetermined procedures. The course of the computation may be conditional upon results obtained during the computation, but all the alternatives must be foreseen in advance. (If an unforeseen alternative arises, the whole process comes to a halt and awaits the necessary extension of the program.) The requirement for preformulation or predetermination is sometimes no great disadvantage. It is often said that programming for a computing machine forces one to think clearly, that it disciplines the thought process. If the user can think his problem through in advance, symbiotic association with a computing machine is not necessary.</p><p>However, many problems that can be thought through in advance are very difficult to think through in advance. They would be easier to solve, and they could be solved faster, through an intuitively guided trial-and-error procedure in which the computer cooperated, turning up flaws in the reasoning or revealing unexpected turns in the solution. Other problems simply cannot be formulated without computing-machine aid. Poincare anticipated the frustration of an important group of would-be computer users when he said, “The question is not, ‘What is the answer?’ The question is, ‘What is the question?’” One of the main aims of man-computer symbiosis is to bring the computing machine effectively into the formulative parts of technical problems.</p><p>The other main aim is closely related. It is to bring computing machines effectively into processes of thinking that must go on in “real time,” time that moves too fast to permit using computers in conventional ways. Imagine trying, for example, to direct a battle with the aid of a computer on such a schedule as this. You formulate your problem today. Tomorrow you spend with a programmer. Next week the computer devotes 5 minutes to assembling your program and 47 seconds to calculating the answer to your problem. You get a sheet of paper 20 feet long, full of numbers that, instead of providing a final solution, only suggest a tactic that should be explored by simulation. Obviously, the battle would be over before the second step in its planning was begun. To think in interaction with a computer in the same way that you think with a colleague whose competence supplements your own will require much tighter coupling between man and machine than is suggested by the example and than is possible today.</p><h1 id="3-Need-for-Computer-Participation-in-Formulative-and-Real-Time-Thinking"><a href="#3-Need-for-Computer-Participation-in-Formulative-and-Real-Time-Thinking" class="headerlink" title="3 Need for Computer Participation in Formulative and Real-Time Thinking"></a>3 Need for Computer Participation in Formulative and Real-Time Thinking</h1><p>The preceding paragraphs tacitly made the assumption that, if they could be introduced effectively into the thought process, the functions that can be performed by data-processing machines would improve or facilitate thinking and problem solving in an important way. That assumption may require justification.</p><h2 id="3-1-A-Preliminary-and-Informal-Time-and-Motion-Analysis-of-Technical-Thinking"><a href="#3-1-A-Preliminary-and-Informal-Time-and-Motion-Analysis-of-Technical-Thinking" class="headerlink" title="3.1 A Preliminary and Informal Time-and-Motion Analysis of Technical Thinking"></a>3.1 A Preliminary and Informal Time-and-Motion Analysis of Technical Thinking</h2><p>Despite the fact that there is a voluminous literature on thinking and problem solving, including intensive case-history studies of the process of invention, I could find nothing comparable to a time-and-motion-study analysis of the mental work of a person engaged in a scientific or technical enterprise. In the spring and summer of 1957, therefore, I tried to keep track of what one moderately technical person actually did during the hours he regarded as devoted to work. Although I was aware of the inadequacy of the sampling, I served as my own subject.</p><p>It soon became apparent that the main thing I did was to keep records, and the project would have become an infinite regress if the keeping of records had been carried through in the detail envisaged in the initial plan. It was not. Nevertheless, I obtained a picture of my activities that gave me pause. Perhaps my spectrum is not typical–I hope it is not, but I fear it is.</p><p>About 85 per cent of my “thinking” time was spent getting into a position to think, to make a decision, to learn something I needed to know. Much more time went into finding or obtaining information than into digesting it. Hours went into the plotting of graphs, and other hours into instructing an assistant how to plot. When the graphs were finished, the relations were obvious at once, but the plotting had to be done in order to make them so. At one point, it was necessary to compare six experimental determinations of a function relating speech-intelligibility to speech-to-noise ratio. No two experimenters had used the same definition or measure of speech-to-noise ratio. Several hours of calculating were required to get the data into comparable form. When they were in comparable form, it took only a few seconds to determine what I needed to know.</p><p>Throughout the period I examined, in short, my “thinking” time was devoted mainly to activities that were essentially clerical or mechanical: searching, calculating, plotting, transforming, determining the logical or dynamic consequences of a set of assumptions or hypotheses, preparing the way for a decision or an insight. Moreover, my choices of what to attempt and what not to attempt were determined to an embarrassingly great extent by considerations of clerical feasibility, not intellectual capability.</p><p>The main suggestion conveyed by the findings just described is that the operations that fill most of the time allegedly devoted to technical thinking are operations that can be performed more effectively by machines than by men. Severe problems are posed by the fact that these operations have to be performed upon diverse variables and in unforeseen and continually changing sequences. If those problems can be solved in such a way as to create a symbiotic relation between a man and a fast information-retrieval and data-processing machine, however, it seems evident that the cooperative interaction would greatly improve the thinking process.</p><p>It may be appropriate to acknowledge, at this point, that we are using the term “computer” to cover a wide class of calculating, data-processing, and information-storage-and-retrieval machines. The capabilities of machines in this class are increasing almost daily. It is therefore hazardous to make general statements about capabilities of the class. Perhaps it is equally hazardous to make general statements about the capabilities of men. Nevertheless, certain genotypic differences in capability between men and computers do stand out, and they have a bearing on the nature of possible man-computer symbiosis and the potential value of achieving it.</p><p>As has been said in various ways, men are noisy, narrow-band devices, but their nervous systems have very many parallel and simultaneously active channels. Relative to men, computing machines are very fast and very accurate, but they are constrained to perform only one or a few elementary operations at a time. Men are flexible, capable of “programming themselves contingently” on the basis of newly received information. Computing machines are single-minded, constrained by their “ pre-programming.” Men naturally speak redundant languages organized around unitary objects and coherent actions and employing 20 to 60 elementary symbols. Computers “naturally” speak nonredundant languages, usually with only two elementary symbols and no inherent appreciation either of unitary objects or of coherent actions.</p><p>To be rigorously correct, those characterizations would have to include many qualifiers. Nevertheless, the picture of dissimilarity (and therefore p0tential supplementation) that they present is essentially valid. Computing machines can do readily, well, and rapidly many things that are difficult or impossible for man, and men can do readily and well, though not rapidly, many things that are difficult or impossible for computers. That suggests that a symbiotic cooperation, if successful in integrating the positive characteristics of men and computers, would be of great value. The differences in speed and in language, of course, pose difficulties that must be overcome.</p><h1 id="4-Separable-Functions-of-Men-and-Computers-in-the-Anticipated-Symbiotic-Association"><a href="#4-Separable-Functions-of-Men-and-Computers-in-the-Anticipated-Symbiotic-Association" class="headerlink" title="4 Separable Functions of Men and Computers in the Anticipated Symbiotic Association"></a>4 Separable Functions of Men and Computers in the Anticipated Symbiotic Association</h1><p>It seems likely that the contributions of human operators and equipment will blend together so completely in many operations that it will be difficult to separate them neatly in analysis. That would be the case it; in gathering data on which to base a decision, for example, both the man and the computer came up with relevant precedents from experience and if the computer then suggested a course of action that agreed with the man’s intuitive judgment. (In theorem-proving programs, computers find precedents in experience, and in the SAGE System, they suggest courses of action. The foregoing is not a far-fetched example. ) In other operations, however, the contributions of men and equipment will be to some extent separable.</p><p>Men will set the goals and supply the motivations, of course, at least in the early years. They will formulate hypotheses. They will ask questions. They will think of mechanisms, procedures, and models. They will remember that such-and-such a person did some possibly relevant work on a topic of interest back in 1947, or at any rate shortly after World War II, and they will have an idea in what journals it might have been published. In general, they will make approximate and fallible, but leading, contributions, and they will define criteria and serve as evaluators, judging the contributions of the equipment and guiding the general line of thought.</p><p>In addition, men will handle the very-low-probability situations when such situations do actually arise. (In current man-machine systems, that is one of the human operator’s most important functions. The sum of the probabilities of very-low-probability alternatives is often much too large to neglect. ) Men will fill in the gaps, either in the problem solution or in the computer program, when the computer has no mode or routine that is applicable in a particular circumstance.</p><p>The information-processing equipment, for its part, will convert hypotheses into testable models and then test the models against data (which the human operator may designate roughly and identify as relevant when the computer presents them for his approval). The equipment will answer questions. It will simulate the mechanisms and models, carry out the procedures, and display the results to the operator. It will transform data, plot graphs (“cutting the cake” in whatever way the human operator specifies, or in several alternative ways if the human operator is not sure what he wants). The equipment will interpolate, extrapolate, and transform. It will convert static equations or logical statements into dynamic models so the human operator can examine their behavior. In general, it will carry out the routinizable, clerical operations that fill the intervals between decisions.</p><p>In addition, the computer will serve as a statistical-inference, decision-theory, or game-theory machine to make elementary evaluations of suggested courses of action whenever there is enough basis to support a formal statistical analysis. Finally, it will do as much diagnosis, pattern-matching, and relevance-recognizing as it profitably can, but it will accept a clearly secondary status in those areas.</p><h1 id="5-Prerequisites-for-Realization-of-Man-Computer-Symbiosis"><a href="#5-Prerequisites-for-Realization-of-Man-Computer-Symbiosis" class="headerlink" title="5 Prerequisites for Realization of Man-Computer Symbiosis"></a>5 Prerequisites for Realization of Man-Computer Symbiosis</h1><p>The data-processing equipment tacitly postulated in the preceding section is not available. The computer programs have not been written. There are in fact several hurdles that stand between the nonsymbiotic present and the anticipated symbiotic future. Let us examine some of them to see more clearly what is needed and what the chances are of achieving it.</p><h2 id="5-1-Speed-Mismatch-Between-Men-and-Computers"><a href="#5-1-Speed-Mismatch-Between-Men-and-Computers" class="headerlink" title="5.1 Speed Mismatch Between Men and Computers"></a>5.1 Speed Mismatch Between Men and Computers</h2><p>Any present-day large-scale computer is too fast and too costly for real-time cooperative thinking with one man. Clearly, for the sake of efficiency and economy, the computer must divide its time among many users. Timesharing systems are currently under active development. There are even arrangements to keep users from “clobbering” anything but their own personal programs.</p><p>It seems reasonable to envision, for a time 10 or 15 years hence, a “thinking center” that will incorporate the functions of present-day libraries together with anticipated advances in information storage and retrieval and the symbiotic functions suggested earlier in this paper. The picture readily enlarges itself into a network of such centers, connected to one another by wide-band communication lines and to individual users by leased-wire services. In such a system, the speed of the computers would be balanced, and the cost of the gigantic memories and the sophisticated programs would be divided by the number of users.</p><h2 id="5-2-Memory-Hardware-Requirements"><a href="#5-2-Memory-Hardware-Requirements" class="headerlink" title="5.2 Memory Hardware Requirements"></a>5.2 Memory Hardware Requirements</h2><p>When we start to think of storing any appreciable fraction of a technical literature in computer memory, we run into billions of bits and, unless things change markedly, billions of dollars.</p><p>The first thing to face is that we shall not store all the technical and scientific papers in computer memory. We may store the parts that can be summarized most succinctly-the quantitative parts and the reference citations-but not the whole. Books are among the most beautifully engineered, and human-engineered, components in existence, and they will continue to be functionally important within the context of man-computer symbiosis. (Hopefully, the computer will expedite the finding, delivering, and returning of books.)</p><p>The second point is that a very important section of memory will be permanent: part indelible <em>memory</em> and part <em>published memory</em>. The computer will be able to write once into indelible memory, and then read back indefinitely, but the computer will not be able to erase indelible memory. (It may also over-write, turning all the 0’s into l’s, as though marking over what was written earlier.) Published memory will be “read-only” memory. It will be introduced into the computer already structured. The computer will be able to refer to it repeatedly, but not to change it. These types of memory will become more and more important as computers grow larger. They can be made more compact than core, thin-film, or even tape memory, and they will be much less expensive. The main engineering problems will concern selection circuitry.</p><p>In so far as other aspects of memory requirement are concerned, we may count upon the continuing development of ordinary scientific and business computing machines There is some prospect that memory elements will become as fast as processing (logic) elements. That development would have a revolutionary effect upon the design of computers.</p><h2 id="5-3-Memory-Organization-Requirements"><a href="#5-3-Memory-Organization-Requirements" class="headerlink" title="5.3 Memory Organization Requirements"></a>5.3 Memory Organization Requirements</h2><p>Implicit in the idea of man-computer symbiosis are the requirements that information be retrievable both by name and by pattern and that it be accessible through procedure much faster than serial search. At least half of the problem of memory organization appears to reside in the storage procedure. Most of the remainder seems to be wrapped up in the problem of pattern recognition within the storage mechanism or medium. Detailed discussion of these problems is beyond the present scope. However, a brief outline of one promising idea, “trie memory,” may serve to indicate the general nature of anticipated developments.</p><p>Trie memory is so called by its originator, Fredkin [10], because it is designed to facilitate retrieval of information and because the branching storage structure, when developed, resembles a tree. Most common memory systems store functions of arguments at locations designated by the arguments. (In one sense, they do not store the arguments at all. In another and more realistic sense, they store all the possible arguments in the framework structure of the memory.) The trie memory system, on the other hand, stores both the functions and the arguments. The argument is introduced into the memory first, one character at a time, starting at a standard initial register. Each argument register has one cell for each character of the ensemble (e.g., two for information encoded in binary form) and each character cell has within it storage space for the address of the next register. The argument is stored by writing a series of addresses, each one of which tells where to find the next. At the end of the argument is a special “end-of-argument” marker. Then follow directions to the function, which is stored in one or another of several ways, either further trie structure or “list structure” often being most effective.</p><p>The trie memory scheme is inefficient for small memories, but it becomes increasingly efficient in using available storage space as memory size increases. The attractive features of the scheme are these: 1) The retrieval process is extremely simple. Given the argument, enter the standard initial register with the first character, and pick up the address of the second. Then go to the second register, and pick up the address of the third, etc. 2) If two arguments have initial characters in common, they use the same storage space for those characters. 3) The lengths of the arguments need not be the same, and need not be specified in advance. 4) No room in storage is reserved for or used by any argument until it is actually stored. The trie structure is created as the items are introduced into the memory. 5) A function can be used as an argument for another function, and that function as an argument for the next. Thus, for example, by entering with the argument, “matrix multiplication,” one might retrieve the entire program for performing a matrix multiplication on the computer. 6) By examining the storage at a given level, one can determine what thus-far similar items have been stored. For example, if there is no citation for Egan, J. P., it is but a step or two backward to pick up the trail of Egan, James … .</p><p>The properties just described do not include all the desired ones, but they bring computer storage into resonance with human operators and their predilection to designate things by naming or pointing.</p><h2 id="5-4-The-Language-Problem"><a href="#5-4-The-Language-Problem" class="headerlink" title="5.4 The Language Problem"></a>5.4 The Language Problem</h2><p>The basic dissimilarity between human languages and computer languages may be the most serious obstacle to true symbiosis. It is reassuring, however, to note what great strides have already been made, through interpretive programs and particularly through assembly or compiling programs such as FORTRAN, to adapt computers to human language forms. The “Information Processing Language” of Shaw, Newell, Simon, and Ellis [24] represents another line of rapprochement. And, in ALGOL and related systems, men are proving their flexibility by adopting standard formulas of representation and expression that are readily translatable into machine language.</p><p>For the purposes of real-time cooperation between men and computers, it will be necessary, however, to make use of an additional and rather different principle of communication and control. The idea may be highlighted by comparing instructions ordinarily addressed to intelligent human beings with instructions ordinarily used with computers. The latter specify precisely the individual steps to take and the sequence in which to take them. The former present or imply something about incentive or motivation, and they supply a criterion by which the human executor of the instructions will know when he has accomplished his task. In short: instructions directed to computers specify courses; instructions-directed to human beings specify goals.</p><p>Men appear to think more naturally and easily in terms of goals than in terms of courses. True, they usually know something about directions in which to travel or lines along which to work, but few start out with precisely formulated itineraries. Who, for example, would depart from Boston for Los Angeles with a detailed specification of the route? Instead, to paraphrase Wiener, men bound for Los Angeles try continually to decrease the amount by which they are not yet in the smog.</p><p>Computer instruction through specification of goals is being approached along two paths. The first involves problem-solving, hill-climbing, self-organizing programs. The second involves real-time concatenation of preprogrammed segments and closed subroutines which the human operator can designate and call into action simply by name.</p><p>Along the first of these paths, there has been promising exploratory work. It is clear that, working within the loose constraints of predetermined strategies, computers will in due course be able to devise and simplify their own procedures for achieving stated goals. Thus far, the achievements have not been substantively important; they have constituted only “demonstration in principle.” Nevertheless, the implications are far-reaching.</p><p>Although the second path is simpler and apparently capable of earlier realization, it has been relatively neglected. Fredkin’s trie memory provides a promising paradigm. We may in due course see a serious effort to develop computer programs that can be connected together like the words and phrases of speech to do whatever computation or control is required at the moment. The consideration that holds back such an effort, apparently, is that the effort would produce nothing that would be of great value in the context of existing computers. It would be unrewarding to develop the language before there are any computing machines capable of responding meaningfully to it.</p><h2 id="5-5-Input-and-Output-Equipment"><a href="#5-5-Input-and-Output-Equipment" class="headerlink" title="5.5 Input and Output Equipment"></a>5.5 Input and Output Equipment</h2><p>The department of data processing that seems least advanced, in so far as the requirements of man-computer symbiosis are concerned, is the one that deals with input and output equipment or, as it is seen from the human operator’s point of view, displays and controls. Immediately after saying that, it is essential to make qualifying comments, because the engineering of equipment for high-speed introduction and extraction of information has been excellent, and because some very sophisticated display and control techniques have been developed in such research laboratories as the Lincoln Laboratory. By and large, in generally available computers, however, there is almost no provision for any more effective, immediate man-machine communication than can be achieved with an electric typewriter.</p><p>Displays seem to be in a somewhat better state than controls. Many computers plot graphs on oscilloscope screens, and a few take advantage of the remarkable capabilities, graphical and symbolic, of the charactron display tube. Nowhere, to my knowledge, however, is there anything approaching the flexibility and convenience of the pencil and doodle pad or the chalk and blackboard used by men in technical discussion.</p><p>1) <em>Desk-Surface Display and Control:</em> Certainly, for effective man-computer interaction, it will be necessary for the man and the computer to draw graphs and pictures and to write notes and equations to each other on the same display surface. The man should be able to present a function to the computer, in a rough but rapid fashion, by drawing a graph. The computer should read the man’s writing, perhaps on the condition that it be in clear block capitals, and it should immediately post, at the location of each hand-drawn symbol, the corresponding character as interpreted and put into precise type-face. With such an input-output device, the operator would quickly learn to write or print in a manner legible to the machine. He could compose instructions and subroutines, set them into proper format, and check them over before introducing them finally into the computer’s main memory. He could even define new symbols, as Gilmore and Savell [14] have done at the Lincoln Laboratory, and present them directly to the computer. He could sketch out the format of a table roughly and let the computer shape it up with precision. He could correct the computer’s data, instruct the machine via flow diagrams, and in general interact with it very much as he would with another engineer, except that the “other engineer” would be a precise draftsman, a lightning calculator, a mnemonic wizard, and many other valuable partners all in one.</p><p>2) <em>Computer-Posted Wall Display:</em> In some technological systems, several men share responsibility for controlling vehicles whose behaviors interact. Some information must be presented simultaneously to all the men, preferably on a common grid, to coordinate their actions. Other information is of relevance only to one or two operators. There would be only a confusion of uninterpretable clutter if all the information were presented on one display to all of them. The information must be posted by a computer, since manual plotting is too slow to keep it up to date.</p><p>The problem just outlined is even now a critical one, and it seems certain to become more and more critical as time goes by. Several designers are convinced that displays with the desired characteristics can be constructed with the aid of flashing lights and time-sharing viewing screens based on the light-valve principle.</p><p>The large display should be supplemented, according to most of those who have thought about the problem, by individual display-control units. The latter would permit the operators to modify the wall display without leaving their locations. For some purposes, it would be desirable for the operators to be able to communicate with the computer through the supplementary displays and perhaps even through the wall display. At least one scheme for providing such communication seems feasible.</p><p>The large wall display and its associated system are relevant, of course, to symbiotic cooperation between a computer and a team of men. Laboratory experiments have indicated repeatedly that informal, parallel arrangements of operators, coordinating their activities through reference to a large situation display, have important advantages over the arrangement, more widely used, that locates the operators at individual consoles and attempts to correlate their actions through the agency of a computer. This is one of several operator-team problems in need of careful study.</p><p>3) <em>Automatic Speech Production and Recognition:</em> How desirable and how feasible is speech communication between human operators and computing machines? That compound question is asked whenever sophisticated data-processing systems are discussed. Engineers who work and live with computers take a conservative attitude toward the desirability. Engineers who have had experience in the field of automatic speech recognition take a conservative attitude toward the feasibility. Yet there is continuing interest in the idea of talking with computing machines. In large part, the interest stems from realization that one can hardly take a military commander or a corporation president away from his work to teach him to type. If computing machines are ever to be used directly by top-level decision makers, it may be worthwhile to provide communication via the most natural means, even at considerable cost.</p><p>Preliminary analysis of his problems and time scales suggests that a corporation president would be interested in a symbiotic association with a computer only as an avocation. Business situations usually move slowly enough that there is time for briefings and conferences. It seems reasonable, therefore, for computer specialists to be the ones who interact directly with computers in business offices.</p><p>The military commander, on the other hand, faces a greater probability of having to make critical decisions in short intervals of time. It is easy to overdramatize the notion of the ten-minute war, but it would be dangerous to count on having more than ten minutes in which to make a critical decision. As military system ground environments and control centers grow in capability and complexity, therefore, a real requirement for automatic speech production and recognition in computers seems likely to develop. Certainly, if the equipment were already developed, reliable, and available, it would be used.</p><p>In so far as feasibility is concerned, speech production poses less severe problems of a technical nature than does automatic recognition of speech sounds. A commercial electronic digital voltmeter now reads aloud its indications, digit by digit. For eight or ten years, at the Bell Telephone Laboratories, the Royal Institute of Technology (Stockholm), the Signals Research and Development Establishment (Christchurch), the Haskins Laboratory, and the Massachusetts Institute of Technology, Dunn [6], Fant [7], Lawrence [15], Cooper [3], Stevens [26], and their co-workers, have demonstrated successive generations of intelligible automatic talkers. Recent work at the Haskins Laboratory has led to the development of a digital code, suitable for use by computing machines, that makes an automatic voice utter intelligible connected discourse [16].</p><p>The feasibility of automatic speech recognition depends heavily upon the size of the vocabulary of words to be recognized and upon the diversity of talkers and accents with which it must work. Ninety-eight per cent correct recognition of naturally spoken decimal digits was demonstrated several years ago at the Bell Telephone Laboratories and at the Lincoln Laboratory [4], [9]. To go a step up the scale of vocabulary size, we may say that an automatic recognizer of clearly spoken alpha-numerical characters can almost surely be developed now on the basis of existing knowledge. Since untrained operators can read at least as rapidly as trained ones can type, such a device would be a convenient tool in almost any computer installation.</p><p>For real-time interaction on a truly symbiotic level, however, a vocabulary of about 2000 words, e.g., 1000 words of something like basic English and 1000 technical terms, would probably be required. That constitutes a challenging problem. In the consensus of acousticians and linguists, construction of a recognizer of 2000 words cannot be accomplished now. However, there are several organizations that would happily undertake to develop an automatic recognize for such a vocabulary on a five-year basis. They would stipulate that the speech be clear speech, dictation style, without unusual accent.</p><p>Although detailed discussion of techniques of automatic speech recognition is beyond the present scope, it is fitting to note that computing machines are playing a dominant role in the development of automatic speech recognizers. They have contributed the impetus that accounts for the present optimism, or rather for the optimism presently found in some quarters. Two or three years ago, it appeared that automatic recognition of sizeable vocabularies would not be achieved for ten or fifteen years; that it would have to await much further, gradual accumulation of knowledge of acoustic, phonetic, linguistic, and psychological processes in speech communication. Now, however, many see a prospect of accelerating the acquisition of that knowledge with the aid of computer processing of speech signals, and not a few workers have the feeling that sophisticated computer programs will be able to perform well as speech-pattern recognizes even without the aid of much substantive knowledge of speech signals and processes. Putting those two considerations together brings the estimate of the time required to achieve practically significant speech recognition down to perhaps five years, the five years just mentioned.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] A. Bernstein and M. deV. Roberts, “Computer versus chess-player,” <em>Scientific American</em>, vol. 198, pp. 96-98; June, 1958.</p><p>[2] W. W. Bledsoe and I. Browning, “Pattern Recognition and Reading by Machine,” presented at the Eastern Joint Computer Conf, Boston, Mass., December, 1959.</p><p>[3] F. S. Cooper, et al., “Some experiments on the perception of synthetic speech sounds,” <em>J. Acoust Soc. Amer.</em>, vol.24, pp.597-606; November, 1952.</p><p>[4] K. H. Davis, R. Biddulph, and S. Balashek, “Automatic recognition of spoken digits,” in W. Jackson, <em>Communication Theory</em>, Butterworths Scientific Publications, London, Eng., pp. 433-441; 1953.</p><p>[5] G. P. Dinneen, “Programming pattern recognition,” <em>Proc. WJCC</em>, pp. 94-100; March, 1955.</p><p>[6] H. K. Dunn, “The calculation of vowel resonances, and an electrical vocal tract,” <em>J. Acoust Soc. Amer.</em>, vol. 22, pp.740-753; November, 1950.</p><p>[7] G. Fant, “On the Acoustics of Speech,” paper presented at the Third Internatl. Congress on Acoustics, Stuttgart, Ger.; September, 1959.</p><p>[8] B. G. Farley and W. A. Clark, “Simulation of self-organizing systems by digital computers.” <em>IRE Trans. on Information Theory</em>, vol. IT-4, pp.76-84; September, 1954</p><p>[9] J. W. Forgie and C. D. Forgie, “Results obtained from a vowel recognition computer program,” <em>J. Acoust Soc. Amer.</em>, vol. 31, pp. 1480-1489; November, 1959</p><p>[10] E. Fredkin, “Trie memory,” <em>Communications of the ACM</em>, Sept. 1960, pp. 490-499</p><p>[11] R. M. Friedberg, “A learning machine: Part I,” <em>IBM J. Res. &amp; Dev.</em>, vol.2, pp.2-13; January, 1958.</p><p>[12] H. Gelernter, “Realization of a Geometry Theorem Proving Machine.” Unesco, NS, ICIP, 1.6.6, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[13] P. C. Gilmore, “A Program for the Production of Proofs for Theorems Derivable Within the First Order Predicate Calculus from Axioms,” Unesco, NS, ICIP, 1.6.14, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[14] J. T. Gilmore and R. E. Savell, “The Lincoln Writer,” Lincoln Laboratory, M. I. T., Lexington, Mass., Rept. 51-8; October, 1959.</p><p>[15] W. Lawrence, et al., “Methods and Purposes of Speech Synthesis,” Signals Res. and Dev. Estab., Ministry of Supply, Christchurch, Hants, England, Rept. 56/1457; March, 1956.</p><p>[16] A. M. Liberman, F. Ingemann, L. Lisker, P. Delattre, and F. S. Cooper, “Minimal rules for synthesizing speech,” <em>J. Acoust Soc. Amer.</em>, vol. 31, pp. 1490-1499; November, 1959.</p><p>[17] A. Newell, “The chess machine: an example of dealing with a complex task by adaptation,” <em>Proc. WJCC</em>, pp. 101-108; March, 1955.</p><p>[18] A. Newell and J. C. Shaw, “Programming the logic theory machine.” <em>Proc. WJCC</em>, pp. 230-240; March, 1957.</p><p>[19] A. Newell, J. C. Shaw, and H. A. Simon, “Chess-playing programs and the problem of complexity,” <em>IBM J. Res &amp; Dev.</em>, vol.2, pp. 320-33.5; October, 1958.</p><p>[20] A. Newell, H. A. Simon, and J. C. Shaw, “Report on a general problem-solving program,” Unesco, NS, ICIP, 1.6.8, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[21] J. D. North, “The rational behavior of mechanically extended man”, Boulton Paul Aircraft Ltd., Wolverhampton, Eng.; September, 1954.</p><p>[22] 0. G. Selfridge, “Pandemonium, a paradigm for learning,” <em>Proc. Symp. Mechanisation of Thought Processes</em>, Natl. Physical Lab., Teddington, Eng.; November, 1958.</p><p>[23] C. E. Shannon, “Programming a computer for playing chess,” <em>Phil. Mag.</em>, vol.41, pp.256-75; March, 1950.</p><p>[24] J. C. Shaw, A. Newell, H. A. Simon, and T. O. Ellis, “A command structure for complex information processing,” <em>Proc. WJCC</em>, pp. 119-128; May, 1958.</p><p>[25] H. Sherman, “A Quasi-Topological Method for Recognition of Line Patterns,” Unesco, NS, ICIP, H.L.5, Internatl. Conf. on Information Processing, Paris, France; June, 1959</p><p>[26] K. N. Stevens, S. Kasowski, and C. G. Fant, “Electric analog of the vocal tract,” <em>J. Acoust. Soc. Amer.</em>, vol. 25, pp. 734-742; July, 1953.</p><p>[27] <em>Webster’s New International Dictionary</em>, 2nd e., G. and C. Merriam Co., Springfield, Mass., p. 2555; 1958.</p><hr><h1 id="中文翻译参考"><a href="#中文翻译参考" class="headerlink" title="中文翻译参考"></a>中文翻译参考</h1><p>摘要</p><p>人机共生是人类和电子计算机之间合作互动的一个预期发展。这将涉及人类和电子设备之间非常密切的耦合。主要目的是1）让计算机促进公式化思维，因为它们现在促进了公式化问题的解决；2）让人类和计算机能够合作做出决策和控制复杂的情况，而不依赖于预先确定的程序。在预期的共生伙伴关系中，人类将设定目标，制定假设，确定标准，并进行评估。计算机将会做一些常规的工作，为人类在技术和科学思考方面的见解和决策做好准备。初步分析表明，共生伙伴关系将比单独的人能更有效地进行智力活动。实现有效合作关系的先决条件包括计算机分时、内存组件、内存组织、编程语言以及输入和输出设备的发展。</p><p>1介绍</p><p>1.1共生</p><p>只有无花果小黄蜂（Blastophaga grossorun）才能帮助无花果树完成授粉。这种昆虫的幼体生活在无花果树的子房中，它们也能在无花果树的子房中找到食物。如此一来，无花果树和无花果小黄蜂便对彼此有着严重的依赖：没有无花果小黄蜂，无花果树就不能结出果实；没有无花果树，无花果小黄蜂也不能获得食物。两者的结合不仅能使彼此生存下去，更能创造一种高产且生机勃勃的合作关系。“两个不同的生物体以亲密合作的方式生活在一起，甚至结成紧密的联盟”，这种合作模式就叫共生。</p><p>人机共生是人机系统的一个子类。有许多人机系统。然而，目前还没有人机共生体。本文的目的是提出这一概念，并希望通过分析人机交互的一些问题，提请人们注意人机工程的适用原则，并指出一些需要研究回答的问题，从而促进人机共生的发展。我们希望，在不太长的时间内，人脑和计算机将紧密结合在一起，由此产生的伙伴关系将会认为，没有人脑能够以我们今天所知的信息处理机器所未有的方式思考和处理数据。</p><p>1.2在“机器增强的人类”和“人工智能”之间</p><p>作为一个概念，人机共生在一个重要的方面与North所称的“机器增强的人类”是不同的。在过去的人机系统中，操作者掌握主动权，提供方向，进行整合，制定标准。系统中机械的部分，首先是人类的胳膊，然后是眼睛的延伸。这些系统当然不是由“生活在一起的不同生物”组成的。只有一种有机体——人，其余的只是为了帮助这个人。</p><p>在某种意义上，任何人造系统都是为了帮助人类，帮助系统外的一个或多个人。然而，如果我们关注系统内的操作人员，我们会发现，在某些技术领域，过去几年发生了巨大的变化。“机器增强”已经取代了人类，转向了自动化，留下来的人更多的是为了帮助，而不是得到帮助。在某些情况下，特别是在以计算机为中心的大型信息和控制系统中，人工操作员主要负责自动化不可行的功能。这种系统（North可能称之为“人类增强的机器”）不是共生系统。它们是“半自动”系统，系统最初是全自动的，但没有达到目标。</p><p>人机共生可能不是复杂技术系统的最终范例。在适当的时候，电子或化学“机器”似乎完全有可能在我们现在专门考虑的大部分功能上超过人脑。即使是现在，Gelernter的IBM - 704平面几何定理证明程序的进度也和布鲁克林高中学生差不多，并且犯了类似的错误。事实上，有几个理论证明、解决问题、下棋和模式识别程序，它们能够在受限制的领域中与人类的智力表现相媲美；而Newell、Simon和Shaw的“一般问题解决器”可能会消除一些限制。简而言之，避免与(其他)人工智能爱好者争论似乎是值得的，因为他们认为在遥远的未来只有机器的统治地位。然而，在此期间，主要的智力进步将会由密切合作的人和计算机来完成，这将会是一个相当长的过渡期。一个多学科的研究小组，研究了空军未来的研究和发展问题，估计在1980年之前，人工智能的发展使机器能够独自思考或解决具有军事意义问题。这将会导致，比如说，5年的时间来发展人机共生，15年的时间来使用它。15年可能是10年或500年，但那些年应该是人类历史上最具创造力和最激动人心的时期。</p><p>2人机共生的目标</p><p>当今的计算机主要是为了解决预先设定的问题或者按照预定的程序处理数据。计算过程可能取决于计算过程中获得的结果，但是所有的替代方案都必须提前预见。（如果出现不可预见的替代方案，整个过程就会停止，等待程序的必要扩展。）预先制定或预先确定的要求有时并没有什么大的缺点。预先制定或预先确定的要求有时并没有什么大的缺点。人们常说，计算机的编程迫使人们要清楚地思考，它会规范思维过程。如果用户能够提前思考他的问题，那么与计算机的共生关系就没有必要了。</p><p>然而，很多问题……很难提前想透彻，回想一下前文对新兴系统的描述。如果能通过与计算机合作，由直觉引导进行试错，暴露出推理过程中的错误，或是揭示解决方案中某些意想不到的转折，就能更快、更好地解决问题。没有计算机辅助，其他问题根本无法解决。庞加莱预见到了一批重要的潜在计算机用户的沮丧，他说，“问题不是，答案是什么？，问题是，问题是什么”。人机共生的主要目的之一是将计算机有效地纳入技术问题的公式化部分。</p><p>另一个主要目标是密切相关的。这是为了有效地将计算机带入必须“实时”进行的思考过程，时间过快，不允许以传统方式使用计算机。想象一下，例如，试图在这样的时间表上借助计算机指挥一场战斗。你今天提出了你的问题。明天你和程序员一起度过。你会得到一张20英尺长的纸，上面写满了数字，这些数字并没有提供最终的解决方案，只是提出了一种应该通过模拟来探索的策略。显然，这场战斗将在其计划的第二步开始之前结束。与电脑互动的思维方式与你与一位同事互动的思维方式是一样的，他的能力补充了你自己的能力，这将要求人与机器之间的耦合比这个例子所建议的和现状可能的要紧密得多。</p><p>3计算机参与公式化和实时思维的需要</p><p>前面的段落默认了这样的假设：如果可以有效地引入到思想过程中，数据处理机器所能执行的功能将会以一种重要的方式改进或促进思考和解决问题。这种假设可能需要正当理由。</p><p>3.1技术思维的初步和非正式工效分析</p><p>尽管有大量关于思考和解决问题的文献，包括对发明过程的大量历史案例研究，但我找不到比对从事科技企业的人的脑力劳动进行工效研究分析更好的东西。因此，在1957年的春天和夏天，我试着记录一个中等技术人员在他认为专注于工作的时间里所做的事情。尽管我意识到取样的不足，但我还是做了自己的研究对象。很明显，我所做的主要事情是保持记录，如果按照最初计划中设想的细节保存记录，这个项目将会变成一个无限倒退。不是。尽管如此，我还是获得了一张让我停下来的活动照片。也许我的范围不典型——我希望不是，但我担心是。</p><p>我85 %的“思考”时间都花在了思考、决策、学习一些我需要知道的事情上。寻找或获取信息的时间比消化信息的时间多得多。几个小时用于绘制图表，其他几个小时用于指导助手如何绘制图表。当图表完成后，两种关系立刻变得明显，但必须进行绘图以使其成为现实。在某一点上，有必要对语音清晰度和语音噪声比相关函数的六个实验测定值进行比较。没有两个实验者使用相同的语音噪声比定义或测量。需要几个小时的计算才能把数据变成可比的形式。当它们处于可比较的形式时，我只花了几秒钟就确定了我需要知道的东西。</p><p>简而言之，在整个研究期间，我的“思考”时间主要用于本质上是文书或机械的活动：搜索、计算、绘图、转换、确定一组假设或假设的逻辑或动态后果，为决策或洞察铺平道路。此外，我对尝试什么和不尝试什么的选择在很大程度上是出于对文书可行性的考虑，而不是智力能力的考虑，这令人尴尬。</p><p>刚刚描述的研究结果传达的主要建议是，在大多数时间里，被称为技术思维的操作都是机器可以比人类更有效地执行的操作。这些操作必须在不同的变量上以不可预见的和不断变化的顺序进行，这一事实带来了严重的问题。然而，如果这些问题能够以在人和快速信息检索和数据处理机器之间建立共生关系的方式得到解决，那么合作互动显然会大大改善思维过程。</p><p>在这一点上，也许应该承认，我们正在使用术语“计算机”来涵盖各种计算、数据处理以及信息存储和检索机器。这类机器的能力几乎每天都在增加。因此，对该类的功能进行一般性陈述是危险的。也许就人的能力发表一般性声明也同样危险。尽管如此，人类和计算机之间在能力上的某些基因型差异确实很突出，并且它们对可能的人机共生的性质和实现这种共生的潜在价值有着影响。</p><p>正如已经以各种方式所说的那样，人类是嘈杂的窄带设备，但是他们的神经系统有很多平行的同时活跃的通道。相对于人类来说，计算机速度非常快而且非常精确，但是它们一次只能执行一个或几个基本操作。人类很灵活，能够根据新收到的信息“不断地自我规划”。计算机是一根筋的，受其“预编程”的约束。人类自然会说冗余性的语言，这些语言围绕着单一的物体和连贯的动作组织起来，使用20到60个基本符号。计算机“自然”会说非冗余语言，通常只有两个基本符号，对单一物体或连贯动作都没有固有的鉴赏能力。</p><p>要严格正确，这些特征必须包括许多限定符。尽管如此，它们所呈现的不同（因此也是潜在的补充）本质上是正确的。计算机可以很容易、很好、很快地做许多对人类来说困难或不可能的事情，而人类可以很容易、很好地做许多对计算机来说困难或不可能的事情，尽管不是很快。这表明，共生合作，如果成功地融合了人和计算机的积极特征，将具有巨大的价值。当然，速度和语言的差异带来了必须克服的困难。</p><p>4预期共生关系中人和计算机的可分离功能</p><p>似乎人类操作员和设备的贡献在许多操作中会如此完全地融合在一起，以至于在分析中很难将它们整齐地分开。情况就是这样；例如，在收集决策依据的数据时，人和计算机都从经验中找到了相关的先例，如果计算机随后提出了一个符合人直觉判断的行动方案。（在定理证明程序中，计算机在经验中找到了先例，在SAGE系统中，它们提出了行动方案。上述内容并不是一个牵强附会的例子。）然而，在其他行动中，人员和设备的贡献在某种程度上是可分离的。</p><p>当然，至少在早期，人类会设定目标并提供动机。他们将提出假设。他们会问问题。他们会想到机制、程序和模型。他们会记得，这样的人早在1947年，或者至少在二战后不久，就对一个感兴趣的主题做了一些可能相关的工作，他们会知道该主题可能在哪些期刊上发表。总的来说，他们会做出近似的、错误的、但领先的贡献，他们会定义标准并充当评估者，判断设备的贡献并指导总体思路。</p><p>此外，当这种情况确实出现时，人类会处理极低概率的情况。（在当前的人机系统中，这是操作员最重要的功能之一。极低概率替代方案的概率之和往往太大，不容忽视。）当计算机没有适用于特定环境的模式或程序时，人们会填补问题解决方案或计算机程序中的空白。</p><p>信息处理设备本身将把假设转换成可测试的模型，然后根据数据对模型进行测试（操作员可以粗略地指定这些数据，并在计算机将它们提交给他审批时确定它们是相关的）。这些设备将回答问题。它将模拟机制和模型，执行程序，并向操作员显示结果。它将转换数据，绘制图表（以人类操作员指定的任何方式“切蛋糕”，或者如果人类操作员不确定他想要什么，那就呈现几种替代方式）。设备将会插入、推断和转换。它将静态方程或逻辑语句转换成动态模型，以便操作员可以检查他们的行为。一般来说，它将执行可例行公事的文书工作，以填补决策之间的间隔。</p><p>此外，只要有足够的基础支持正式的统计分析，计算机将充当统计推断、决策理论或博弈论机器，对建议的行动方案进行初步评估。最后，它将尽可能多地进行诊断、模式匹配和相关性识别，但在这些领域，它将接受一个明显的次要地位。</p><p>5实现人机共生的前提条件</p><p>在前一节中默认的数据处理设备是不可用的。计算机程序尚未编写。事实上，在非共生的当下和预期的共生未来之间存在着一些障碍。让我们研究一下其中的一些障碍，以便更清楚地了解需要什么以及实现这一目标的可能性。</p><p>5.1人与计算机之间的速度不匹配</p><p>现在的大型计算机对于与一个人进行实时合作思考来说，速度太快，成本太高。显然，为了效率和经济，计算机必须在许多用户之间分配时间。分时系统目前正在积极开发中。甚至有一些安排来防止用户“破坏”除了他们自己的个人程序之外的任何东西。</p><p>在10年或15年后的一段时间里，设想一个“思维中心”似乎是合理的，它将结合当今图书馆的功能，以及信息存储和检索的预期进展和本文前面建议的共生功能。这种设想很容易放大成这样的中心网络，通过宽带通信线路相互连接，并通过租用线路服务连接到各个用户。在这样的系统中，计算机的速度将会平衡，巨大的存储器和复杂程序的成本将会除以用户的数量。</p><p>5.2存储器硬件要求</p><p>当我们开始考虑将任何已知的技术文献存储在计算机存储器中时，我们会遇到数十亿比特数据，除非事情发生显着变化，否则将花费数十亿美元。</p><p>首先要面对的是，我们不会将所有的技术和科学论文都存储在计算机存储器中。我们可能会储存概括得最简洁的部分——数量部分和参考文献——但不是全部。书籍是现存最精美、最人性化的组件之一，在人机共生的背景下，它们将继续发挥重要的功能。（希望计算机能加快图书的查找、交付和归还。）</p><p>第二点是，存储器的一个非常重要的部分将是永久的:部分是不可擦除的内存和部分是发布的内存。计算机将能够一次写入不可擦除的内存，然后无限期地读取，但是计算机将无法擦除不可擦除的内存。（它也可能会重写，将所有的0变成1，就像在之前写的东西上做标记一样。）发布的内存将是“只读”内存。它将被引入到已经构建好的计算机中。计算机将能够重复引用它，但不能改变它。随着计算机越来越大，这些类型的内存将变得越来越重要。它们可以做的比核心、薄膜、甚至磁带存储器更紧凑，而且价格也要便宜得多。主要的工程问题将涉及选择电路。</p><p>就内存需求的其他方面而言，我们可以指望普通的科学和商业计算机的持续发展。存储元件有可能变得与处理（逻辑）元件一样快。这一发展将对计算机的设计产生革命性的影响。</p><p>5.3存储组织要求</p><p>人机共生理念中隐含着这样的要求，即信息可以按名称和模式检索，并且可以通过比串行搜索快得多的程序访问。至少有一半的内存组织问题似乎存在于存储过程中。其余大部分似乎都包含在存储机制或介质中的模式识别问题中。对这些问题的详细讨论超出了目前的范围。然而，简要概述一个有希望的想法，即“trie存储”，可能有助于说明预期发展的一般性质。</p><p>Trie存储是由其创始人Fredkin所称的，是因为它被设计成便于检索信息，并且因为分支存储结构在开发的时候类似于一棵树。大多数常见的内存系统在参数指定的位置存储参数的函数。（从某种意义上说，它们根本不存储这些参数。在另一个更现实的意义上，它们将所有可能的参数存储在内存的框架结构中。）另一方面，trie存储系统存储函数和参数。从标准的初始寄存器开始，参数首先被引入内存，一次一个字符。每个参数寄存器都有一个单元格，每个字符都有一个单元格（例如，两个用于二进制形式的信息），每个字符单元都有一个存储空间，用于下一个寄存器的地址。这个参数是通过写一系列地址来存储的，每一个地址都告诉我们在哪里找到下一个地址。在引数的最后，是一个特殊的“结束参数”标记。然后遵循函数的指示，该函数以多种方式中的一种或另一种方式存储，进一步的trie结构或“列表结构”通常是最有效的。</p><p>Trie存储方案对于小内存来说是低效的，但是随着内存大小的增加，它在使用可用存储空间方面变得越来越高效。该方案吸引人的特点是：1）检索过程极其简单。给定参数后，输入第一个字符的标准初始寄存器，并提取第二个字符的地址。然后转到第二个寄存器，获取第三个寄存器的地址，等等。2）如果两个参数具有相同的初始字符，则它们对这些字符使用相同的存储空间。3）参数的长度不必相同，也不必事先指定。4）在实际存储之前，任何参数都不会保留或使用存储空间。trie结构是在项目被引入内存时创建的。5）一个函数可以用作另一个函数的参数，该函数可以用作下一个函数的参数。因此，例如，通过用参数“矩阵乘法”输入，人们可以检索在计算机上执行矩阵乘法的整个程序。6）通过检查给定级别的存储，可以确定迄今为止存储了哪些相似的项目。例如，如果没有引用Egan, J. P.，那么只需要一两步就能找到Egan James的踪迹…….</p><p>刚刚描述的属性并不包括所有想要的属性，但是它们使计算机存储与人类操作者产生共鸣，并且他们倾向于通过命名或指向来指定事物。</p><p>5.4语言问题</p><p>人类语言和计算机语言之间的基本差异可能是真正共生的最严重障碍。然而，令人欣慰的是，通过解释程序，特别是通过汇编或编译程序，如FORTRAN，已经取得了巨大进步，使计算机适应人类语言形式。Shaw，Newell，Simon和Ellis的“信息处理语言（Information Processing Language）”代表了另一种和解方式。而且，在ALGOL和相关系统中，人们通过采用可以轻易翻译成机器语言的表示和表达的标准公式来证明其灵活性。</p><p>然而，为了实现人与计算机之间的实时合作，有必要利用另外一种相当不同的通信和控制原理。可以通过比较通常针对智能人的指令和通常用于计算机的指令来突出这个想法。后者精确地指定了要采取的各个步骤以及采取这些步骤的顺序。前者提出或暗示了一些关于激励或动机的东西，它们提供了一个标准，在这个标准中，指令的执行者将知道完成任务的时间。简而言之：针对计算机的指令指定路线；针对人类的指令指定了目标。</p><p>人类似乎在目标方面比在路线方面更自然，更容易地思考。的确，他们通常知道一些关于旅行或工作路线的信息，但很少有人能从精确制定的行程开始。例如，谁会带着详细的路线说明从波士顿出发去洛杉矶？相反，用Wiener的话来说，前往洛杉矶的人试图不断减少他们还没有被烟雾笼罩的程度。</p><p>通过两种途径来实现计算机指令。第一个涉及解决问题、爬山算法、自组织项目。第二种是预编程段和闭合子程序的实时串联，操作员可以简单地通过名字来指定和调用这些子程序。</p><p>沿着第一条道路，已经有了有希望的探索性工作。很明显，在预定策略的宽松约束下工作，计算机将能够在适当的时候设计和简化自己的程序来实现既定的目标。迄今为止，这些成就并不重要；他们只是“原则上的示范”。然而，其影响深远。</p><p>尽管第二条道路更简单，显然能够更早实现，但它相对被忽视了。Fredkin的trie存储提供了一个有前途的范例。我们可能会在适当的时候看到一个认真努力来开发的计算机程序，这些程序可以像语言的单词和短语一样连接在一起，这样就可以进行任何计算或控制。显然，阻碍这种努力的考虑因素是，这种努力不会产生任何在现有计算机环境中具有重大价值的东西。在没有任何计算机能够对语言做出有意义的反应之前，开发语言是不可取的。</p><p>5.5输入输出设备</p><p>就人机共生的要求而言，似乎最不先进的数据处理部门是处理输入和输出设备的部门，或者从操作员的角度来看，是处理显示和控制的部门。在说了这句话之后，有必要做出符合条件的评论，因为用于高速引入和提取信息的设备工程一直很出色，而且一些非常复杂的显示和控制技术已经在林肯实验室等研究实验室中得到发展。然而，总的来说，在一般可用的计算机中，几乎没有比电动打字机更有效、更即时的人机通信。</p><p>显示器似乎比控制的状态好一些。许多计算机在示波器屏幕上绘制图形，少数计算机利用了字符显示管卓越的图形和符号功能。然而，据我所知，在技术讨论中，没有任何东西能接近铅笔和涂鸦板的灵活性和方便性，或者是人们使用的粉笔和黑板。</p><p>1）桌面显示和控制：当然，为了有效的人机交互，在相同的显示面上，人和电脑需要绘制图形和图画，并在相同的显示面上写注释和方程。这个人应该能够通过绘制图表，以粗糙但快速的方式向计算机展示一个功能。计算机应该阅读这个人的文字，也许是在清楚的大写字母的条件下，并且应该立即在每个手绘符号的位置张贴相应的字符，并将其翻译成精确的字体。有了这种输入输出设备，操作员将很快学会以机器可读的方式书写或打印。他可以编写指令和子程序，将它们设置成适当的格式，并在最终将它们引入计算机的主存储器之前检查它们。他甚至可以像Gilmore和Savell在林肯实验室所做的那样定义新的符号，并将它们直接呈现给计算机。他可以粗略地勾画出一张表格的格式，然后让电脑精确地塑造它。他可以修正计算机的数据，通过流程图指导机器，并且就像通常与其他工程师一样进行交互，除了“其他工程师”将是精确的绘图员，快速的计算器，助记符向导，以及许多其他有价值的合作伙伴。</p><p>2）计算机发布的墙面显示：在一些技术系统中，几个人共同负责控制行为相互影响的车辆。一些信息必须同时呈现给所有人，最好是在一个公共网格上，以协调他们的行动。其他信息仅与一两个操作者相关。如果所有信息都在一个显示器上呈现给所有人，那将只会产生无法解释的混乱。这些信息必须由计算机发布，因为手工绘图太慢，无法保持最新。</p><p>刚才概述的问题现在甚至是一个关键问题，随着时间的推移，它似乎肯定会变得越来越关键。一些设计者相信，基于光阀原理，可以借助脉冲光源和分时观看屏幕来构建具有所需特性的显示器。</p><p>大多数思考过这个问题的人认为，大型显示器应该由单独的显示器控制单元来补充。后者将允许操作者修改墙面显示而不离开他们的位置。出于某些目的，希望操作者能够通过辅助显示器甚至墙面显示与计算机通信。至少有一种提供这种通信的方案似乎是可行的。</p><p>当然，大型墙面显示及其相关系统与计算机和一组人之间的共生合作相关。实验室实验一再表明，操作员非正式的平行安排，通过参考大型位置显示器来协调他们的活动，比更广泛使用的安排具有重要优势，它将操作员定位在各个控制台上，并试图通过计算机代理来关联他们的行动。这是需要仔细研究的几个操作团队问题之一。</p><p>3）自动语音生成和识别：人类操作员和计算机之间的语音通信有多理想和可行？每当讨论复杂的数据处理系统时，都会问这个复杂的问题。与计算机一起工作和生活的工程师对这种愿望持保守态度。在自动语音识别领域有经验的工程师对可行性持保守态度。然而，人们仍然对与计算机对话的想法感兴趣。在很大程度上，这种兴趣源于人们认识到，很难把一名军事指挥官或公司总裁离开他们的工作，教他们打字。如果计算机能够被高层决策者直接使用，那么通过最自然的方式提供通信可能是值得的，即使花费相当大的成本。</p><p>对公司总裁的问题和时间尺度的初步分析表明，他只对作为爱好的计算机的共生关系感兴趣。业务情况通常进展缓慢，以至于有时间进行简报和会议。因此，对于计算机专家而言，与商务办公室中的计算机直接交互似乎是合理的。</p><p>另一方面，军事指挥官在短时间内做出关键决策的可能性更大。人们很容易夸大10分钟战争的概念，但是指望有十分钟以上的时间来做出关键决定是危险的。因此，随着军事系统地面环境和控制中心的能力和复杂性的增长，计算机自动语音生成和识别的真正需求似乎有可能得到发展。当然，如果设备已经被开发、可靠的和可用的，它就会被使用。</p><p>就可行性而言，与自动识别语音相比，语音产生带来的技术性问题不那么严重。一台商用电子数字电压表现在一个数字一个数字地大声读出它的指示。八年或十年，贝尔电话实验室，皇家理工学院（斯德哥尔摩），Signals Research and Development Establishment（Christchurch），耶鲁大学汉斯金实验室和麻省理工学院，Dunn，Fant，Lawrence，Cooper，Stevens和他们的同事，已经展示了一代又一代的可理解的自动发生器。汉斯金实验室的研究已经开发出了一种适合计算机使用的数字代码，这种代码使得自动语音完全可以理解相关的话语。</p><p>自动语音识别的可行性在很大程度上取决于要识别的单词的词汇量以及说话者和口音的多样性。几年前，在贝尔电话实验室和林肯实验室，人们已经证明了百分之九十八的正确识别自然的十进制数字。为了进一步扩大词汇量，我们可以说，现在几乎可以肯定地在现有知识的基础上开发出一种清晰发音的字母数字字符的自动识别器。由于未经训练的操作员读取的速度与训练有素的操作员键入的速度至少一样快，因此这种设备几乎可以在任何计算机安装中使用。</p><p>然而，为了在真正共生的水平上进行实时交互，可能需要大约2000个单词的词汇，例如1000个基本英语单词和1000个专业术语。这是一个具有挑战性的问题。在声学专家和语言学家的共识中，现在还不能完成建立2000个单词的识别器。然而，有几个组织乐意承诺在五年内为这样的词汇开发一个自动识别系统。他们会规定演讲要清晰，听写的风格，没有不寻常的口音。</p><p>尽管对自动语音识别技术的详细讨论超出了目前的范围，但值得注意的是，计算机在自动语音识别器的发展中起着主导作用。他们为当前的乐观情绪提供了动力，或者说是一些人目前的乐观情绪。两三年前，似乎在10年或15年内不会自动识别大量词汇；它将不得不等待语音交流中声学、语音、语言和心理过程的知识的逐渐积累。然而，现在，许多人看到了借助计算机处理语音信号来加速获取这种知识的前景，不少工作者认为，即使没有语音信号和过程的大量实质性知识的帮助，复杂的计算机程序也能像语音模式识别一样表现出色。将这两个考虑因素结合起来，可以将实现实际意义上的语音识别所需的时间估计降低到五年，即刚才提到的五年。</p><hr><h1 id="个人解读"><a href="#个人解读" class="headerlink" title="个人解读"></a>个人解读</h1>]]></content>
      
      
      <categories>
          
          <category> -未来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU机组</title>
      <link href="/2020/11/28/shu-ji-zu/"/>
      <url>/2020/11/28/shu-ji-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理与结构体系"><a href="#计算机组成原理与结构体系" class="headerlink" title="计算机组成原理与结构体系"></a>计算机组成原理与结构体系</h1><h2 id="理论学习"><a href="#理论学习" class="headerlink" title="理论学习"></a>理论学习</h2><p><a href="https://www.bilibili.com/video/BV1BE411D7ii" target="_blank" rel="noopener">b站王道机组课程</a></p><h2 id="实验一二三（实验箱）"><a href="#实验一二三（实验箱）" class="headerlink" title="实验一二三（实验箱）"></a>实验一二三（实验箱）</h2><h2 id="实验四（虚拟机）"><a href="#实验四（虚拟机）" class="headerlink" title="实验四（虚拟机）"></a>实验四（虚拟机）</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>看一遍老师给的教程。（虽然它是一份老掉牙的教程，但是你首先得知道自己要干什么，然后才好跟上大家吐槽的脚步。建议先全部看一遍，而且最后的问题汇总其实更应该放到教程开头才对）</p></li><li><p>最好提前了解一点Linux操作系统的相关知识，不是很清楚也没关系，按照步骤把实验做一遍下来大概也就差不多了。</p></li><li><p>这里是一些可能需要提前在自己电脑上安装好的东西，可能会用到的链接和教程都放在这里了，需要的请自取。</p></li></ul><p><a href="https://blog.csdn.net/hao5119266/article/details/89198275" target="_blank" rel="noopener">VM虚拟机下载及安装教程</a></p><p><a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">Vmware官方</a></p><p><a href="https://vault.centos.org/6.5/isos/x86_64/" target="_blank" rel="noopener">centos6.5下载</a><strong>（版本一致很重要！版本一致很重要！版本一致很重要！）</strong></p><hr><p>重要的事说三遍，这里说的一致是和老师给的教程里使用的版本一致，因为有的同学安装的是centos7或8甚至是Ubuntu（不同版本操作命令可能不同，安装过程也可能不会完全相同），如果你不想花费大量时间在打开CSDN上的话，建议还是装这个CentOS-6.5-x86_64-<strong>LiveCD</strong>。而且这个下载起来也快，只有600多M。之后再按照教程走就会轻松很多，直到你碰上你的第一个问题，最起码你可以不那么困难地迈出第一步。</p><hr><p>下面是几篇避坑的博客，<strong>偷懒最好的办法是一遍就把事情做好</strong>，所以为了省时间还是值得一看的，当然你也可以等遇到问题再来查</p><p><a href="https://zhuanlan.zhihu.com/p/68111471" target="_blank" rel="noopener">精通 VIM ，此文就够了</a>（linux的编辑器，和你以前使用过的编辑器可能完全不一样，做好心理准备）</p><p><a href="https://yuhui.blog.csdn.net/article/details/52325716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai" target="_blank" rel="noopener">虚拟机：三台虚拟机互通且连网</a>（要是早点看到这篇我就不用花那么多时间找其他博客了，感谢原博主帮我找到了我的问题）</p><p><a href="https://blog.csdn.net/mijichui2153/article/details/80918285" target="_blank" rel="noopener">CentOS7虚拟机克隆，且成功互ping</a>（仅供参考）</p><p>最后还是不得不吐槽一下老师给的参考教程版本实在是太老了，虽然我在这个很痛苦的过程中也学到了不少东西，但也带来了很多不必要的困扰，就拿centos6.5这个版本举例，现在都0202年了，官网上有的是centos7和8，那找起6.5来就是一个重复做功的过程，而教程后的链接也是失效的，简直是浪费感情。</p><p>剩下的其实就只要按照老师给的教程来就行了，直到虚拟机之间互通这里，我碰到最麻烦的问题也还是版本的问题，吐槽最多的地方也还是教程太老以及不够仔细。</p><hr><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>下面是我在实验过程中遇到过的一些问题，仅供参考。</p><p>首先还是回到老师给的教程上里面，如果你看的足够仔细就会发现有个地方很奇怪，那就是在修改复制的（或者说克隆）虚拟机ip这里，原来教程这里写的是</p><pre><code>修改ip：vim /etc/sysconfig/network-scripts/ifconfig-eth0将IPADDR=后的ip改为192.168.224.201</code></pre><p>但是在创建第一台虚拟机配置centos网络时是这样的</p><pre><code>配置centos网络：vim /etc/sysconfig/network-scripts/ifcfg-eth0修改（或者说是输入）DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticBROADCAST=192.168.224.225 IPADDR=192.168.224.130 NETMASK=255.255.255.0NETWORK=192.168.224.0 GATEWAY=192.168.224.2 </code></pre><p>同样是改IPADDR，为什么两个文件名不一样呢？（ifconfig-eth0和ifcfg-eth0）</p><p>这里要么是版本的问题，要么就是一个笔误，造成的后果可能就是你三台虚拟机都能ping master而不能实现真正的互通（会显示Unreachable）。</p><p>因为如果你细心的话就会发现当你在复制的虚拟机上打开ifconfig-eth0时，其实是新建了一个名为ifconfig-eth0的文件，而不是打开了复制过来的ifcfg-eth0文件。（可以自己验证一下）这里只需要注意一下即可。</p><p>我遇到的最坑的问题还是下面这个</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/798663-20160711161510686-1749110137.png" alt="直接复制文件导致两台虚拟机Mac相同，即物理地址和备份的虚拟机重复"></p><p>我是按照教程在windows中文件中直接将一个虚拟机进行复制了两份（克隆好像就没有问题），然后用vm打开， 选择我已经复制，结果虚拟机开机的时候出现了上面的日志消息提示，导致了我无法ping 通。解决方法如下（改不了的话先关闭一下虚拟机）： </p><p><a href="https://www.cnblogs.com/nucdy/p/5660701.html" target="_blank" rel="noopener">如何更改Mac地址</a></p><hr><p><strong>ssh无密码验证原理：</strong></p><p>节点A要实现无密码公钥认证连接到节点B上时，节点A是客户端，节点B是服务端，需要在客户端A上生成一个密钥对，包括一个公钥和一个私钥，而后将公钥复制到服务端B上。当客户端A通过ssh连接服务端B时，服务端B就会生成一个随机数并用客户端A的公钥对随机数进行加密，并发送给客户端A。客户端A收到加密数之后再用私钥进行解密，并将解密数回传给B，B确认解密数无误之后就允许A进行连接了。这就是一个公钥认证过程，其间不需要用户手工输入密码。重要过程是将客户端A公钥复制到B上。</p><p><img src="https://m.qpic.cn/psc?/V50yGAmm4Y7rG60gKAT73IXxN50OzhRf/bqQfVz5yrrGYSXMvKr.cqfBUrrv5isfzJMoRkFHPwqDEOOykWN3ExbxXLwX3CIPppXZvOULP*UwfGuI0whImzuhWCI3ZKLgliZeH.HHaIik!/b&bo=gAcPBAAAAAADB64!&rf=viewer_4" alt="第一步就出错了"></p><p>教程里第一步启用shh服务找不到文件，可能是版本不一样所以命令不一样了，不过很神奇的是我在第一台虚拟机上能够使用这条命令，但是复制的那两台上无法成功运行。所以我直接参考了<a href="https://www.cnblogs.com/opsprobe/p/9147934.html" target="_blank" rel="noopener">CentOS6.5下安装、配置SSH</a>（最后是使用putty需要自行安装），只要确认shh正常启用就行。以下是我成功运行的一些命令</p><blockquote><p>1.登录CentOS 6.5系统，使用root用户登录，如果为非root用户则执行 su 或 su - 或 su root 或 su - root 输入root密码切换为root用户。</p><p>2.查看SSH是否安装（检查是否装了SSH包）。<br>输入命令：rpm -qa | grep ssh 或者（rpm -qa | grep openssh）</p><p>3.查看SSH服务是否正在运行。<br>输入命令：/etc/init.d/sshd status 或者（service sshd status）</p><p>4.若CentOS 6.5系统中SSH服务处于非运行状态则使用（service sshd start）命令开启SSH服务；停止SSH服务命令（service sshd stop）；重启SSH服务命令（service sshd restart）。为了演示效果，我这里先停止SSH服务，然后启动SSH服务，再接着重启SSH服务。[service sshd stop] -&gt; [/etc/init.d/sshd status] -&gt; [service sshd start]-&gt; [service sshd restart] -&gt; [/etc/init.d/sshd status] </p><p>[重启后可输入：netstat -antp | grep sshd 查看是否启动22端口]</p><p>5.检查sshd是否在本运行级别下设置为开机启动<br>输入命令：chkconfig –list sshd<br>CentOS 6.5系统中SSH服在本运行级别下已经设置为开机启动,如果没设置启动就使用如下命令[chkconfig –level 2345 sshd on]设置下即可。（每个级别需要分别开启）</p></blockquote><p>【常见的远程SSH登录工具有：securecrt、xshell、putty等..】</p><p><a href="https://blog.csdn.net/wojiuguowei/article/details/79308090" target="_blank" rel="noopener">使用Xshell远程访问虚拟机</a></p><p>先来看看按照老师给的教程能不能幸运地完成实验吧。</p><p>![很不幸，不能](<a href="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc" target="_blank" rel="noopener">https://gitee.com/henry-avery/my_pic_bed/raw/master/psc</a> (1).png)</p><p>最后一条重启命令一看就知道应该是又把service写错成servive了。</p><p>![正常重启](<a href="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc" target="_blank" rel="noopener">https://gitee.com/henry-avery/my_pic_bed/raw/master/psc</a> (2).png)</p><p>之后就是一路采坑，最后也不知道自己怎么搞定的，看了很多博客但好像最后都没怎么用上。</p><p>而且这里具体问题还需要具体解决，可以在这篇博客的评论区把遇到的问题发出来，让大家帮忙看看。</p><p><strong>scp连接远程传输报错The authenticity of host …… can‘t be established.</strong></p><p><a href="https://blog.csdn.net/qq_35022803/article/details/108937779" target="_blank" rel="noopener">解决linux配置ssh免密登录遇到的异常：-bash: cd: /root/.ssh: Not a directory</a></p><p>No such file：可能要先进入子目录（cd .ssh），然后在使用scp命令，否则找不到你要传输的文件</p><hr><p><strong>使用ssh实现windows主机与linxu虚拟机文件互传</strong></p><p>这一步网上教程很多，但是可能还是不能完全符合我们的需求。</p><p>首先在主机上安装SSH Secure Shell，这个软件的下载地址是：<a href="http://ccm.net/download/download-1423-ssh-secure-shell-windows，如果打不开，请自行百度解决。" target="_blank" rel="noopener">http://ccm.net/download/download-1423-ssh-secure-shell-windows，如果打不开，请自行百度解决。</a></p><p>在实现互传文件之前先要令主机和虚拟机ping通，所以在这里先直接测试能不能ping通，别急着关防火墙和调整网络设置，如果之前的操作正确的话是可以直接跳过前两步的。</p><blockquote><p>在cmd中输入ipconfig查看本机ip，在terminal中输入ifconfig查看虚拟机ip</p></blockquote><p><a href="https://blog.csdn.net/jiechuhoudeshang/article/details/94407815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai" target="_blank" rel="noopener">虚拟机和主机相互ping不通方法总结</a></p><p>为了使用虚拟机而关闭防火墙这种因小失大的做法是不大可取的，其实设置防火墙很简单，以win7为例，打开控制面板 &gt; 系统和安全 &gt; windows防火墙 &gt;高级设置 &gt;入站规则 &gt; 文件和打印机共享(回显请求 - ICMPv4-In) （专用，公用） &gt; 右键启用 即可</p><p><strong>注意事项</strong>：直接打开SSH Secure File Transfer输入Hostname和Username然后输入密码。</p><p><strong>注意用户名这里不是master和slave1或2，而是你登录虚拟机时的用户名，</strong>比如我三台虚拟机用户名都是centos，否则用户名和密码不匹配会一直让你输入密码。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc.png" alt="小波男神镇贴"></p><hr><p><strong>RSH互通</strong></p><p>摆脱教程之后说不定还更简单了，而且碰巧找到了一篇可能是前两届某位学长写的博客，补充了没有的rsh部分，有兴趣可以看看，反正我是不想再多看了一眼了。</p><p><a href="https://blog.csdn.net/kingdomkitty/article/details/79897572" target="_blank" rel="noopener">centos6.5 配置ssh与rsh</a></p><hr><p><a href="https://www.cnblogs.com/baimh/p/11139668.html" target="_blank" rel="noopener"><strong>连接外网</strong></a></p><p><strong>下面摘抄了关于网络配置模式的介绍，可以详细了解下，可以对配置更加清晰；</strong></p><blockquote><p>桥接 通过使用物理机网卡 具有单独ip<br>NAT 把物理机为路由器进行上网</p><p>下面是详细的解说：</p><p>VMWare提供了三种工作模式，它们是bridged(bridged模式)、NAT(网络地址转换模式)和host-only(主机模式)。要想在网络管理和维护中合理应用它们，了解一下这三种工作模式。</p><p><strong>1.bridged(桥接模式)</strong></p><p>在bridged模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。在bridged模式下，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信。如果想利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择bridged模式。<br>这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡 绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。<br>使用这种方式很简单，前提是可以得到1个以上的地址。</p><p><strong>2.NAT(网络地址转换模式)</strong></p><p>使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。<br>这种方式也可以实现Host OS与Guest OS的双向访问。但网络内其他机器不能访问Guest OS，Guest OS可通过Host OS用NAT协议访问网络内其他机器。NAT方式的IP地址配置方法是由VMware的虚拟DHCP服务器中分配一个IP ，在这个IP地址中已经设置好路由，就是指向192.168.138.1的。</p><p>如果想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。这种方式下host内部出现了一个虚拟的网卡vmnet8（默认情况下），如果有过 做nat服务器的经验，这里的vmnet8就相当于连接到内网的网卡，而虚拟机本身则相当于运 行在内网上的机器，虚拟机内的网卡（eth0）则独立于vmnet8。发现在这种方式下，vmware自带的dhcp会默认地加载到vmnet8界面上，这样虚拟机就可以使用dhcp服务。更为重要的是，vmware自带了nat服务，提供了从vmnet8到外网的地址转换，所以这种情况是一个实实在在的nat服务器在运行，只不过是供虚拟机用的。</p></blockquote><hr><h2 id="AI科普：NVIDIA自动避障小车Jetbot-amp-口罩识别"><a href="#AI科普：NVIDIA自动避障小车Jetbot-amp-口罩识别" class="headerlink" title="AI科普：NVIDIA自动避障小车Jetbot &amp;口罩识别"></a>AI科普：NVIDIA自动避障小车Jetbot &amp;口罩识别</h2><p>讲师：侯宇涛，英伟达公司GPU/CUDA应用市场总监。何琨，英伟达开发者社区高级培训师。</p><blockquote><p>上机实验口罩识别就只是使用一下他们写的代码，挺无聊的。</p></blockquote><hr><h2 id="实验五OpenMP"><a href="#实验五OpenMP" class="headerlink" title="实验五OpenMP"></a>实验五OpenMP</h2><p><a href="https://zhuanlan.zhihu.com/p/61857547" target="_blank" rel="noopener">OpenMP入门实例与分析</a></p><p><strong>实验目的</strong></p><p>1) 在Linux平台上编译和运行OpenMP程序；</p><p>2) 在Windows平台上编译和运行OpenMP程序。</p><p>3) 掌握OpenMP并行编程基础。</p><p><strong>实验环境</strong></p><p>1) 硬件环境：计算机一台；</p><p>2) 软件环境：Linux、Win2003、GCC、MPICH、VS2008或其他版本Visual Studio；</p><p><strong>实验内容</strong></p><p>Linux下OpenMP程序的编译和运行。OpenMP是一个共享存储并行系统上的应用编程接口，支持C/C++和FORTRAN等语言，编译和运行简单的”Hello World”程序。在Linux下编辑hellomp.c源程序，或在Windows下编辑并通过附件中的FTP工具（端口号：1021）上传，用”gcc -fopenmp -O2 -o hellomp.out hellomp.c”命令编译，用”./hellomp.out”命令运行程序。</p><p>注：在虚拟机中当使用vi编辑文件时，不是以ESC键退出插入模式，可以使用“Ctrl+c”进入命令模式，然后输入wq进行存盘退出。</p><p>Linux下OpenMP环境，需要安装gcc(<strong>此处注意避坑</strong>，6.5版本太老需换源，可参考以下链接提供方法)</p><pre><code>yum intall gcc    (在redhat, centOS 下使用，用root安装，必须保证网络畅通)</code></pre><p><a href="https://blog.csdn.net/weixin_44160584/article/details/110872926?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-2.nonecase" target="_blank" rel="noopener">centos 6.5 yum安装报YumRepo Error: All mirror URLs are not using ftp, http[s] or file</a></p><p><a href="https://bbs.csdn.net/topics/392269634" target="_blank" rel="noopener">Linux中安装gcc出现All mirror URLs are not using ftp,http[s] or file</a></p><blockquote><p>修改镜像配置：vim /etc/yum.repos.d/CentOS-Base.repo</p><p>将配置文件中的#mirrorlist注释掉，取消注销baseurl的行，将$releasever改成你的centos的版本号,可用cat /etc/redhat-release查看</p></blockquote><p>如果能够正常安装好编译器就没有什么问题了，写好代码放在不同地方跑而已。</p><p>测试代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <omp.h>#include <stdio.h>int main(){int nthreads,tid;omp_set_num_threads(8);#pragma omp parallel private(nthreads,tid){tid=omp_get_thread_num();printf("Hello World from OMP thread %d\n",tid);if(tid==0){nthreads=omp_get_num_threads();printf("Number of threads is %d\n",nthreads);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先从本地传到虚拟机上去，编译然后运行正常就OK了。</p><p><strong>实验报告</strong></p><p><strong>实验目的</strong></p><p>1) 在Linux平台上编译和运行OpenMP程序；</p><p>2) 在Windows平台上编译和运行OpenMP程序。</p><p>3) 掌握OpenMP并行编程基础。</p><p><strong>实验环境</strong></p><p>1) 硬件环境：计算机一台；</p><p>2) 软件环境：Linux（centOS6.5）、Win10、GCC、G++、VS2019</p><p><strong>问题描述</strong></p><p>对于一个大向量（所有元素全部大于 0）， 把它的前半部分全部平方，后半部分全部开方取整。</p><p>将所得的新向量中的奇数个数输出。</p><pre class="line-numbers language-c++"><code class="language-c++">vector<int> v_i{}//初始给定大小的大向量（从1e100~1e10000）vector<int> v_ans{};//新生成的向量，大小与向量v_i相同clock_t s, f;//记录时间double duration;//计算时间长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实验过程</strong></p><p>数据量变动，大于cache</p><p>L1缓存256KB，L2缓存1.0MB，L3缓存6.0MB</p><p>纸质打印</p><p><strong>实验结果</strong></p><pre class="line-numbers language-c++"><code class="language-c++">s :0.372000- size of v_ans:        2522907p :1.378000- size of v_ans:        2522907<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码附录</strong></p><pre class="line-numbers language-c++"><code class="language-c++">/*核心代码示例*/    s = clock();//计时开始#pragma omp parallel for reduction(+:cnt_ans) default(shared)  num_threads(10)//openmp并行计算，开启十个线程    for (int i = 0; i < len; i++)    {        auto& e = v_i[i];        int t = 0;        if (i < len / 2)        {            t = pow(e, 2);        }        else        {            t = (int)sqrt(e);        }        if (t % 2 == 1)        {            cnt_ans += 1;//计数器，计算新向量奇数个数        }    }    f = clock();//计时结束    duration = (double)(f - s) / CLOCKS_PER_SEC;//计算计时时间    printf("s :%f\n", duration);//输出并行计算计时时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/yt_42370304/article/details/83904121" target="_blank" rel="noopener">linux 上查询cache 大小的方法</a></p><p><a href="https://blog.csdn.net/azri81226/article/details/101691139?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">并行程序耗时过大问题</a></p><h2 id="实验六HPL安装和测试"><a href="#实验六HPL安装和测试" class="headerlink" title="实验六HPL安装和测试"></a>实验六HPL安装和测试</h2><h3 id="Linpack背景及内容"><a href="#Linpack背景及内容" class="headerlink" title="Linpack背景及内容"></a><strong>Linpack背景及内容</strong></h3><p><a href="https://blog.csdn.net/hanzhenbushihu/article/details/88416724" target="_blank" rel="noopener">HPL与HPCG测试 (一)</a></p><p><a href="https://blog.csdn.net/sishuiliunian0710/article/details/20493101/" target="_blank" rel="noopener"></a></p><p><a href="https://wenku.baidu.com/view/ce44c4a5b8f67c1cfad6b8f8.html" target="_blank" rel="noopener"></a></p><p>（1）背景介绍</p><p>LINPACK全名Linear Equations Package，是近年来较为常用的一种计算机系统性能测试的线性方程程序包，内容包括求解稠密矩阵运算，带状的线性方程，求解最小平方问题以及其它各种矩阵运算。它最早由来自Tennessee 大学的超级计算专家Jack Dongarra提出。程序用FORTRAN编写，在此基础上还有C，JAVA等版本。Linpack使用线性代数方程组，利用选主元高斯消去法在分布式内存计算机上按双精度(64 bits)算法，测量求解稠密线性方程组所需的时间。Linpack的结果按每秒浮点运算次数（flops）表示。第一个Linpack测试报告出现在1979年的Linpack用户手册上，最初LINPACK包并不是要制订一个测试计算机性能的统一标准，而是提供了一些很常用的计算方法的实现程序，但是由于这一程序包被广泛使用，就为通过Linpack 例程来比较不同计算机的性能提供了可能，从而发展出一套完整的Linpack 测试标准。</p><p>（2）测试标准的内容</p><p>LINPACK标准可以解决的问题有：</p><p> 1) 各种矩阵分解(Matrix factorization)，如LU分解，Cholesky分解， Schur，Gauss分解，SVD分解，QR分解，generalized Schur分解等</p><p>2) 矢量运算（Vector operation），如Copy，Add，scalar multiple，Interchange</p><p>3) 存储模式（Storage Modes），如full，banded，symmetric </p><p>Linpack原始版本的问题规模为100×100的矩阵，目前的Linpack测试分成三个层次的问题规模和优化选择： </p><p>—- 100×100的矩阵</p><p>在该测试中，不允许对Linpack测试程序进行任何修改，哪怕是注释行。 所有的优化工作只能在编译器里完成。</p><hr><p>—- 1000×1000的矩阵</p><p>该测试也叫“面向峰值性能的测试”，在该测试中，要求有所放宽，允许对算法和软件进行修改或替换，并尽量利用系统的硬件特点，以达到尽可能高的性能。但是所有的优化都必须保持和标准算法如高斯消去法相同的相对精度，而且必须使用Linpack的主程序进行调用。测试者可修改或替换其中的过程调用例程DGEFA 和DGESL 。其中DGEFA 是Linpack 软件包中标准的高斯消去LU 分解过程，而DGESL 是根据分解后得到的结果回代求解过程。</p><hr><p>—- 针对大规模并行计算系统的测试，即Highly Parallel Computing。</p><p>在这一测试中，问题规模限制被取消，针对现代的并行计算机，要求最宽松，即用户可对任意大小的问题规模，使用任意个数的CPU ，使用各种优化方法（必须基于高斯消去法）来执行该测试程序，寻求最佳的测试结果。</p><p>目前，用Linpack基准测试出的最高性能指标已经成为衡量机器性能的标准之一，这个数字可以作为对系统峰值性能的一个修正。</p><h3 id="HPL基准测试"><a href="#HPL基准测试" class="headerlink" title="HPL基准测试"></a><strong>HPL基准测试</strong></h3><p>（1）概述</p><p>HPL，即High Performance Linpack，目前已经成为国际标准的Linpack基准测试程序，其1.0版于2000年9月发布，是第一个标准的公开版本并行Linpack测试软件包，一般用于全世界TOP500超级计算机上的并行超级计算机排名。HPL测试标准的用户自由度要大很多，使用者可以选择矩阵的规模，分块大小，分解方法等等一系列的各种参数，都是按需要更改的。 </p><p>HPL软件包需要在配备了MPI环境下的系统中才能运行，还需要底层有线性代数子程序包BLAS的支持（或者有另一种向量信号图像处理库VSIPL也可）。</p><p>HPL软件包不仅提供了完整的Linpack测试程序，还进行了全面细致的计时工作，最后可以得到求解的精确性和计算所花费的总时间。该软件在系统上所能达到的最佳性能值适合很多因素有关的。</p><p>（2）主算法</p><p>该软件包是用来求一个N维的线性方程组A x = b的解，首先通过选局部列主元的方法对Nⅹ(N+1)的[A b]系数矩阵进行LU分解成如下形式：</p><p>[A b]=[[L,U] y]</p><p>由于下三角矩阵L因子所作的变换在分解的过程中也逐步应用到b上，所以最后方程组的解x就可以由转化为求解上三角矩阵U作为系数矩阵的线性方程组 U x = y从而得到。</p><p>为了保证良好的负载平衡和算法的可扩展性，数据是以循环块的方式分布到一个P x Q的由所有进程组成的2维网格中。N x (N+1)的系数矩阵首先在逻辑上被分成一个个Nb x Nb大小的数据块，然后循环的分配到P x Q进程网格上去处理。这个分配的工作在矩阵的行、列两个方向同时进行。</p><p>在前面所提到的N，Nb，P，Q都是可以根据集群的具体配置和用户需要而随时修改的，也是HPL测试中十分关键和重要的几个参数。详细内容请看后面。</p><h3 id="HPL的安装及使用"><a href="#HPL的安装及使用" class="headerlink" title="HPL的安装及使用"></a><strong>HPL的安装及使用</strong></h3><p>主要软件包：</p><p>hpl-2.1.tar.gz</p><p>GotoBLAS2-1.13.tar.gz</p><p>openmpi-1.6.5.tar.gz</p><p><strong>HPL的安装过程</strong></p><p>（1）安装gotoblas</p><p>注：出于提高性能的因数，选择GOTO BLAS，作为HPL调用的底层线性代数子程序包</p><p>目前最新版本为GotoBLAS2</p><p>下载GotoBLAS2-1.13.tar.gz</p><p>（网址<a href="https://www.tacc.utexas.edu/tacc-projects/gotoblas2）" target="_blank" rel="noopener">https://www.tacc.utexas.edu/tacc-projects/gotoblas2）</a></p><blockquote><p>这个网址not found，直接在学习通下载</p></blockquote><p>执行步骤：</p><blockquote><p>需要在虚拟机上进行，先把文件传到虚拟机上</p></blockquote><p>在usr/local/mathlib/goto下解压：（随便什么位置应该都可以，我全部放在桌面了）</p><p>$ tar -zxvf GotoBLAS2-1.13.tar.gz</p><p>$ cd GotoBLAS2</p><p>$ make  （TARGET=NEHALEM）</p><p>注：可直接输入#make既可 也可自己选择参数 类似</p><p> $ make CC=gcc  BINARY=64 TARGET=NEHALEM </p><p>（新的intel都要有后面这个参数）</p><p>依次是编译器 库的位数和cpu的类型（architecture），具体可选择的参数可从GotoBLAS2的目录下02QuickInstall.txt的查找</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228101841554.png" alt></p><p>（3）安装openmpi</p><p> <strong>安装tar压缩的安装包</strong></p><p>tar -zxvf <em>**</em>.tar.gz</p><p>tar -jxvf <em>**</em>.tar.bz(或bz2)<br> 1、用CD命令进入解压缩后的目录<br> 2、输入编译文件命令：./configure（有的压缩包已经编译过，这一步可以省去）<br> 3、然后是命令：make<br> 4、再是安装文件命令：make install<br> 5、安装完毕<br>————————————————<br><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228103352342.png" alt="make好久之后"></p><p>（4）安装HPL</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110042073.png" alt="又是文件名的问题，自己打开文件夹确认"></p><p>（5）编译</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110150035.png" alt="貌似成功编译了"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110340435.png" alt="任务说明，mpicc写错了"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110248444.png" alt="快速成功"></p><p>运行</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110838391.png" alt="没配置好结点，把结点名设置一下试试"></p><p>改好结点还是遇到错误</p><p><a href="https://www.cnblogs.com/codingmengmeng/p/7456539.html" target="_blank" rel="noopener">Linux中error while loading shared libraries错误解决办法</a></p><p>原因：默认情况下，编译器只会使用/lib和/usr/lib这两个目录下的库文件，通常通过源码包进行安装时，如果不指定–prefix，会将库安装在/usr/local/lib目录下；当运行程序需要链接动态库时，提示找不到相关的.so库，会报错。也就是说，/usr/local/lib目录不在系统默认的库搜索目录中，需要将目录加进去。</p><p>也可能是由于我安装位置的问题，<strong>安装共享库后要注意共享库路径设置问题</strong>，解决方法如下，第二部排错后成功</p><p><a href="https://www.cnblogs.com/lcw/p/3341257.html" target="_blank" rel="noopener">【linux排错】”error while loading shared libraries: xxx.so.x” 错误的原因和解决办法</a></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228112440345.png" alt="大概用了一个多小时搞定"></p><p>然后就是慢慢调参写报告了。</p><p>使用gcc编译器的情况下测试，当进程数为4时，测试结果如下表：</p><table><thead><tr><th>N</th><th>NB</th><th>P</th><th>Q</th><th>Time</th><th>Gflops</th></tr></thead><tbody><tr><td>1960</td><td>60</td><td>2</td><td>2</td><td>0.83</td><td>6.079</td></tr><tr><td>1960</td><td>80</td><td>2</td><td>2</td><td>0.84</td><td>6.015</td></tr><tr><td>2048</td><td>60</td><td>2</td><td>2</td><td>0.91</td><td>6.319</td></tr><tr><td>2048</td><td>80</td><td>2</td><td>2</td><td>0.93</td><td>6.165</td></tr><tr><td>1960</td><td>60</td><td>4</td><td>1</td><td>1.28</td><td>3.940</td></tr><tr><td>1960</td><td>80</td><td>4</td><td>1</td><td>1.27</td><td>3.949</td></tr><tr><td>2048</td><td>60</td><td>4</td><td>1</td><td>1.40</td><td>4.105</td></tr><tr><td>2048</td><td>80</td><td>4</td><td>1</td><td>1.37</td><td>4.176</td></tr></tbody></table><h2 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h2><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/726DBF8B-6D7B-4E92-B5BE-3CF9D9C2D016_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/850EB3AB-490C-4527-8278-97C28814B684_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/78801AE2-0135-4690-A858-ABC9023D409C_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/CD541527-A203-405B-BA33-0E1E51415147_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/928ECBFF-572D-4303-8AA2-7055F4891DB7_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/27F3CB21-B6EF-4B6E-9684-A9D9B5BC4F93_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/A854536F-CEAE-428F-AB35-E8976946BB6E_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/300FE9C1-3433-4E74-BF52-6688ECD31D53_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/CBC1B61E-8738-4A8F-B9DB-BE1B4EFA2496_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9F926425-6690-4D1B-97F7-6B55D99A4F75_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/FD440926-C674-4713-8926-3E2432F475E9_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/A37504FC-C3DF-4B77-A28A-34CAD13DA3D8_org.jpg" alt="历年卷"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/FB9B20B3-B585-434E-A6CA-6D7B2DDB1ACB_org.jpg" alt="填空"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/0E9C81FA-A748-488A-B18D-272C01B460FA_org.jpg" alt></p><p><strong>参考资料</strong></p><p><a href="https://wenku.baidu.com/view/ce44c4a5b8f67c1cfad6b8f8.html#" target="_blank" rel="noopener">实验报告</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU数据结构</title>
      <link href="/2020/11/28/shu-shu-ju-jie-gou/"/>
      <url>/2020/11/28/shu-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>如果有人不相信数学是简单的,那是因为他们没有意识到人生有多复杂。<br>——冯•诺依曼</p></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="编程问题"><a href="#编程问题" class="headerlink" title="编程问题"></a>编程问题</h4><h5 id="函数指针Visit"><a href="#函数指针Visit" class="headerlink" title="函数指针Visit"></a>函数指针Visit</h5><p><strong>函数指针</strong> 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，<strong>函数指针就是指向代码段中函数入口地址的指针。</strong></p><p>函数指针的声明方法为：</p><p>返回值类型 ( * 指针变量名) ([形参列表]);</p><p>注1：“返回值类型”说明函数的返回类型，“(指针变量名 )”中的括号不能省，括号改变了运算符的优先级。若省略整体则成为一个函数说明，说明了一个返回的数据类型是指针的函数，后面的“形参列表”表示指针变量指向的函数所带的参数列表。例如：</p><p>int func(int x); /<em> 声明一个函数 </em>/</p><p>int (<em>f) (int x); /</em> 声明一个函数指针 */</p><p>f=func; /<em> 将func函数的首地址赋给指针f </em>/</p><p>或者使用下面的方法将函数地址赋给函数指针：</p><p>f = &func;</p><p>赋值时函数func不带括号，也不带参数，由于func代表函数的首地址，因此经过赋值以后，指针f就指向函数func(x)的代码的首地址。</p><p>注2：函数括号中的形参可有可无，视情况而定。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/viafcccy/article/details/102765886" target="_blank" rel="noopener">(*visit)(TElemType e )函数指针理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外国经典音乐</title>
      <link href="/2020/11/17/wai-guo-jing-dian-yin-le/"/>
      <url>/2020/11/17/wai-guo-jing-dian-yin-le/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐的巴洛克——巴洛克艺术的整体风格"><a href="#音乐的巴洛克——巴洛克艺术的整体风格" class="headerlink" title="音乐的巴洛克——巴洛克艺术的整体风格"></a>音乐的巴洛克——巴洛克艺术的整体风格</h2><h3 id="第一讲-音乐与建筑、音乐与绘画、音乐与宗教"><a href="#第一讲-音乐与建筑、音乐与绘画、音乐与宗教" class="headerlink" title="第一讲 音乐与建筑、音乐与绘画、音乐与宗教"></a><strong>第一讲 音乐与建筑、音乐与绘画、音乐与宗教</strong></h3><p><strong>巴洛克艺术的整体风格</strong> “巴洛克（Baroque） 一词源自葡萄牙文，意为不规则的珍珠。</p><p>18世纪“巴洛克”一词首先用于建筑，被18世纪的文艺理论家用来贬称17世纪以来的意大利建筑、雕刻、绘画等艺术。后来巴罗克一词成为一个时代艺术风格的代名词。</p><p>在艺术史上，巴洛克风格是指17、18世纪一种华丽的建筑风格，表现为精密的雕刻、弯曲的线条和夸张的装饰，这种风格明显和文艺复兴时期的平衡风格形成对比。</p><p><strong>巴洛克建筑、雕塑与绘画</strong></p><p>巴洛克时期的艺术表现的是充满动感的形态和刻意夸张的结构</p><p>德国哲学家谢林把建筑称为“凝固的音乐”，因而音乐也被称为“流动的建筑”。建筑与音乐作为艺术的两个载体，相互关联，相互渗透。建筑和音乐的外在形式可以有很多种，但其中的审美规律和审美意蕴有着异曲同工之意味。</p><p>巴洛克建筑（Baroque Architecture）与巴洛克音乐（ Baroque Music）都冠以“巴洛克”这个定语。一个是空间艺术，一个是时间艺术。这二者互相渗透呈现了巴洛克时代的人文景观。</p><p><strong>音乐中的巴洛克</strong></p><p>   巴洛克时期的艺术特征是高贵庄严，气势雄伟，富有动力，激情和张力。同时期的音乐大体上也具有这些特征。巴洛克音乐时期由于普遍使用数字低音记谱法，因此又称“数字低音时代”。</p><p>   巴洛克时期一般是指1600年到1750年，共150年的历史阶段。其重要的标志是1600年歌剧的诞生，到1750年巴赫逝世为止。</p><p><strong>巴洛克时期代表音乐家</strong></p><p>  像同时代的姊妹艺术一样，巴洛克时期的音乐也充满着激情与色彩，在追求广博与深远的同时，也喜好精致与华丽。在这一个半世纪的音乐历史中，出现大批作曲家，主要代表有：蒙特威尔第、维瓦尔第、吕利、珀塞尔、亨德尔和J.S.巴赫等。他们的创作领域和艺术个性虽然各不相同，但都包含了巴洛克音乐的某些基本特征。</p><p>  音乐在西方文明进程中与宗教文化关系紧密，甚至可以说它就是宗教文化的一部分。圣咏、经文歌、赞美诗、弥散曲等都是宗教音乐文化的主要形式。西方音乐就是在这个基础上发展起来的。</p><p>​    18世纪启蒙时期以后，音乐开始向世俗化发展，艺术的自主性、社会性以及创造性进入蓬勃发展的时期。但宗教音乐仍然占据着一定的地位。从巴洛克时期、古典时期到浪漫时期，众多的音乐大师们给我们留下了极其丰富的宗教音乐的遗产。</p><p><strong>圣咏——宗教音乐重要源头</strong></p><p>   宗教音乐是欧洲艺术音乐的源头。在18世纪以前，欧洲音乐主要以教会音乐为主，而教会音乐则以圣咏为主。圣咏是指单声调，没有固定节拍的宗教歌曲，分东方圣咏和西方圣咏，前者例如亚美尼亚圣咏，拜占庭圣咏等，后者例如安布罗西圣咏，格里高利圣咏等。公元6世纪，教皇格雷高利一世对宗教音乐——圣咏进行了统一。</p><p><strong>管风琴——宗教音乐的象征</strong></p><p>   管风琴在西方音乐中是历史最悠久的键盘乐器。它的体积庞大，构造复杂，通常是固定置放在大教堂或音乐厅里，大型的管风琴可拥有多层键盘和上千根乐管。因此，管风琴的音域宽广，音量洪大、音色多样，气势宏伟，能模仿管弦乐器效果，能演奏丰富的和声，有“乐器之王”之称。</p><p> 管风琴具有雄伟磅礴的气势，肃穆庄严的气氛，其丰富的和声效果绝不逊色于一支管弦乐队，是最能激发人类产生敬畏之情的乐器，也是最具宗教色彩的乐器。</p><p>经典作品赏析：</p><p><strong>管风琴曲《D小调托卡塔与赋格》</strong></p><p>这首作品是德国作曲家、管风琴家 约翰•塞巴斯蒂安•巴赫（Johann Sebastian Bach ，1685-1750）的代表作之一，具有华丽的技巧、风格和雄伟的戏剧情节。是巴赫在1704-1707年间专为阿恩斯塔德教堂的新管风琴所创作的。</p><p>托卡塔（Toccata）是巴洛克时期常用的键盘音乐乐体裁，以炫示即兴创作和表演为主要目的。</p><p>赋格是拉丁文Fuga的音译，意思是“飞翔”、“遁走”。是复调音乐中最复杂而又严谨的曲式体裁，其结构通常包括呈示部、展开部、再现部三部分，基本特点是运用模仿对位法，使一个简短而富有特性的主题在乐曲的各个声部轮流出现，互相模仿，造成力量的不断积聚增长，当乐曲内在的能量完全释放，乐曲便告结束。因此了解主题的性格特点往往是把握整个乐曲的关键。</p><p><strong>清唱剧《弥赛亚》</strong></p><p><strong>英籍德国作曲家</strong>亨德尔（Georg Friedrich Handel，1685-1759）的代表作。亨德尔出生在德国中部的哈雷镇。成年后的亨德尔离开汉堡游历欧洲。最后他选择了英国，并在伦敦定居下来，在这个城市生活了近50年。成为英国音乐界的领军人物，对英国的音乐发生深远的响。</p><p><strong>清唱剧(Oratorio)</strong>是一种从十七世纪发展起来的音乐形式，常以宗教或半宗教故事作为主题，没有复杂的舞台情节而注重音乐的表现。亨德尔的清唱剧由于剧情取材于英国人耳熟能详的圣经故事，且采用英语演唱，因此广受英国人喜爱。1742年，他仅用24天就完成了清唱剧《弥赛亚》的创作。同年这部作品在爱尔兰首府都柏林低调上演，获得了巨大的成功。亨德尔在英国的声誉得到极大的提升，成为英国的音乐生活的核心人物。</p><p> 《弥撒亚》分三部分：第一部分为 [预言与完成] 描写耶稣诞生的预言和他的诞生。第二部分为 [受难与得胜] 描写耶稣四处传播福音和受难。第三部分为 [复活与光荣] 写耶稣显圣复活。全曲包括有序曲、咏叹调、独唱、重唱、合唱、间奏等57首分曲。</p><p>​    这部作品每年圣诞节都在世界各地上演，以庆祝耶稣基督的降生并歌颂他的救世精神。其中“哈里路亚”合唱以其崇高雄浑的旋律，谐和丰满的和声，鲜明活跃的节奏，充分表现出基督教徒对救世主衷心的感恩，以及欢愉喜悦的心情。</p><p>《弥赛亚》中的第44分曲 “哈里路亚”合唱</p><p><strong>巴洛克艺术的共通性</strong></p><p> 巴洛克时期艺术的重要特点之一就是艺术一体化的高度融合和繁荣，无论是建筑、雕塑、绘画、音乐都相互影响，相互融合，所有宏伟建筑都囊括了这些艺术组合。在表现形式上，巴洛克艺术在观念和造型上是大胆的、装饰性的、且气势宏伟、动感强烈、充满活力。</p><h3 id="第二讲-数字与音乐的游戏——巴洛克复调艺术之美"><a href="#第二讲-数字与音乐的游戏——巴洛克复调艺术之美" class="headerlink" title="第二讲 数字与音乐的游戏——巴洛克复调艺术之美"></a>第二讲 数字与音乐的游戏——巴洛克复调艺术之美</h3><p>杜费与经文歌《近日玫瑰开放》</p><p>巴洛克时期的键盘乐器：拨弦古钢琴、击弦古钢琴、近代钢琴（1710）、现代钢琴（1850）</p><p>巴赫与《十二平均律钢琴曲集》——钢琴乐的“旧约全书”</p><p>《C大调前奏曲与赋格》</p><p>约翰·帕赫贝尔与卡农，帕赫贝尔的卡农的全名是《Canon and Gigue in D major for 3 violins and Basso Continuo》（为三把小提琴和通奏低音创作的D大调卡农和吉格舞曲）。</p><p>《G弦上的咏叹调》</p><p>出自巴赫《D大调第3管弦乐组曲》第二乐章“咏叹调”。1871年由德国小提琴家威廉密将其改编成小提琴独奏曲，他将原曲由D大调改为C大调，让乐曲的主旋律完全在小提琴最低的一根弦——G弦上演奏，此曲因而得名“G弦上的咏叹调”：</p><p><strong>复调</strong></p><p>一种“多声部音乐”。作品中含有两条以上（含）独立旋律，通过技术性处理，和谐地结合在一起，这样的音乐就叫做<em>复调</em>音乐。</p><h3 id="第三讲-神性时代的世俗快乐"><a href="#第三讲-神性时代的世俗快乐" class="headerlink" title="第三讲 神性时代的世俗快乐"></a>第三讲 神性时代的世俗快乐</h3><p>世俗歌曲起源：意大利牧歌</p><p><strong>意大利牧歌 蒙特威尔第《残酷的阿马里利》</strong></p><p>文艺复兴时期最后一位伟大的牧歌作曲家，巴洛克早期歌剧奠基人</p><p><strong>法国尚松 雅内坎《百鸟之歌》</strong></p><p><strong>第一部歌剧</strong></p><p>1597利努契尼剧本，佩里作曲《达芙妮》（残片）</p><p>1600利努契尼剧本，佩里和卡契尼作曲《尤里迪西》（Euridice）</p><p><strong>第一座歌剧院</strong>（1637，威尼斯，圣卡西亚诺）</p><p><strong>蒙特威尔第 歌剧《奥菲欧》序曲</strong>(歌剧史上第一部真正意义上的歌剧，1607)</p><p><strong>巴洛克时期主要四大类乐器</strong></p><p>键盘乐器、弦乐器、管乐器、打击乐器</p><p><strong>巴洛克时期的乐曲题体裁</strong></p><p>巴洛克时期奏鸣曲（sonata）巴洛克时期协奏曲（concerto）</p><p>托卡塔（toccata）赋格曲（fugue）前奏曲（prelude）组曲（Dance Suite）</p><p><strong>安东尼奥·维瓦尔第</strong>“红发神父”（1678-1741）</p><p>“快慢快”三乐章结构规范，对巴洛克协奏曲贡献巨大，为古典协奏曲形式打下基础</p><p>维瓦尔第 小提琴协奏曲《四季》（指挥：卡拉扬，小提琴：安妮·索菲·穆特）</p><p>第一乐章：快板</p><p>第二乐章：广板</p><p>第三乐章：快板“田园舞曲”</p><p><strong>亨德尔 管弦乐组曲《水上音乐》</strong></p><h2 id="形式美的时代"><a href="#形式美的时代" class="headerlink" title="形式美的时代"></a>形式美的时代</h2><h3 id="第一讲-十八世纪西方宫廷音乐文化"><a href="#第一讲-十八世纪西方宫廷音乐文化" class="headerlink" title="第一讲 十八世纪西方宫廷音乐文化"></a><strong>第一讲 十八世纪西方宫廷音乐文化</strong></h3><p><strong>约瑟夫·海顿 ——维也纳古典乐派奠基人</strong>（1732-1809）“交响曲之父”</p><p>古典主义（法语：Le Classicisme 英语：Western classical），形成并繁盛于17世纪的法国，从古希腊罗马文化里面吸取艺术形式和题材，主张拥护中央集权，尊崇王权，歌颂君主；崇尚理性，克制个人情欲，有严格的艺术规范和标准。</p><p>注重形式优雅与和谐的美。</p><p>古典乐派（18世纪中叶-19世纪30年代）</p><p><strong>第45交响曲“告别”末乐章</strong></p><p>引发思考：古典主义时期音乐家社会身份、音乐家与雇主的关系</p><p><strong>交响曲</strong></p><p>第一乐章：快板，奏鸣式</p><p>第二乐章：广板行板或广板，奏鸣式或主题与变奏形式</p><p>第三乐章：带三声中部的小步舞曲</p><p>第四乐章：快板或比第一章更快的急板</p><p>乐队编制以弦乐四声部为基础，双管制的管弦乐体制在海顿手里成型</p><p><strong>海顿 第94交响曲“惊愕”第二乐章片段</strong></p><p>引发思考：古典主义时期音乐的功能：娱乐社交</p><p><strong>海顿 弦乐四重奏 NO.76-3 “皇帝”第二乐章</strong></p><h3 id="第二讲-纯音乐之美在形式中自由飞扬"><a href="#第二讲-纯音乐之美在形式中自由飞扬" class="headerlink" title="第二讲 纯音乐之美在形式中自由飞扬"></a><strong>第二讲 纯音乐之美在形式中自由飞扬</strong></h3><p><strong>沃尔夫冈阿马德乌斯莫扎特</strong>（Wolfgang Amadeus Mozart，1756-1791）</p><p>萨尔茨堡与维也纳</p><p><strong>莫扎特 D小调第20钢琴协奏曲</strong></p><p>第一乐章：快板</p><p>第二乐章：慢板，浪漫曲</p><p>第三乐章：快板，回旋曲</p><p><strong>莫扎特 A大调第五小提琴协奏曲</strong></p><p><strong>莫扎特 第40交响曲</strong></p><p>第一乐章：很快的快板 G小调 2/4 奏鸣曲式</p><p>第二乐章：行板 降E大调 6/8 奏鸣曲式</p><p>第三乐章：小快板 G小调 3/4 小步舞曲</p><p>第四乐章：很快的快板 G小调 2/2 奏鸣曲式</p><p><strong>小夜曲或嬉游曲</strong></p><p>主要是指供娱乐的，室内重奏乐队演奏的多乐章组曲，主题朴素民歌风，情绪轻松活泼</p><p><strong>莫扎特 G大调弦乐小夜曲</strong></p><p>第一乐章：快板，奏鸣曲式</p><p>第二乐章：行板，浪漫曲</p><p>第三乐章：小快板，小步舞曲</p><p>第四乐章：快板，回旋曲</p><h3 id="第三讲-音乐戏剧的天才禀赋"><a href="#第三讲-音乐戏剧的天才禀赋" class="headerlink" title="第三讲 音乐戏剧的天才禀赋"></a>第三讲 音乐戏剧的天才禀赋</h3><p><strong>莫扎特的歌剧</strong></p><p>意大利喜歌剧：《费加罗的婚礼》《唐璜》《女人心》</p><p>德国歌唱剧：《魔笛》《后宫诱逃》</p><p>正歌剧：《伊多美纽斯》《狄多的仁慈》</p><p><strong>莫扎特 歌剧《费加罗的婚礼》男中音选段 费加罗“你不要再去做情郎”</strong></p><p><strong>莫扎特</strong> <strong>歌剧《费加罗的婚礼》女高音二重唱“微风轻拂的时光”</strong></p><h2 id="奏响时代最强音"><a href="#奏响时代最强音" class="headerlink" title="奏响时代最强音"></a>奏响时代最强音</h2><h3 id="第一讲-音符迸发出的思想火花"><a href="#第一讲-音符迸发出的思想火花" class="headerlink" title="第一讲 音符迸发出的思想火花"></a>第一讲 音符迸发出的思想火花</h3><p><strong>路德维希·范·贝多芬</strong>(1770-1872)——集古典音乐之大成，开浪漫主义之先河</p><p>波恩时期与维也纳早中晚期，谐虐曲取代小步舞曲，主要作品歌剧《费德里奥》艺术歌曲《远方的爱人》宗教性合唱《庄严弥撒》</p><p><strong><em>贝多芬的交响曲</em></strong></p><p><strong>贝多芬 第三交响曲 “英雄” 第一乐章片断</strong></p><p>贝多芬 第五交响曲 “命运”第一乐章</p><p>贝多芬 第六交响曲“田园”第一乐章</p><p>贝多芬 第九交响曲 “合唱交响曲” 第四乐章片断</p><h3 id="第二讲-用音乐的力和美颂扬全人类最高理想"><a href="#第二讲-用音乐的力和美颂扬全人类最高理想" class="headerlink" title="第二讲 用音乐的力和美颂扬全人类最高理想"></a>第二讲 用音乐的力和美颂扬全人类最高理想</h3><p><strong><em>贝多芬的钢琴奏鸣曲</em></strong></p><p><strong>贝多芬 C小调第八钢琴奏鸣曲 “悲怆” 第一乐章</strong></p><p>贝多芬 第十四钢琴奏鸣曲 “月光”</p><p>贝多芬 D小调第十七钢琴奏鸣曲 “暴风雨”</p><p>贝多芬 第五钢琴协奏曲 “皇帝”第三乐章</p><p><strong>贝多芬弦乐四重奏 Op.59 ‘Rasumovsky’ No.2-4</strong></p><h2 id="音乐史上的“狂飙时代”"><a href="#音乐史上的“狂飙时代”" class="headerlink" title="音乐史上的“狂飙时代”"></a>音乐史上的“狂飙时代”</h2><p><strong>狂飙突进运动</strong>（<a href="https://baike.baidu.com/item/德语/240836" target="_blank" rel="noopener">德语</a>：Sturm und Drang）是指1760年代晚期到1780年代早期德国<a href="https://baike.baidu.com/item/新兴资产阶级/1831940" target="_blank" rel="noopener">新兴资产阶级</a>城市青年所发动的一次文学解放运动，也是德国启蒙运动的第一次高潮。这个时期，是文艺形式从<a href="https://baike.baidu.com/item/古典主义/202936" target="_blank" rel="noopener">古典主义</a>向<a href="https://baike.baidu.com/item/浪漫主义/214808" target="_blank" rel="noopener">浪漫主义</a>过渡时的阶段，也可以说是幼稚时期的浪漫主义。其名称来源于剧作家<a href="https://baike.baidu.com/item/克林格/13868929" target="_blank" rel="noopener">克林格</a>的戏剧“狂飙突进”，但其中心代表人物是<a href="https://baike.baidu.com/item/歌德/63083" target="_blank" rel="noopener">歌德</a>和<a href="https://baike.baidu.com/item/席勒/3020501" target="_blank" rel="noopener">席勒</a>，歌德的《<a href="https://baike.baidu.com/item/少年维特的烦恼" target="_blank" rel="noopener">少年维特的烦恼</a>》是其典型代表作品，表达的是人类内心感情的冲突和奋进精神。这次运动是由一批市民阶级出身的青年德国作家发起的，他们受到<a href="https://baike.baidu.com/item/启蒙时代/29262" target="_blank" rel="noopener">启蒙时代</a>影响，推崇天才，创造性的力量，并把其作为其<a href="https://baike.baidu.com/item/美学" target="_blank" rel="noopener">美学</a>观点的核心。狂飙突进时期的作家受到当时<a href="https://baike.baidu.com/item/启蒙运动/119997" target="_blank" rel="noopener">启蒙运动</a>的影响，特别是受到了<a href="https://baike.baidu.com/item/卢梭/193632" target="_blank" rel="noopener">卢梭</a>哲学思想的影响，他们歌颂“天才”，主张“自由”、“个性解放”，提出了“返回自然”的口号。但另一方面这些年轻作家反对启蒙运动时期的社会关系，驳斥了过分强调<a href="https://baike.baidu.com/item/理性/576586" target="_blank" rel="noopener">理性</a>的观点。这个运动持续了将近二十多年，从1765年到1795年，然后被成熟的<a href="https://baike.baidu.com/item/浪漫主义运动/10620044" target="_blank" rel="noopener">浪漫主义运动</a>所取代。</p><h3 id="第一讲-音乐中的幻想与狂想"><a href="#第一讲-音乐中的幻想与狂想" class="headerlink" title="第一讲 音乐中的幻想与狂想"></a>第一讲 音乐中的幻想与狂想</h3><p><strong>柏辽兹《幻想交响曲》第四乐章（柏林爱乐乐团 杨松斯指挥）</strong></p><p>恋人主题“固定乐思”</p><p><strong>李斯特</strong>（Franz Liszt，1811-1886）</p><p>匈牙利钢琴家、作曲家、指挥家，浪漫主义音乐代表人物，被誉为“钢琴之王”。</p><p>帕格尼尼的《第二小提琴协奏曲》与李斯特的音乐会练习曲《钟》</p><p><strong>李斯特 交响诗《前奏曲》</strong></p><p>引子：疑问动机，主部：年轻人对爱情的憧憬，展开部：暴风雨的来临，插部：田园曲，再现部，副部：爱情主题变为威严的进行曲，主部：年轻人在爱情中经历了考验重新恢复青春</p><p><strong>李斯特《匈牙利狂想曲》第二首</strong>“猫和老鼠”</p><p><strong>交响诗</strong></p><hr><h3 id="第二讲-音乐中抒情与激情"><a href="#第二讲-音乐中抒情与激情" class="headerlink" title="第二讲 音乐中抒情与激情"></a>第二讲 音乐中抒情与激情</h3><p><strong>门德尔松 《仲夏夜之梦》序曲</strong></p><p><em><em>舒伯特 艺术歌曲《小夜曲》 </em></em></p><p>舒伯特 艺术歌曲《魔王》</p><p><strong>舒曼 《a小调钢琴协奏曲》</strong></p><p>舒曼 钢琴作品《童年情景》之《梦幻曲》</p><h3 id="第三讲-浪漫狂潮中的孤独与坚守"><a href="#第三讲-浪漫狂潮中的孤独与坚守" class="headerlink" title="第三讲 浪漫狂潮中的孤独与坚守"></a>第三讲 浪漫狂潮中的孤独与坚守</h3><p><strong>肖邦</strong>（Fryderyk Chopin，1810-1849）</p><p><strong>肖邦 “革命”练习曲</strong></p><p>肖邦 降E大调夜曲 Op.9 No.2</p><p>肖邦 “黑键”练习曲 Op.10 No.5</p><p><strong>约翰内斯·勃拉姆斯</strong>——“最后的古典主义音乐家”</p><p>勃拉姆斯 第一交响曲 第一乐章——“贝多芬第十交响曲”</p><p>勃拉姆斯 艺术歌曲《摇篮曲》</p><p>勃拉姆斯 第五匈牙利舞曲 管弦乐版</p><p>勃拉姆斯 第一匈牙利舞曲 双钢琴</p><h3 id="第四讲-歌剧艺术的辉煌与绽放（一）"><a href="#第四讲-歌剧艺术的辉煌与绽放（一）" class="headerlink" title="第四讲 歌剧艺术的辉煌与绽放（一）"></a>第四讲 歌剧艺术的辉煌与绽放（一）</h3><p><strong>歌剧</strong></p><p>歌剧（英文：opera，意大利语：opera）是一门西方舞台艺术，简单而言就是主要或完全以歌唱和音乐来交代和表达剧情的戏剧（是唱出来而不是说出来的戏剧）。歌剧在17世纪，即1600年前后，出现在意大利<a href="https://baike.baidu.com/item/佛罗伦萨/32608" target="_blank" rel="noopener">佛罗伦萨</a>，源自<a href="https://baike.baidu.com/item/古希腊戏剧/1978649" target="_blank" rel="noopener">古希腊戏剧</a>的剧场音乐。歌剧的演出和戏剧的所需一样，都要凭借剧场的典型元素，如背景、<a href="https://baike.baidu.com/item/戏服/880548" target="_blank" rel="noopener">戏服</a>以及表演等。</p><p><strong>浪漫主义时期歌剧的繁荣</strong></p><p>歌剧序曲、间奏曲、咏叹调、重唱合唱</p><p><strong><em>19世纪意大利歌剧</em></strong></p><p><strong>乔阿基诺·安东尼奥·罗西尼</strong>（17952-1868）</p><p><strong>罗西尼 歌剧《塞维利亚理发师》 费加罗咏叹调“快给忙人让路”</strong></p><p>罗西尼 歌剧《威廉退尔》序曲 （片段）</p><p><strong>朱塞佩·威尔第</strong>（1813-1901）</p><p>威尔第 歌剧《纳布科》 合唱“飞吧，思想，展开金色的翅膀”</p><p>威尔第 歌剧《茶花女》选段“饮酒歌”</p><p>威尔第 歌剧《阿依达》  “凯旋”片段</p><p><strong>真实主义</strong></p><hr><p><strong>贾科莫·普契尼</strong>（1858-1924）</p><p>早期歌剧《曼侬·列斯科》中期《艺术家的生涯》《托斯卡》《蝴蝶夫人》晚期《西部女郎》《外套》（真实主义）《姜尼·斯基基》（仅有喜歌剧）<strong>《图兰朵》</strong></p><p>普契尼 歌剧《蝴蝶夫人》巧巧桑咏叹调“晴朗的一天”</p><p><strong>普契尼 歌剧《图兰朵》王子咏叹调“今夜无人入眠”</strong></p><h3 id="第五讲-歌剧艺术的辉煌与绽放（二）"><a href="#第五讲-歌剧艺术的辉煌与绽放（二）" class="headerlink" title="第五讲 歌剧艺术的辉煌与绽放（二）"></a>第五讲 歌剧艺术的辉煌与绽放（二）</h3><p><strong><em>喜歌剧</em></strong></p><hr><p><strong><em>法国抒情歌剧</em></strong></p><hr><p>托马、古诺、乔治·比才、圣桑、马斯涅</p><p>奥芬·巴赫 歌剧《地狱中的奥菲欧》序曲片段</p><p><strong>古诺 歌剧《浮士德》士兵合唱</strong></p><p><strong>《卡门》</strong>——“主导动机”</p><p>比才 歌剧《卡门》序曲</p><p><strong>比才 歌剧《卡门》 卡门的咏叹调“哈巴涅拉”</strong></p><p>比才 歌剧《卡门》 “斗牛士之歌”</p><p><strong>19世纪德国歌剧</strong></p><p><strong>瓦格纳</strong>（Richard Wagner，1813-1883）</p><p>瓦格纳 歌剧《尼伯龙根的指环》之《女武神》“女武神的骑行”</p><p><strong>瓦格纳 歌剧《罗恩格林》选段“婚礼进行曲”</strong></p><hr><h2 id="音乐中的民族旋风"><a href="#音乐中的民族旋风" class="headerlink" title="音乐中的民族旋风"></a>音乐中的民族旋风</h2><h3 id="第一讲-乐声中的森林、河流、晨曦、阳光"><a href="#第一讲-乐声中的森林、河流、晨曦、阳光" class="headerlink" title="第一讲 乐声中的森林、河流、晨曦、阳光"></a>第一讲 乐声中的森林、河流、晨曦、阳光</h3><p><strong>十九世纪民族乐派</strong></p><p>俄罗斯——格林卡，五人团</p><p>捷克——斯美塔纳，德沃夏克</p><p>挪威——格里格</p><p>芬兰——西贝柳斯</p><p>格里格《培尔·金特组曲》第一组曲 之 “晨曲”</p><p>格里格《培尔·金特组曲》第一组曲 之 “阿尼特拉舞曲”</p><p><strong>格里格《培尔·金特组曲》第二组曲 之 “索尔维格之歌”（第五首）</strong>    </p><p>西贝柳斯 交响诗《芬兰颂》</p><h3 id="第二讲-异国他乡的母国情怀"><a href="#第二讲-异国他乡的母国情怀" class="headerlink" title="第二讲 异国他乡的母国情怀"></a>第二讲 异国他乡的母国情怀</h3><p><strong>捷克作曲家德沃夏克</strong></p><p>《幽魂曲》,《水仙花》女高音咏叹调“月亮颂”</p><p><strong>德沃夏克 第九交响曲 “自新大陆”</strong>（版本：卡尔· 伯姆 指挥 维也纳爱乐乐团演奏）</p><p>斯美塔那 歌剧《被出卖的新嫁娘》序曲</p><p>斯美塔那 交响诗套曲《我的祖国》第二乐章《伏尔塔瓦河》</p><h2 id="欧亚风情画"><a href="#欧亚风情画" class="headerlink" title="欧亚风情画"></a>欧亚风情画</h2><h3 id="第一讲-业余出身的“专业”作曲家"><a href="#第一讲-业余出身的“专业”作曲家" class="headerlink" title="第一讲 业余出身的“专业”作曲家"></a>第一讲 业余出身的“专业”作曲家</h3><p><strong><em>五人团</em></strong></p><hr><p><strong>穆索尔斯基钢琴组曲 《图画展览会》（管弦乐版）”基辅大门”</strong></p><p>格林卡 歌剧《鲁斯兰与柳德米拉》序曲</p><p>里姆斯基-科萨科夫 交响组曲《舍赫拉查德》（又名《天方夜谭》）</p><p><strong><em>交响音画</em></strong></p><hr><p><strong>鲍罗丁 交响音画《在中亚细亚草原上》</strong></p><h3 id="第二讲-“悲情大师”的世纪绝唱"><a href="#第二讲-“悲情大师”的世纪绝唱" class="headerlink" title="第二讲 “悲情大师”的世纪绝唱"></a>第二讲 “悲情大师”的世纪绝唱</h3><p><strong>彼得·伊里奇·柴可夫斯基</strong>（1840-1893）——古典浪漫结合</p><p>《第四交响曲》《第五交响曲》《第六交响曲》圆舞曲替代谐虐曲</p><p>柴科夫斯基 第六交响曲“悲怆”第一乐章</p><p>柴科夫斯基 第一钢琴协奏曲 第一乐章</p><h3 id="第三讲-俄罗斯的舞剧音乐王国"><a href="#第三讲-俄罗斯的舞剧音乐王国" class="headerlink" title="第三讲 俄罗斯的舞剧音乐王国"></a>第三讲 俄罗斯的舞剧音乐王国</h3><p>柴科夫斯基的《天鹅湖》《胡桃夹子》《睡美人》</p><p><strong>柴可夫斯基 舞剧《天鹅湖》“主题”</strong></p><p>柴可夫斯基 舞剧《天鹅湖》“白天鹅和王子双人舞”</p><p>柴可夫斯基 舞剧《天鹅湖》“四小天鹅舞”</p><p>柴可夫斯基 舞剧《天鹅湖》“黑天鹅32圈转”</p><p>柴可夫斯基 舞剧《天鹅湖》“西班牙舞”“拿波里舞”</p><p>柴可夫斯基 舞剧《胡桃夹子》配乐 “糖梅仙子之舞”</p><p>柴可夫斯基 舞剧《胡桃夹子》配乐“花之圆舞曲” Waltz of the Flowers</p><p>柴可夫斯基 舞剧《睡美人》“婚礼大双人舞“ （双人舞-王子-公主-双人舞）</p><h2 id="从“印象”到“音响”（略）"><a href="#从“印象”到“音响”（略）" class="headerlink" title="从“印象”到“音响”（略）"></a>从“印象”到“音响”（略）</h2><h3 id="音响中五光十色的“印象”"><a href="#音响中五光十色的“印象”" class="headerlink" title="音响中五光十色的“印象”"></a>音响中五光十色的“印象”</h3><p><strong><em>印象主义</em></strong></p><p><strong>德彪西</strong>（1862-1918）</p><p>德彪西 管弦乐前奏曲《牧神午后》</p><p>德彪西 钢琴前奏曲《亚麻色头发的少女》</p><p>德彪西 钢琴曲《月光》‘</p><p>拉威尔 管弦乐曲《波莱罗舞曲》</p><hr><h2 id="课程回顾与总结"><a href="#课程回顾与总结" class="headerlink" title="课程回顾与总结"></a>课程回顾与总结</h2><h3 id="音乐家和音乐主题"><a href="#音乐家和音乐主题" class="headerlink" title="音乐家和音乐主题"></a>音乐家和音乐主题</h3><p>（1）古代音乐</p><p>西方最早的弦乐器是里拉琴，又称诗琴。</p><p>（2）中纪音乐</p><p>（3）文艺复兴时期的音乐</p><p>这一时期的乐派有尼德兰乐派（勃艮第乐派和法一佛兰德乐派）、罗马乐派、威尼斯乐派。</p><p>（4）巴洛克时期的音乐</p><p>①欧洲历史上的第一部歌剧是由里努契尼写脚本、佩里作曲的《达芙妮》，但是乐谱已失传。现存的第一部歌剧是《优丽狄茜》，由里努契尼写脚本、佩里和卡契尼作曲。</p><p>②清唱剧又叫圣剧、神剧，17世纪诞生于意大利，是一种宗教性的大型声乐体裁。创作清唱剧的最重要的作曲家是卡里西米和亨德尔。</p><p>③巴赫，德国作曲家，代表作品有《平均律钢琴曲集》《赋格的艺术》《b小调弥撒曲》《马太受难乐》等。</p><p>（5）古典主义时期的音乐</p><p>①维也纳古典时期的代表作曲家是海顿、莫扎特和贝多芬，称他们为“维也纳三杰”。</p><p>②海顿是古典维也纳乐派的奠基者，被誉为“交响曲之父”“弦乐四重奏之父”。代表作有12首“伦敦”交响曲，清唱剧《创世纪》和《四季》等。</p><p>③莫扎特是西方音乐史上最富有智慧的音乐家，被誉为“音乐神童”，代表作品有歌剧《后宫诱逃》《费加罗的婚礼》《唐璜》《魔笛》，钢琴奏鸣曲《G大调弦乐小夜曲》等。</p><p>④贝多芬被誉为“乐圣”，他在后期虽然两耳失聪，但仍然坚持音乐创作，代表作品有钢琴奏鸣曲《悲怆》《月光》《暴风雨》《黎明》《热情》，交响曲《第三交响曲“英雄”》《第五交响曲“命运”》《第六交响曲“田园”》《第九交响曲“合唱”》，歌剧《费德里奥》等。</p><p>（6）浪漫主义时期的音乐</p><p>①韦伯，德国浪漫主义歌剧奠基人。</p><p>②舒伯特，德奥艺术歌曲之王，代表作品有艺术歌曲《野玫瑰》《魔王》《鳟鱼》，声乐套曲《美丽的磨坊姑娘》《冬之旅》，钢琴小品《音乐的瞬间》等。</p><p>③门德尔松，德国作曲家，首创钢琴体裁“无词歌”。</p><p>④舒曼，德国作曲家、钢琴家、音乐评论家，代表作品有钢琴套曲《狂欢节》《童年情景》，声乐套曲《桃金娘》《诗人之恋》等。</p><p>⑤肖邦，波兰钢琴家、作曲家，被誉为“钢琴诗人”，是较早将东欧民间音乐融入西方音乐艺术的大师。</p><p>⑥李斯特，匈牙利钢琴家、作曲家、指挥家，被誉为“钢琴之王”。</p><p>⑦古诺，法国作曲家，代表作品有《浮土德》《罗密欧与朱丽叶》等。</p><p>⑧比才，法国作曲家，代表作品有歌剧《卡门》等。</p><p>⑨柴可夫斯基，俄国作曲家，代表作品有歌剧《叶甫盖尼·奥涅金》《黑桃皇后》，舞剧《天鹅湖》《睡美人》《胡桃夹子》，《第六“悲怆”交响曲》《1812序曲》等</p><p>（7）民族主义音乐</p><p>①俄国民族乐派的奠基人是格林卡和达尔戈梅斯基。格林卡是俄国民族歌剧的创始人，被称为“俄罗斯民族音乐之父”。</p><p>②帕修斯是芬兰民族乐派的创始人，“芬兰歌剧之父”，代表作品是第一部芬兰歌剧《卡尔王之猎》。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h3 id="形式与体裁"><a href="#形式与体裁" class="headerlink" title="形式与体裁"></a>形式与体裁</h3><p>1．曲调：具有歌唱性的器乐曲，常用于18世纪的组曲中。</p><p>2．阿勒曼德：17世纪盛行于法国和英国的舞曲体裁，四拍子，节奏平稳，速度较慢，常用于组曲。同样的名称在19世纪指流行于瑞士乡村的三拍子轻快舞曲，它是华尔兹的前身。</p><p>3．赞美歌：英国基督教教会仪式所用音乐，有独唱、合唱形式，歌词大多取自圣经，用英语演唱，一般用管风琴伴奏。</p><p>4．咏叹调：独唱曲，是歌剧、清唱剧等大型声乐作品中的重要段落，也可以是独立的作品。具有高超的演唱技巧和幅度较大的情感抒发。</p><p>5．叙事歌：</p><p>（1）13、14世纪的法国世俗歌曲；</p><p>（2）19世纪盛行于德国的具有叙事性的歌曲，内容常与民间故事、传奇有关；</p><p>（3）19世纪抒情浪漫的器乐曲，如肖邦和勃拉姆斯的钢琴作品。</p><p>6．芭蕾舞剧：由舞蹈演员身着剧装在音乐伴奏下表演的戏剧。起源于文艺复兴时期的意大利，后传入法国获得极大发展。最初的法国芭蕾舞剧音乐不仅有器乐，还有歌唱和朗诵，因此可看作是歌剧的前身（当时的歌剧中也有芭蕾舞，此传统一直延续到19世纪末，并影响到意大利歌剧）。19世纪中叶以后出现大量优秀的芭蕾舞剧音乐，如柴可夫斯基的《天鹅湖》、斯特拉文斯基的《火鸟》等。</p><p>7．船歌：来源于威尼斯船夫歌曲的器乐曲（钢琴曲为多，也有管弦乐曲），6/8或12/8拍，速度和缓，通常是在荡漾的节奏韵律之上有一条歌唱性的悠扬曲调。</p><p>8．摇篮曲：安静温和的声乐或器乐小曲，节奏有如摇篮缓缓摆动。</p><p>9．布鲁斯：又译蓝调。美国爵士乐的一种风格，源于黑人灵歌。通常为十二小节，节奏平稳，速度较慢，其名称来源于别具特色的常降低半音的大调第三和第七级音。</p><p>10．波莱罗：西班牙舞曲，三拍子，稳定的中速，用响板敲击具有特性的节奏。拉威尔的管弦乐《波莱罗舞曲》是最著名的作品，肖邦也写有这种风格的钢琴曲。</p><p>11．布列：</p><p>（1）盛行于17和18世纪的法国舞曲，速度较快，通常为2/2拍。</p><p>（2）现流行于法国中部奥弗涅山区的三拍子舞曲。</p><p>12．康康：19世纪末盛行于法国的舞曲，快速，2/4拍，热烈而粗俗。最著名的是奥芬巴赫所作轻歌剧《地狱中的奥菲欧》中的康康舞曲。</p><p>13．卡农：“规律”，一种二声部或更多声部的复调音乐形式，当一个声部的旋律出现之后，另外的声部紧跟模仿。它可以是一首独立乐曲的形式，也可在大型作品中出现局部性的卡农写法。</p><p>14．康塔塔：又译大合唱。盛行于17世纪和18世纪上半叶的多乐章声乐作品，包括独唱的宣叙调、咏叹调，重唱，合唱，由管弦乐队伴奏，与清唱剧相类似，但规模较小。有宗教的也有世俗内容的。巴赫留存于世的二百余部康塔塔是经典之作。</p><p>15．随想曲：</p><p>（1）16世纪末至17世纪较为自由的赋格性质器乐曲，多为古钢琴作品；</p><p>（2）技巧性练习曲，如帕格尼尼的《24首小提琴随想曲》；</p><p>（3）19世纪用于形式较为自由的乐曲，常借用著名曲调为主题，如柴可夫斯基的管弦乐曲《意大利随想曲》。</p><p>16．夏空：又译恰空。盛行于17世纪的风格庄重的三拍子舞曲，也是一种复调音乐形式，即在固定的主题或一连串固定的和声进行之上作多次变奏。</p><p>17．室内乐：指适合在室内而不是大厅由少数人演奏的器乐曲，早期曾包括声乐。主要体裁是数种重奏，最常见的是古典时期的弦乐四重奏、钢琴五重奏等。现在虽常在音乐厅演奏这类作品，但依然保持原有的细腻亲切的特性。</p><p>18．众赞歌：基督新教（路德教派）的赞美诗曲调，最早出版于1524年。宗教改革者马丁-路德将其作为改革手段之一（他本人还曾创作过一些）。其特点为：采用本国语演唱，曲调大多选自朴素通俗的民歌和古老的圣歌。起初为单声部，后来出现了主旋律在最高声部的四部合唱式以及复调形式。17、18世纪众赞歌成为重要的音乐创作源泉，如巴赫的管风琴众赞歌前奏曲、众赞歌变奏曲以及大量宗教康塔塔中都以众赞歌旋律为素材。</p><p>19．众赞歌前奏曲：以众赞歌为素材的管风琴曲通称，盛行于17、18世纪。在路德教派的教堂仪式中，会众唱赞美歌之前要先由管风琴将其旋律演奏一遍。演奏者可将旋律作自由变奏，这种做法逐渐形成了众赞歌前奏曲体裁。</p><p>20．协奏曲：也称作独奏协奏曲，是一件独奏乐器和管弦乐队的协奏。形成于18世纪，通常为快－慢－快三个乐章。在莫扎特奠定的古典协奏曲模式中，第一乐章有两个呈示部，即乐队先呈示主题，然后由主奏乐器在乐队伴奏下带有变化地再次呈示主题；第一乐章（有时也在末乐章）将近结束处有华彩乐段，即主奏乐器单独演奏的炫技性段落。19世纪逐渐不再遵循这种模式。</p><p>21．大协奏曲：盛行于17世纪和18世纪初的多乐章作品，是由几件乐器组成的独奏小组和管弦乐队的协奏。主奏组大多由小提琴、长笛、双簧管、大提琴、古钢琴组成，通常为2-5件乐器，它们细腻纤巧的音响与宏亮的乐队合奏形成鲜明对比。</p><p>22．库朗：盛行于17和18世纪初的活泼的三拍子舞曲，常用于组曲。</p><p>23．恰尔达什：又译查尔达什。匈牙利舞曲，由缓慢而忧郁的lassan段和快速热烈的friss段构成。李斯特的《第二匈牙利狂想曲》即典型的恰尔达什舞曲。</p><p>24．嬉游曲：盛行于18世纪末的轻松怡情的多乐章室内乐或小乐队作品。在莫扎特的嬉游曲中，也有些比较深刻严肃。</p><p>25．二重协奏曲：两件独奏乐器与乐队的协奏曲。如勃拉姆斯《小提琴与大提琴二重协奏曲》。</p><p>26．二重奏：供两人演奏（演唱）的形式，二个声部不分主次，可有伴奏或无伴奏。器乐二重奏（除钢琴二重奏外）还专门称做duo。</p><p>27．练习曲：专为练习乐器演奏技巧而作的乐曲。19世纪肖邦、李斯特、德彪西等人加强了这种体裁的艺术性，使之成为音乐会上的正式曲目。这类作品称为音乐会练习曲。</p><p>28．凡丹戈：活泼的西班牙舞曲，快速、三拍子，用响板和吉他伴奏。</p><p>29．幻想曲：器乐曲，总体特点是形式上自由不拘，带有幻想的性质。</p><p>（1）文艺复兴时期指不采用舞曲形式或变奏手法而采用复调技巧自由写作的器乐曲。</p><p>（2）巴洛克时期即兴性的键盘或琉特琴乐曲，如巴赫的《半音阶幻想曲》。</p><p>（3）古典主义时期在写法上比奏鸣曲更为自由的大型作品。</p><p>（4）浪漫时期带有幻想色彩的乐曲。</p><p>（5）根据现成主题（民歌、他人音乐素材）所写的乐曲，如李斯特《根据贝利尼歌剧&lt;梦游女&gt;主题而作的幻想曲》等。</p><p>30．法朗多尔：古老的法国舞曲，目前仍流行于普罗旺斯一带。6/8拍，也有2/4拍，如比才管弦乐组曲《阿莱城姑娘》中的《法朗多尔舞曲》。</p><p>31．弗拉门科：盛行于西班牙南部安达卢西亚的歌舞体裁，用吉他伴奏，常常带有悲伤意味。在西班牙吉他作品中弗拉门科是一种典型风格。</p><p>32．赋格：在一个主题上构成的多声部（至少二声部）复调作品。单声部的主题在原调上出现之后，另外的声部依次进行模仿。主题在全曲多次出现，中间有数个间插段，它们大多采用主题片断作素材，在不同调性上进行丰富多样的变化，也可引进新材料。最后一次主题在原调上完整出现，便告结束。赋格可用于一部独立的作品，也可用于一部大作品的局部，称作赋格段。</p><p>33．加伏特：盛行于17世纪的法国舞曲，传入宫廷后，成为当时各种作品中不可或缺的形式，如歌剧、组曲中常有加伏特舞曲。快速，4/4拍。</p><p>34．格里高利圣咏：又译素歌。罗马教会所保存并沿用至今的最古老的宗教歌曲集，以教皇格里高利一世命名。单声部旋律，节奏自由，以拉丁文歌词的抑扬顿挫为依据。</p><p>分为两大类：</p><p>（1）用于教堂举行弥撒的成套圣咏，内容集中于耶稣最后的晚餐与受难；</p><p>（2）用于修道院每天不同时辰祈祷的日课圣咏。</p><p>35．哈巴涅拉：又译阿伐奈拉。起源于古巴哈瓦那的舞曲，较慢的二拍子，第一拍为切分音。19世纪传入西班牙</p><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>音乐常识经典!<br>这些都是平时老师上课提到的一些比较常识的东西，有很多都是经典。</p><ol><li>三大安魂曲是指哪三首呢<br>三大安魂曲是指莫札特的《Ｄ小调安魂曲》、威尔第的《安魂曲》和佛瑞的《安魂曲 》。</li><li>三大神剧是指哪三首呢<br> 三大神剧是指韩德尔的《弥赛亚》、海顿的《创世纪》和门德尔松的《伊利亚 》</li><li>中国乐器有哪几类呢<br> 中国乐器依八音分类法分为金、石、丝、竹、匏、土、革、木八种</li><li>中国传统音乐如何分类呢<br> 中国传统音乐分为民间歌曲，民间歌舞，民间曲艺，民间戏曲，民间器乐！</li><li>西方乐器如何分类呢<br>西方乐器总括分为擦弦、木管、铜管及敲击四大类</li><li>五大纲琴协奏曲是指哪几首呢<br>贝多芬的《第五号降Ｅ大调钢琴协奏曲“皇帝”》、柴可夫斯基的《第一号降Ｂ大调钢琴协奏曲》、拉赫曼尼诺夫的《第二号Ｃ小调钢琴协奏曲》、舒曼的《Ａ小调钢琴协奏曲》和李斯特的《降Ｅ大调钢琴协奏曲合称为“五大纲琴协奏曲”》其实还有拉赫曼尼诺夫的《第三钢琴协奏曲》这是公认的世界最难钢琴曲。</li><li>六大交响曲是指哪几首呢<br> 六大交响曲包含了贝多芬的《第六田园交响曲》、《第五命运交响曲》、舒伯特的《第八未完成交响曲》、德沃夏克的《新世界交响曲》、柴可夫斯基的《悲怆交响曲》和柏辽兹的《幻想交响曲》</li><li>四大小提琴协奏曲是哪几首呢<br>贝多芬的《Ｄ大调小提琴协奏曲》、门德尔松的《Ｅ小调小提琴协奏曲》、柴可夫斯基的《Ｄ大调小提琴协奏曲》和布拉姆斯的《Ｄ大调小提琴协奏曲》并称为四大小提琴协奏曲 ，老师提的问题，很遗憾当时没有答上。</li><li>音乐史上的3B（4B）是指哪些人呢<br>布拉姆斯（Brahms, Johannes）、巴赫（Bach, Johann Sebastian）与贝多芬（Beethoven, Ludwig van）三人并称为音乐史上的3B，若是4B就要另加巴尔托克（Bartok, Bela）</li><li>音乐的新旧约是指什么呢<br>在音乐史上，通常我们会把巴赫的，《钢琴十二平均律曲集》比喻为旧约圣经，且把贝多芬的《三十二首钢琴奏鸣曲》比喻为新约圣经 ，这是去年考试没有答上的问题！</li><li>约翰·斯特劳斯家族的音乐家.小约翰·斯特劳斯(圆舞曲之王），老约翰·斯特劳斯（圆舞曲之父），其最出名的作品《拉德斯基进行曲》是每年维也纳新年音乐会的押尾曲目.爱德华·斯特劳斯。</li><li>谁是歌曲之王呢<br>  奥地利的舒伯特（Schubert, Franz (Peter)）因为留有超过六百首的歌曲而被称为歌曲之王 。代表曲目有《野玫瑰》，《魔王》 等，套曲有《冬之旅》，《美丽的磨坊女》。</li><li>谁是“交响曲之父”<br>  “交响曲之父”指的是海顿（Haydn, Franz Joseph）。由于当时的人们总把音乐会当作打瞌睡的场所，海顿创作了在漫长的宁静之后突然钟鼓齐鸣的“惊愕”交响曲 ，还是四重奏之父。</li><li>谁是“协奏曲之父”呢？<br>  “协奏曲之父”就是因一头红发而被称为“红发教士”的韦瓦尔第代表曲目《四季》</li><li>谁是“音乐之父”呢？<br>  “音乐之父”就是出身于音乐世家的巴赫。</li><li>谁是“音乐神童”呢？<br>  “音乐神童”就是从小就到处旅行演奏并创作的莫札特</li><li>谁是“神剧之父”呢？<br> “神剧之父”指的是神剧“弥赛亚”的作者亨德尔《弥赛亚》–《哈里路亚》。</li><li>谁是音乐史上的“乐圣”呢？<br>  “乐圣”是指丧失听力的贝多芬。</li><li>谁是“钢琴诗人”呢？<br>  波兰作曲家萧邦，被视为钢琴音乐最伟大的作曲家，通常被誉为“钢琴诗人”</li><li>十二平均律是由谁首创？</li></ol><p>中国十二平均律是由明代朱载堉首创，西洋十二平均律是由德国巴赫首创</p><p>21.交响诗是由谁首创？</p><p>交响诗是由李斯特首创，他曾受业于彻尔尼 ！</p><p>22.世界三大芭蕾舞剧为何？</p><p>世界三大芭蕾舞剧为柴可夫斯基所做的天鹅湖，睡美人及胡桃钳子</p><p>23.音乐史上最早的第一部协奏曲为何？</p><p>音乐史上最早的第一部协奏曲为科赖里所做的大协奏曲</p><p>24.古代组曲的顺序为何？</p><p>古代组曲的顺序为阿勒曼 库朗 萨拉邦 吉格</p><p>25.法国歌剧的创始人是谁？</p><p>法国歌剧的创始人是卢利</p><p>26.在西洋音乐史上有哪几位作曲家是二十世纪新音乐的开创者？</p><p>在西洋音乐史上被称为是二十世纪新音乐的开创者有德彪西、荀白克及斯特拉文斯基</p><p>27.何谓俄国五人组（强力集团）？</p><p>鲍罗丁、巴拉基列夫、居伊、穆索斯基及里姆斯基.科萨可夫被称为俄国五人组</p><p>31·谁有和声学之父之称？</p><p>法国了作曲家及理论家拉莫Rameau,Jean-Philippe (1683-1764) 有和声学之父之称，他是巴洛克时期的作曲家</p><p>32·何谓清唱剧？</p><p>清唱剧通常已故视为题材，有角色但无布景与动作的音乐</p><p>33·何谓巴黎六人组？</p><p>巴黎六人组(Les Six)为米约(Milhaud)、普朗克(Poulence)、奥里克(Auric)、迪霍(Durey)、塔乐费尔(Tailleferre)、奥乃格(Honnegar)</p><p>34·有哪些作曲家曾经编写管弦乐曲“罗密欧与朱丽叶”？</p><p>普罗科菲耶夫(Prokofiev)、柴可夫斯基(Tchaikovsky)、柏辽兹(Berlioz)三人均曾编写过管弦乐曲“罗密欧与朱丽叶”</p><p>35·谁是进行曲之王？</p><p>美国作曲家，致力于军乐队的发展，发明苏沙低音号的苏沙</p><p>36·谁是俄国音乐之父？</p><p>采用俄罗斯民谣作为主题运用欧洲式的音乐手法，创作许多民族性的音乐是俄国作曲家葛令卡</p><p>37·简谱是由谁创立的?？</p><p>简谱是由法国的医生兼音乐理论家舒威以音乐教育为目的(Cheve, Emile-Joseph-Maurice 1804～1864)所创立，所以这种简谱又称为”舒威谱式”。以阿拉伯数字中的1、2、3、4、5、6、7</p><p>38.一些美誉：音乐诗人–舒曼。</p><p>清唱剧大师–亨德尔。</p><p>乐剧工匠–瓦格纳</p><p>指挥界帝王–卡拉扬</p><p>歌剧之王–威尔第</p><p>男高音歌王–卡鲁索</p><p>高音之王–帕瓦罗蒂</p><p>小提琴之王–帕格尼尼</p><p>歌剧界女王–卡拉斯</p><p>钢琴之王（标题交响诗之父）–李斯特</p><p>现代管弦乐之父–柏辽兹</p><p>印象派大师–德彪西</p><p>法国音乐之父–保尔·莫里亚</p><p>俄罗斯音乐之父–格林卡</p><p>神弓–海菲兹</p><p>音乐绘画大师–穆索尔斯基</p><p>捷克音乐之父–德沃夏克</p><p>新捷克音乐之父–斯美塔纳</p><p>民族乐派大师–格里格</p><p>当代钢琴泰斗–鲁宾斯坦</p><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><h4 id="听辨题"><a href="#听辨题" class="headerlink" title="听辨题"></a>听辨题</h4><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%A4%96%E5%9B%BD%E7%BB%8F%E5%85%B8%E9%9F%B3%E4%B9%90%5C1.png" alt="1"></p><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%A4%96%E5%9B%BD%E7%BB%8F%E5%85%B8%E9%9F%B3%E4%B9%90%5C2.png" alt="2"></p><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><h4 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h4><h3 id="期中作业（莫扎特传电影影评or音乐会）"><a href="#期中作业（莫扎特传电影影评or音乐会）" class="headerlink" title="期中作业（莫扎特传电影影评or音乐会）"></a>期中作业（莫扎特传电影影评or音乐会）</h3><p><strong>《Amadeus》观后感</strong></p><p>关于电影。</p><p>影片中的沃尔夫冈·阿马德乌斯·莫扎特与安东尼奥·萨列里两人。</p><p>一个是上帝的宠儿，一个是信仰上帝最终却与上帝反目。</p><p>萨列里第一次遇见莫扎特是在一个非常喜剧的场景之下，那是一次大主教的宫廷乐会，萨列里因为好奇去寻找莫扎特，寻找无果于是去偷吃甜品，此时莫扎特正好在追逐嬉戏中出现了，而萨列里躲在一旁观察着他。</p><p>虽然该电影以莫扎特的中间名命名，但主角其实是莫扎特的对手——萨列里，而从萨列里的视角中，我也试着从旁观者的角度去看待莫扎特这个神话一般的音乐家。</p><p>电影主要讲述了年迈七十的维也纳宫廷乐师萨列里回忆起三十年前因嫉妒莫扎特的才华，数次从其音乐事业中作梗，精神折磨莫扎特并将其“谋杀”的故事。</p><p>莫扎特的音乐天赋和宫廷乐师父亲的严厉指导让他六岁就能写出协奏曲曲，十一岁创作了第一部歌剧，十七岁就在萨尔兹堡大主教的宫廷乐队里担任首席乐师。</p><p>而萨列里则远不如莫扎特幸运，虽然他出生在一个富商家庭，可是家里没人懂音乐，内心对音乐的渴望对他来说反而是一种折磨。直到父亲突然去世之后，萨列里才有机会挣脱束缚去学习音乐，并靠着自己的努力当上了宫廷乐长，所以他虔诚地信仰上帝。</p><p>其实萨列里更像是我们生活中的大多数人，一步步实现自己梦想的同时却又无可避免地沦为平庸，但他从未放弃对音乐的热爱，所以在遇见莫扎特的时候他又怎么能不心生嫉妒呢？他遇见的是一个幸运的音乐天才，一个只为热爱音乐而生的上帝宠儿，莫扎特可以一边放荡不羁，同时轻松地创造出吸引人的音乐。</p><p>就像德国诗人歌德曾评价莫扎特的那样：神的创造力在人间的化身，他的音乐才华是神送来的。</p><p>对于萨列里来说，莫扎特的音乐才华确实是一种打击，但同时由于他自己对音乐的热爱，他对莫扎特的嫉妒中其实也有着一种惺惺相惜。压倒骆驼最后的那根稻草，或许是他自己爱的人被莫扎特夺走的那一刻，从那一刻起，他开始彻头彻尾地嫉恨莫扎特的才华。</p><p>也难怪萨列里后来会与上帝反目，觉得上帝从未爱过世人，因为如果祂爱过，那为什么不多带点人去享享福呢，或者每个人轮着来也可以。</p><p>可是从来没有这样过。</p><p>所以我每次看到甜品出现的场景，都好像能听见有人在轻声低语“生活已经那么苦了，还是给自己加点糖吧。”</p><p>结尾处萨列里说，我代表世界所有的庸才。上帝宽恕你们。</p><p>其实看到电影结尾我反而没有多少讨厌萨列里，可能是因为他已经得到了应该得到的惩罚，并且用了一生来承受它。</p><p>但或许这也正应了那句话：人世间的苦难见多了，对那些即使是做错了事的人，也再难以说出活该二字。</p><p>关于音乐</p><p>算上这部传记电影的话，我也已经看过不少音乐相关的电影了，比如《海上钢琴师1900》《爆裂鼓手》等等，无一例外的是，我们都能从中感受到它们想向观众传达的那种特殊的情感，那就是对音乐极致般的热爱，而对音乐的热爱影响着音乐家们的一生，同时也影响了我们所有人的一生。</p><p>从电影刚开头牧师破门而入看到萨列里自杀，随即镜头切换到街上，维也纳夜晚的街头，行色匆匆，同时浮现出片名《Amadeus》，莫扎特第二十五交响曲奏起，仅凭音乐就能够感受到电影导演的用心良苦。</p><p>从萨列里面对年轻牧师回忆当初，第一首莫扎特《小夜曲》的出现使萨列里内心中仇恨的种子展露开始，再到他嘲讽莫扎特执意创作德语歌剧《后宫诱逃》、阻止《费加罗的婚礼》的上演、观看《唐璜》想到用莫扎特父亲来压垮莫扎特，音乐一步步推动着二人之间的矛盾和冲突，直至最后《安魂曲》宣告落幕，将莫扎特一生中最著名的音乐和歌剧作品贯穿全局，最终直指人物内心。</p><p>如果是对莫扎特本人或者对他的音乐有更深入了解的话，这部电影或许更加能够触动人心，而这其实也是艺术的魅力所在。无论是音乐、电影还是艺术作品，所有的艺术形式所传达出来的情感，都需要进行所谓的“二次加工”，不同的人甚至是同一个人在不同时期对同一作品会有不同的感触。我想，这或许也是它们能恒久流传至今的原因之一。</p><p>作为音乐家的莫扎特的确伟大，因为他的音乐至今仍能触动人们的心灵。</p><p>但就像他自己说的那样，“我是个低俗的人呢，但我的音乐绝不低俗”，他在音乐之外的生活上可能也只是一个普普通通的人，无法事事做到完美，而能够勇敢地面对生活不轻易屈服，并且一直对音乐报以热爱，这大概也是他人生之所以伟大的原因之一。</p><p>影片最后一幕，又响起了莫扎特那标志性的笑声，他仿佛带着他的音乐穿越时空而来，三个小时的电影已经结束，但他好像还在说：</p><p>“但我绝不会屈服，我会一直坚持，直到到达我音乐的尽头，直到你们的心里。”</p><p>​    “我，沃尔夫冈·阿玛多伊兹·莫扎特，在遭受羞辱与背叛后，向各位致敬。”</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读一篇科研论文</title>
      <link href="/2020/10/09/ru-he-yue-du-ke-yan-lun-wen/"/>
      <url>/2020/10/09/ru-he-yue-du-ke-yan-lun-wen/</url>
      
        <content type="html"><![CDATA[<h2 id="检索论文"><a href="#检索论文" class="headerlink" title="检索论文"></a>检索论文</h2><p>知网（学校资源库）、知乎、各大顶会……</p><h2 id="下载论文"><a href="#下载论文" class="headerlink" title="下载论文"></a>下载论文</h2><p><a href="https://tool.yovisun.com/scihub/" target="_blank" rel="noopener">sci-hub</a></p><h2 id="阅读论文"><a href="#阅读论文" class="headerlink" title="阅读论文"></a>阅读论文</h2><blockquote><p>拿到一篇文献后，不妨先问自己几个问题：</p><p><strong>（1）这篇文章属于什么领域或方向？</strong></p><p><strong>（2）解决了什么问题？为什么这个问题这么重要？</strong></p><p><strong>（3）使用了什么方法和模型？为什么这个方法可以解决这个问题？</strong></p><p><strong>（4）核心结论是什么？下一步还可以怎么做？</strong></p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="信号处理课程论文报告"><a href="#信号处理课程论文报告" class="headerlink" title="信号处理课程论文报告"></a>信号处理课程论文报告</h3><h4 id="报告要求"><a href="#报告要求" class="headerlink" title="报告要求"></a>报告要求</h4><p>The project report requires you to conduct a comprehensive self-proposed survey research on recent developments in the signal processing. The research topics can be relevant to the materials in your oral presentation, but not limited. You should focus on a particular topic with <strong><em>\</em>only one**</strong> particular <strong><em>\</em>journal**</strong> paper. The journal paper should be published in recent two years (2019-2020). The page limit of final project is between 10-15 with at least 10 references.</p><p><strong><em>\</em>Language:**</strong>    Mandarin (Suggested) or English (Optimal)</p><p><strong><em>\</em>Submission:**</strong> All the project report should be submitted before <strong><em>\</em>Week 11 (Nov 15th).**</strong> The upload files should include the checking report of your academic integrity, with overlapping rate less than <strong><em>\</em>20%**</strong>. <strong>Fail to upload the plagiarism checking report will not get the marks in your final exam.</strong></p><p><strong><em>\</em>Academic**</strong> <strong><em>\</em>Integrity:**</strong>    All the final report should avoid plagiarism, collusion and misconduct, which will include the checking report from the online academic integrity system. For the Mandarin version, please click    <a href="http://www.biguolunwen.com/?aid=983" target="_blank" rel="noopener">http://www.biguolunwen.com/?aid=983</a> or scan the QR code.  For English version,  please click    <a href="http://www.turnitin.com.cn/" target="_blank" rel="noopener">http://www.turnitin.com.cn/</a> or other system.</p><h4 id="选取论文"><a href="#选取论文" class="headerlink" title="选取论文"></a>选取论文</h4><p><strong><em>《Invertible Image Rescaling》</em></strong></p><p><strong>ECCV2020oral 可逆的图像变换</strong></p><p>论文地址：<a href="https://arxiv.org/pdf/2005.05650.pdf" target="_blank" rel="noopener"><strong>https://arxiv.org/pdf/2005.05650.pdf</strong></a></p><p>源码地址：<a href="https://github.com/pkuxmq/Invertible-Image-Rescaling" target="_blank" rel="noopener"><strong>https://github.com/pkuxmq/Invertible-Image-Rescaling</strong></a></p><h4 id="前言概述部分"><a href="#前言概述部分" class="headerlink" title="前言概述部分"></a>前言概述部分</h4><p>本文是对ECCV 2020 Oral论文《<strong>Invertible Image Rescaling</strong>》的解读。这篇论文提出了通过构建可逆缩放网络模型（IRN，Invertible Rescaling Net）来解决图像压缩或缩放后的还原问题，并且介绍了其相关构建方法和原理，可以从本质上缓解求解不适定问题（ill-posed problem）带来的困难。相对于前人完全忽视图像缩放中不适定问题的做法，其效果上的提升也非常显著。信息丢失(Information Loss)所导致的不适定问题（ill-posed）在现实中也大量存在，该论文提供的对丢失信息（Lost Information）进行建模的视角，相信可以对类似任务也有一定的参考价值。</p><h4 id="解读主体部分"><a href="#解读主体部分" class="headerlink" title="解读主体部分"></a>解读主体部分</h4><p><strong>研究背景</strong></p><p>信号在我们的日常生活中随处可见，例如：声音、图像、视频等。然而在信号的传输或存储过程中，往往会面临信号失真、质量变差等问题。比如，为了让图片能够适配各种不同分辨率的屏幕或者是为了节省图片的存储空间，高分辨率的图片通常会被缩减规模成低分辨率的图片，而在这个过程中发生了信息的损失，因此新的问题也随之而来，在图片被降低分辨率之后，如果要再次放大图片，就需要想办法恢复原来图片的分辨率和细节。</p><p>然而，在此之前传统的图片缩放方法由于损失了图片的高频信息所以并不是单映射的（non-injective），这就导致了图片缩减（downscale）后再扩大（upscale）的病态问题（ill-posed problem），即对降采样后图片的原图求解的病态(ill-posed)问题。</p><p>这是一个病态问题的原因是在降采样的过程中存在信息丢失(information loss)，以至于无法很好地还原回原图。而前人的做法一般是使用一个超分辨率的卷积神经网络，尝试从大量的数据中强行学习低分辨率到高分辨率的映射关系；或者使用encoder网络对原图进行降采样，同时使用decoder网络还原图片，二者进行联合训练(jointly training)达到更好的效果。但以上这些方法都没有从本质上解决病态问题，效果也不尽如人意。因此我们需要更好的方法来解决病态问题。</p><h4 id="报告PPT部分"><a href="#报告PPT部分" class="headerlink" title="报告PPT部分"></a>报告PPT部分</h4><p>不知道同学们平日里上网有没有遇到过这种情况：自己精心拍摄的高清照片/视频，想发给朋友or分享到朋友圈/微博/抖音/知乎，结果上传文件之后，直接被无良服务器压成超低分辨率渣画质。甚至有些图片/表情包在经过多次传播之后，画质已经糊到惨不忍睹。</p><p>其实，图片的降采样(缩放)可以说是对数字图像最常见的操作了，它的用处多种多样：压缩图片尺寸、节省服务器存储or带宽、适配不同分辨率的屏幕等等。像现在服务器资源这么贵，大家发微博/知乎也不交钱，顶多给各位多塞点广告，所以高清图片和视频自然是能压则压，能分得清张一山和夏雨就可以了。</p><p>如何恢复降采样后的图片是图像处理中一个非常有挑战的问题，一直没有被很好的解决。今天给大家介绍一篇在ECCV2020上最新的Oral工作，巧妙地尝试从本质上解决这个问题。</p><hr><p>这种情况是由于程序为了减轻服务器端的传输和存储压力，主动对信号进行了采样、压缩等操作，而这些操作会不可避免地引起信息丢失（information loss）的问题，造成对原始信号还原的挑战性。直到今天，信息丢失问题仍没有被很好地解决。</p><hr><p>……</p><hr><h4 id="补充文献资料部分"><a href="#补充文献资料部分" class="headerlink" title="补充文献资料部分"></a>补充文献资料部分</h4><h5 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h5><p><a href="https://zhuanlan.zhihu.com/p/22450818" target="_blank" rel="noopener">形象易懂讲解算法I——小波变换</a></p><blockquote><p>于是小波变换的出发点和STFT还是不同的。<strong>STFT是给信号加窗，分段做FFT</strong>；而小波直接把傅里叶变换的基给换了——将<strong>无限长的三角函数基</strong>换成了<strong>有限长的会衰减的小波基</strong>。这样<strong>不仅能够获取频率</strong>，还可以<strong>定位到时间</strong>了~</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/xiaobobianhuan.jpg" alt="xiaobobianhuan"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/xiaobo.jpg" alt="小波"></p><h5 id="可逆神经网络模型（Invertible-NN-INN）"><a href="#可逆神经网络模型（Invertible-NN-INN）" class="headerlink" title="可逆神经网络模型（Invertible NN, INN）"></a>可逆神经网络模型（Invertible NN, INN）</h5><p><a href="https://lilianweng.github.io/lil-log/2018/10/13/flow-based-deep-generative-models.html" target="_blank" rel="noopener">可逆神经网络模型</a></p><p><a href="https://zhuanlan.zhihu.com/p/268242678" target="_blank" rel="noopener">神经网络的可逆形式</a></p><p><a href="https://www.jianshu.com/p/37c482fe4d2a" target="_blank" rel="noopener">可逆神经网络 Invertible Neural Networks</a></p><p>对于一些问题，研究人员建立了复杂的理论模型，用于实现隐式参数到可测量值的映射，这种映射称之为前向过程。逆向过程即根据测量值得到隐式参数，这也是实际需要解决的问题。但是逆向过程难以解决，因为在前向过程中丢失了一些关键信息。</p><p>如果直接用传统神经网络去训练逆向过程，则效果会很受限，因为逆向过程为一对多映射。神经网络训练出的模型，最好情况是识别最可能的解决方案；最差情况是采用多种解决方案的平均值。</p><p>INN 有三个特征：（i）从输入到输出的映射是双射的，即它的逆存在（ii）正向和反向映射都是有效可计算的（iii）映射具有易处理的雅可比行列式，因此概率可以通过变量公式明确转换。</p><p>标准NN v.s. INN</p><p>标准 NN 直接对逆向过程进行训练，但其需要一个监督损失（SL）项，来区分真正的 x 与预测的 x（我们可以暂时把 SL 理解为一个确定的代价函数），而 y-&gt;x 这种一对多映射使得传统 NN 受到很大限制。INN 只对前向过程使用 SL，而由于并没有一个确定的 x 值，因此预测的 x 属于无监督损失（USL），需要遵循之前的 p(x)；另外，潜在变量 z 需要服从高斯分布，也是属于 USL。</p><p>由于在前向过程中会丢失一些信息，因此引入了额外的潜在输出变量 z，被训练去抓获与 x 有关的但并未包含在 y 内的信息。此外，需要训练网络根据高斯分布对 p(z) 进行调整。即，p(x|y) 被调整为一个确定的函数 x = g(y,z)，这个函数将已知的分布 p(z) 在满足 y 的情况下转换到 x 空间。</p><h5 id="Encoder-Decoder-网络"><a href="#Encoder-Decoder-网络" class="headerlink" title="Encoder-Decoder 网络"></a>Encoder-Decoder 网络</h5><p><a href="https://blog.csdn.net/qq_38906523/article/details/79838000" target="_blank" rel="noopener">Encoder-Decoder模型</a></p><p>所谓<strong>encoder-decoder模型，又叫做编码-解码模型。这是一种应用于seq2seq问题的模型</strong>。</p><p>那么seq2seq又是什么呢？简单的说，就是根据一个输入序列x，来生成另一个输出序列y。seq2seq有很多的应用，例如翻译，文档摘取，问答系统等等。在翻译中，输入序列是待翻译的文本，输出序列是翻译后的文本；在问答系统中，输入序列是提出的问题，而输出序列是答案。</p><p>为了解决seq2seq问题，有人提出了encoder-decoder模型，也就是编码-解码模型。所谓编码，就是将输入序列转化成一个固定长度的向量；解码，就是将之前生成的固定向量再转化成输出序列。 </p><p><strong>encoder-decoder模型虽然非常经典，但是局限性也非常大</strong>。最大的局限性就在于编码和解码之间的唯一联系就是一个固定长度的语义向量C。也就是说，编码器要将整个序列的信息压缩进一个固定长度的向量中去。但是这样做有两个弊端，一是语义向量无法完全表示整个序列的信息，还有就是先输入的内容携带的信息会被后输入的信息稀释掉，或者说，被覆盖了。输入序列越长，这个现象就越严重。这就使得在解码的时候一开始就没有获得输入序列足够的信息， 那么解码的准确度自然也就要打个折扣了</p><h5 id="不适定问题-ill-posed-problem"><a href="#不适定问题-ill-posed-problem" class="headerlink" title="不适定问题(ill-posed problem)"></a>不适定问题(ill-posed problem)</h5><p><a href="https://blog.csdn.net/leviopku/article/details/89296455" target="_blank" rel="noopener">计算机视觉中的不适定问题</a></p><p>适定问题(well-posed problem)和不适定问题(ill-posed problem)都是数学领域的术语。</p><p>前者需满足三个条件，若有一个不满足则称为”ill-posed problem”：</p><blockquote><p>a solution exists   </p><p> 解必须存在</p><ol start="2"><li>the solution is unique    </li></ol><p>解必须唯一</p><ol start="3"><li>the solution’s behavior changes continuously with the initial conditions. </li></ol><p>解能根据初始条件连续变化，不会发生跳变，即解必须稳定</p></blockquote><p>上述来自wiki。</p><hr><p>图像处理中不适定问题（ill posed problem）或称为反问题（inverse Problem）的研究从20世纪末成为国际上的热点问题，成为现代数学家、计算机视觉和图像处理学者广为关注的研究领域。数学和物理上的反问题的研究由来已久，法国数学家阿达马早在19世纪就提出了不适定问题的概念:称一个数学物理定解问题的解存在、唯一并且稳定的则称该问题是适定的（Well Posed）.如果不满足适定性概念中的上述判据中的一条或几条，称该问题是不适定的。典型的图像处理不适定问题包括：图像去噪（Image De-nosing），图像恢复（Image Restorsion），图像放大（Image Zooming），图像修补（Image Inpainting），图像去马赛克（image Demosaicing），图像超分辨(Image super-resolution )等。<br>迄今为止，人们已经提出许多方法来解决图像处理中的不适定性。但是如何进一步刻画图像的边缘、纹理和角形等图像中重要视觉几何结构，提高该类方法在噪声抑制基础上有效保持结构和纹理能力是有待深入研究的问题。</p><hr><h5 id="Super-Resolution（超分辨率）"><a href="#Super-Resolution（超分辨率）" class="headerlink" title="Super Resolution（超分辨率）"></a>Super Resolution（超分辨率）</h5><p><a href="https://blog.csdn.net/shenziheng1/article/details/72818588/" target="_blank" rel="noopener">漫谈深度学习在Super Resolution（超分辨率）领域上的应用</a></p><p><a href="https://blog.csdn.net/sinat_39372048/article/details/81628945" target="_blank" rel="noopener">超分辨率技术（Super-Resolution, SR）</a></p><p>超分辨率技术（Super-Resolution, SR）是指从观测到的低分辨率图像重建出相应的高分辨率图像，在监控设备、卫星图像和医学影像等领域都有重要的应用价值。</p><hr><p>Super Resolution（SR），这个方向做的事情是给你一张低分辨率的小图（Low Resolution，LR），通过算法将这张LR放大成一张高分辨率的大图（High Resolution，HR）。这个事情乍一听挺简单的，普通的插值算法即可胜任，其实大有玄机，主要的难点在于细节的恢复，如下两张图，第一张图是原图，第二张图是将原图进行3倍下采样后，用Bicubic插值算法[1]进行SR恢复的图像，从图像整体来看，第二张图比第一张图要显得糊一些，如果将蝴蝶的翅膀纹路放大看可以发现，第二张图的细节已经很不清晰，纹路间的边缘已经模糊。这正是SR这个方向所面临的挑战。</p><hr><h3 id="大数据课程论文阅读Paper"><a href="#大数据课程论文阅读Paper" class="headerlink" title="大数据课程论文阅读Paper"></a>大数据课程论文阅读Paper</h3><p>这次挑了篇发表在IEEE Intelligent Systems上的文章《基于图像大数据的道路交通态势感知系统研究》，好像挺水的。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_0.png" alt="Image_Big_Data_00"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_1.png" alt="Image_Big_Data_01"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_2.png" alt="Image_Big_Data_02"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_03.png" alt="Image_Big_Data_03"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_04.png" alt="Image_Big_Data_04"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_05.png" alt="Image_Big_Data_05"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_06.png" alt="Image_Big_Data_06"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_07.png" alt="Image_Big_Data_07"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_big_Data_08.png" alt="Image_big_Data_08"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_09.png" alt="Image_Big_Data_09"></p><p><strong>我的参考文献</strong></p><p>基础目标检测算法介绍（一）：CNN、RCNN、Fast RCNN和Faster RCNN - 论智的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/46963225" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46963225</a></p><h3 id="大数据课程Project"><a href="#大数据课程Project" class="headerlink" title="大数据课程Project"></a>大数据课程Project</h3><p><a href="https://www.aclweb.org/anthology/2020.acl-main.343/" target="_blank" rel="noopener">A Chinese Multimodal Sentiment Analysis Dataset with Fine-grained Annotation of Modality</a></p><p><a href="https://github.com/thuiar/MMSA" target="_blank" rel="noopener">code</a></p><hr><blockquote><p>太南了，还是从基础做起吧。</p></blockquote><hr><p><a href="https://www.bilibili.com/video/BV1Fv411E7Vs" target="_blank" rel="noopener">aiwin的舆情分析bilibili</a></p><h2 id="论文查重"><a href="#论文查重" class="headerlink" title="论文查重"></a>论文查重</h2><p><a href="http://www.biguolunwen.com/" target="_blank" rel="noopener">中文论文查重</a></p><p><a href="http://www.turnitin.com.cn/" target="_blank" rel="noopener">英文论文查重</a></p><blockquote><p>竟然是按字符数收费，查了我二十几块钱，简直无语了，参考文献篇篇标红，把参考文献删了才能过。</p><p>一次及其糟糕的查重体验。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 论文 </tag>
            
            <tag> 信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS使用技巧</title>
      <link href="/2020/10/07/vs-shi-yong-ji-qiao/"/>
      <url>/2020/10/07/vs-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="VS常用快捷键"><a href="#VS常用快捷键" class="headerlink" title="VS常用快捷键"></a>VS常用快捷键</h2><h3 id="变量-方法-类-相关操作"><a href="#变量-方法-类-相关操作" class="headerlink" title="[变量/方法/类] 相关操作"></a>[变量/方法/类] 相关操作</h3><blockquote><p>Ctrl + R,Ctrl + R ：变量/方法/类[重命名]</p><p>Alt+F12: ：变量/方法/类[查看相关定义(Esc退出)]</p></blockquote><h3 id="·-光标移动"><a href="#·-光标移动" class="headerlink" title="· 光标移动"></a>· 光标移动</h3><blockquote><p>Ctrl + ← / → ：按单词移动光标</p><p>Ctrl + Home / End ：移动到文档前端/末尾</p><p>Page Up/Down ：快速移动到下一页</p></blockquote><h3 id="·-文本选择"><a href="#·-文本选择" class="headerlink" title="· 文本选择"></a>· 文本选择</h3><blockquote><p>Shift + ← / → ：按字符选择文本</p><p>Ctrl + Shift + ← / → ：按单词选择文本</p><p>Ctrl + W ：选择整个单词</p><p>Shift + Home/End ：选择光标位置到本行开头/结尾的所有文本</p><p>Ctrl + Shift + Home/End ：选择光标位置到文档开头/结尾的所有文本</p></blockquote><h3 id="·-复制删除文本"><a href="#·-复制删除文本" class="headerlink" title="· 复制删除文本"></a>· 复制删除文本</h3><blockquote><p>Ctrl + Shift + V ：可选择进几次的复制内容</p><p>Ctrl + D ：快速复制一行</p><p>Shift + Delete ：删除整行</p><p>Ctrl + Delete/Backspace ：删除整个单词[从前往后/从后往前]<br>Ctrl + Enter ：在上面插入空白行[实用]<br>Ctrl + Shift + Enter ：在下面插入空白行</p></blockquote><h3 id="·-格式化代码-注释"><a href="#·-格式化代码-注释" class="headerlink" title="· 格式化代码/注释"></a>· 格式化代码/注释</h3><blockquote><p>tab ：向后缩进指定tab空间</p><p>Shift + tab ：向前缩进指定tab空间</p><p>Ctrl + K,Ctrl + D ：格式化整个文档</p><p>Ctrl + K,Ctrl + F ：格式化选中行</p><p>Ctrl + K,Ctrl + C ：注释选中行</p><p>Ctrl + K,Ctrl + U ：取消注释选中行</p><p>[工具] Power Tool for Visual Studio ：保存时格式化文档/删除未引用命名空间/重新排序命名空间</p><p>[下载] 扩展-&gt;搜索Power Command</p></blockquote><h3 id="·-跳转-展开-折叠代码"><a href="#·-跳转-展开-折叠代码" class="headerlink" title="· 跳转/展开/折叠代码"></a>· 跳转/展开/折叠代码</h3><blockquote><p>Ctrl + G ：指定跳转到某行</p><p>Ctrl + M,Ctrl + M ：展开/折叠光标所在位置的代码块</p><p>Ctrl + M,Ctrl + O ：折叠整个文档的代码块</p><p>Ctrl + M,Ctrl + L ：展开整个文档的代码块</p><p>Ctrl + K,Ctrl + S ：包裹选中的代码</p></blockquote><h3 id="·-代码片段"><a href="#·-代码片段" class="headerlink" title="· 代码片段"></a>· 代码片段</h3><blockquote><p>prop/propfull + tab + tab ：生成字段属性<br>try/tryf/class/interface/foreach/for/while/switch + tab + tab ：快捷生成相应的代码片段模板</p></blockquote><h3 id="·-选项卡和窗口"><a href="#·-选项卡和窗口" class="headerlink" title="· 选项卡和窗口"></a>· 选项卡和窗口</h3><blockquote><p>Ctrl + Tab ：正序切换选项卡</p><p>Ctrl + Shift + Tab ：倒序切换选项卡</p><p>Ctrl + F6 ：导航到下一个选项卡</p><p>Ctrl + Shift + F6 ：导航到前一个选项卡</p><p>Ctrl + F4 ：关闭当前选项卡</p><p>Alt + W + L ：关闭所有选项卡</p><p>Shift + Alt + Enter ：关闭所有选项卡</p><p>Ctrl + Alt + L : 解决方案资源管理器</p><p>Ctrl + ,Ctrl + M ：团队资源管理器</p><p>Ctrl + ,Ctrl + E ：错误列表</p><p>Ctrl + ,Ctrl + E ：任务列表</p><p>Ctrl + Alt + O ：输出窗口</p></blockquote><h3 id="·-查找替换"><a href="#·-查找替换" class="headerlink" title="· 查找替换"></a>· 查找替换</h3><blockquote><p>Ctrl + F ：查找</p><p>Ctrl + H ：查找+替换</p><p>F3 ：查找下一个</p><p>Shift + F3 ：查找上一个</p></blockquote><h3 id="·-运行和调试"><a href="#·-运行和调试" class="headerlink" title="· 运行和调试"></a>· 运行和调试</h3><blockquote><p>F5 ：调试</p><p>Ctrl + F5 ：运行（非调试）</p><p>Shift + F5 ：结束调试</p><p>F10 ：多步调试</p><p>F11 ：单步调试</p><p>Shift + F11 ：跳出当前调试的方法体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git和Github</title>
      <link href="/2020/10/03/guan-yu-git-he-github/"/>
      <url>/2020/10/03/guan-yu-git-he-github/</url>
      
        <content type="html"><![CDATA[<h2 id="关于廖雪峰的Git教程小结"><a href="#关于廖雪峰的Git教程小结" class="headerlink" title="关于廖雪峰的Git教程小结"></a>关于廖雪峰的Git教程小结</h2><p><img src="https://pic1.zhimg.com/v2-49c265e6c878e26b314702d1f1cb9ee4_b.jpg" alt="img"></p><ol><li><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol></li></ol><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p><h2 id="关于Github的使用"><a href="#关于Github的使用" class="headerlink" title="关于Github的使用"></a>关于Github的使用</h2><p><a href="https://zhuanlan.zhihu.com/p/89607964" target="_blank" rel="noopener">Github进行fork后如何与原仓库同步</a></p><p><a href="https://blog.csdn.net/zhongzunfa/article/details/80344585?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">Github fork 别人的项目源作者更新后如何同步更新</a></p><h2 id="关于Git命令"><a href="#关于Git命令" class="headerlink" title="关于Git命令"></a>关于Git命令</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Linux私房菜</title>
      <link href="/2020/09/26/wo-de-linux-si-fang-cai/"/>
      <url>/2020/09/26/wo-de-linux-si-fang-cai/</url>
      
        <content type="html"><![CDATA[<h1 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h1><p>在腾讯云买了一年的服务器和域名（henryavery.cn）,接下来要正式开始学习Linux操作系统了，在此之前先复习一下计算机概论，也顺便为下次自己装机做准备。</p><p>关于linux的东西一点点放进来。</p><hr><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>刚开始用 VIM 打开文件的时候，需要从宏观的去了解一下 VIM 这个编辑器。</p><p>​    VIM 有四个模式，：</p><ul><li>正常模式 (Normal-mode)</li><li>插入模式 (Insert-mode)</li><li>命令模式 (Command-mode)</li><li>可视模式 (Visual-mode)</li></ul><p><strong>什么是正常模式（Normal-mode) ？</strong></p><p>正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一些组合键就是 vim 的功能键，而不会在文本中键入对应的字符。</p><p>在这个模式下，我们可以通过键盘在文本中快速移动光标，光标范围从小到大是字符、单词、行、句子、段落和屏幕。启动 VIM 后默认位于正常模式。不论是什么模式，按一下 <code>&lt;Esc&gt;</code>键  ( 有时可能需要按两下，插入模式按一下 <code>Esc</code> ，就会切换到正常模式，命令模式或者可视模式下执行完操作以后，就会自动进入正常模式，如果进入命令模式或者可视模式没有执行任何操作，按两下 <code>Esc</code> 即可 ）都会进入正常模式。</p><p>下面的三个模式都是过键盘上相应的键位去触发的。</p><p><strong>什么是插入模式？（Insert-mode)</strong></p><p>在正常模式中按下个别字母键（后面会详细介绍），会进入插入模式。</p><p>例如按 <code>i</code> 键会进行插入模式。该模式启动以后，就会进入编辑状态，通过键盘输入内容。</p><p><strong>什么是命令模式（Command-mode)</strong></p><p>在正常模式中，按下<code>：</code>（冒号）键或者<code>/</code> （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。</p><p><strong>什么是可视模式（Visual-mode）</strong></p><p>在正常模式按下<code>v, V, &lt;Ctrl&gt;+v</code>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</p><p>以上是关于 VIM 四种模式的解读，我们在使用 VIM 操作文本的时候，编辑区底部一般都会显示当前处于什么模式下（插入模式会有 INSERT 提示，可视模式会有 VISUAL 或者 VISUAL LINE 的提示）。</p><p>当对 VIM 有了感觉之后 ，个人认为 VIM 只有两个模式，便于理解（纯个人见解，用熟 VIM 以后，应该会赞同这个理解）：</p><ul><li>操作模式</li><li>编辑模式</li></ul><p>一个好的编辑器我们无非就使用它的两个功能：</p><p>1、通过一些快捷键操作编辑器实现我们的功能：复制，黏贴，删除，查询。。。等</p><p>2、我们用来编辑，输入内容进入编辑器。</p><p>VIM 有一个很重要的按键需要一开始就做出说明，那就是键盘中的 <esc> ,这个按键用来切换模式，该按键可以快速切换到正常模式.</esc></p><p><esc> 这个按键有点特殊，它脱离了主键盘区，每次操作这个按键的时候都会有些蛮烦。估计很多使用 VIM 的人都会有这个痛点，因此有了一个解决方案，<code>control + [</code>  这两个按键取代 <code>&lt;ESC&gt;</code>。 </esc></p><p>曾经很长一段时间我都是用 <code>control + [</code> 用来取代 <code>&lt;ESC&gt;</code> ，但是还是感觉有些难受？</p><p> VIM 有一个配置文件，在 linux 系统中，该配置文件是 .vimrc , 该文件位于 ～ 目录下面 （～ 目录是家目录，也就是用户目录，不了解的可以科学上网查询），是一个隐藏文件，如果该文件不存在可以手动创建一个。</p><p>.vimrc 可以有很多配置，例如显示行号，快捷键配置，插件配置等等。VIM 很多个性化的设置都离不开这个配置文件。<strong>zempty 认为 .vimrc 有一个特别重要的配置，那就是配置如下的一行：</strong></p><pre class="line-numbers language-text"><code class="language-text"> #将ESC键映射为两次j键                                      inoremap jj <Esc><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个配置是将 <esc> 功能键用  jj  (连续按两次 j) 来取代。这个配置可以很大程度提高 VIM 的使用效率，下文的讲解 zempty 都会用  jj  来取代键盘上的 <esc>。</esc></esc></p><p><strong>用 VIM 打开文件</strong></p><p><strong>如何用 VIM 去打开一个文件呢？</strong></p><p>现在假如有一个文件 file1 ,只需要在文件前面加上 vim 关键字就好：</p><pre><code>vim file1</code></pre><p>上面这个命令将会打开 file1 这个文件，file1 是指你具体操作的文件名。</p><p><strong>如何用 VIM 一次性打开多个文件呢？</strong></p><p>现在有多个文件 file1 ，file2 , … ,filen.</p><p>现在举例打开两个文件 file1，file2 </p><pre><code>vim file1 file2</code></pre><p>该方式打开文件，显示屏默认显示第一个文件也就是 file1，如何进行文件间的切换呢？VIM 的正常模式下（参考上文关于正常模式的描述）按下键盘上的冒号 <code>：</code>这时会在显示屏底部出现冒号 <code>：</code>（进入了 VIM 的命令模式），然后在输入 ls ，屏幕上会出现打开的所有文件的序号和文件名，我们继续输入冒号 <code>：</code> ，然后输入 bn (这里的 n需要做一个解释并不是键盘上的 n ,而是文件序号的代指，如 b1 代表显示屏上切换到第一个文件，b2 代表显示屏上切换到第二个文件)。</p><pre><code>:ls</code></pre><p>上面这个命令将会列出 VIM 打开的所有文件。</p><pre><code>:b2</code></pre><p>上面的这个命令将会在显示屏上显示第二个文件。</p><p><strong>如何在显示屏上一次性显示多个文件呢？</strong></p><p>VIM 可以实现分屏操作，一个屏幕被多个文件给分占，有左右和上下两种分屏的方式。</p><p>左右分屏如下操作：</p><pre><code>vim -On file1  file2  ...  filen</code></pre><p>这里的 n （ n  是要打开的具体文件的数目：1,2,3 …）是代表有几个文件需要分屏，从左至右依次显示 n 个文件。</p><p>上下分屏如下操作：</p><pre><code>vim -on file1 file2 ... filen</code></pre><p>这个命令跟上一个命令不同的是其中的参数 -on（ n  是要打开的具体文件的数目：1,2,3 …） 中的 o 是小写，这样将会上下依次显示 n 个文件。</p><p><strong>VIM 如何进行分屏操作呢？</strong></p><p>请记住一个重要的组合键 <code>Ctrl + w</code> ,操作分屏离不开这个组合键(这里的组合键可没有 + ，只是 Ctrl 和 w 组合实现一个动能,下文谈到的组合健都这样描述 )。</p><p>按住组合键 <code>Ctrl + w</code> ，然后在按下 s</p><pre><code>Ctrl + w  s</code></pre><p>上面这个命令将会上下分割当前打开的文件。</p><p>按住冒号<code>：</code>，紧接着输入 sp ,在键入文件名，如下：</p><pre><code>:sp file</code></pre><p>上面的这个命令将会上下分割当前文件和新打开的 file 。</p><p>按住组合键 <code>Ctrl + w</code> ,然后在按下 v </p><pre><code>Ctrl +w  v</code></pre><p>上面的这个命令将会左右分割当前的文件</p><p>按住冒号 <code>：</code>，紧接着输入 vsp ,在键入文件名称，如下：</p><pre><code>:vsp file</code></pre><p>上面的这个命令将会左右分割当前打开的文件和新打开的文件 file 。</p><p><strong>分屏以后如何在文件间切换光标，和移动分屏？</strong></p><p>1.切换左右分屏的光标 ：</p><pre><code>Ctrl + w h </code></pre><p>将当前光标定位到左边的屏幕</p><pre><code>Ctrl + w l</code></pre><p>将当前的光标定位到右边的屏幕</p><p>2.移动左右分屏 ：</p><pre><code>Ctrl + w H</code></pre><p>将当前的分屏移动到左边</p><pre><code>Ctrl + w L </code></pre><p>将当前的分屏移动到右边</p><p>3.切换上下分屏的光标 ：</p><pre><code>Ctrl + w j</code></pre><p>将当前的光标移动到下面的分屏</p><pre><code>Ctrl + w k</code></pre><p>将当前光标移动到上面的分屏</p><p>4.移动上下分屏：</p><pre><code>Ctrl + w J</code></pre><p>将当前的分屏移动到下面的分屏</p><pre><code>Ctrl + w K</code></pre><p>将当前的分屏移动到上面的分屏</p><p><strong>如何关闭分屏呢？</strong></p><pre><code>Ctrl + w c </code></pre><p>上面这个命令是关闭当前的分屏</p><pre><code>Ctrl + w q </code></pre><p>上面的这个命令也是关闭当前的分屏，如果是最后一个分屏将会退出 VIM 。</p><p><strong>VIM 的退出</strong></p><p>VIM 的最终操作就是 VIM 的退出，如何进行 VIM 的有效退出呢？下面针对 VIM 的退出来做一下说明：</p><pre><code>:w </code></pre><p>保存当前对文件的修改，但是不退出文件。</p><pre><code>:w!</code></pre><p>强制保存但是不退出文件。</p><pre><code>:w file</code></pre><p>保存当前的文件修改到 file 文件当中。</p><pre><code>:q!</code></pre><p>退出文件，对文件的修改不做保存。</p><pre><code>:qa!</code></pre><p>退出所有的文件，对所有的文件修改都不做保存。</p><pre><code>:wq</code></pre><p>退出文件并保存对文件的修改。</p><pre><code>:x</code></pre><p>退出文件并保存对文件的修改。</p><pre><code>:e file</code></pre><p>打开另一个文件。</p><pre><code>:e!</code></pre><p>放弃对文件的所有修改，恢复文件到上次保存的位置。</p><pre><code>:saveas file</code></pre><p>另存为 file。</p><pre><code>:bn` 和  `:bp</code></pre><p>当打开多个文件的时候可以输入 <code>:bn</code> 和 <code>:bp</code> 进行上一个文件或者下一个文件的切换。</p><p>以上的命令都是在命令行模式下的操作（也就是输入冒号 <code>：</code>紧接着输入相应的字符命令如 <code>:q!</code> 就会执行退出操作）。 zempty 在这里要推荐一个常用的操作就是 <code>ZZ</code> , 当你对文件进行了修改，需要保存退出，那么可以在键盘上快速的键入两个大些的 Z (ZZ),这样文件就会快速的保存退出了 。</p><p><strong>VIM 的输入模式</strong></p><p>编辑器的主要功能就是输入文本，编辑文本，很多编辑器在打开文件的时候就可以通过键盘录入文字，但是 VIM 有稍许的不同，刚刚接触 VIM 的时候是很难对 VIM 进行编辑操作的，记得我在刚接触它的时候是很崩溃的（千万个草泥马在内心奔腾），但是你接触久了，了解的多了，也就理解如此设计的美妙之处。</p><p><strong>如何使用 VIM 编辑文本？</strong> </p><p>这里有必要再强调一下，在使用 VIM 打开文件的时候，这时候的状态是正常模式（Normal-mode）,请务必记住这个模式，如果你不确定当前是否处在正常模式，请连续按两下键盘上的 <code>jj</code> (这个 <code>jj</code> 需要读者去做相应的配置，上文有做过讲解)，VIM 处理编辑文本需要从正常模式(Normal)切换到插入模式(Insert-mode),进入插入模式的时候你应该会在屏幕底部看到 INSERT 的提示，这时候就可以编辑文本了。</p><p><strong>如何从正常模式进入插入模式呢？</strong></p><p>请记住下面几个常用启动录入文本的键盘字符 <code>i,I,a,A,o,O,s,S</code> 。</p><p><code>i</code>是在光标所在的字符之前插入需要录入的文本。</p><p><code>I</code> 是在光标所在行的行首插入需要录入的文本。</p><p><code>a</code> 是在光标所在的字符之后插入需要录入的文本。</p><p><code>A</code> 是在光标所在行的行尾插入需要录入的文本。</p><p><code>o</code> 是光标所在行的下一行行首插入需要录入的文本。</p><p><code>O</code> 是光标所在行的上一行行首插入需要录入的文本。</p><p><code>s</code> 删除光标所在处的字符然后插入需要录入的文本。</p><p><code>S</code> 删除光标所在行，在当前行的行首开始插入需要录入的文本。</p><p>还有一个可能经常用到的就是 <code>cw</code> ，删除从光标处开始到该单词结束的所有字符，然后插入需要录入的文本（这个命令是两个字符的合体 cw ）。</p><p><strong>VIM 的命令模式</strong></p><p>关于命令模式上文有提到过，下面主要来列举几个常用的命令模式操作（命令输入完以后，需要按下 Enter 键去执行命令）：</p><p><strong>文本的行号设置最好不要设置在配置文件中（因为复制文件的时候行号的出现会很麻烦），在命令行实现就好</strong>。</p><pre><code>:set nu</code></pre><p>该命令会显示行号。</p><pre><code>:set nonu</code></pre><p>该命令会取消行号。</p><pre><code>:n</code></pre><p>定位到 n 行。</p><p><strong>VIM 进行关键字的查找。</strong></p><pre><code>/{目标字符串}</code></pre><p>如：/zempty   会在文本中匹配 zempty 的地方高亮。</p><p>查找文本中匹配的目标字符串，查到以后，输入键盘上的 n 会去寻找下一个匹配，N 会去寻找上一个匹配。</p><p><strong>VIM 处理大小写的区分</strong></p><pre><code>:set ic</code></pre><p>编辑器将不会区分大小写，如果你进行该设置之后，进行关键字查询如  /zempty 如果文本中有 Zempty ,zEmpty,….,只要是字符相同不会区分大小写都会进行匹配。</p><pre><code>:set noic</code></pre><p>区分大小写的查询。</p><p><strong>VIM 删除多行文本</strong></p><pre><code>:n1,n2d</code></pre><p>n1 和 n2 指的是起始行号和结束行号，d 是删除关键字</p><p><strong>VIM 处理文本的替换</strong></p><pre><code>:{作用范围}s/{目标}/{替换}/{替换的标志}</code></pre><p>作用范围分为当前行、全文、选区等等。</p><pre><code>:s/zempty/handsome/g</code></pre><p>将会把当前光标所在行的 zempty 替换成 handsome</p><pre><code>:%s/zempty/handsome/g</code></pre><p>将会把全文中的 zempty 替换成 handsome</p><pre><code>:n1,n2s/zempty/handsome/g</code></pre><p>这里的 n1 和 n2 值得是行号，将会替换掉 n1 到 n2 的所有 zempty 为 handsome.</p><p>选区，在可视模式下选择区域后输入<code>:</code>，VIM 会自动补全为 <code>:&#39;&lt;,&#39;&gt;</code>。</p><pre><code>:&#39;&lt;,&#39;&gt;s/zempty/handsome/g</code></pre><p>这个操作咋一看起来有点懵逼，这个操作是可视模式 (Visual-mode) 下选区中的替换操作（可视模式下文会谈到），可视模式下输入<code>：</code>会自动补全 <code>:&#39;&lt;,&#39;&gt;</code> 这个是可视范围下的操作范围，类似于 % 和 n1,n2，代表操作的文本范围，上面的例子就是替换掉可视区域的 zempty 为 handsome。</p><p>下面来谈谈替换的标志。</p><p>上文中命令结尾的 <code>g</code>即是替换标志之一，表示全局 <code>global</code>替换（即替换目标的所有出现）。 还有很多其他有用的替换标志：</p><p>空替换标志表示只替换从光标位置开始，目标的第一次出现</p><pre><code>:s/zempty/handsome</code></pre><p>作用于当前行，从光标处开始查找替换，仅仅替换第一次匹配 zempty 的地方为handsome 。</p><pre><code>:%s/zempty/handsome</code></pre><p>替换掉文件中所有行第一次出现 zempty 的地方为 handsome 。</p><p>i 表示大小写不敏感查找，I 表示大小写敏感：</p><pre><code>:%s/zempty/handsome/i</code></pre><p>替换掉所有行第一个出现 zempty (不区分大小写) 为 handsome 。</p><pre><code>:%s/zempty/handsome/gi</code></pre><p>替换掉所有行出现 zempty (不区分大小写) 为 handsome 。</p><p>c 表示需要确认，例如全局查找”zempty”替换为”handsome”并且需要确认：</p><pre><code>:%s/zempty/handsome/gc</code></pre><p><strong>VIM 执行 Linux 命令</strong></p><pre><code>:!command</code></pre><p><code>:</code> 后面紧跟着 <code>!</code> ，<code>!</code> 后面紧跟着 linux 命令（ command 指操作 Linux 系统的一系列命令，如创建文件，新建文件夹，查询文件的属性的等），例子如下，</p><pre><code> :!date</code></pre><p>执行 date 命令显示时间，执行完命令以后按下键盘上的 Enter 就会返回到文件。</p><p><strong>VIM 执行命令，并且添加结果至操作文本光标处</strong></p><pre><code>:r !command</code></pre><p>: 后面紧跟着 r , r 后面是空格，紧接着是  !command( command 解释同上)，例子如下，</p><pre><code>:r !date </code></pre><p>执行 date 命令显示时间，并且添加命令结果到文本中。</p><p><strong>定义快捷键</strong></p><p>下面举例说明：</p><pre><code>:map ^M I#&lt;ESC&gt;</code></pre><p>上面的例子也就是通过快捷键 <code>Ctrl + m</code> 在文件光标处所在行的行首插入 # （ # 代表注释）。</p><p><code>:</code> 后面的 map 是关键字 ，后面是 key 和 value 。</p><p>key 对应的是 ^M ， 这个 key 需要强调一下 ^M 是 Ctrl + v + m 打出来的（按下这三个键，VIM 会显示成 ^M ）,^M 代表快捷键是<code>Ctrl + m</code> , Ctrl + v + n 就是  ^N ,代表快捷键是 Ctrl + n 。Ctrl + v + x 就是 ^X (这里的 x 是代表 26 个字母中的任意一个) 代表快捷键 <code>Ctrl + x</code>。</p><p>value 对应的是 <code>I#&lt;ESC&gt;</code>,表示按下快捷键以后执行的相应操作，<code>I</code> 是切换光标至行首并切换到编辑模式，<code>#</code>是行首输入的内容（ # 是VIM 文件中的注释符号 ），<code>&lt;ESC&gt;</code> 是退出编辑模式。 </p><p>举例如下：</p><p><code>:map ^D Ahelloworld&lt;ESC&gt;</code>表示在文件的光标所在行的行尾，添加 helloworld 字符串，按住组合键 ctrl + d 就会执行操作。</p><p><strong>使用 ab</strong></p><pre><code>:ab email kickcodeman@gmail.com</code></pre><p><code>:</code> 后面的 ab 是关键字 ,该命令执行后，然后切换到编辑模式下,输入 email 会把输入的 email 自动替换成 <a href="mailto:kickcodeman@gmail.com" target="_blank" rel="noopener">kickcodeman@gmail.com</a>。</p><p>这个命令主要是处理频繁输入同样的长串字符串。</p><p><strong>VIM 的正常模式（Normal-model）</strong></p><p>VIM 正常模式下，主要进行的操作有光标的移动，复制文本，删除文本，黏贴文本等。</p><p><strong>快速移动光标</strong></p><p>几个重要的快捷键</p><p>请记住这几个快捷键 <code>h,j,k,l</code> 这几个按键主要是用来快速移动光标的，<code>h</code> 是向左移动光标，<code>l</code> 是向右移动光标，<code>j</code> 是向下移动光标，<code>k</code> 是向上移动光标，<code>h , j , k ,l</code> 在主键盘区完全可以取代键盘上的 <code>↑ ,↓ ,← , →</code> 的功能。</p><p><strong>在当前行上移动光标</strong></p><p><code>0</code> 移动到行头</p><p><code>^</code>   移动到本行的第一个不是 blank 字符</p><p><code>$</code>  移动到行尾</p><p><code>g_</code>  移动到本行最后一个不是 blank 字符的位置</p><p><code>w</code> 光标移动到下一个单词的开头</p><p><code>e</code>  光标移动到下一个单词的结尾</p><p><code>fa</code>  移动到本行下一个为 a 的字符处，fb 移动到下一个为 b 的字符处</p><p><code>nfa</code> 移动到本行光标处开始的第 n 个 字符为 a 的地方（n 是 1，2，3，4 … 数字）</p><p><code>Fa</code> 同 <code>fa</code> 一样，光标移动方向同 <code>fa</code> 相反</p><p><code>nFa</code> 同 <code>nfa</code> 类似，光标移动方向同 <code>nfa</code>相反</p><p><code>ta</code> 移动光标至 a 字符的前一个字符</p><p><code>nta</code> 移动到第二个 a 字符的前一个字符处</p><p><code>Ta</code> 同 <code>ta</code> 移动光标方向相反</p><p><code>nTa</code> 同 <code>nta</code> 移动光标方向相反</p><p><code>;</code> 和<code>,</code> 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 <code>；</code>可以快速跳转到写一个指定的字符，<code>,</code> 是跳到前一个指定的字符</p><p><strong>跨行移动光标</strong></p><p><code>nG</code> 光标定位到第 n 行的行首</p><p><code>gg</code> 光标定位到第一行的行首</p><p><code>G</code>  光标定位到最后一行的行首</p><p><code>H</code> 光标定位到当前屏幕的第一行行首</p><p><code>M</code>   光标移动到当前屏幕的中间</p><p><code>L</code> 光标移动到当前屏幕的尾部</p><p><code>zt</code> 把当前行移动到当前屏幕的最上方，也就是第一行</p><p><code>zz</code> 把当前行移动到当前屏幕的中间</p><p><code>zb</code> 把当前行移动到当前屏幕的尾部</p><p><code>%</code>   匹配括号移动，包括 ( , { , [  需要把光标先移动到括号上</p><p><code>*</code> 和 <code>#</code> 匹配光标当前所在的单词，移动光标到下一个（或者上一个）匹配的单词（ <code>*</code> 是下一个，<code>#</code> 是上一个）</p><p><strong>翻页操作</strong></p><p><code>ctrl+f</code> 查看下一页内容</p><p><code>ctrl+b</code> 查看上一页内容</p><p><strong>VIM 的复制，黏贴 ，删除</strong></p><p>三个重要的快捷键 <code>d</code> , <code>y</code> , <code>p</code></p><p><code>d</code> 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：</p><p><code>dw</code> 删除一个单词</p><p><code>dnw</code> 删除 n 个单词，</p><p><code>dfa</code> 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ）</p><p><code>dnfa</code> 删除光标处到第 n 个 a 的字符处</p><p><code>dd</code> 删除一整行</p><p><code>ndd</code> 删除光标处开始的 n 行</p><p><code>d$</code> 删除光标到本行的结尾</p><p><code>dH</code> 删除屏幕显示的第一行文本到光标所在的行</p><p><code>dG</code> 删除光标所在行到文本的结束</p><p><code>y</code> 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：</p><pre><code>yw` 复制一个单词，还有 `ynwyfa` 复制光标到下一个 a 的字符处,还有`ynfayy` 复制一行，还有 `nyy</code></pre><p><code>y$</code> 复制光标到本号的结尾</p><p><code>yH</code> 复制屏幕显示的第一行文本到光标所在的行</p><p><code>yG</code> 复制光标所在行到文本的结束</p><p><code>p</code> ，<code>P</code>是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来。</p><p><code>p</code> 在光标后开始复制</p><p><code>P</code> 大写的 P 光标前开始复制</p><p><strong>撤销操作和恢复</strong></p><p><code>u</code> 撤销刚才的操作</p><p><code>ctrl + r</code> 恢复撤销操作</p><p><strong>删除字符操作和替换</strong></p><p><code>x</code> 删除光标当前所在的字符</p><p><code>r</code> 替换掉光标当前所在的字符</p><p><code>R</code> 替换掉从光标开始以后的所有字符，除非 <code>&lt;ESC &gt;</code> 退出，或者 <code>jj</code> （代替 <esc> 上文有提到）退出。</esc></p><p><strong>大小写转换</strong></p><p>~ 将光标下的字母改变大小写<br>3~ 将光标位置开始的3个字母改变其大小写<br>g~~ 改变当前行字母的大小写<br>gUU 将当前行的字母改成大写<br>guu 将当前行的字母全改成小写</p><p>3gUU 将从光标开始到下面3行字母改成大写<br>gUw 将光标下的单词改成大写。<br>guw 将光标下的单词改成小写</p><p><strong>VIM 的重复命令</strong></p><p>. 该命令是重复上一个操作的命令<br>n<command>重复某个命令 n 次，<br>如 10p复制 10 次，10dd 删除十次。</p><p><strong>VIM 可视化模式（Visual-mode)</strong></p><p>v,V,Ctrl+v </p><p>v字符可视化，按下键盘上的v以后，屏幕底部应该会有一个 VISUAl 的提示，操作 h,j,k,l就选中文本，继续按 v 退出可视化模式。</p><p>V 行可视化，按下键盘上的 V 以后，屏幕底部应该有一个 VISUAL LINE 的提示，操作 j,k 可以向上或者向下以行为单位选中文本，继续按下 V 退出可视化模式。</p><p>Ctrl+v 块状可视化，按下键盘上的 Ctrl+v 以后，屏幕底部应该会有一个提示 VISUALBLOCK ，可以通过 h,j,k,l 块状的操作选择区域，这是很多编辑器都不可以做到的，继续按下 Ctrl+v 会退出可视化模式。</p><p><strong>可视化模式下操作文本</strong></p><p>可视化模式下选择操作区域以后，<br>按下 d会删除选择的区域，<br>按下 y 会复制选择的区域，按下 p 会黏贴选择的区域。</p><p><strong>可视化模式下 v 的特殊操作</strong></p><p>当操作的文本光标在 “”，‘’ ，（），{} ，[（双引号，单引号，小括号，大括号，中括号）<br>当中的时候,可以通过 va”选中 ”“ 内的所有内容包括双引号 ，vi” 选中 “” 内的所有内容，不包括 “”。va,vi 会快速选择区域，va 后面会紧跟一个区域结束标志，a 会选中结束符标志，i 就不会。例子如下：</p><p>“hello world [VI<strong>M</strong> is so strong],{we all can master vim skill}”</p><p>假设当前光标定位在上面的文本 M 处：<br>va] 操作将会选中以下文本（加粗部分）：<br>“hello world <strong>[VIM is so strong]</strong>,{we all can master vim skill}“<br>vi] 操作将会选中如下的区域，没有包含 []：<br>“hello world [<strong>VIM is so strong</strong>],{we all can master vim skill}“</p><p><strong>块区域下的特殊操作</strong></p><p>Ctrl+v 选中块区域以后，按下大写的 I 或者 A 可以在区域的前面或者后面输入内容，按下 jj 或者 <esc>,可以看到选中的区域前面或者后面会有输入的内容。</esc></p><p><strong>VIM 的代码提示功能</strong></p><p>在编辑模式下 ，快捷键 Ctrl+n 或者 Ctrl+p 会有代码提示功能，我们可以实现快速录入的效果。</p><p><strong>VIM 的宏录制</strong></p><p>假设需要操作的文本如下,需要将如下的多行文本的首行键入一个 tab 键。</p><p>hello<br>hello world<br>hello world , vim </p><p><strong>宏录制的录制操作</strong></p><p>先将光标移动到第一行，在普通模式下按下 q 键（宏录制是 q 键启动的),在按一个 a （字母随意）,表示该宏注册为 a  ，按下 I 在行首插入一个 tab 键，按下jj或者 <esc>退出编辑模式,按下 j 将光标移动到下一行行首，最后按下 q 键完成录制操作（宏录制是 q 键结束的）。<br>总结上面例子的操作流程：<br>q → a → I → tab → jj → j → q<br>上面的例子成功地把在行首插入 tab 的功能录制了下来，那么如何应用到其他行呢？</esc></p><p><strong>宏录制的使用</strong></p><p>上述的例子，在正常模式下，按 @a执行宏录制的一系列动作，将会在第二行执行插入 tab 。<br>@@ 是对上一次宏使用的重复操作。n@a 就会执行 n 次一系列的动作。使用宏录制可以一次执行一系列的操作，可以针对一些重复度较高的操作进行宏录制。</p><p><strong>结束</strong></p><p>文章篇幅稍长，看到这里也是挺有耐心的，VIM 的学习重在实践，需要经常复盘，时间久了，也就有了使用 VIM 的技能。文中提到的操作都是 VIM 常用的基本操作，VIM 还可以针对个人需求进行各种插件的安装，针对不同开发语言都有相应的插件支持,学习完本文推荐再看一下这篇文章 <a href="https://zhuanlan.zhihu.com/p/96801314" target="_blank" rel="noopener">关于 vim 你应该理解的几个名词</a>，在此恭喜你入坑 vim,  就到这里了，结束 ！！！</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><hr><h2 id="运行Shell"><a href="#运行Shell" class="headerlink" title="运行Shell"></a>运行Shell</h2><p><em>#!/bin/bash</em><br><strong>echo</strong> “Hello World !”</p><p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>echo 命令用于向窗口输出文本。</p><p>运行 Shell 脚本有两种方法：</p><p><strong>1、作为可执行程序</strong></p><p>将上面的代码保存为 test.sh，并 cd 到相应目录：</p><pre><code>chmod +x ./test.sh  #使脚本具有执行权限./test.sh  #执行脚本</code></pre><p>注意，一定要写成 <strong>./test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p><p><strong>2、作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。</p><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写</p><pre><code>$your_name=&quot;alibaba&quot;，使用变量的时候才加美元符（$）。</code></pre><h4 id="shell常用内部变量"><a href="#shell常用内部变量" class="headerlink" title="shell常用内部变量"></a>shell常用内部变量</h4><pre class="line-numbers language-shell"><code class="language-shell">预定义变量和环境变量相类似，也是在Shell一开始就定义的变量，不同的是，用户只能根据shell的定义来使用这些变量，所有预定义变量都是由符号“$”和另一个符号组成。 常见的Shell预定义变量有以下几种。$# ：位置参数的数量$* ：所有位置参数的内容$? ：命令执行后返回的状态，0表示没有错误，非0表示有错误$$ ：当前进程的进程号$! ：后台运行的最后一个进程号$0 ：当前执行的进程名————————————————版权声明：本文为CSDN博主「谢公子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_36119192/article/details/82964713<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a><strong>文件测试操作符</strong></h4><p>常用文件测试操作符    说明<br>-d   ， d的全拼为 directory    文件存在且为目录则为真<br>-f   ,   f的全拼为  file    文件存在且为文件则为真<br>-e ， e的全拼为 exists    文件存在则为真<br>-s ，s的全拼为 size    文件存在且大小不为0则为真<br>-r ，r的全拼为 read    文件存在且可读则为真<br>-w ，w的全拼为write    文件存在且可写则为真<br>-x ，x的全拼为executable    文件存在且可执行则为真<br>-L ，L的全拼为link    文件存在且为链接文件则为真<br>f1 -nt  f2  ，nt的全拼为 newer than    文件f1比文件f2新则为真<br>f1 -ot f2 ，ot的全拼为older than    文件f1比文件f2旧则为真<br>————————————————<br>版权声明：本文为CSDN博主「谢公子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_36119192/article/details/82964713" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/82964713</a></p><p>反引号</p><pre class="line-numbers language-shell"><code class="language-shell">for v in `ls`> do> echo $v> done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h4><p>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略。</p><p>通过每一行加一个 <strong>#</strong> 号设置多行注释，像这样：</p><pre><code>#--------------------------------------------# 这是一个注释# author：菜鸟教程# site：www.runoob.com# slogan：学的不仅是技术，更是梦想！#--------------------------------------------##### 用户配置区 开始 ######## 这里可以添加脚本描述信息# ###### 用户配置区 结束  #####</code></pre><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p><p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><p><strong>多行注释</strong></p><p>多行注释还可以使用以下格式：</p><pre><code>:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF</code></pre><p>EOF 也可以使用其他符号:</p><pre><code>:&lt;&lt;&#39;注释内容...注释内容...注释内容...&#39;:&lt;&lt;!注释内容...注释内容...注释内容...!</code></pre><hr><pre><code>$* 与 $@ 区别：</code></pre><ul><li>相同点：都是引用所有参数。</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul><pre><code>#!/bin/bash# author:菜鸟教程# url:www.runoob.comecho &quot;-- \$* 演示 ---&quot;for i in &quot;$*&quot;; do    echo $idoneecho &quot;-- \$@ 演示 ---&quot;for i in &quot;$@&quot;; do    echo $idone</code></pre><p>执行脚本，输出结果如下所示：</p><pre><code>$ chmod +x test.sh $ ./test.sh 1 2 3-- $* 演示 ---1 2 3-- $@ 演示 ---123</code></pre><h2 id="Shell-echo命令"><a href="#Shell-echo命令" class="headerlink" title="Shell echo命令"></a>Shell echo命令</h2><p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：</p><pre><code>echo string</code></pre><p>您可以使用echo实现更复杂的输出格式控制。</p><h3 id="1-显示普通字符串"><a href="#1-显示普通字符串" class="headerlink" title="1.显示普通字符串:"></a>1.显示普通字符串:</h3><pre><code>echo &quot;It is a test&quot;</code></pre><p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p><pre><code>echo It is a test</code></pre><h3 id="2-显示转义字符"><a href="#2-显示转义字符" class="headerlink" title="2.显示转义字符"></a>2.显示转义字符</h3><pre><code>echo &quot;\&quot;It is a test\&quot;&quot;</code></pre><p>结果将是:</p><pre><code>&quot;It is a test&quot;</code></pre><p>同样，双引号也可以省略</p><h3 id="3-显示变量"><a href="#3-显示变量" class="headerlink" title="3.显示变量"></a>3.显示变量</h3><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p><pre><code>#!/bin/shread name echo &quot;$name It is a test&quot;</code></pre><p>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</p><pre><code>[root@www ~]# sh test.shOK                     #标准输入OK It is a test        #输出</code></pre><h3 id="4-显示换行"><a href="#4-显示换行" class="headerlink" title="4.显示换行"></a>4.显示换行</h3><pre><code>echo -e &quot;OK! \n&quot; # -e 开启转义echo &quot;It is a test&quot;</code></pre><p>输出结果：</p><pre><code>OK!It is a test</code></pre><h3 id="5-显示不换行"><a href="#5-显示不换行" class="headerlink" title="5.显示不换行"></a>5.显示不换行</h3><pre><code>#!/bin/shecho -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行echo &quot;It is a test&quot;</code></pre><p>输出结果：</p><pre><code>OK! It is a test</code></pre><h3 id="6-显示结果定向至文件"><a href="#6-显示结果定向至文件" class="headerlink" title="6.显示结果定向至文件"></a>6.显示结果定向至文件</h3><pre><code>echo &quot;It is a test&quot; &gt; myfile</code></pre><h3 id="7-原样输出字符串，不进行转义或取变量-用单引号"><a href="#7-原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="7.原样输出字符串，不进行转义或取变量(用单引号)"></a>7.原样输出字符串，不进行转义或取变量(用单引号)</h3><pre><code>echo &#39;$name\&quot;&#39;</code></pre><p>输出结果：</p><pre><code>$name\&quot;</code></pre><h3 id="8-显示命令执行结果"><a href="#8-显示命令执行结果" class="headerlink" title="8.显示命令执行结果"></a>8.显示命令执行结果</h3><pre><code>echo `date`</code></pre><p><strong>注意：</strong> 这里使用的是反引号 <strong>`</strong>, 而不是单引号 <strong>‘</strong>。</p><p>结果将显示当前日期</p><hr><h1 id="Shell-test-命令"><a href="#Shell-test-命令" class="headerlink" title="Shell test 命令"></a>Shell test 命令</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><hr><h2 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h2><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-eq</td><td align="left">等于则为真</td></tr><tr><td align="left">-ne</td><td align="left">不等于则为真</td></tr><tr><td align="left">-gt</td><td align="left">大于则为真</td></tr><tr><td align="left">-ge</td><td align="left">大于等于则为真</td></tr><tr><td align="left">-lt</td><td align="left">小于则为真</td></tr><tr><td align="left">-le</td><td align="left">小于等于则为真</td></tr></tbody></table><hr><h2 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h2><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于则为真</td></tr><tr><td align="left">!=</td><td align="left">不相等则为真</td></tr><tr><td align="left">-z 字符串</td><td align="left">字符串的长度为零则为真</td></tr><tr><td align="left">-n 字符串</td><td align="left">字符串的长度不为零则为真</td></tr></tbody></table><hr><h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-e 文件名</td><td align="left">如果文件存在则为真</td></tr><tr><td align="left">-r 文件名</td><td align="left">如果文件存在且可读则为真</td></tr><tr><td align="left">-w 文件名</td><td align="left">如果文件存在且可写则为真</td></tr><tr><td align="left">-x 文件名</td><td align="left">如果文件存在且可执行则为真</td></tr><tr><td align="left">-s 文件名</td><td align="left">如果文件存在且至少有一个字符则为真</td></tr><tr><td align="left">-d 文件名</td><td align="left">如果文件存在且为目录则为真</td></tr><tr><td align="left">-f 文件名</td><td align="left">如果文件存在且为普通文件则为真</td></tr><tr><td align="left">-c 文件名</td><td align="left">如果文件存在且为字符型特殊文件则为真</td></tr><tr><td align="left">-b 文件名</td><td align="left">如果文件存在且为块特殊文件则为真</td></tr></tbody></table><p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： <strong>!</strong> 最高， <strong>-a</strong> 次之， <strong>-o</strong> 最低。</p><hr><h1 id="Shell流程控制"><a href="#Shell流程控制" class="headerlink" title="Shell流程控制"></a>Shell流程控制</h1><h1 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h1><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p><p>shell中函数的定义格式如下：</p><pre class="line-numbers language-shell"><code class="language-shell">[ function ] funname [()]{    action;    [return int;]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><p><strong>资料</strong></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/82964713?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163278810116780262563550%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fnavwordall.%2522%257D&request_id=163278810116780262563550&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~navwordall~first_rank_ecpm_v1~hot_rank-1-82964713.first_rank_v2_pc_rank_v29&utm_term=shell&spm=1018.2226.3001.4187" target="_blank" rel="noopener">CSDN的Linux中编写Shell脚本</a></p><p><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">菜鸟教程shell</a></p><p><a href="https://www.runoob.com/try/showbash.php?filename=helloworld" target="_blank" rel="noopener"><strong>Shell 在线工具</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django后续</title>
      <link href="/2020/09/19/django-hou-xu/"/>
      <url>/2020/09/19/django-hou-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="Django后续"><a href="#Django后续" class="headerlink" title="Django后续"></a>Django后续</h1><blockquote><p>Web应用程序的核心是让任何用户都能够注册账户并能够使用它，不管用户身处何方。</p></blockquote><h2 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h2><p>创建表单、实现用户的使用功能、Django防范常见攻击、用户身份验证系统……总之就是让用户都能正常使用</p><h3 id="让用户能够输入数据"><a href="#让用户能够输入数据" class="headerlink" title="让用户能够输入数据"></a>让用户能够输入数据</h3><h4 id="添加新的主题和条目、编辑条目"><a href="#添加新的主题和条目、编辑条目" class="headerlink" title="添加新的主题和条目、编辑条目"></a>添加新的主题和条目、编辑条目</h4><p>表单，url模式，视图函数views，创建模板并链接到页面。</p><p>GET请求与POST请求，POST用于提交表单，GET用于从服务器读取数据。</p><blockquote><p>from django.urls import reverse</p><p>需要</p></blockquote><h3 id="创建用户账户"><a href="#创建用户账户" class="headerlink" title="创建用户账户"></a>创建用户账户</h3><p>建立一个用户注册和身份验证系统，先创建一个新的应用程序，然后修改模型Topic</p><h4 id="应用程序users"><a href="#应用程序users" class="headerlink" title="应用程序users"></a>应用程序users</h4><pre class="line-numbers language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py startapp users<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、将应用程序添加到settings</p><p>2、修改根目录urls.py使其包含将为应用程序定义的URL</p><h4 id="用户登录、注销与注册"><a href="#用户登录、注销与注册" class="headerlink" title="用户登录、注销与注册"></a>用户登录、注销与注册</h4><p>要老命了，百度了一下午，我愿称其为Django新版本(3.x)踩坑记录。</p><p>我还是直接把代码上传到GitHub上好了，要改的地方实在太多了。</p><h3 id="让用户拥有自己的数据"><a href="#让用户拥有自己的数据" class="headerlink" title="让用户拥有自己的数据"></a>让用户拥有自己的数据</h3><p>用户需要专属学习笔记</p><h4 id="使用-login-required限制访问"><a href="#使用-login-required限制访问" class="headerlink" title="使用@login_required限制访问"></a>使用@login_required限制访问</h4><p>全面限制。装饰器（decorator）是放在函数定义前的指令，修改函数代码的行为。</p><h4 id="数据关联用户"><a href="#数据关联用户" class="headerlink" title="数据关联用户"></a>数据关联用户</h4><ol><li>修改模型Topic</li><li>确定当前有哪些用户（启动Django shell）</li><li>迁移数据库</li></ol><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>当执行 python manage.py shell 出现错误：TypeError: <strong>init</strong>() missing 1 required positional argument: ‘on_delete’</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>定义外键的时候需要加上 on_delete=;<br>即：<code>contract = models.ForeignKey(Contract, on_delete=models.CASCADE)</code></p><h5 id="原因如下："><a href="#原因如下：" class="headerlink" title="原因如下："></a>原因如下：</h5><p>django 升级到2.0之后,表与表之间关联的时候,必须要写on_delete参数,否则会报异常:<br>TypeError: init() missing 1 required positional argument: ‘on_delete’</p><p>on_delete各个参数的含义如下：</p><pre><code>    on_delete=None,               # 删除关联表中的数据时,当前表与其关联的field的行为    on_delete=models.CASCADE,     # 删除关联数据,与之关联也删除    on_delete=models.DO_NOTHING,  # 删除关联数据,什么也不做    on_delete=models.PROTECT,     # 删除关联数据,引发错误ProtectedError    # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_NULL, blank=True, null=True)    on_delete=models.SET_NULL,    # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理）    # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_DEFAULT, default=&#39;默认值&#39;)    on_delete=models.SET_DEFAULT, # 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值,一对一同理）    on_delete=models.SET,         # 删除关联数据,     a. 与之关联的值设置为指定值,设置：models.SET(值)     b. 与之关联的值设置为可执行对象的返回值,设置：models.SET(可执行对象)1234567891011</code></pre><hr><blockquote><p>由于多对多(ManyToManyField)没有 on_delete 参数,所以以上只针对外键(ForeignKey)和一对一(OneToOneField)</p></blockquote><h4 id="完善用户功能"><a href="#完善用户功能" class="headerlink" title="完善用户功能"></a>完善用户功能</h4><p>只允许用户访问自己的主题，保护用户的主题和页面，将主题关联到当前用户。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token comment" spellcheck="true"># 确认请求的主题属于当前用户</span>    <span class="token keyword">if</span> topic<span class="token punctuation">.</span>owner <span class="token operator">!=</span> request<span class="token punctuation">.</span>user<span class="token punctuation">:</span>        <span class="token keyword">raise</span> Http404<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于某些原因（主要是“网络原因”和Windows系统的差别），后续Heroku注册和服务器部署继续太过麻烦，于是我决定换个思路，等搞清楚云服务器怎么用再试着部署到自己的服务器上，也许之后可以去备个案然后解析域名，这样就能真正上线使用了（有没有用户另说）</p><p>而且由于我的目的是正常使用应用程序，使用Bootstrap库设置应用程序的样式来进行美化，在目前阶段卡那里也就缺少必要了，可以在解决部署之后再完善。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的“学习笔记”项目就暂告一段落了，虽然我也还不想就这样结项，但是有必要进行这段时间以来的学习总结了。</p><p>首先，整个项目都是基于python开发的，并且主要是用到了Django框架——一套用于开发交互式网站的工具（还有很多类似）</p><p>虽然不是第一次接触到前端开发，但确实是第一次一个人上手开发一整个Web应用程序，借此我也大概了解了Web的整个开发流程，并且接触到了数据库和服务器的使用。</p><p>包括第一次接触正则表达式，创建表单（提交数据）以及模型定义（继承类）。</p><p>用Django创建网页三步走：定义URL，编写视图和模板。</p><p>然后让数据关联用户，功能齐备后，美化以及部署还有待完成。</p><p>最最重要的，还是在本次项目开发过程中所学到和实践使用的东西。</p><p>比如再次深入体会到使用git进行版本控制能够带来的方便，而且通过项目实践也接触到了很多之前不明白也不知道的新东西。</p><p>比如vim编辑器（举例而言，还有很多），虽然目前可能还不会使用，但就好像埋下了一颗种子，将来总有一天会生根发芽。</p><p>再就是实践过程中学到的一些习惯和方法。</p><p>根据自己的兴趣开发有意义的项目。</p><p>只要有机会，就向别人发出邀请，根据反馈改进程序。</p><p>遇到棘手问题时，想办法寻求帮助。首先认清形势（想要做什么？已尝试那些方式？结果如何？）橡皮鸭子调试法。</p><p>再试试，歇一会。</p><p>正确使用在线搜索解决问题，直接搜索报错消息，看别人的博客里的解决方案。</p><p>Stack Overflow 和官方文档文库，reddit和IRC（还没用过）</p><p>用什么学什么的精神。</p><p>peace！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门</title>
      <link href="/2020/09/11/django-ru-men/"/>
      <url>/2020/09/11/django-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Django入门"><a href="#Django入门" class="headerlink" title="Django入门"></a>Django入门</h1><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>先建立项目规范（先要立好规矩），再建立虚拟环境，以便在其中创建项目。</p><h3 id="制定规范"><a href="#制定规范" class="headerlink" title="制定规范"></a>制定规范</h3><p>只把这个项目的一些明确目标列出来，突出开发重点。</p><p>规范如下：</p><p>开始编写一个名为“学习笔记”的Web应用程序，让用户能够记录感兴趣的主题，并在学习每个主题的过程中添加日志条目。“学习笔记”的主页对这个网站进行描述，并邀请用户注册或登录。用户登录后，就可以创建主题、添加新条目以及阅读既有的条目。</p><p>学习新的主题时，记录学到的知识可以帮助跟踪和复习这些知识。优秀的应用程序让这个记录的过程简单易行。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Python从入门到实践》</p><p><a href="https://www.jianshu.com/p/c92345eea6b4" target="_blank" rel="noopener">Django新版本(2.x)踩坑记录</a></p><p><a href="https://blog.csdn.net/u012084802/article/details/79625428" target="_blank" rel="noopener">Python练习Django项目——学习笔记</a></p><p><a href="https://www.jianshu.com/p/b3267d16c245" target="_blank" rel="noopener">Python编程从入门到实践：Web应用程序 - Django入门</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">HTML 教程</a></p><p><a href="https://docs.djangoproject.com/en/2.2/ref/templates/language/#templates" target="_blank" rel="noopener">Django 官网文档 The Django template language</a></p><p><a href="https://docs.djangoproject.com/en/1.8/ref/templates/" target="_blank" rel="noopener">Django模板文档</a></p><h3 id="建立虚拟环境并激活"><a href="#建立虚拟环境并激活" class="headerlink" title="建立虚拟环境并激活"></a>建立虚拟环境并激活</h3><p>虚拟环境是系统的一个位置，把它隔离出来，这是必须的返校隔离措施，之后我们还要把它公之于众——部署到服务器上。</p><p>刚刚开始问题就出现了，Windows要怎么终端切换到目录来着？之前外星人入侵的项目明明用过，给忘了。之前就是只看了一眼，没有动手去做，所以才拖了这么久，这次让我一鼓作气搞定。</p><pre><code>C:\Users\ASUS&gt;d:D:\&gt;cd learning_logD:\learning_log&gt;</code></pre><p>原来切换目录这么简单，我只是还不会用（心虚，这我都不记得了，原因还是以前都没怎么认真用过电脑）</p><p>还有一个很蠢的问题也解决了，之前下载的是Anaconda 3，用的也一直是Anaconda 的Prompt，我这次直接cmd能有用才怪。不过好在总算是可以继续了。</p><p>现在我们为项目新建了一个目录， 将其命名为learning_log，使用如下命令成功创建名为ll_env的虚拟环境：</p><pre><code>python -m venv ll_env</code></pre><p>建立虚拟环境后， (Windows系统下)成功使用下面的命令激活它：</p><pre><code>ll_env\Scripts\activate</code></pre><p>要停止的话，使用终止命令deactivate</p><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><p>出问题了就重新来过，建立虚拟环境然后激活,然后再安装Django包：</p><pre><code>(ll_env) (base) D:\learning_log&gt; pip install DjangoCollecting Django</code></pre><p>下载可能有点慢，要等一会。</p><p>记住，Django仅在虚拟环境处于活动状态才可用。</p><p>嘛，就知道没有这么简单，下载失败了，这次又是哪里出了问题呢？更新了一下pip的版本重新下载。</p><pre><code>(ll_env) (base) D:\learning_log&gt;pip install DjangoCollecting Django  Downloading https://files.pythonhosted.org/packages/01/a5/fb3dad18422fcd4241d18460a1fe17542bfdeadcf74e3861d1a2dfc9e459/Django-3.1.1-py3-none-any.whl (7.8MB)     |████████████████████████████████| 7.8MB 12kB/sCollecting pytz (from Django)  Downloading https://files.pythonhosted.org/packages/4f/a4/879454d49688e2fad93e59d7d4efda580b783c745fd2ec2a3adf87b0808d/pytz-2020.1-py2.py3-none-any.whl (510kB)     |████████████████████████████████| 512kB 9.5kB/sCollecting asgiref~=3.2.10 (from Django)  Downloading https://files.pythonhosted.org/packages/d5/eb/64725b25f991010307fd18a9e0c1f0e6dff2f03622fc4bcbcdb2244f60d6/asgiref-3.2.10-py3-none-any.whlCollecting sqlparse&gt;=0.2.2 (from Django)  Downloading https://files.pythonhosted.org/packages/85/ee/6e821932f413a5c4b76be9c5936e313e4fc626b33f16e027866e1d60f588/sqlparse-0.3.1-py2.py3-none-any.whl (40kB)     |████████████████████████████████| 40kB 7.8kB/sInstalling collected packages: pytz, asgiref, sqlparse, DjangoSuccessfully installed Django-3.1.1 asgiref-3.2.10 pytz-2020.1 sqlparse-0.3.1WARNING: You are using pip version 19.2.3, however version 20.2.3 is available.You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command.</code></pre><p>原来是pip命令需要更新了，按照提示更新版本就成功了。</p><h3 id="创建项目以及数据库"><a href="#创建项目以及数据库" class="headerlink" title="创建项目以及数据库"></a>创建项目以及数据库</h3><pre><code>django-admin.py startproject learning_log .</code></pre><p>新建一个名为learning_log的项目，不知道又出什么问题，先到这吧，睡了睡了。</p><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h4><p>在prompt命令窗口执行上面的命令，会打开 django-admin.py 源代码</p><h4 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h4><p>*.py 的默认打开方式为 pycharm。所以自然直接打开，我没有安装pycharm，所以是用vscode打开的。</p><h4 id="3-解决"><a href="#3-解决" class="headerlink" title="3 解决"></a>3 解决</h4><p>修改一下命令</p><pre><code>django-admin startproject [项目名] .</code></pre><p>执行成功后，输入ls命令（Windows对应dir）就会发现 Django 新建好了需要的文件</p><table><thead><tr><th align="center">文件名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">settings.py</td><td align="center">指定Django如何与你的系统交互以及如何管理项目，修改其中一些设置， 并添加一些设置</td></tr><tr><td align="center">urls.py</td><td align="center">告诉Django应创建哪些网页来响应浏览器请求</td></tr><tr><td align="center">wsgi.py</td><td align="center">帮助Django提供它创建的文件， 这个文件名是web server gateway interface（Web服务器网关接口 ） 的首字母缩写。</td></tr></tbody></table><p>一大早起来直接查命令哪里出了问题，一下就解决了。接下来建立一个数据库。在这里更新了一下Django的版本。然后dir查看一下，确认后启动一个服务器，查看系统中的项目，按照响应操作打开生成的页面。</p><pre><code>python manage.py migratepython manage.py runserver</code></pre><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%9F%BA%E4%BA%8EDjango%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%5C%E9%A1%B5%E9%9D%A2.png" alt="生成页面"></p><p>至此，这个项目成功建立了，耶！</p><h2 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h2><p>打开另一个终端，切换到manage.py所在目录，激活虚拟环境，执行命令startapp。</p><h3 id="定义模型并激活"><a href="#定义模型并激活" class="headerlink" title="定义模型并激活"></a>定义模型并激活</h3><p>模型告诉Django如何处理应用程序中存储的数据。 在代码层面， 模型就是一个类， 包含属性和方法。</p><p><strong>models.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment" spellcheck="true"># Create your models here.</span><span class="token comment" spellcheck="true"># 创建了一个名为Topic 的类， 它继承了Model ——Django中一个定义了模型基本功能的类。 Topic 类只有两个属性： text 和date_added 。</span><span class="token keyword">class</span> <span class="token class-name">Topic</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' 用户学习的主题'''</span>    text <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 属性text是一个CharField——由字符或文本组成的数据</span>    <span class="token comment" spellcheck="true"># https://docs.djangoproject.com/en/1.8/ref/models/fields</span>    <span class="token comment" spellcheck="true"># Django Model Field Reference 用于熟悉模型中可使用的各种字段，自己开发时可能会用到</span>    date_added <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实参auto_add_now=True 让Django将这个属性自动设置成当前日期和时间。</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""返回模型的字符串表示"""</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每当需要修改“学习笔记”管理的数据时， 都采取如下三个步骤： 修改models.py； 对learning_logs 调用makemigrations ； migrate让Django迁移项目。</p><pre class="line-numbers language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py makemigrations learning_logs<span class="token comment" spellcheck="true"># 让Django修改数据库， 使其能够存储与模型Topic 相关的信息</span><span class="token comment" spellcheck="true"># 命令makemigrations 让Django确定该如何修改数据库， 使其能够存储与定义的新模型相关联的数据。</span>python manage<span class="token punctuation">.</span>py migrate<span class="token comment" spellcheck="true"># 应用这种迁移， 让Django替我们修改数据库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Django-管理网站"><a href="#Django-管理网站" class="headerlink" title="Django 管理网站"></a>Django 管理网站</h3><p>为应用程序定义模型时，Django提供的管理网站（admin site）让你能够轻松地处理模型。网站的管理员可使用管理网站，但普通用户不能使用。</p><h4 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h4><pre><code>(ll_env)learning_log&gt;python manage.py createsuperuser❶ Username (leave blank to use &#39;ehmatthes&#39;): ll_admin❷ Email address:❸ Password:  Password (again):  Superuser created successfully.</code></pre><h4 id="向管理网站注册模型"><a href="#向管理网站注册模型" class="headerlink" title="向管理网站注册模型"></a><strong>向管理网站注册模型</strong></h4><p> Django自动在管理网站中添加了一些模型，如User 和Group ，但对于我们创建的模型，必须手工进行注册。我们创建应用程序learning_logs 时，Django在models.py所在的目录中创建了一个名为admin.py的文件。</p><h4 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h4><p>在网站上测试添加主题“Chess”和“Rock Climbing”</p><h3 id="定义并迁移模型Entry"><a href="#定义并迁移模型Entry" class="headerlink" title="定义并迁移模型Entry"></a>定义并迁移模型Entry</h3><p>要记录学到的国际象棋和攀岩知识，需要为用户可在学习笔记中添加的条目定义模型。每个条目都与特定主题相关联，这种关系被称为多对一关系，即多个条目可关联到同一个主题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment" spellcheck="true"># Model是Django中一个定义了模型基本功能的类</span><span class="token keyword">class</span> <span class="token class-name">Topic</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token operator">-</span><span class="token operator">-</span>snip<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""学到的有关某个主题的具体知识"""</span>    topic <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>Topic<span class="token punctuation">,</span>on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span>    text <span class="token operator">=</span> models<span class="token punctuation">.</span>TextField<span class="token punctuation">(</span><span class="token punctuation">)</span>    date_added <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        verbose_name_plural <span class="token operator">=</span> <span class="token string">'entries'</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"..."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性topic 是一个ForeignKey 实例，外键是一个数据库术语，引用了数据库中的另一条记录； </p><p>这些代码将每个条目关联到特定的主题。每个主题创建时，都给它分配了一个键（或ID）。 需要在两项数据之间建立联系时，Django使用与每项信息相关联的键。Django2.0版本外键要求添加on_delete参数。</p><p>在Entry 类中嵌套了Meta 类。Meta 存储用于管理模型的额外信息，设置一个特殊属性，让Django需要时使用Entries表示多个条目，没有这个类将使用Entrys来表示多个条目。</p></blockquote><p>没有看明白这些想说明什么，往后看应该就会知道了。接下来迁移数据库。生成新的迁移文件。</p><p>添加一个模型，就迁移一次数据库。过程：修改models.py，执行命令python manage.py makemigrations app_name ，再执行命令python manage.py migrate 。</p><h3 id="向管理网站注册Entry"><a href="#向管理网站注册Entry" class="headerlink" title="向管理网站注册Entry"></a>向管理网站注册Entry</h3><p>修改admin.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> learning_logs<span class="token punctuation">.</span>models <span class="token keyword">import</span> Topic<span class="token punctuation">,</span> Entryadmin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Topic<span class="token punctuation">)</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Entry<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Django-shell"><a href="#Django-shell" class="headerlink" title="Django shell"></a>Django shell</h3><pre><code>python manage.py shell</code></pre><blockquote><p>Cr+Z,回车退出</p></blockquote><p>用于测试和排除故障的理想之地</p><p><a href="https：//docs.djangoproject.com/en/7.8/topics/db/queries">更多关于如何查询数据的文档</a></p><h2 id="创建网页：学习笔记主页"><a href="#创建网页：学习笔记主页" class="headerlink" title="创建网页：学习笔记主页"></a>创建网页：学习笔记主页</h2><p>定义URL、编写视图和编写模板。</p><p>urls -&gt; views -&gt; html  添加网页步骤。</p><h3 id="映射URL"><a href="#映射URL" class="headerlink" title="映射URL"></a>映射URL</h3><blockquote><p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫<em>URL</em>（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址。</p></blockquote><p>实际的URL模式是一个对函数url的调用，这个函数接受三个实参。</p><pre class="line-numbers language-python"><code class="language-python">urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">#主页</span>    <span class="token comment" spellcheck="true">#第一个是正则表达式，r让Python将接下来的字符串视为原始字符串，引号正则表达式始于和终于何处</span>    <span class="token comment" spellcheck="true">#第二个实参指定了要调用的视图函数</span>    <span class="token comment" spellcheck="true">#第三个实参将这个URL模式的名称指定为index</span>    path<span class="token punctuation">(</span>r<span class="token string">''</span><span class="token punctuation">,</span>views<span class="token punctuation">.</span>index<span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式（regex），这是个什么鬼东西？相信后面还会有很多见面的机会……</p><blockquote><p>请求的URL与正则表达式匹配时调用视图函数</p></blockquote><h3 id="编写视图和模板"><a href="#编写视图和模板" class="headerlink" title="编写视图和模板"></a>编写视图和模板</h3><p>默认的urls.py包含在文件夹learning_log中， 现在需要在文件夹learning_logs中创建另一个urls.py文件：<strong>(注意关于 Django版本更新,书上的代码需做相应修改)</strong></p><p>打开项目主文件夹learning_log中的文件urls.py， 修改为<br> <strong>learning_log/urls.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> pathurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true"># 该模块定义了可在管理网站中请求的所有URL</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'learning_logs.urls'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'learning_logs'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 代码包含实参namespace ， 让我们能够将learning_logs 的URL同项目中的其他URL区分开来</span><span class="token punctuation">]</span><span class="token triple-quoted-string string">'''Django版本更新,书上的代码需做相应修改书中源代码：from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [    url(r'^admin/', include(admin.site.urls)),    url(r'', include('learning_logs.urls', namespace='learning_logs')),]应改为：from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    path('', include('learning_logs.urls', namespace='learning_logs')),]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的urls.py包含在文件夹learning_log中， 现在需要在文件夹learning_logs中创建另一个urls.py文件：(注意关于 Django版本更新,书上的代码需做相应修改)<br> <strong>learning_logs/urls.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""定义learning_logs的URL模式"""</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span>re_path<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> viewsapp_name<span class="token operator">=</span><span class="token string">'learning_logs'</span> <span class="token comment" spellcheck="true"># 不能少 ，否则runserver的时候就会出错</span><span class="token comment" spellcheck="true"># https://docs.djangoproject.com/en/2.2/ref/urls/#module-django.urls.conf</span>urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># 主页</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>index<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># Django将在文件views.py中查找函数index()</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># urls -> views -> html  添加网页步骤</span><span class="token triple-quoted-string string">'''Django版本更新,书上的代码需做相应修改书中源代码：from django.conf.urls import urlfrom . import viewsurlpatterns = [     # Home page.    url(r'^$', views.index, name='index'),    # Show all topics.    url(r'^topics/$', views.topics, name='topics'),    # Detail page for a single topic.    url(r'^topics/(?P&lt;topic_id>\d+)/$', views.topic, name='topic'),]应改为：from django.urls import pathfrom . import viewsapp_name='learning_logs'urlpatterns = [    # 主页    path('', views.index, name='index'),    # 显示所有的主题    path('topics/', views.topics, name='topics'),    # 特定主题的详细页面    path("topics/(?P&lt;topic_id>\d+)/", views.topic, name='topic'),]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建其他网页"><a href="#创建其他网页" class="headerlink" title="创建其他网页"></a>创建其他网页</h2><p>确定创建网页的流程后，可以扩充“学习笔记”项目了。</p><p>接下来要创建两个显示数据的页面。</p><p>所以先创建一个父模板，其他模板都将继承它。</p><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><h4 id="父模板"><a href="#父模板" class="headerlink" title="父模板"></a>父模板</h4><p>这个文件包含所有页面都有的元素； 其他的模板都继承base.html。 当前， 所有页面都包含的元素只有顶端的标题。 将在每个页面中包含这个模板， 因此将这个标题设置为到主页的链接：</p><pre class="line-numbers language-html"><code class="language-html">{% raw %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{% url <span class="token punctuation">'</span>learning_logs:index<span class="token punctuation">'</span> %}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Learning Log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% block content %}{% endblock content %}{% endraw %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板标签用(<strong>{ % % }</strong>)表示，生成一个URL。</p><p>在简单的HTML页面中，用锚标签定义链接：</p><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link_url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>link text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要修改项目中的URL，只需要修改urls.py中的URL模式。</p><h4 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h4><p>重新编写index.html,使其继承base.html。</p><h3 id="显示所有主题的页面"><a href="#显示所有主题的页面" class="headerlink" title="显示所有主题的页面"></a>显示所有主题的页面</h3><p>urls -&gt; views -&gt; html 添加网页步骤</p><p>下面来写一个显示全部主题的页面和一个显示特定主题中条目的页面。</p><pre><code>name &#39;request&#39; is not defined</code></pre><p><strong>views.py</strong></p><p>def topics(request) 写错成 def topics(reqest)了</p><h3 id="显示特定主题的页面"><a href="#显示特定主题的页面" class="headerlink" title="显示特定主题的页面"></a>显示特定主题的页面</h3><pre><code>Reverse for &#39;topic&#39; with arguments &#39;(&#39;&#39;,)&#39; not found. 1 pattern(s) tried: [&#39;topics/(?P&lt;topic_id&gt;\\d+)/$&#39;]</code></pre><p>return render(request, ‘learning_logs/topic.html’,context)</p><p>写成了</p><p>return render(request, ‘learning_logs/topics.html’,context)</p><pre class="line-numbers language-python"><code class="language-python">  <span class="token comment" spellcheck="true"># 特定主题的详细页面</span>  <span class="token comment" spellcheck="true"># 错误</span>  <span class="token comment" spellcheck="true"># path("topics/(?P&lt;topic_id>\d+)/", views.topic, name='topic'),</span>  <span class="token comment" spellcheck="true"># 正确</span>  re_path<span class="token punctuation">(</span>r<span class="token string">'^topics/(?P&lt;topic_id>\d+)/$'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'topic'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># ?P&lt;topic_id> 将匹配的值存储到topic_id 中； 而表达式\d+ 与包含在两个斜杆内的任何数字都匹配， 不管这个数字为多少位。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天首先学习了如何使用Django框架来创建Web程序应用，相信其他语言或者框架都是大同小异。</p><p>然后制定了项目规范，列出参考资料，最后在项目完成后需要鸣谢。</p><p>在虚拟环境中安装Django，创建一个项目，并且核实已经成功立项。</p><p>学习如何创建应用程序，以及如何定义表示应用程序数据的模型。</p><p>学习了数据库，以及在修改模型后让Django来迁移数据库。</p><p>创建了可管理网站的超级用户，并使用管理网站输入了一些数据。</p><p>探索Django Shell，它能够让我在终端对话处理项目数据，排除障碍。</p><p>学习了如何定义URL、创建网络视图以及编写网页的模板。最后还使用了模板继承，让各个模板简化，使修改网站变得更加容易。</p><p>遇上了劲敌“正则表达式”和“URL模式”，而且由于Django版本更新，url（）和path（）等函数更是变得乱七八糟，最后还是靠着上网看别人写的博客才K.O了它们。</p><hr><p>下一次，我们将创建对用户友好而直观的网页，让用户无需管理网站就可以使用“学习笔记”。</p><p>我们还将添加一个用户注册系统，让用户能够注册和创建自己的学习笔记。</p><blockquote><p>“让任意数量的用户都能与之交互，是Web应用程序的核心所在。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习</title>
      <link href="/2020/09/11/matlab-xue-xi/"/>
      <url>/2020/09/11/matlab-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一周信号处理实验课"><a href="#第一周信号处理实验课" class="headerlink" title="第一周信号处理实验课"></a>第一周信号处理实验课</h2><h3 id="上课学习"><a href="#上课学习" class="headerlink" title="上课学习"></a>上课学习</h3><p>学校东区计算机学院708机房没有安装好MATLAB，而且有些机位不能联网，上课简单介绍了一下MATLAB和课后作业。</p><p>下次上课带自己的电脑去。</p><hr><h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>一些MATLAB的简单操作，课程报告第二周后再提交。</p><p>回去在自己电脑上安装好MATLAB，学校网速太慢了，而且还不稳定，百度云限速。</p><p>MATLAB安装办法自己网上找。</p><hr><h2 id="MATLAB学习"><a href="#MATLAB学习" class="headerlink" title="MATLAB学习"></a>MATLAB学习</h2><p>百度云下了我两天两夜，终于下载安装好了。</p><p>明天开始学。</p><hr><p>学了半天，看了两节课，还是不会做作业……</p><hr><h2 id="第五周信号处理实验课"><a href="#第五周信号处理实验课" class="headerlink" title="第五周信号处理实验课"></a>第五周信号处理实验课</h2><h3 id="Command-conv"><a href="#Command-conv" class="headerlink" title="Command conv"></a><strong>Command conv</strong></h3><p><em>First rule</em>: The two signals (input and impulse response) should be defined in the <strong>same time interval</strong>. </p><p><em>Second rule</em>: When a signal consists of <strong>multiple parts</strong>, the time intervals in which each part is defined must <strong>not overlap</strong>.</p><p><em>Third rule</em>: The output of the conv command has to be <strong>multiplied with the time step</strong> used in the definition of the input and impulse response signals, in order to correctly compute the output of the system. </p><p><em>Fourth rule</em>: The output of the system is plotted in the <strong>double time interval</strong> of the one in which the input and impulse response signals are defined.</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%1st  way</span> t1<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">0.01</span><span class="token punctuation">;</span> t2<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> t3<span class="token operator">=</span><span class="token number">2.01</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span> t<span class="token operator">=</span><span class="token punctuation">[</span>t1 t2 t3<span class="token punctuation">]</span><span class="token punctuation">;</span> x1<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x2<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x3<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">=</span><span class="token punctuation">[</span>x1 x2 x3<span class="token punctuation">]</span><span class="token punctuation">;</span> h<span class="token operator">=</span>x<span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token function">conv</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">axis</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">6</span> <span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'y(t)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%the two signals</span> figure <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token number">0</span><span class="token operator">-</span>t<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'x(t)'</span><span class="token punctuation">,</span><span class="token string">'h(t-\tau)=h(0-\tau)'</span><span class="token punctuation">)</span> <span class="token function">ylim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> figure <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">-</span>t<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token function">ylim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'x(t)'</span><span class="token punctuation">,</span><span class="token string">'h(t-\tau)=h(2-\tau)'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%2nd  way</span> figure t<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> x<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> h<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token function">conv</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'y(t)'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Other-command"><a href="#Other-command" class="headerlink" title="Other command"></a>Other command</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">% syms</span><span class="token comment" spellcheck="true">% Create symbolic variables and functions</span><span class="token comment" spellcheck="true">% 符号变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>hold on是当前轴及图像保持而不被刷新，准备接受此后将绘制的图形，多图共存。即，启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。</p><p>hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即，关闭图形保持功能。</p><hr><p>area(x, y)：该函数以参数x和y绘制面积图。如果x和y为向量，则相当于函数plot(x, y)，并将0到y之间进行了填充。如果参数y为矩阵，则将y的每一列绘制面积图并进行累计求和。<br>area(y)：如果参数y为向量，则绘制面积图；如果y为矩阵则绘制每一列的面积图之和。</p><hr><p>simplify的调用格式为：simplify(S)，对表达式S进行化简</p><hr><h2 id="矩阵代数上机实验"><a href="#矩阵代数上机实验" class="headerlink" title="矩阵代数上机实验"></a>矩阵代数上机实验</h2><h3 id="第一周学习matlab"><a href="#第一周学习matlab" class="headerlink" title="第一周学习matlab"></a>第一周学习matlab</h3><p>MATLAB 使用撇号运算符 (<code>&#39;</code>) 执行复共轭转置，使用点撇号运算符 (<code>.&#39;</code>) 执行无共轭的转置。对于包含所有实数元素的矩阵，这两个运算符返回相同结果。</p><p>非共轭复数转置（其中每个元素的复数部分保留其符号）表示为 <code>z.&#39;</code>：</p><p><code>eye(n)</code> 返回 n×n 单位方阵</p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/inv.html" target="_blank" rel="noopener"><code>inv</code></a> 函数和表达式 <code>A^-1</code> 均可对矩阵求逆</p><p>有些矩阵<em>接近奇异矩阵</em>，虽然存在逆矩阵，但计算容易出现数值误差。<a href="https://ww2.mathworks.cn/help/matlab/ref/cond.html" target="_blank" rel="noopener"><code>cond</code></a> 函数计算<em>逆运算的条件数</em>，它指示矩阵求逆结果的精度。条件数的范围是从 <code>1</code>（数值稳定的矩阵）到 <code>Inf</code>（奇异矩阵）。</p><p>很少需要为某个矩阵构造显式逆矩阵。求解线性方程组 Ax = b 时，常常会误用 <code>inv</code>。从执行时间和数值精度方面而言，求解此方程的最佳方法是使用矩阵反斜杠运算符，即 <code>x = A\b</code>。有关详细信息，请参阅 <a href="https://ww2.mathworks.cn/help/matlab/ref/mldivide.html" target="_blank" rel="noopener"><code>mldivide</code></a>。</p><p><strong>Kronecker 张量积</strong></p><p>两个矩阵的 Kronecker 乘积 <code>kron(X,Y)</code> 为 <code>X</code> 的元素与 <code>Y</code> 的元素的所有可能乘积构成的较大矩阵。如果 <code>X</code> 为 m×n 且 <code>Y</code> 为 p×q，则 <code>kron(X,Y)</code> 为 mp×nq。元素以特定方式排列，呈现 <code>X</code> 的每个元素分别与整个矩阵 <code>Y</code> 相乘的结果。</p><p><strong>向量范数和矩阵范数</strong></p><p>向量 x 的 p-范数，</p><p>使用 <code>norm(x,p)</code> 进行计算。此运算是为 p &gt; 1 的任意值定义的，但最常见的 p 值为 1、2 和 ∞。默认值为 p = 2，这与<em>欧几里德长度</em>或<em>向量幅值</em>对应：</p><pre><code>v = [2 0 -1];[norm(v,1) norm(v) norm(v,inf)]ans =    3.0000    2.2361    2.0000</code></pre><p>矩阵 A 的 p-范数，</p><p>可以针对 p = 1、2 和 ∞ 通过 <code>norm(A,p)</code> 进行计算。同样，默认值也为 p = 2：</p><pre><code>A = pascal(3);[norm(A,1) norm(A) norm(A,inf)]ans =   10.0000    7.8730   10.0000</code></pre><p>如果要计算矩阵的每行或每列的范数，可以使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/vecnorm.html" target="_blank" rel="noopener"><code>vecnorm</code></a>：</p><pre><code>vecnorm(A)ans =    1.7321    3.7417    6.7823</code></pre><h3 id="第二周InverseMatrix"><a href="#第二周InverseMatrix" class="headerlink" title="第二周InverseMatrix"></a>第二周InverseMatrix</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> B<span class="token operator">=</span> <span class="token function">InverseMatrix</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> m<span class="token operator">~=</span>n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a square matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token function">rank</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a full rank matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span>C <span class="token operator">=</span> <span class="token punctuation">[</span>A <span class="token punctuation">;</span><span class="token function">eye</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%初等列变换代码</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n    <span class="token comment" spellcheck="true">%第一步对角线元素变1</span>    <span class="token comment" spellcheck="true">%第二步变A为单位矩阵</span>    d_1<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">/</span>d_1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n        <span class="token keyword">if</span> <span class="token number">i</span><span class="token operator">~=</span><span class="token number">j</span>            d_2<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">-</span>d_2<span class="token operator">.*</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span>B <span class="token operator">=</span> <span class="token function">C</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>忘了除数不为0</p></blockquote><h3 id="第三周InverseMatrixCramer"><a href="#第三周InverseMatrixCramer" class="headerlink" title="第三周InverseMatrixCramer"></a>第三周InverseMatrixCramer</h3><pre class="line-numbers language-matlab"><code class="language-matlab">n<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>A<span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>B<span class="token operator">=</span><span class="token function">InverseMatrixCramer</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token function">inv</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token keyword">function</span> B <span class="token operator">=</span> <span class="token function">InverseMatrixCramer</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> m<span class="token operator">~=</span>n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a square matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token function">rank</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a full rank matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span>B <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%Cramer's rule</span>C<span class="token operator">=</span><span class="token function">eye</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n    c<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    B_det<span class="token operator">=</span><span class="token function">det</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n        D<span class="token operator">=</span>A<span class="token punctuation">;</span>        <span class="token function">D</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span>c<span class="token punctuation">;</span>        B_det_j<span class="token operator">=</span><span class="token function">det</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token operator">=</span>B_det_j<span class="token operator">/</span>B_det<span class="token punctuation">;</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span>b<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span>B<span class="token operator">=</span>B<span class="token operator">'</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第四周SloveEquationKron"><a href="#第四周SloveEquationKron" class="headerlink" title="第四周SloveEquationKron"></a>第四周SloveEquationKron</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%% 可观察四个变量不同取值的变化</span>m<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> p<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> q<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>A <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> X<span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>B <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> D <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>X <span class="token operator">=</span> <span class="token function">SloveEquationKron</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%%% 验证程序是否正确</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token function">kron</span><span class="token punctuation">(</span>B<span class="token operator">'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span><span class="token operator">\</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'fro'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%正确输出0</span><span class="token function">norm</span><span class="token punctuation">(</span>A<span class="token operator">*</span>X<span class="token operator">*</span>B<span class="token operator">-</span>D<span class="token punctuation">,</span><span class="token string">'fro'</span><span class="token punctuation">)</span><span class="token keyword">function</span> X <span class="token operator">=</span> <span class="token function">SloveEquationKron</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>q<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%K=kron(B',A)</span>B_<span class="token operator">=</span>B<span class="token operator">'</span><span class="token punctuation">;</span><span class="token punctuation">[</span>ma<span class="token punctuation">,</span>na<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>B_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>mb<span class="token punctuation">,</span>nb<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>ia<span class="token punctuation">,</span>ib<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">meshgrid</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>ma<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>mb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>ja<span class="token punctuation">,</span>jb<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">meshgrid</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>na<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span>K <span class="token operator">=</span> <span class="token function">B_</span><span class="token punctuation">(</span>ia<span class="token punctuation">,</span>ja<span class="token punctuation">)</span><span class="token operator">.*</span><span class="token function">A</span><span class="token punctuation">(</span>ib<span class="token punctuation">,</span>jb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%Solve equation via kron</span>C<span class="token operator">=</span>K<span class="token punctuation">;</span>XX <span class="token operator">=</span> C<span class="token operator">\</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>X <span class="token operator">=</span> <span class="token function">reshape</span><span class="token punctuation">(</span>XX<span class="token punctuation">,</span><span class="token punctuation">[</span>p<span class="token punctuation">,</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/u010555688/article/details/37811141" target="_blank" rel="noopener">Matlab学习笔记 kron函数</a></p><h3 id="第五周SVD-my"><a href="#第五周SVD-my" class="headerlink" title="第五周SVD_my"></a>第五周SVD_my</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> <span class="token punctuation">[</span>U<span class="token punctuation">,</span>D<span class="token punctuation">,</span>V<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SVD_my</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%[m,n] = size(A);</span><span class="token comment" spellcheck="true">%U=rand(m,m);</span><span class="token comment" spellcheck="true">%V=rand(n,n);</span><span class="token comment" spellcheck="true">%D=A;</span>T1 <span class="token operator">=</span> <span class="token function">null</span><span class="token punctuation">(</span>A<span class="token operator">'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%计算A共轭转置零空间的标准正交基</span>B<span class="token operator">=</span>A<span class="token operator">'</span><span class="token operator">*</span>A<span class="token punctuation">;</span><span class="token punctuation">[</span>V<span class="token punctuation">,</span>D<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">eig</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%求特征值</span><span class="token punctuation">[</span>m0<span class="token punctuation">,</span>n0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>m0        <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n0            <span class="token keyword">if</span> <span class="token number">i</span><span class="token operator">+</span><span class="token number">j</span><span class="token operator">==</span>m0<span class="token operator">+</span><span class="token number">1</span>                <span class="token function">E</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">E</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span><span class="token keyword">end</span>V<span class="token operator">=</span>V<span class="token operator">*</span>E<span class="token punctuation">;</span>D<span class="token operator">=</span>E<span class="token operator">*</span>D<span class="token operator">*</span>E<span class="token punctuation">;</span>%V1<span class="token operator">=</span>V<span class="token punctuation">;</span>T<span class="token operator">=</span><span class="token function">diag</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>T0<span class="token operator">=</span>T<span class="token punctuation">;</span>D0<span class="token operator">=</span>D<span class="token punctuation">;</span><span class="token punctuation">[</span>m1<span class="token punctuation">,</span>n1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span>m1<span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span>        <span class="token keyword">if</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">T0</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&lt;</span> <span class="token number">10</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span>                <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">V1</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">D0</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span><span class="token keyword">end</span>S<span class="token operator">=</span><span class="token function">sqrt</span><span class="token punctuation">(</span>D0<span class="token punctuation">)</span><span class="token punctuation">;</span>D1<span class="token operator">=</span><span class="token function">diag</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>U<span class="token operator">=</span>A<span class="token operator">*</span>V1<span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>D1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>md<span class="token punctuation">,</span>nd<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>z<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span>m<span class="token operator">-</span>md<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>D<span class="token operator">=</span><span class="token punctuation">[</span>S<span class="token punctuation">;</span>z<span class="token punctuation">]</span><span class="token punctuation">;</span>U<span class="token operator">=</span><span class="token punctuation">[</span>U T1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第七周满秩分解求广义逆"><a href="#第七周满秩分解求广义逆" class="headerlink" title="第七周满秩分解求广义逆"></a>第七周满秩分解求广义逆</h3><pre class="line-numbers language-matlab"><code class="language-matlab">close allclear all<span class="token comment" spellcheck="true">%m=10;   n=8;</span><span class="token comment" spellcheck="true">%A = rand(m,n);</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>A_MP<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fullrank_my</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%%% 验证程序是否正确</span><span class="token function">norm</span><span class="token punctuation">(</span>A_MP<span class="token operator">-</span><span class="token function">pinv</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'fro'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%%正确为接近于0</span><span class="token comment" spellcheck="true">%%</span><span class="token keyword">function</span> <span class="token punctuation">[</span>A_MP<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fullrank_my</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>A1 <span class="token operator">=</span> <span class="token function">rref</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%将矩阵A化成行最简形式保存在A1中</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%获取矩阵A的大小：m行n列</span>B0<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%生成一个空向量</span>C0<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%生成一个空向量</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>m    <span class="token comment" spellcheck="true">%依次扫描矩阵m行</span>   flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n    <span class="token comment" spellcheck="true">%依次扫描矩阵n列</span>       <span class="token keyword">if</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span>    <span class="token comment" spellcheck="true">%若A1(i, j)等于1      </span>           <span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">i</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">%固定j列，扫描此列的第1行到i-1行元素</span>               <span class="token keyword">if</span> <span class="token function">A1</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">~=</span><span class="token number">0</span>    <span class="token comment" spellcheck="true">%判断是否全为0</span>                   flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%若不全为0，则将flag置为0（说明此列不是单位矩阵的列）</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token keyword">end</span>           <span class="token keyword">end</span>           <span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">i</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>m        <span class="token comment" spellcheck="true">%固定j列，扫描此列的第i+1行到m行（即最后一行）元素</span>               <span class="token keyword">if</span> <span class="token function">A1</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">~=</span><span class="token number">0</span>    <span class="token comment" spellcheck="true">%判断是否全为0</span>                   flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%若不全为0，则将flag置为0（说明此列不是单位矩阵的列）</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token keyword">end</span>           <span class="token keyword">end</span>           <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token number">1</span>         <span class="token comment" spellcheck="true">%若flag为1（不为0），则说明此列是【矩阵的行最简形式矩阵】的单位矩阵的列</span>               B0<span class="token operator">=</span><span class="token punctuation">[</span>B0<span class="token punctuation">,</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%将矩阵A的j列加到B0列向量之后</span>               C0<span class="token operator">=</span><span class="token punctuation">[</span>C0<span class="token punctuation">;</span><span class="token function">A1</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%将矩阵A1的i行加到C0行向量之后，</span>           <span class="token keyword">end</span>       <span class="token keyword">end</span>         <span class="token keyword">end</span><span class="token keyword">end</span><span class="token punctuation">[</span>m1<span class="token punctuation">,</span>n1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>B0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%获取矩阵B0的大小：m1行n1列</span><span class="token punctuation">[</span>m2<span class="token punctuation">,</span>n2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>C0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%获取矩阵C0的大小：m2行n2列</span>B<span class="token operator">=</span><span class="token function">B0</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">%将矩阵B0的第1列到最后一列赋值给矩阵B</span>C<span class="token operator">=</span><span class="token function">C0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>m2<span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">%将矩阵C0的第1行到最后一行赋值给矩阵C</span>L<span class="token operator">=</span>B<span class="token punctuation">;</span>R<span class="token operator">=</span>C<span class="token punctuation">;</span><span class="token comment" spellcheck="true">%A_MP=R'*(R*R')^(-1)*(L'*L)^(-1)*L';</span>A_MP<span class="token operator">=</span>R<span class="token operator">'</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>R<span class="token operator">*</span>R<span class="token operator">'</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>L<span class="token operator">'</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">*</span>L<span class="token operator">'</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h3><p><a href="https://www.bilibili.com/video/BV1GJ41137UH" target="_blank" rel="noopener">MATLAB教程_台大郭彦甫（14课=15h）</a></p><p><a href="https://zhuanlan.zhihu.com/p/77669451?utm_source=qq" target="_blank" rel="noopener">matlab入门图文教程</a></p><p><a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">matlab帮助文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> SHU </tag>
            
            <tag> Signal Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛启航</title>
      <link href="/2020/09/11/mei-sai-qi-hang/"/>
      <url>/2020/09/11/mei-sai-qi-hang/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="美国大学生数学建模竞赛（MCM-ICM）"><a href="#美国大学生数学建模竞赛（MCM-ICM）" class="headerlink" title="美国大学生数学建模竞赛（MCM/ICM）"></a>美国大学生数学建模竞赛（MCM/ICM）</h3><p>美国大学生数学建模竞赛（MCM/ICM）由美国数学及其应用联合会主办，是唯一的国际性数学建模竞赛，也是世界范围内最具影响力的数学建模竞赛。赛题内容涉及经济、管理、环境、资源、生态、医学、安全、等众多领域。竞赛要求三人（本科生）为一组，在四天时间内，就指定的问题完成从建立模型、求解、验证到论文撰写的全部工作，体现了参赛选手研究问题、解决方案的能力及团队合作精神。 为现今各类<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B" target="_blank" rel="noopener">数学建模竞赛</a>之鼻祖。</p><hr><h3 id="报名须知"><a href="#报名须知" class="headerlink" title="报名须知"></a>报名须知</h3><p>组队要求：三人（本科生）为一组（模型搭建，模型实现，论文写作）</p><p>比赛时间：2021年•2月4日——2月8日，在四天时间内，一般都是早晨到早晨，要安排好比赛的时间。比赛以美国东部时间为准，其比北京时间晚了大约13个小时。</p><p>竞赛开始时间：2021年2月4日 下午5点（美国东部时间）（北京时间2月5日早上6点）</p><p>竞赛截止：2021年2月8日 下午8点（美国东部时间）（北京时间2月9日早上9点）</p><p>论文提交截止时间：2021年2月8日 下午9点（美国东部时间）（北京时间2月9日早上10点）</p><p>竞赛结果：2021年4月30日之前</p><p>比赛题目：一共分为6种题型。分别为：连续型、离散型、大数据、运筹学/网络科学、环境科学、政策。</p><p>奖项设置及获奖比例：特等奖（Outstanding Winner） 0.14%，特等奖提名奖（Finalist） 0.17%，一等奖（Meritorious Winner）7%左右，二等奖（Honorable Mentioned） 15%左右，成功参与奖也叫三等奖（Successful Participant）</p><hr><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><h3 id="信息入口"><a href="#信息入口" class="headerlink" title="信息入口"></a>信息入口</h3><p><a href="https://www.zhihu.com/question/19714813" target="_blank" rel="noopener">知乎：如何入门参与数学建模？</a></p><hr><h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><p>写作软件：latex</p><p>编程软件：Matlab</p><p>公式编辑器：Mathtype</p><p>画图：Visio，亿图</p><hr><h3 id="数模学习"><a href="#数模学习" class="headerlink" title="数模学习"></a>数模学习</h3><p>书籍推荐：《数学建模》 姜启源 ，《数学建模算法与应用》司守奎</p><hr><h3 id="其他准备"><a href="#其他准备" class="headerlink" title="其他准备"></a>其他准备</h3><p>论文写作：往届获奖论文，论文模板等</p><p>经典的算法：待补充</p><hr><h3 id="学术搜索引擎"><a href="#学术搜索引擎" class="headerlink" title="学术搜索引擎"></a>学术搜索引擎</h3><p>1、<a href="https://link.zhihu.com/?target=http%3A//scholar.google.com/" target="_blank" rel="noopener">http://scholar.google.com/</a> </p><p>2、<a href="https://link.zhihu.com/?target=http%3A//qns.cc/" target="_blank" rel="noopener">http://qns.cc/</a> </p><p>后起之秀，科研人员的良好助手，上此网站的90%是从事科研的学生与老师。其词典搜索集成了目前市面上最好的在线英汉写作及科研词典，用此搜索引擎写作英文论文相当方便；其文献搜索集成了目前最优秀的数据库。</p><p>3、<a href="https://link.zhihu.com/?target=http%3A//www.scirus.com" target="_blank" rel="noopener">http://www.scirus.com</a> </p><p>Scirus是目前互联网上最全面、综合性最强的科技文献搜索引擎之一，由Elsevier科学出版社开发，用于搜索期刊和专利，效果很不错！Scirus覆盖的学科范围包括：农业与生物学，天文学，生物科学，化学与化工，计算机科学，地球与行星科学，经济、金融与管理科学，工程、能源与技术，环境科学，语言学，法学，生命科学，材料科学，数学，医学 ，神经系统科学，药理学，物理学，心理学，社会与行为科学，社会学等。</p><p>4、sci-hub</p><h3 id="关于Latex"><a href="#关于Latex" class="headerlink" title="关于Latex"></a>关于Latex</h3><p><a href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener">一份其实很短的 LaTeX 入门文档</a></p><p>在文档类 <code>article</code>/<code>ctexart</code> 中，定义了五个控制序列来调整行文组织结构。他们分别是</p><ul><li><code>\section{·}</code></li><li><code>\subsection{·}</code></li><li><code>\subsubsection{·}</code></li><li><code>\paragraph{·}</code></li><li><code>\subparagraph{·}</code></li></ul><pre class="line-numbers language-tex"><code class="language-tex">\documentclass{article}% 这里是导言区% 中英文混排% \documentclass[UTF8]{ctexart}% 数学模式\usepackage{amsmath}\begin{document}% 行内式Einstein 's $E=mc^2$.% 行间式\[ E=mc^2. \]% 根式与分式$\sqrt{x}$, $\frac{1}{2}$.\[ \sqrt{x}, \]\[ \frac{1}{2}. \]% 上下标，下标是_\[ z = r\cdot e^{2\pi i}. \]% 运算符\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;\geq\; \leq\; \neq\; \approx \; \equiv \]% 大型运算符$ \sum_{i=1}^n i\quad \prod_{i=1}^n $$ \sum\limits _{i=1}^n i\quad \prod\limits _{i=1}^n $\[ \lim_{x\to0}x^2 \quad \int_a^b x^2 dx \]\[ \lim\nolimits _{x\to0}x^2\quad \int\nolimits_a^b x^2 dx \]% 多重积分\[ \iint\quad \iiint\quad \iiiint\quad \idotsint \]% 定界符（括号等）\lvert\rvert\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]\[ \Biggl \{\biggl \{\Bigl \{\bigl \{\{x\}\bigr \}\Bigr \}\biggr \}\Biggr\} \]\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]% 省略号\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad\vdots\quad \ddots \]% 矩阵\[ \begin{pmatrix} a&b\\c&d \end{pmatrix} \quad\begin{bmatrix} a&b\\c&d \end{bmatrix} \quad\begin{Bmatrix} a&b\\c&d \end{Bmatrix} \quad\begin{vmatrix} a&b\\c&d \end{vmatrix} \quad\begin{Vmatrix} a&b\\c&d \end{Vmatrix} \]Marry has a little matrix $ ( \begin{smallmatrix} a&b\\c&d \end{smallmatrix} ) $.% 多行公式% 如果不需要编号，可以使用 multline* 环境代替\begin{multline}x = a+b+c+{} \\d+e+f+g\end{multline}% 对齐\[\begin{aligned}x ={}& a+b+c+{} \\&d+e+f+g\end{aligned}\]% 公式组% 无需对齐的公式组可以使用 gather 环境% 需要对齐的公式组可以使用 align 环境% 如果不需要编号可以使用带星花的版本\begin{gather}a = b+c+d \\x = y+z\end{gather}\begin{align}a &= b+c+d \\x &= y+z\end{align}% 分段函数\[ y= \begin{cases}-x,\quad x\leq 0 \\x,\quad x>0\end{cases} \]% 图片%\documentclass{article}%\usepackage{graphicx}%\begin{document}%\includegraphics{a.jpg}% \includegraphics[width = .8\textwidth]{a.jpg}% 控制大小%\end{document}% 表格\begin{tabular}{|l|c|r|} \hlinesys& release& editor\\ \hlineWindows & MikTeX & TexMakerX \\ \hlineUnix/Linux & teTeX & Kile \\ \hlineMac OS & MacTeX & TeXShop \\ \hlineuniverse& TeX Live & TeXworks \\ \hline\end{tabular}% 浮动体\begin{figure}[htbp]% [htbp]用来指定插图的理想位置，% 这几个字母分别代表 here, top, bottom, float page\centering% \centering 用来使插图居中% \includegraphics{a.jpg}\caption{the truth}% \caption 命令设置插图标题\label{fig:myphoto}% 注意 \label 应该放在标题命令之后\end{figure}\end{document}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h2><h3 id="2020美赛C题（9-25）"><a href="#2020美赛C题（9-25）" class="headerlink" title="2020美赛C题（9.25）"></a>2020美赛C题（9.25）</h3><hr><p><a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">麻省理工公开课：线性代数</a></p><p>第一次刷题试水，需要补一下数学，再补一下排版和画图</p><hr><h3 id="2020美赛D题（12-16）"><a href="#2020美赛D题（12-16）" class="headerlink" title="2020美赛D题（12.16）"></a>2020美赛D题（12.16）</h3><h4 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h4><p><a href="https://www.bilibili.com/video/BV1j7411W7FP/?spm_id_from=trigger_reload" target="_blank" rel="noopener">美赛latex排版b站视频</a></p><p><a href="https://liam.page/2016/01/27/how-to-use-mcmthesis/" target="_blank" rel="noopener">如何使用美赛模板 mcmthesis</a></p><p><a href="https://github.com/latexstudio-org/mcmthesis" target="_blank" rel="noopener">模板下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> 美赛 </tag>
            
            <tag> 数模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机书单</title>
      <link href="/2020/09/02/ji-suan-ji-shu-dan/"/>
      <url>/2020/09/02/ji-suan-ji-shu-dan/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>《现代操作系统》Andrew S.Tanenbaum &amp; Herbert Bos   </p><p>​    </p><p>《鸟哥的Linux私房菜》</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>《计算机网络》James F. Kurose &amp; Keith W.Ross</p><p>《图解TCP\IP》</p><p>《图解HTTP》</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>《大话数据结构》</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>《Python从入门到实践》</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>《Java核心技术卷Ⅰ》</p><p>《深入理解Java虚拟机》</p><h4 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h4><p>《Go语言实战》</p><p>​      </p><h4 id="程序员人生"><a href="#程序员人生" class="headerlink" title="程序员人生"></a>程序员人生</h4><p>《代码整洁之道》</p><p>​       </p><p>吴军老师的书</p><p>《浪潮之巅》</p><p>​     </p><p>《数学之美》</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《数据挖掘——实用机器学习技术》</p><p>《机器学习实战》</p><p>《机器学习》（西瓜书）周志华</p>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 书 </tag>
            
            <tag> 待更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从1开始写Blog</title>
      <link href="/2020/08/31/cong-1-kai-shi-xie-blog/"/>
      <url>/2020/08/31/cong-1-kai-shi-xie-blog/</url>
      
        <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrENiK9j7bR9qXYA11EY4TsPRZJqdImIwU1LgreNkyYn04*MFe2ZNrTrthPykK2B.ahOc0P5g1Gp1rjyBsYJnDKjU!/r" alt></p><h2 id="从1开始写Blog"><a href="#从1开始写Blog" class="headerlink" title="从1开始写Blog"></a>从1开始写Blog</h2><h3 id="写给自己"><a href="#写给自己" class="headerlink" title="写给自己"></a>写给自己</h3><h4 id="博客是什么"><a href="#博客是什么" class="headerlink" title="博客是什么"></a>博客是什么</h4><p>参见我的<a href="https://henry-avery.github.io/friends/" target="_blank" rel="noopener">友情链接</a>里的博客以及其他知名博客</p><p><a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="https://coolshell.cn/" target="_blank" rel="noopener">陈皓&amp;酷壳</a></p><p><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a></p><p><a href="https://lepture.com/" target="_blank" rel="noopener">LEPTURE</a></p><p><a href="http://www.yinwang.org/" target="_blank" rel="noopener">王垠</a></p><h4 id="要怎么写博客"><a href="#要怎么写博客" class="headerlink" title="要怎么写博客"></a>要怎么写博客</h4><p><a href="https://blog.huihut.com/2017/01/25/MarkdownTutorial/#urllink" target="_blank" rel="noopener">Markdown 简易入门教程</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰写的Git教程</a></p><p>建议window系统先参考教程安装好Git bash</p><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a></p><h4 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h4><p>可以看看《暗时间》作者刘未鹏写的这篇博客文章</p><p><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）写博客</a></p><p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrEElfJNrKjuyWae8U.db2Cr12qAfm0jJPNi8jwmhLjXfrKEBE9HoyGNcJKjczdR*jtuu3yOjfUe79vJswISqmipY!/r" alt="黄金圈法则"></p><h3 id="写给同类"><a href="#写给同类" class="headerlink" title="写给同类"></a>写给同类</h3><h4 id="为什么写博客"><a href="#为什么写博客" class="headerlink" title="为什么写博客"></a>为什么写博客</h4><p>种下一棵树最好的时间是十年以前，其次是现在。</p><p>阅读和学习是输入，写作和实践是输出，都是我们了解这个世界的途径。</p><p>阅读和写作、策划组织都是一个人的心智体现。不断阅读就需要不断主动思考，将思考的过程和结果写出来，不仅能够提高自己的心智，提高组织策划的能力，也能为他人提供参考。</p><p>为了不断超越自己。</p><p>Challenge the status quo</p><h4 id="怎么写博客"><a href="#怎么写博客" class="headerlink" title="怎么写博客"></a>怎么写博客</h4><p>搭建好博客，写下去。每周至少写完一篇发到博客上。所以平时需要多写，每天都至少要写三十分钟。</p><h4 id="博客写什么"><a href="#博客写什么" class="headerlink" title="博客写什么"></a>博客写什么</h4><p>可能写一写日常生活里值得思考的小事，或者是技术上解决的问题和信息资源的整理。</p><hr><h2 id="各种报错"><a href="#各种报错" class="headerlink" title="各种报错"></a>各种报错</h2><p><strong>hexo s</strong>报错</p><pre><code>FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error:  [Line 78, Column 29] expected variable end</code></pre><p>解决办法：<br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">官网描述</a></p><p>翻译过来就是： 转义内容 Hexo使用Nunjucks渲染帖子（较早的版本使用Swig，它们具有相似的语法）。</p><p>用<code>{ { } }</code>或<code>{ ％ ％ }</code>包装的内容将被解析，并可能导致问题。</p><p>您可以使用原始标签插件包装敏感内容。<br>找到正文里面<code>{ {</code>、<code>} }</code>、<code>{ %</code>、<code>% }</code>这样的语句，作如下修改：</p><pre><code>{% raw %}//敏感内容前加上这个Hello {{ sensitive }}l/敏感内容被包装在中间{% endraw %}    //敏感内容后加上这个</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> 在更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一复盘总结</title>
      <link href="/2020/08/25/da-yi-fu-pan-zong-jie/"/>
      <url>/2020/08/25/da-yi-fu-pan-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1456606483&auto=1&height=66"></iframe></div><p><img src="https://i.loli.net/2020/08/23/iPFjVSvNz416AQn.jpg" alt></p><hr><blockquote><p>在大二开学之前把大一复盘总结完成，拖了两个礼拜了还没写,可能拖延症又犯了。</p></blockquote><h1 id="我的大一"><a href="#我的大一" class="headerlink" title="我的大一"></a>我的大一</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrEDmlLxX5p3JcMGVqq00maXeZj1EL0BlNZ39Ez98p56TknxscaiaPIitxGWIdZhgwdciiCH25KkO0BNthc.zunsQ!/r" alt="从这里开始，十八岁收到的生日礼物是大学录取通知书"></p><p>​    </p><h3 id="2019上半年"><a href="#2019上半年" class="headerlink" title="2019上半年"></a>2019上半年</h3><p>8.27  <strong>初见上大</strong></p><p>9月-11月  <strong>秋季学期</strong></p><p>11月-12月  <strong>冬季学期前六周</strong></p><p>​    </p><p>小插曲  <strong>COVID-19</strong></p><p>​    </p><hr><p>​    </p><h3 id="2020上半年"><a href="#2020上半年" class="headerlink" title="2020上半年"></a>2020上半年</h3><p>1月  <strong>寒假生活</strong></p><p>2月  <strong>疫情影响居家网课</strong></p><p>3月-7月  <strong>冬季学期春季学期网课考试分流</strong></p><p>8月  <strong>计算机实训+十天暑假</strong></p><p>8.27 <strong>返校换寝</strong></p><blockquote><p>再见了，大一！</p></blockquote><hr><h2 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h2><p>到了大学的第三周之后开始<strong>早睡早起</strong>，一开始是因为看了张萌姐姐写的《人生效率手册》，富兰克林自传里的时间规划，后来又认识了一个知乎大V王振宇，我也切身体会到了每天早上多出来三个小时自由时间到带来的好处，喜欢上了每天早起写作的感觉，就一直坚持了下来，慢慢也就形成了习惯。</p><p><strong>阅读，写书评</strong>。因为小木屋的返现活动要打卡80天，所以借此机会认真写了一些书评，不过大多数都还是很水的。但是养成了借书看书的习惯。每个月去图书馆借一次书，制定了500本书的大学四年阅读计划。按照《如何阅读一本书》训练自己的阅读能力。商业科技政治文学历史哲学均有涉猎，尤其喜欢各种传记。</p><p><strong>写作，运营公众号</strong>。通过公众号了解互联网运营中的各种策略和技巧，以管窥豹。对于流量有了更清晰的认识，不止是知乎和b站、抖音短视频等等。理解更重要的是内容创作，从每周一更到后来每月一更，不同的阶段有不同的感悟。开始用心留意之前生活中可能并不在意的东西。写作反过来又推动阅读的需求，形成欧皇飞轮，良性循环反馈。</p><p><strong>做计划，复盘总结</strong>。不停尝试新事物，把想做的事情和没做完的事情列出来，在下一个月一项一项去完成。总结自己一个月里值得记录的事情。不断更新，有了自己的个人宪法和复盘系统。每周的日程规划也帮助我很好地处理各种看似不可能完成的任务。形成了自己完成计划的个人习惯。</p><p><strong>时间管理</strong>，其实就是做计划的一部分。主要是花在手机屏幕上的时间太多，使用番茄TODO和手机应用限时减少手机使用时间。不打游戏，不把时间花在没有意义的事情上。</p><p><strong>跑步。</strong>之前是想以参加一次半马为目标，中秋节晚上跑了人生的第一个10公里，那天在宿舍看完《搏击俱乐部》，绕着学校跑了三四圈，一个小时，喜欢上了多巴胺刺激大脑的这种感觉，每个月都会跑个三四十公里，可能还是跑量不够，也没控制配速，所以速度提升不大。后来开始健身，更多了解相关知识，改变了把长跑当做训练目标的想法，制定了自己的健身计划，以提升力量为主。居家半年买了一对哑铃自己在家训练，由于器材有限主要锻炼的是前臂。效果没有达到想象中的好。但是运动成了很好的放松方式，大大提升了我的生活质量。</p><p><strong>写日记。</strong>其实也没什么好记的，有时候就是写一句话，感触深的时候写一大段直抒胸臆，晚上睡觉做的梦记录下来留作写作素材。虽然想要借此训练写作，但实施起来还是有困难，原因在于没有认真考虑过把写日记当成一项任务安排进每天的日程里。目前没有在日记里写过多少有价值的东西，最多是我自己的一些片段回忆。</p><hr><h2 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h2><p>在更……</p><hr><h2 id="信息篇"><a href="#信息篇" class="headerlink" title="信息篇"></a>信息篇</h2><h3 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h3><blockquote><p>​    “信息管理就是拓宽信道，即打开新的信息入口，接受新的信息；然后整合你收集到的信息，即对无用的信息进行降噪，并且对有用的信息进行排序，提高查找信息的效率。”</p></blockquote><hr><h3 id="信息入口"><a href="#信息入口" class="headerlink" title="信息入口"></a>信息入口</h3><h4 id="我的书单"><a href="#我的书单" class="headerlink" title="我的书单"></a>我的书单</h4><ul><li>计算机书单</li><li>待更……</li></ul><p>​    </p><h4 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h4><ul><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1ex411u7GV" target="_blank" rel="noopener">CS183B@Stanford/YC创业课</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">【英字】MIT公开课 概率论</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1Kt411h7Ep" target="_blank" rel="noopener">【公开课】耶鲁大学：博弈论（中英双语字幕）</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1as411o7tU" target="_blank" rel="noopener">國立清華大學開放課：科幻概論——主講：鄭運鴻</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1gE411M7Eg" target="_blank" rel="noopener">【吴恩达亲授】适用于所有人的人工智能课程（中字）</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1JE411g7XF" target="_blank" rel="noopener">李宏毅2020机器学习深度学习(完整版)国语</a></li></ul><h4 id="手机app"><a href="#手机app" class="headerlink" title="手机app"></a>手机app</h4><ul><li>豆瓣、知乎</li><li>微信读书、京东读书（校园版）、藏书馆</li><li>得到、喜马拉雅、每日英语听力</li><li>一席、TED、b站</li><li>微信公众号</li></ul><h4 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h4><ul><li>收藏网址书签<ul><li><a href="https://b-ok.cc/" target="_blank" rel="noopener">英文原版电子书1</a></li><li><a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">英文原版电子书2</a></li><li><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学MOOC</a></li><li><a href="https://open.163.com/" target="_blank" rel="noopener">网易公开课</a></li><li>优质博客</li></ul></li></ul><h4 id="社交通讯APP"><a href="#社交通讯APP" class="headerlink" title="社交通讯APP"></a>社交通讯APP</h4><ul><li>Tim</li><li>微信</li><li>QQ    </li></ul><hr><h2 id="启航篇"><a href="#启航篇" class="headerlink" title="启航篇"></a>启航篇</h2><p>待更……</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
