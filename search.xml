<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021一月复盘</title>
      <link href="/2021/01/30/yi-yue/"/>
      <url>/2021/01/30/yi-yue/</url>
      
        <content type="html"><![CDATA[<h1 id="一月复盘（1-30）"><a href="#一月复盘（1-30）" class="headerlink" title="一月复盘（1.30）"></a>一月复盘（1.30）</h1><h2 id="本月关键词：原点"><a href="#本月关键词：原点" class="headerlink" title="本月关键词：原点"></a>本月关键词：原点</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“物来顺应，未来不迎，当事不杂，过往不恋。”</strong></p><p><strong>——曾国藩</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>上课</strong></p><p>数据结构：这次小组作业真是太让人不放心了</p><p>机组：王道的书真好用，上课听不懂多刷题就完事了，有空刷刷csapp就当课外书看</p><p>概率论：刷题真有意思</p><p>离散数学：希望多学一点</p><p><strong>学习</strong></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113446714" target="_blank" rel="noopener">SHU机组实验</a></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113407044" target="_blank" rel="noopener">吴恩达机器学习</a></p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>30km，2021年运动副本预热，放假前后没有怎么运动，寒假里过年要加强锻炼了。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p>开了巨多篇博客的坑，等着2021去填，比如2021新年计划</p><p><a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于一瓶水</a></p><p><a href="https://henryavery.cn/2021/01/01/ren-ji-gong-sheng/">《人机共生》</a></p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>还真是不如拿着钱买一台新电脑，买点新软件也行，比如MarginNote3</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>研究关于社交网络的推荐算法，从量变引起质变，但我对线上社交的看法仍旧没有改变，除了扩大我们的社交圈以外没有更多的实际意义，人类的基因只允许我们和148个人有交集，因此对交往的人更应该慎重。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>早睡早起，偶尔出现打卡不起的情况，特别是回家以后，每天睡眠时长长达8个多小时，放松一周就差不多了，接下来的一年都要按照十点半早睡，五点早起的作息来完成早睡早起的flag。</p><p>每天起床做俯卧撑，微习惯。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>2021年的新年计划</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事</p><p>第二件事</p><p>第三件事</p><p>第四件事</p><p>第五件事</p><p>第六件事</p><p>第七件事</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达的机器学习课程笔记</title>
      <link href="/2021/01/25/ml/"/>
      <url>/2021/01/25/ml/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习"><a href="#吴恩达机器学习" class="headerlink" title="吴恩达机器学习"></a>吴恩达机器学习</h1><blockquote><p><strong>几乎每一个和我讨论过的人都同意，人生的最糟糕时期是在11岁到14岁。——《黑客与画家》</strong></p></blockquote><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>课程</p><p><a href="https://www.bilibili.com/video/BV164411b7dx?p=1" target="_blank" rel="noopener">b站[中英字幕]吴恩达机器学习系列课程</a></p><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习</a></p><p><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera深度学习</a></p><blockquote><p>主成分数据选择那里有一节课没有字幕，建议移步Coursera</p></blockquote><p>黄海广笔记</p><p><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener"><strong>Coursera深度学习教程中文笔记</strong></a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>斯坦福大学2014（吴恩达）机器学习教程中文笔记</strong></a></p><h1 id="第0天"><a href="#第0天" class="headerlink" title="第0天"></a>第0天</h1><p>搜集信息，注册Coursera，申请奖学金，安排学习计划。（2h）</p><h2 id="引言-Introduction"><a href="#引言-Introduction" class="headerlink" title="引言(Introduction)"></a>引言(Introduction)</h2><h3 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1.1 欢迎"></a>1.1 欢迎</h3><p>参考视频: 1 - 1 - Welcome (7 min).mkv</p><p>第一个视频主要讲了什么是机器学习，机器学习能做些什么事情。</p><h3 id="1-2-机器学习是什么？"><a href="#1-2-机器学习是什么？" class="headerlink" title="1.2 机器学习是什么？"></a>1.2 机器学习是什么？</h3><p>第一个机器学习的定义来自于<strong>Arthur Samuel</strong>。他定义机器学习为，在进行特定编程的情况下，给予计算机学习能力的领域。<strong>Samuel</strong>的定义可以回溯到50年代，他编写了一个西洋棋程序。</p><p>另一个年代近一点的定义，由<strong>Tom Mitchell</strong>提出，来自卡内基梅隆大学，<strong>Tom</strong>定义的机器学习是，一个好的学习问题定义如下，他说，一个程序被认为能从经验<strong>E</strong>中学习，解决任务<strong>T</strong>，达到性能度量值<strong>P</strong>，当且仅当，有了经验<strong>E</strong>后，经过<strong>P</strong>评判，程序在处理T时的性能有所提升。我认为经验<strong>E</strong> 就是程序上万次的自我练习的经验而任务<strong>T</strong> 就是下棋。性能度量值<strong>P</strong>呢，就是它在与一些新的对手比赛时，赢得比赛的概率。</p><p>目前存在几种不同类型的学习算法。主要的两种类型被我们称之为<strong>监督学习和无监督学习</strong>。此外你将听到诸如，强化学习和推荐系统等各种术语。这些都是机器学习算法的一员，以后我们都将介绍到，但学习算法最常用两个类型就是监督学习、无监督学习。我会在接下来的两个视频中给出它们的定义。本课中，我们将花费最多的精力来讨论这两种学习算法。而另一个会花费大量时间的任务是了解应用学习算法的实用建议。</p><h3 id="1-3-监督学习"><a href="#1-3-监督学习" class="headerlink" title="1.3 监督学习"></a>1.3 监督学习</h3><p>监督学习指的就是我们给学习算法一个数据集。这个数据集由“正确答案”组成。</p><p>回归这个词的意思是，我们在试着推测出这一系列连续值属性。</p><p>分类指的是，我们试着推测出离散的输出值：0或1良性或恶性，而事实上在分类问题中，输出可能不止两个值。</p><h3 id="1-4-无监督学习"><a href="#1-4-无监督学习" class="headerlink" title="1.4 无监督学习"></a>1.4 无监督学习</h3><p>所以这个就是无监督学习，因为我们没有提前告知算法一些信息，比如，这是第一类的人，那些是第二类的人，还有第三类，等等。我们只是说，是的，这是有一堆数据。我不知道数据里面有什么。我不知道谁是什么类型。我甚至不知道人们有哪些不同的类型，这些类型又是什么。但你能自动地找到数据中的结构吗？就是说你要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。</p><p>鸡尾酒宴问题</p><h1 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h1><h2 id="单变量线性回归-Linear-Regression-with-One-Variable"><a href="#单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="单变量线性回归(Linear Regression with One Variable)"></a>单变量线性回归(Linear Regression with One Variable)</h2><h3 id="2-1-模型表示"><a href="#2-1-模型表示" class="headerlink" title="2.1 模型表示"></a>2.1 模型表示</h3><h3 id="2-2-代价函数"><a href="#2-2-代价函数" class="headerlink" title="2.2 代价函数"></a>2.2 代价函数</h3><p>接下来我们会引入一些术语我们现在要做的便是为我们的模型选择合适的<strong>参数</strong>（<strong>parameters</strong>）</p><p>我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是<strong>建模误差</strong>（<strong>modeling error</strong>）。</p><p>我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。</p><p>代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。</p><h3 id="2-3-代价函数的直观理解I"><a href="#2-3-代价函数的直观理解I" class="headerlink" title="2.3 代价函数的直观理解I"></a>2.3 代价函数的直观理解I</h3><h3 id="2-4-代价函数的直观理解II"><a href="#2-4-代价函数的直观理解II" class="headerlink" title="2.4 代价函数的直观理解II"></a>2.4 代价函数的直观理解II</h3><h3 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h3><p>梯度下降是一个用来求函数最小值的算法</p><p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到找到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。</p><p>批量梯度下降（<strong>batch gradient descent</strong>）算法的公式为：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7da5a5f635b1eb552618556f1b4aac1a.png" alt="7da5a5f635b1eb552618556f1b4aac1a"></p><p>其中是学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/ef4227864e3cabb9a3938386f857e938.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/13176da01bb25128c91aca5476c9d464.png" alt></p><p>在梯度下降算法中，这是正确实现<strong>同时更新</strong>的方法。我不打算解释为什么你需要同时更新，同时更新是梯度下降中的一种常用方法。我们之后会讲到，同步更新是更自然的实现方法。当人们谈到梯度下降时，他们的意思就是同步更新。</p><h3 id="2-6-梯度下降的直观理解"><a href="#2-6-梯度下降的直观理解" class="headerlink" title="2.6 梯度下降的直观理解"></a>2.6 梯度下降的直观理解</h3><p>学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p><p>如果太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</p><p>如果太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果太大，它会导致无法收敛，甚至发散。</p><h3 id="2-7-梯度下降（gradient-descent）的线性回归"><a href="#2-7-梯度下降（gradient-descent）的线性回归" class="headerlink" title="2.7 梯度下降（gradient descent）的线性回归"></a>2.7 梯度下降（gradient descent）的线性回归</h3><p>实际上，在机器学习中，通常不太会给算法起名字，但这个名字”<strong>批量梯度下降</strong>”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有m个训练样本求和。</p><h2 id="线性代数回顾-Linear-Algebra-Review"><a href="#线性代数回顾-Linear-Algebra-Review" class="headerlink" title="线性代数回顾(Linear Algebra Review)"></a>线性代数回顾(Linear Algebra Review)</h2><p><strong>matlab</strong>中矩阵转置：直接打一撇，<code>x=y&#39;</code>。</p><h2 id="多变量线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多变量线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多变量线性回归(Linear Regression with Multiple Variables)"></a>多变量线性回归(Linear Regression with Multiple Variables)</h2><h3 id="4-1-多维特征"><a href="#4-1-多维特征" class="headerlink" title="4.1 多维特征"></a>4.1 多维特征</h3><h3 id="4-2-多变量梯度下降"><a href="#4-2-多变量梯度下降" class="headerlink" title="4.2 多变量梯度下降"></a>4.2 多变量梯度下降</h3><p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和</p><p>我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。 </p><p><strong>Python</strong> 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">computeCost</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">:</span>    inner <span class="token operator">=</span> np<span class="token punctuation">.</span>power<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">*</span> theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>inner<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-梯度下降法实践1-特征缩放"><a href="#4-3-梯度下降法实践1-特征缩放" class="headerlink" title="4.3 梯度下降法实践1-特征缩放"></a>4.3 梯度下降法实践1-特征缩放</h3><p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。</p><h3 id="4-4-梯度下降法实践2-学习率"><a href="#4-4-梯度下降法实践2-学习率" class="headerlink" title="4.4 梯度下降法实践2-学习率"></a>4.4 梯度下降法实践2-学习率</h3><p>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。</p><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率a过小，则达到收敛所需的迭代次数会非常高；如果学习率a过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p><h3 id="4-5-特征和多项式回归"><a href="#4-5-特征和多项式回归" class="headerlink" title="4.5 特征和多项式回归"></a>4.5 特征和多项式回归</h3><p>注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。</p><h3 id="4-6-正规方程Normal-Equation"><a href="#4-6-正规方程Normal-Equation" class="headerlink" title="4.6 正规方程Normal Equation"></a>4.6 正规方程Normal Equation</h3><h2 id="Octave教程-Octave-Tutorial"><a href="#Octave教程-Octave-Tutorial" class="headerlink" title="Octave教程(Octave Tutorial)"></a>Octave教程(Octave Tutorial)</h2><p>现在大家都用python了，octave不想再浪费时间去搞了，反正作业可以用matlab一样可以做。5.6向量化看一下，当你使用向量化地实现线性回归，通常运行速度就会比你以前用你的<strong>for循环</strong>快的多，也就是自己写代码更新。</p><h1 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h1><h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h2><h3 id="6-1-分类问题"><a href="#6-1-分类问题" class="headerlink" title="6.1 分类问题"></a>6.1 分类问题</h3><p>我们将学习一种叫做逻辑回归 (<strong>Logistic Regression</strong>) 的算法，这是目前最流行使用最广泛的一种学习算法。</p><p>我们从二元的分类问题开始讨论。</p><p>我们将因变量(<strong>dependent variable</strong>)可能属于的两个类分别称为负向类（<strong>negative class</strong>）和正向类（<strong>positive class</strong>），则因变量，其中 0 表示负向类，1 表示正向类。</p><p>顺便说一下，<strong>逻辑回归算法是分类算法</strong>，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上是一种分类算法</p><h3 id="6-2-假说表示"><a href="#6-2-假说表示" class="headerlink" title="6.2 假说表示"></a>6.2 假说表示</h3><p>逻辑回归模型的假设</p><h3 id="6-3-判定边界"><a href="#6-3-判定边界" class="headerlink" title="6.3 判定边界"></a>6.3 判定边界</h3><p>现在讲下决策边界(<strong>decision boundary</strong>)的概念。这个概念能更好地帮助我们理解逻辑回归的假设函数在计算什么。</p><p>我们可以用非常复杂的模型来适应非常复杂形状的判定边界。</p><h3 id="6-4-代价函数"><a href="#6-4-代价函数" class="headerlink" title="6.4 代价函数"></a>6.4 代价函数</h3><p>定义用来拟合参数的优化目标或者叫代价函数，这便是监督学习问题中的逻辑回归模型的拟合问题。</p><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将h()带入到这样定义了的代价函数中时，我们得到的代价函数将是一个非凸函数（<strong>non-convexfunction</strong>）。</p><p>这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p><p>我们重新定义逻辑回归的代价函数为</p><p>在得到这样一个代价函数以后，我们便可以用梯度下降算法来求得能使代价函数最小的参数了。算法为：</p><p>在这个视频中，我们定义了单训练样本的代价函数，凸性分析的内容是超出这门课的范围的，但是可以证明我们所选的代价值函数会给我们一个凸优化问题。代价函数会是一个凸函数，并且没有局部最优值。</p><p>注：虽然得到的梯度下降算法表面上看上去与线性回归的梯度下降算法一样，但是这里的${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$与线性回归中不同，所以实际上是不一样的。另外，在运行梯度下降算法之前，进行特征缩放依旧是非常必要的。</p><p>一些梯度下降算法之外的选择： 除了梯度下降算法以外，还有一些常被用来令代价函数最小的算法，这些算法更加复杂和优越，而且通常不需要人工选择学习率，通常比梯度下降算法要更加快速。这些算法有：<strong>共轭梯度</strong>（<strong>Conjugate Gradient</strong>），<strong>局部优化法</strong>(<strong>Broyden fletcher goldfarb shann,BFGS</strong>)和<strong>有限内存局部优化法</strong>(<strong>LBFGS</strong>) ，<strong>fminunc</strong>是 <strong>matlab</strong>和<strong>octave</strong> 中都带的一个最小值优化函数，使用时我们需要提供代价函数和每个参数的求导，下面是 <strong>octave</strong> 中使用 <strong>fminunc</strong> 函数的代码示例</p><h3 id="6-5-简化的成本函数和梯度下降"><a href="#6-5-简化的成本函数和梯度下降" class="headerlink" title="6.5 简化的成本函数和梯度下降"></a>6.5 简化的成本函数和梯度下降</h3><p>找出一种稍微简单一点的方法来写代价函数，来替换我们现在用的方法。同时我们还要弄清楚如何运用梯度下降法，来拟合出逻辑回归的参数。。因此，听了这节课，你就应该知道如何实现一个完整的逻辑回归算法。</p><p>最小化代价函数的方法，是使用<strong>梯度下降法</strong>(<strong>gradient descent</strong>)。这是我们的代价函数：</p><p>如果我们要最小化这个关于$\theta$的函数值，这就是我们通常用的梯度下降法的模板。</p><p>因此，即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p><p>在先前的视频中，当我们在谈论线性回归的梯度下降法时，我们谈到了如何监控梯度下降法以确保其收敛，我通常也把同样的方法用在逻辑回归中，来监测梯度下降，以确保它正常收敛。</p><p>最后还有一点，我们之前在谈线性回归时讲到的特征缩放，我们看到了特征缩放是如何提高梯度下降的收敛速度的，这个特征缩放的方法，也适用于逻辑回归。如果你的特征范围差距很大的话，那么应用特征缩放的方法，同样也可以让逻辑回归中，梯度下降收敛更快。</p><p>就是这样，现在你知道如何实现逻辑回归，这是一种非常强大，甚至可能世界上使用最广泛的一种分类算法。</p><h3 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h3><p>使通过梯度下降，进行逻辑回归的速度大大提高，而这也将使算法更加适合解决大型的机器学习问题</p><p>这三种算法有许多优点：</p><h3 id="6-7-多类别分类：一对多"><a href="#6-7-多类别分类：一对多" class="headerlink" title="6.7 多类别分类：一对多"></a>6.7 多类别分类：一对多</h3><p>如何使用逻辑回归 (<strong>logistic regression</strong>)来解决多类别分类问题，具体来说，我想通过一个叫做”一对多” (<strong>one-vs-all</strong>) 的分类算法。</p><p>我们先从用三角形代表的类别1开始，实际上我们可以创建一个，新的”伪”训练集，类型2和类型3定为负类，类型1设定为正类，我们创建一个新的训练集，如下图所示的那样，我们要拟合出一个合适的分类器。</p><p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。</p><h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化(Regularization)"></a>正则化(Regularization)</h2><h3 id="7-1-过拟合的问题-over-fitting"><a href="#7-1-过拟合的问题-over-fitting" class="headerlink" title="7.1 过拟合的问题(over-fitting)"></a>7.1 过拟合的问题(<strong>over-fitting</strong>)</h3><p>如果我们发现了过拟合问题，应该如何处理？</p><ol><li>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li><li>正则化。 保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）。</li></ol><h3 id="7-2-代价函数"><a href="#7-2-代价函数" class="headerlink" title="7.2 代价函数"></a>7.2 代价函数</h3><p>正则化参数（<strong>Regularization Parameter</strong>）。 </p><h3 id="7-3-正则化线性回归"><a href="#7-3-正则化线性回归" class="headerlink" title="7.3 正则化线性回归"></a>7.3 正则化线性回归</h3><p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程。</p><p>我们同样也可以利用正规方程来求解正则化线性回归模型</p><h3 id="7-4-正则化的逻辑回归模型"><a href="#7-4-正则化的逻辑回归模型" class="headerlink" title="7.4 正则化的逻辑回归模型"></a>7.4 正则化的逻辑回归模型</h3><p>针对逻辑回归问题，我们在之前的课程已经学习过两种优化算法：我们首先学习了使用梯度下降法来优化代价函数$J\left( \theta \right)$，接下来学习了更高级的优化算法，这些高级优化算法需要你自己设计代价函数$J\left( \theta \right)$。</p><p>自己计算导数同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数：</p><h2 id="神经网络：表述-Neural-Networks-Representation"><a href="#神经网络：表述-Neural-Networks-Representation" class="headerlink" title="神经网络：表述(Neural Networks: Representation)"></a>神经网络：表述(Neural Networks: Representation)</h2><h3 id="8-1-非线性假设"><a href="#8-1-非线性假设" class="headerlink" title="8.1 非线性假设"></a>8.1 非线性假设</h3><p>我们之前学的，无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p><p>普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要神经网络。</p><h3 id="8-2-神经元和大脑"><a href="#8-2-神经元和大脑" class="headerlink" title="8.2 神经元和大脑"></a>8.2 神经元和大脑</h3><p>神经网络是一种很古老的算法，它最初产生的目的是制造能模拟大脑的机器。</p><h3 id="8-3-模型表示1"><a href="#8-3-模型表示1" class="headerlink" title="8.3 模型表示1"></a>8.3 模型表示1</h3><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？每一个神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>）。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被称为权重（<strong>weight</strong>）。</p><p>神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。下图为一个3层的神经网络，第一层成为输入层（<strong>Input Layer</strong>），最后一层称为输出层（<strong>Output Layer</strong>），中间一层成为隐藏层（<strong>Hidden Layers</strong>）。我们为每一层都增加一个偏差单位（<strong>bias unit</strong>）：</p><p>（我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )）</p><h3 id="8-4-模型表示2"><a href="#8-4-模型表示2" class="headerlink" title="8.4 模型表示2"></a>8.4 模型表示2</h3><p>( <strong>FORWARD PROPAGATION</strong> ) 相对于使用循环来编码，利用向量化的方法会使得计算更为简便。</p><h3 id="8-5-特征和直观理解1"><a href="#8-5-特征和直观理解1" class="headerlink" title="8.5 特征和直观理解1"></a>8.5 特征和直观理解1</h3><p><strong>OR</strong>与<strong>AND</strong>整体一样，区别只在于的取值不同。</p><h3 id="8-6-样本和直观理解II"><a href="#8-6-样本和直观理解II" class="headerlink" title="8.6 样本和直观理解II"></a>8.6 样本和直观理解II</h3><p>二元逻辑运算符（<strong>BINARY LOGICAL OPERATORS</strong>）当输入特征为布尔值（0或1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。</p><h3 id="8-7-多类分类"><a href="#8-7-多类分类" class="headerlink" title="8.7 多类分类"></a>8.7 多类分类</h3><h2 id="神经网络的学习-Neural-Networks-Learning"><a href="#神经网络的学习-Neural-Networks-Learning" class="headerlink" title="神经网络的学习(Neural Networks: Learning)"></a>神经网络的学习(Neural Networks: Learning)</h2><h3 id="9-1-代价函数"><a href="#9-1-代价函数" class="headerlink" title="9.1 代价函数"></a>9.1 代价函数</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/8f7c28297fc9ed297f42942018441850.jpg" alt></p><h3 id="9-2-反向传播算法"><a href="#9-2-反向传播算法" class="headerlink" title="9.2 反向传播算法"></a>9.2 反向传播算法</h3><h3 id="9-3-反向传播算法的直观理解"><a href="#9-3-反向传播算法的直观理解" class="headerlink" title="9.3 反向传播算法的直观理解"></a>9.3 反向传播算法的直观理解</h3><h3 id="9-4-实现注意：展开参数"><a href="#9-4-实现注意：展开参数" class="headerlink" title="9.4 实现注意：展开参数"></a>9.4 实现注意：展开参数</h3><h3 id="9-5-梯度检验"><a href="#9-5-梯度检验" class="headerlink" title="9.5 梯度检验"></a>9.5 梯度检验</h3><p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。</p><p>为了避免这样的问题，我们采取一种叫做梯度的数值检验（<strong>Numerical Gradient Checking</strong>）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。</p><h3 id="9-6-随机初始化"><a href="#9-6-随机初始化" class="headerlink" title="9.6 随机初始化"></a>9.6 随机初始化</h3><p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为0，这将意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非0的数，结果也是一样的。</p><p>我们通常初始参数为正负ε之间的随机值</p><h3 id="9-7-综合起来"><a href="#9-7-综合起来" class="headerlink" title="9.7 综合起来"></a>9.7 综合起来</h3><p>我们真正要决定的是隐藏层的层数和每个中间层的单元数。</p><p>训练神经网络：</p><ol><li><p>参数的随机初始化</p></li><li><p>利用正向传播方法计算所有的h</p></li><li><p>编写计算代价函数 J的代码</p></li><li><p>利用反向传播方法计算所有偏导数</p></li><li><p>利用数值检验方法检验这些偏导数</p></li><li><p>使用优化算法来最小化代价函数</p></li></ol><h3 id="9-8-自主驾驶"><a href="#9-8-自主驾驶" class="headerlink" title="9.8 自主驾驶"></a>9.8 自主驾驶</h3><p>这就是基于神经网络的自动驾驶技术。当然，我们还有很多更加先进的试验来实现自动驾驶技术。在美国，欧洲等一些国家和地区，他们提供了一些比这个方法更加稳定的驾驶控制技术。但我认为，使用这样一个简单的基于反向传播的神经网络，训练出如此强大的自动驾驶汽车，的确是一次令人惊讶的成就。</p><h2 id="应用机器学习的建议-Advice-for-Applying-Machine-Learning"><a href="#应用机器学习的建议-Advice-for-Applying-Machine-Learning" class="headerlink" title="应用机器学习的建议(Advice for Applying Machine Learning)"></a>应用机器学习的建议(Advice for Applying Machine Learning)</h2><h3 id="10-1-决定下一步做什么"><a href="#10-1-决定下一步做什么" class="headerlink" title="10.1 决定下一步做什么"></a>10.1 决定下一步做什么</h3><p>当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？</p><ol><li><p>获得更多的训练样本——通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。</p></li><li><p>尝试减少特征的数量</p></li><li><p>尝试获得更多的特征</p></li><li><p>尝试增加多项式特征</p></li><li><p>尝试减少正则化程度</p></li><li><p>尝试增加正则化程度</p></li></ol><p>我们不应该随机选择上面的某种方法来改进我们的算法，而是运用一些机器学习诊断法来帮助我们知道上面哪些方法对我们的算法是有效的。</p><h3 id="10-2-评估一个假设"><a href="#10-2-评估一个假设" class="headerlink" title="10.2 评估一个假设"></a>10.2 评估一个假设</h3><p>为了检验算法是否过拟合，我们将数据分成训练集和测试集，通常用70%的数据作为训练集，用剩下30%的数据作为测试集。很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行“洗牌”，然后再分成训练集和测试集。</p><p>测试集评估在通过训练集让我们的模型学习得出其参数后，对测试集运用该模型，我们有两种方式计算误差：</p><ol><li>对于线性回归模型，我们利用测试集数据计算代价函数J</li><li>对于逻辑回归模型，我们除了可以利用测试数据集来计算代价函数外：</li></ol><p>误分类的比率，对于每一个测试集样本，计算：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/751e868bebf4c0bf139db173d25e8ec4.png" alt></p><p>然后对计算结果求平均。</p><h3 id="10-3-模型选择和交叉验证集"><a href="#10-3-模型选择和交叉验证集" class="headerlink" title="10.3 模型选择和交叉验证集"></a>10.3 模型选择和交叉验证集</h3><p>适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用交叉验证集来帮助选择模型。</p><p>即：使用60%的数据作为训练集，使用 20%的数据作为交叉验证集，使用20%的数据作为测试集</p><p>模型选择的方法为：</p><ol><li><p>使用训练集训练出10个模型</p></li><li><p>用10个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</p></li><li><p>选取代价函数值最小的模型</p></li><li><p>用步骤3中选出的模型对测试集计算得出推广误差（代价函数的值）</p></li></ol><h3 id="10-4-诊断偏差和方差"><a href="#10-4-诊断偏差和方差" class="headerlink" title="10.4 诊断偏差和方差"></a>10.4 诊断偏差和方差</h3><p>训练集误差和交叉验证集误差近似时：偏差/欠拟合</p><p>交叉验证集误差远大于训练集误差时：方差/过拟合</p><h3 id="10-5-正则化和偏差-方差"><a href="#10-5-正则化和偏差-方差" class="headerlink" title="10.5 正则化和偏差/方差"></a>10.5 正则化和偏差/方差</h3><p>选择$\lambda$的方法为：</p><ol><li>使用训练集训练出12个不同程度正则化的模型</li><li>用12个模型分别对交叉验证集计算的出交叉验证误差</li><li>选择得出交叉验证误差<strong>最小</strong>的模型</li><li>运用步骤3中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与λ的值绘制在一张图表上：</li></ol><p>• 当 $\lambda$ 较小时，训练集误差较小（过拟合）而交叉验证集误差较大</p><p>• 随着 $\lambda$ 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</p><h3 id="10-6-学习曲线"><a href="#10-6-学习曲线" class="headerlink" title="10.6 学习曲线"></a>10.6 学习曲线</h3><p>学习曲线就是一种很好的工具，我经常使用学习曲线来判断某一个学习算法是否处于偏差、方差问题。学习曲线是学习算法的一个很好的<strong>合理检验</strong>（<strong>sanity check</strong>）。学习曲线是将训练集误差和交叉验证集误差作为训练集样本数量的函数绘制的图表。</p><p>如何利用学习曲线识别高偏差/欠拟合：作为例子，我们尝试用一条直线来适应下面的数据，可以看出，无论训练集有多么大误差都不会有太大改观：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/4a5099b9f4b6aac5785cb0ad05289335.jpg" alt></p><p>也就是说在高偏差/欠拟合的情况下，增加数据到训练集不一定能有帮助。</p><p>如何利用学习曲线识别高方差/过拟合：假设我们使用一个非常高次的多项式模型，并且正则化非常小，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2977243994d8d28d5ff300680988ec34.jpg" alt></p><p>也就是说在高方差/过拟合的情况下，增加更多数据到训练集可能可以提高算法效果。</p><h3 id="10-7-决定下一步做什么"><a href="#10-7-决定下一步做什么" class="headerlink" title="10.7 决定下一步做什么"></a>10.7 决定下一步做什么</h3><p>哪些方法可能有助于改进学习算法的效果，而哪些可能是徒劳的呢？</p><p>回顾 1.1 中提出的六种可选的下一步，让我们来看一看我们在什么情况下应该怎样选择：</p><ol><li><p>获得更多的训练样本——解决高方差</p></li><li><p>尝试减少特征的数量——解决高方差</p></li><li><p>尝试获得更多的特征——解决高偏差</p></li><li><p>尝试增加多项式特征——解决高偏差</p></li><li><p>尝试减少正则化程度λ——解决高偏差</p></li><li><p>尝试增加正则化程度λ——解决高方差</p></li></ol><p>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。</p><p>对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络，<br>然后选择交叉验证集代价最小的神经网络。</p><h1 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h1><h2 id="机器学习系统的设计-Machine-Learning-System-Design"><a href="#机器学习系统的设计-Machine-Learning-System-Design" class="headerlink" title="机器学习系统的设计(Machine Learning System Design)"></a>机器学习系统的设计(Machine Learning System Design)</h2><h3 id="11-1-首先要做什么"><a href="#11-1-首先要做什么" class="headerlink" title="11.1 首先要做什么"></a>11.1 首先要做什么</h3><p>以一个垃圾邮件分类器算法为例进行讨论。</p><p>为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量$x$。我们可以选择一个由100个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否有在邮件中出现，来获得我们的特征向量（出现为1，不出现为0），尺寸为100×1。</p><p>为了构建这个分类器算法，我们可以做很多事，例如：</p><ol><li><p>收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件的样本</p></li><li><p>基于邮件的路由信息开发一系列复杂的特征</p></li><li><p>基于邮件的正文信息开发一系列复杂的特征，包括考虑截词的处理</p></li><li><p>为探测刻意的拼写错误（把<strong>watch</strong> 写成<strong>w4tch</strong>）开发复杂的算法</p></li></ol><h3 id="11-2-误差分析"><a href="#11-2-误差分析" class="headerlink" title="11.2 误差分析"></a>11.2 误差分析</h3><p>误差分析（<strong>Error Analysis</strong>）的概念。这会帮助你更系统地做出决定。如果你准备研究机器学习的东西，或者构造机器学习应用程序，最好的实践方法不是建立一个非常复杂的系统，拥有多么复杂的变量；而是构建一个简单的算法，这样你可以很快地实现它。</p><p>构建一个学习算法的推荐方法为：</p><p>1.从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法</p><p>2.绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</p><p>3.进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的样本，看看这些样本是否有某种系统化的趋势</p><h3 id="11-3-类偏斜的误差度量"><a href="#11-3-类偏斜的误差度量" class="headerlink" title="11.3 类偏斜的误差度量"></a>11.3 类偏斜的误差度量</h3><p>类偏斜情况表现为我们的训练集中有非常多的同一种类的样本，只有很少或没有其他类的样本。</p><p><strong>查准率</strong>（<strong>Precision</strong>）和<strong>查全率</strong>（<strong>Recall</strong>） 我们将算法预测的结果分成四种情况：</p><p>1.<strong>正确肯定</strong>（<strong>True Positive,TP</strong>）：预测为真，实际为真</p><p>2.<strong>正确否定</strong>（<strong>True Negative,TN</strong>）：预测为假，实际为假</p><p>3.<strong>错误肯定</strong>（<strong>False Positive,FP</strong>）：预测为真，实际为假</p><p>4.<strong>错误否定</strong>（<strong>False Negative,FN</strong>）：预测为假，实际为真</p><p>则：查准率=<strong>TP/(TP+FP)</strong>。例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。</p><p>查全率=<strong>TP/(TP+FN)</strong>。例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p><p>这样，对于我们刚才那个总是预测病人肿瘤为良性的算法，其查全率是0。</p><table><thead><tr><th></th><th></th><th><strong>预测值</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td><strong>Positive</strong></td><td><strong>Negtive</strong></td></tr><tr><td><strong>实际值</strong></td><td><strong>Positive</strong></td><td><strong>TP</strong></td><td><strong>FN</strong></td></tr><tr><td></td><td><strong>Negtive</strong></td><td><strong>FP</strong></td><td><strong>TN</strong></td></tr></tbody></table><h3 id="11-4-查准率和查全率之间的权衡"><a href="#11-4-查准率和查全率之间的权衡" class="headerlink" title="11.4 查准率和查全率之间的权衡"></a>11.4 查准率和查全率之间的权衡</h3><p>我们希望有一个帮助我们选择这个阀值的方法。一种方法是计算<strong>F1 值</strong>（<strong>F1 Score</strong>），其计算公式为：</p><p>我们选择使得<strong>F1</strong>值最高的阀值。</p><h3 id="11-5-机器学习的数据"><a href="#11-5-机器学习的数据" class="headerlink" title="11.5 机器学习的数据"></a>11.5 机器学习的数据</h3><p>在一定的条件下，得到大量的数据并在某种类型的学习算法中进行训练，可以是一种有效的方法来获得一个具有良好性能的学习算法。</p><h2 id="支持向量机-Support-Vector-Machines"><a href="#支持向量机-Support-Vector-Machines" class="headerlink" title="支持向量机(Support Vector Machines)"></a>支持向量机(Support Vector Machines)</h2><h3 id="12-1-优化目标"><a href="#12-1-优化目标" class="headerlink" title="12.1 优化目标"></a>12.1 优化目标</h3><p>与逻辑回归和神经网络相比，支持向量机，或者简称<strong>SVM</strong>，在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p><h3 id="12-2-大边界的直观理解"><a href="#12-2-大边界的直观理解" class="headerlink" title="12.2 大边界的直观理解"></a>12.2 大边界的直观理解</h3><p>这就相当于在支持向量机中嵌入了一个额外的安全因子，或者说安全的间距因子。</p><p>支持向量机将会选择这个黑色的决策边界，相较于之前我用粉色或者绿色画的决策界。这条黑色的看起来好得多，黑线看起来是更稳健的决策界。在分离正样本和负样本上它显得的更好。数学上来讲，这是什么意思呢？这条黑线有更大的距离，这个距离叫做间距(<strong>margin</strong>)。</p><p>这个距离叫做支持向量机的间距，而这是支持向量机具有<strong>鲁棒性</strong>的原因，因为它努力用一个最大间距来分离样本。因此支持向量机有时被称为<strong>大间距分类器</strong></p><p>关于大间距分类器，我想讲最后一点：我们将这个大间距分类器中的正则化因子常数$C$设置的非常大，我记得我将其设置为了100000，因此对这样的一个数据集，也许我们将选择这样的决策界，从而最大间距地分离开正样本和负样本。那么在让代价函数最小化的过程中，我们希望找出在$y=1$和$y=0$两种情况下都使得代价函数中左边的这一项尽量为零的参数。如果我们找到了这样的参数，则我们的最小化问题便转变成：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f4b6dee99cfb4352b3cac5287002e8de.png" alt></p><p>事实上，支持向量机现在要比这个大间距分类器所体现得更成熟，尤其是当你使用大间距分类器的时候，你的学习算法会受异常点(outlier) 的影响。比如我们加入一个额外的正样本。</p><p>C 较大时，相当于 lambda​ 较小，可能会导致过拟合，高方差。</p><p>C​ 较小时，相当于lambda较大，可能会导致低拟合，高偏差。</p><h3 id="12-3-大边界分类背后的数学（选修）"><a href="#12-3-大边界分类背后的数学（选修）" class="headerlink" title="12.3 大边界分类背后的数学（选修）"></a>12.3 大边界分类背后的数学（选修）</h3><p>因此支持向量机做的全部事情，就是<strong>极小化参数向量</strong>范数的平方，或者说长度的平方。</p><h3 id="12-4-核函数1"><a href="#12-4-核函数1" class="headerlink" title="12.4 核函数1"></a>12.4 核函数1</h3><p>给定一个训练样本$x$，我们利用$x$的各个特征与我们预先选定的<strong>地标</strong>(<strong>landmarks</strong>)的近似程度来选取新的特征。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2516821097bda5dfaf0b94e55de851e0.png" alt></p><h3 id="12-5-核函数2"><a href="#12-5-核函数2" class="headerlink" title="12.5 核函数2"></a>12.5 核函数2</h3><p>如何选择地标？</p><h3 id="12-6-使用支持向量机"><a href="#12-6-使用支持向量机" class="headerlink" title="12.6 使用支持向量机"></a>12.6 使用支持向量机</h3><p>在高斯核函数之外我们还有其他一些选择，如：</p><p>多项式核函数（<strong>Polynomial Kerne</strong>l）</p><p>字符串核函数（<strong>String kernel</strong>）</p><p>卡方核函数（ <strong>chi-square kernel</strong>）</p><p>直方图交集核函数（<strong>histogram intersection kernel</strong>）</p><p>等等…</p><p>这些核函数的目标也都是根据训练集和地标之间的距离来构建新特征，这些核函数需要满足Mercer’s定理，才能被支持向量机的优化软件正确处理。</p><p><strong>多类分类问题</strong></p><p>尽管你不去写你自己的<strong>SVM</strong>的优化软件，但是你也需要做几件事：</p><p>1、是提出参数的选择。我们在之前的视频中讨论过误差/方差在这方面的性质。</p><p>2、你也需要选择内核参数或你想要使用的相似函数，其中一个选择是：我们选择不需要任何内核参数，没有内核参数的理念，也叫线性核函数。因此，如果有人说他使用了线性核的<strong>SVM</strong>（支持向量机），这就意味这他使用了不带有核函数的<strong>SVM</strong>（支持向量机）。</p><p>从逻辑回归模型，我们得到了支持向量机模型，在两者之间，我们应该如何选择呢？</p><p><strong>下面是一些普遍使用的准则：</strong></p><h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类(Clustering)"></a>聚类(Clustering)</h2><h3 id="13-1-无监督学习：简介"><a href="#13-1-无监督学习：简介" class="headerlink" title="13.1 无监督学习：简介"></a>13.1 无监督学习：简介</h3><p>在一个典型的监督学习中，我们有一个有标签的训练集，我们的目标是找到能够区分正样本和负样本的决策边界，在这里的监督学习中，我们有一系列标签，我们需要据此拟合一个假设函数。与此不同的是，在非监督学习中，我们的数据没有附带任何标签</p><h3 id="13-2-K-均值算法"><a href="#13-2-K-均值算法" class="headerlink" title="13.2 K-均值算法"></a>13.2 K-均值算法</h3><p><strong>K-均值</strong>是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。</p><p><strong>K-均值</strong>是一个迭代算法，假设我们想要将数据聚类成n个组，其方法为:</p><h3 id="13-3-优化目标"><a href="#13-3-优化目标" class="headerlink" title="13.3 优化目标"></a>13.3 优化目标</h3><p>K-均值最小化问题，是要最小化所有的数据点与其所关联的聚类中心点之间的距离之和，因此<br>K-均值的代价函数（又称<strong>畸变函数</strong> <strong>Distortion function</strong>）为：</p><h3 id="13-4-随机初始化"><a href="#13-4-随机初始化" class="headerlink" title="13.4 随机初始化"></a>13.4 随机初始化</h3><p>在运行K-均值算法的之前，我们首先要随机初始化所有的聚类中心点，下面介绍怎样做：</p><h3 id="13-5-选择聚类数"><a href="#13-5-选择聚类数" class="headerlink" title="13.5 选择聚类数"></a>13.5 选择聚类数</h3><p>没有所谓最好的选择聚类数的方法，通常是需要根据不同的问题，人工进行选择的。选择的时候思考我们运用<strong>K-均值</strong>算法聚类的动机是什么，然后选择能最好服务于该目的标聚类数。</p><h2 id="降维-Dimensionality-Reduction"><a href="#降维-Dimensionality-Reduction" class="headerlink" title="降维(Dimensionality Reduction)"></a>降维(Dimensionality Reduction)</h2><h3 id="14-1-动机一：数据压缩"><a href="#14-1-动机一：数据压缩" class="headerlink" title="14.1 动机一：数据压缩"></a>14.1 动机一：数据压缩</h3><p>第二种类型的无监督学习问题，称为降维。有几个不同的的原因使你可能想要做降维。一是数据压缩，后面我们会看了一些视频后，数据压缩不仅允许我们压缩数据，因而使用较少的计算机内存或磁盘空间，但它也让我们加快我们的学习算法。</p><h3 id="14-2-动机二：数据可视化"><a href="#14-2-动机二：数据可视化" class="headerlink" title="14.2 动机二：数据可视化"></a>14.2 动机二：数据可视化</h3><p>在许多及其学习问题中，如果我们能将数据可视化，我们便能寻找到一个更好的解决方案，降维可以帮助我们。</p><p>这样做的问题在于，降维的算法只负责减少维数，新产生的特征的意义就必须由我们自己去发现了。</p><h3 id="14-3-主成分分析问题"><a href="#14-3-主成分分析问题" class="headerlink" title="14.3 主成分分析问题"></a>14.3 主成分分析问题</h3><p>主成分分析(<strong>PCA</strong>)是最常见的降维算法。</p><p>在<strong>PCA</strong>中，我们要做的是找到一个方向向量（<strong>Vector direction</strong>），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。</p><p>面给出主成分分析问题的描述：</p><p>主成分分析与线性回归是两种不同的算法。主成分分析最小化的是投射误差（<strong>Projected Error</strong>），而线性回归尝试的是最小化预测误差。线性回归的目的是预测结果，而主成分分析不作任何预测。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7e1389918ab9358d1432d20ed20f8142.png" alt="7e1389918ab9358d1432d20ed20f8142"></p><p>左边的是线性回归的误差（垂直于横轴投影），右边则是主要成分分析的误差（垂直于红线投影）。</p><p><strong>PCA</strong>将n个特征降维到k个，可以用来进行数据压缩，如果100维的向量最后可以用10维来表示，那么压缩率为90%。同样图像处理领域的<strong>KL变换</strong>使用<strong>PCA</strong>做图像压缩。但<strong>PCA</strong> 要保证降维后，还要保证数据的特性损失最小。</p><p><strong>PCA</strong>技术的一大好处是对数据进行降维的处理。我们可以对新求出的“主元”向量的重要性进行排序，根据需要取前面最重要的部分，将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息。</p><p><strong>PCA</strong>技术的一个很大的优点是，它是完全无参数限制的。在<strong>PCA</strong>的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。</p><p>但是，这一点同时也可以看作是缺点。如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。</p><h3 id="14-4-主成分分析算法"><a href="#14-4-主成分分析算法" class="headerlink" title="14.4 主成分分析算法"></a>14.4 主成分分析算法</h3><p>第一步是均值归一化。</p><p>第二步是计算<strong>协方差矩阵</strong>（<strong>covariance matrix</strong>)</p><p>第三步是计算协方差矩阵的<strong>特征向量</strong>（<strong>eigenvectors</strong>）:</p><h3 id="14-5-选择主成分的数量"><a href="#14-5-选择主成分的数量" class="headerlink" title="14.5 选择主成分的数量"></a>14.5 选择主成分的数量</h3><p>主要成分分析是减少投射的平均均方误差：</p><blockquote><p>方差越大，表明这个特征里数据分布的离散程度就越大，特征所包含的信息量就越大；反之，如果特征里数据的方差小，分布集中，则表明其包含的信息量就小。那么，我们自然选择保留信息量大的那个特征了。</p></blockquote><h3 id="14-6-重建的压缩表示"><a href="#14-6-重建的压缩表示" class="headerlink" title="14.6 重建的压缩表示"></a>14.6 重建的压缩表示</h3><h3 id="14-7-主成分分析法的应用建议"><a href="#14-7-主成分分析法的应用建议" class="headerlink" title="14.7 主成分分析法的应用建议"></a>14.7 主成分分析法的应用建议</h3><pre><code>  1. 第一步是运用主要成分分析将数据压缩至1000个特征  2. 然后对**训练集**运行学习算法  3. 在预测时，采用之前学习而来的U将输入的特征x转换成特征向量z，然后再进行预测</code></pre><p>错误的主要成分分析情况：一个常见错误使用主要成分分析的情况是，将其用于减少过拟合（减少了特征的数量）。这样做非常不好，不如尝试正则化处理。原因在于主要成分分析只是近似地丢弃掉一些特征，它并不考虑任何与结果变量有关的信息，因此可能会丢失非常重要的特征。然而当我们进行正则化处理时，会考虑到结果变量，不会丢掉重要的数据。</p><p>另一个常见的错误是，默认地将主要成分分析作为学习过程中的一部分，这虽然很多时候有效果，最好还是从所有原始特征开始，只在有必要的时候（算法运行太慢或者占用太多内存）才考虑采用主要成分分析。</p><h2 id="异常检测-Anomaly-Detection"><a href="#异常检测-Anomaly-Detection" class="headerlink" title="异常检测(Anomaly Detection)"></a>异常检测(Anomaly Detection)</h2><h3 id="15-1-问题的动机"><a href="#15-1-问题的动机" class="headerlink" title="15.1 问题的动机"></a>15.1 问题的动机</h3><p>异常检测(<strong>Anomaly detection</strong>)问题。这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于：它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。</p><p>异常检测主要用来识别欺骗。例如在线采集而来的有关用户的数据，一个特征向量中可能会包含如：用户多久登录一次，访问过的页面，在论坛发布的帖子数量，甚至是打字速度等。尝试根据这些特征构建一个模型，可以用这个模型来识别那些不符合该模式的用户。</p><h3 id="15-2-高斯分布"><a href="#15-2-高斯分布" class="headerlink" title="15.2 高斯分布"></a>15.2 高斯分布</h3><p>回顾高斯分布的基本知识。</p><h3 id="15-3-算法"><a href="#15-3-算法" class="headerlink" title="15.3 算法"></a>15.3 算法</h3><p>异常检测算法：</p><h3 id="15-4-开发和评价一个异常检测系统"><a href="#15-4-开发和评价一个异常检测系统" class="headerlink" title="15.4 开发和评价一个异常检测系统"></a>15.4 开发和评价一个异常检测系统</h3><p>具体的评价方法如下：</p><h3 id="15-5-异常检测与监督学习对比"><a href="#15-5-异常检测与监督学习对比" class="headerlink" title="15.5 异常检测与监督学习对比"></a>15.5 异常检测与监督学习对比</h3><table><thead><tr><th>异常检测</th><th>监督学习</th></tr></thead><tbody><tr><td>非常少量的正向类（异常数据 ）, 大量的负向类（）</td><td>同时有大量的正向类和负向类</td></tr><tr><td>许多不同种类的异常，非常难。根据非常 少量的正向类数据来训练算法。</td><td>有足够多的正向类实例，足够用于训练 算法，未来遇到的正向类实例可能与训练集中的非常近似。</td></tr><tr><td>未来遇到的异常可能与已掌握的异常、非常的不同。</td><td></td></tr><tr><td>例如： 欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况</td><td>例如：邮件过滤器 天气预报 肿瘤分类</td></tr></tbody></table><h3 id="15-6-选择特征"><a href="#15-6-选择特征" class="headerlink" title="15.6 选择特征"></a>15.6 选择特征</h3><p>对于异常检测算法，我们使用的特征是至关重要的，下面谈谈如何选择特征：</p><p>异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布</p><p>误差分析：</p><p>我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小），例如，在检测数据中心的计算机状况的例子中，我们可以用<strong>CPU</strong>负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。</p><h3 id="15-7-多元高斯分布（选修）"><a href="#15-7-多元高斯分布（选修）" class="headerlink" title="15.7 多元高斯分布（选修）"></a>15.7 多元高斯分布（选修）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/598db991a7c930c9021cec5f6ab9beb9.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/29df906704d254f18e92a63173dd51e7.jpg" alt></p><p>上图是5个不同的模型，从左往右依次分析：</p><ol><li><p>是一个一般的高斯分布模型</p></li><li><p>通过协方差矩阵，令特征1拥有较小的偏差，同时保持特征2的偏差</p></li><li><p>通过协方差矩阵，令特征2拥有较大的偏差，同时保持特征1的偏差</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的正相关性</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的负相关性</p></li></ol><p>多元高斯分布模型与原高斯分布模型的关系：</p><p>可以证明的是，原本的高斯分布模型是多元高斯分布模型的一个子集，即像上图中的第1、2、3，3个例子所示，如果协方差矩阵只在对角线的单位上有非零的值时，即为原本的高斯分布模型了。</p><p>原高斯分布模型和多元高斯分布模型的比较：</p><table><thead><tr><th>原高斯分布模型</th><th>多元高斯分布模型</th></tr></thead><tbody><tr><td>不能捕捉特征之间的相关性 但可以通过将特征进行组合的方法来解决</td><td>自动捕捉特征之间的相关性</td></tr><tr><td>计算代价低，能适应大规模的特征</td><td>计算代价较高 训练集较小时也同样适用</td></tr><tr><td></td><td>必须要有 m&gt;n​，不然的话协方差矩阵不可逆的，通常需要 m&gt;10n​另外特征冗余也会导致协方差矩阵不可逆</td></tr></tbody></table><p>原高斯分布模型被广泛使用着，如果特征之间在某种程度上存在相互关联的情况，我们可以通过构造新新特征的方法来捕捉这些相关性。</p><p>如果训练集不是太大，并且没有太多的特征，我们可以使用多元高斯分布模型。</p><h3 id="15-8-使用多元高斯分布进行异常检测（可选）"><a href="#15-8-使用多元高斯分布进行异常检测（可选）" class="headerlink" title="15.8 使用多元高斯分布进行异常检测（可选）"></a>15.8 使用多元高斯分布进行异常检测（可选）</h3><p>原始模型和多元高斯分布比较如图：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f4585239738f2b5149608879fa166889.png" alt></p><h2 id="推荐系统-Recommender-Systems"><a href="#推荐系统-Recommender-Systems" class="headerlink" title="推荐系统(Recommender Systems)"></a>推荐系统(Recommender Systems)</h2><h3 id="16-1-问题形式化"><a href="#16-1-问题形式化" class="headerlink" title="16.1 问题形式化"></a>16.1 问题形式化</h3><blockquote><p>机器学习中的大思想</p></blockquote><p>我们从一个例子开始定义推荐系统的问题。</p><p>假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。</p><h3 id="16-2-基于内容的推荐系统"><a href="#16-2-基于内容的推荐系统" class="headerlink" title="16.2 基于内容的推荐系统"></a>16.2 基于内容的推荐系统</h3><h3 id="16-3-协同过滤"><a href="#16-3-协同过滤" class="headerlink" title="16.3 协同过滤"></a>16.3 协同过滤</h3><h3 id="16-4-协同过滤算法"><a href="#16-4-协同过滤算法" class="headerlink" title="16.4 协同过滤算法"></a>16.4 协同过滤算法</h3><h3 id="16-5-向量化：低秩矩阵分解"><a href="#16-5-向量化：低秩矩阵分解" class="headerlink" title="16.5 向量化：低秩矩阵分解"></a>16.5 向量化：低秩矩阵分解</h3><p>实现一种选择的方法，写出协同过滤算法的预测情况。</p><p>通过这个方法，希望你能知道，如何进行一个向量化的计算来对所有的用户和所有的电影进行评分计算。同时希望你也能掌握，通过学习特征参数，来找到相关电影和产品的方法。</p><h3 id="16-6-推行工作上的细节：均值归一化"><a href="#16-6-推行工作上的细节：均值归一化" class="headerlink" title="16.6 推行工作上的细节：均值归一化"></a>16.6 推行工作上的细节：均值归一化</h3><p>如果我们新增一个用户 <strong>Eve</strong>，并且 <strong>Eve</strong> 没有为任何电影评分，那么我们以什么为依据为<strong>Eve</strong>推荐电影呢？</p><p>我们首先需要对结果矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9ec5cb55e14bd1462183e104f8e02b80.png" alt></p><p>然后我们利用这个新的Y矩阵来训练算法。<br>如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，对于<strong>Eve</strong>，我们的新模型会认为她给每部电影的评分都是该电影的平均分。</p><h2 id="大规模机器学习-Large-Scale-Machine-Learning"><a href="#大规模机器学习-Large-Scale-Machine-Learning" class="headerlink" title="大规模机器学习(Large Scale Machine Learning)"></a>大规模机器学习(Large Scale Machine Learning)</h2><h3 id="17-1-大型数据集的学习"><a href="#17-1-大型数据集的学习" class="headerlink" title="17.1 大型数据集的学习"></a>17.1 大型数据集的学习</h3><p>如果我们有一个低方差的模型，增加数据集的规模可以帮助你获得更好的结果。我们应该怎样应对一个有100万条记录的训练集？</p><p>首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用1000个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。</p><h3 id="17-2-随机梯度下降法"><a href="#17-2-随机梯度下降法" class="headerlink" title="17.2 随机梯度下降法"></a>17.2 随机梯度下降法</h3><p>如果我们一定需要一个大规模的训练集，我们可以尝试使用随机梯度下降法来代替批量梯度下降法。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9710a69ba509a9dcbca351fccc6e7aae.jpg" alt></p><h3 id="17-3-小批量梯度下降"><a href="#17-3-小批量梯度下降" class="headerlink" title="17.3 小批量梯度下降"></a>17.3 小批量梯度下降</h3><p>小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数b次训练实例，便更新一次参数</p><h3 id="17-4-随机梯度下降收敛"><a href="#17-4-随机梯度下降收敛" class="headerlink" title="17.4 随机梯度下降收敛"></a>17.4 随机梯度下降收敛</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/76fb1df50bdf951f4b880fa66489e367.png" alt></p><h3 id="17-5-在线学习"><a href="#17-5-在线学习" class="headerlink" title="17.5 在线学习"></a>17.5 在线学习</h3><p>在这个视频中，讨论一种新的大规模的机器学习机制，叫做在线学习机制。在线学习机制让我们可以模型化问题。</p><p>今天，许多大型网站或者许多大型网络公司，使用不同版本的在线学习机制算法，从大批的涌入又离开网站的用户身上进行学习。特别要提及的是，如果你有一个由连续的用户流引发的连续的数据流，进入你的网站，你能做的是使用一个在线学习机制，从数据流中学习用户的偏好，然后使用这些信息来优化一些关于网站的决策。</p><p>一个算法来从中学习的时候来模型化问题在线学习算法指的是对数据流而非离线的静态数据集的学习。许多在线网站都有持续不断的用户流，对于每一个用户，网站希望能在不将数据存储到数据库中便顺利地进行算法学习。</p><p>在线学习的算法与随机梯度下降算法有些类似，我们对单一的实例进行学习，而非对一个提前定义的训练集进行循环。</p><p>一旦对一个数据的学习完成了，我们便可以丢弃该数据，不需要再存储它了。这种方式的好处在于，我们的算法可以很好的适应用户的倾向性，算法可以针对用户的当前行为不断地更新模型以适应该用户。</p><p><strong>每次交互事件并不只产生一个数据集</strong>，例如，我们一次给用户提供3个物流选项，用户选择2项，我们实际上可以获得3个新的训练实例，因而我们的算法可以一次从3个实例中学习并更新模型。</p><p>在线学习的一个优点就是，如果你有一个变化的用户群，又或者你在尝试预测的事情，在缓慢变化，就像你的用户的品味在缓慢变化，这个在线学习算法，可以慢慢地调试你所学习到的假设，将其调节更新到<strong>最新的用户行为</strong>。</p><h3 id="17-6-映射化简和数据并行"><a href="#17-6-映射化简和数据并行" class="headerlink" title="17.6 映射化简和数据并行"></a>17.6 映射化简和数据并行</h3><p>映射化简和数据并行对于大规模机器学习问题而言是非常重要的概念。</p><p>如果我们能够将我们的数据集分配给不多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计所的结果汇总在求和。这样的方法叫做映射简化。</p><p>具体而言，如果任何学习算法能够表达为，对训练集的函数的求和，那么便能将这个任务分配给多台计算机（或者同一台计算机的不同<strong>CPU</strong> 核心），以达到加速处理的目的。</p><h2 id="应用实例：图片文字识别-Application-Example-Photo-OCR"><a href="#应用实例：图片文字识别-Application-Example-Photo-OCR" class="headerlink" title="应用实例：图片文字识别(Application Example: Photo OCR)"></a>应用实例：图片文字识别(Application Example: Photo OCR)</h2><h3 id="18-1-问题描述和流程图Problem-Description-and-Pipeline"><a href="#18-1-问题描述和流程图Problem-Description-and-Pipeline" class="headerlink" title="18.1 问题描述和流程图Problem Description and Pipeline"></a>18.1 问题描述和流程图Problem Description and Pipeline</h3><p>图像文字识别应用所作的事是，从一张给定的图片中识别文字。这比从一份扫描文档中识别文字要复杂的多。</p><p>为了完成这样的工作，需要采取如下步骤：</p><ol><li><p>文字侦测（<strong>Text detection</strong>）——将图片上的文字与其他环境对象分离开来</p></li><li><p>字符切分（<strong>Character segmentation</strong>）——将文字分割成一个个单一的字符</p></li><li><p>字符分类（<strong>Character classification</strong>）——确定每一个字符是什么<br>可以用任务流程图来表达这个问题，每一项任务可以由一个单独的小队来负责解决：</p></li></ol><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/610fffb413d8d577882d6345c166a9fb.png" alt></p><h3 id="18-2-滑动窗口"><a href="#18-2-滑动窗口" class="headerlink" title="18.2 滑动窗口"></a>18.2 滑动窗口</h3><p>滑动窗口是一项用来从图像中抽取对象的技术。假使我们需要在一张图片中识别行人，首先要做的是用许多固定尺寸的图片来训练一个能够准确识别行人的模型。然后我们用之前训练识别行人的模型时所采用的图片尺寸在我们要进行行人识别的图片上进行剪裁，然后将剪裁得到的切片交给模型，让模型判断是否为行人，然后在图片上滑动剪裁区域重新进行剪裁，将新剪裁的切片也交给模型进行判断，如此循环直至将图片全部检测完。</p><p>滑动窗口技术也被用于文字识别，首先训练模型能够区分字符与非字符，然后，运用滑动窗口技术识别字符，一旦完成了字符的识别，我们将识别得出的区域进行一些扩展，然后将重叠的区域进行合并。接着我们以宽高比作为过滤条件，过滤掉高度比宽度更大的区域（认为单词的长度通常比高度要大）。</p><p>模型训练完后，我们仍然是使用滑动窗口技术来进行字符识别。</p><p>以上便是字符切分阶段。</p><p>最后一个阶段是字符分类阶段，利用神经网络、支持向量机或者逻辑回归算法训练一个分类器即可。</p><h3 id="18-3-获取大量数据和人工数据"><a href="#18-3-获取大量数据和人工数据" class="headerlink" title="18.3 获取大量数据和人工数据"></a>18.3 获取大量数据和人工数据</h3><p>如果我们的模型是低方差的，那么获得更多的数据用于训练模型，是能够有更好的效果的。问题在于，我们怎样获得数据，数据不总是可以直接获得的，我们有可能需要人工地创造一些数据。</p><p>有关获得更多数据的几种方法：</p><pre><code>1. 人工数据合成2. 手动收集、标记数据3. 众包</code></pre><h3 id="18-4-上限分析：哪部分管道的接下去做"><a href="#18-4-上限分析：哪部分管道的接下去做" class="headerlink" title="18.4 上限分析：哪部分管道的接下去做"></a>18.4 上限分析：哪部分管道的接下去做</h3><p>在机器学习的应用中，我们通常需要通过几个步骤才能进行最终的预测，我们如何能够知道哪一部分最值得我们花时间和精力去改善呢？这个问题可以通过上限分析来回答。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f1ecee10884098f98032648da08f8937.jpg" alt></p><h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结(Conclusion)"></a>总结(Conclusion)</h2><p>作为这门课的结束时间，那么我们学到了些什么呢？在这门课中，我们花了大量的时间介绍了诸如<strong>线性回归、逻辑回归、神经网络、支持向量机</strong>等等一些<strong>监督学习算法</strong>，这类算法具有带标签的数据和样本.</p><p>然后我们也花了很多时间介绍<strong>无监督学习</strong>。例如 <strong>K-均值聚类</strong>、<strong>用于降维的主成分分析</strong>，以及当你只有一系列无标签数据时的<strong>异常检测算法</strong>。</p><p>当然，有时带标签的数据，也可以用于异常检测算法的评估。此外，我们也花时间讨论了一些特别的应用或者特别的话题，比如说<strong>推荐系统</strong>。以及<strong>大规模机器学习系统</strong>，包括<strong>并行系统和映射化简方法，</strong>还有其他一些特别的应用。比如，用于计算机视觉技术的<strong>滑动窗口分类</strong>算法。</p><p>最后，我们还提到了很多关于<strong>构建机器学习系统的实用建议</strong>。这包括了怎样理解某个机器学习算法是否正常工作的原因，所以我们谈到了<strong>偏差和方差</strong>的问题，也谈到了解决<strong>方差问题的正则化</strong>，同时我们也讨论了怎样决定接下来<strong>怎么做</strong>的问题，也就是说当你在开发一个机器学习系统时，什么工作才是接下来应该优先考虑的问题。因此我们讨论了学习算法的<strong>评价法</strong>。介绍了评价矩阵，比如：<strong>查准率、召回率以及F1分数，还有评价学习算法比较实用的训练集、交叉验证集和测试集</strong>。我们也介绍了<strong>学习算法</strong>的调试，以及如何确保学习算法的正常运行，于是我们介绍了一些诊断法，比如<strong>学习曲线</strong>，同时也讨论了<strong>误差分析、上限分析</strong>等等内容。</p><p>所有这些工具都能有效地指引你决定接下来应该怎样做，让你把宝贵的时间用在刀刃上。现在你已经掌握了很多机器学习的工具，包括监督学习算法和无监督学习算法等等。</p><p>但除了这些以外，我更希望你现在不仅仅只是认识这些工具，更重要的是掌握怎样有效地利用这些工具来建立强大的机器学习系统。所以，以上就是这门课的全部内容。如果你跟着我们的课程一路走来，到现在，你应该已经感觉到自己已经成为机器学习方面的专家了吧？</p><p>我们都知道，机器学习是一门对科技、工业产生深远影响的重要学科，而现在，你已经完全具备了应用这些机器学习工具来创造伟大成就的能力。我希望你们中的很多人都能在相应的领域，应用所学的机器学习工具，构建出完美的机器学习系统，开发出无与伦比的产品和应用。并且我也希望你们通过应用机器学习，不仅仅改变自己的生活，有朝一日，还要让更多的人生活得更加美好！</p><p>我也想告诉大家，教这门课对我来讲是一种享受。所以，谢谢大家！</p><p>最后，在结束之前，我还想再多说一点：那就是，也许不久以前我也是一个学生，即使是现在，我也尽可能挤出时间听一些课，学一些新的东西。所以，我深知要坚持学完这门课是很需要花一些时间的，我知道，也许你是一个很忙的人，生活中有很多很多事情要处理。正因如此，你依然挤出时间来观看这些课程视频。我知道，很多视频的时间都长达数小时，你依然花了好多时间来做这些复习题。你们中好多人，还愿意花时间来研究那些编程练习，那些又长又复杂的编程练习。我对你们表示衷心的感谢！我知道你们很多人在这门课中都非常努力，很多人都在这门课上花了很多时间，很多人都为这门课贡献了自己的很多精力。所以，我衷心地希望你们能从这门课中有所收获！</p><p>最后我想说！再次感谢你们选修这门课程！</p><p><strong>Andew Ng</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>申请Coursera奖学金拿证书</p><blockquote><p>I am a Master student at Shang Hai  University which located in China，I’m so sorry I’m so poor to afford the cost in China All my income is just enough to cover my living expense, so I don’t have extra money to register the class. Furthermore, I want to save money for my family Since my parents have been working so hard to support me.For nowadays ，machine learning is so hot not only in China but also in the world I request Coursera for financial aid, and I promise I will finish the course in time. I think Coursera is a very good platform for people to learn something they need, and sincerely hoping to learn something. This program provided by Coursera is a great opportunity for a poor student like me to pursue the course, and I hope I can get the chance. Thank you for your consideration. I hope you can agree with my application. I look forward to your reply.Thank you so much</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Processing</title>
      <link href="/2021/01/22/processing/"/>
      <url>/2021/01/22/processing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter</title>
      <link href="/2021/01/22/flutter/"/>
      <url>/2021/01/22/flutter/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2021寒假计划</title>
      <link href="/2021/01/22/2021/"/>
      <url>/2021/01/22/2021/</url>
      
        <content type="html"><![CDATA[<h1 id="2021寒假计划1-0"><a href="#2021寒假计划1-0" class="headerlink" title="2021寒假计划1.0"></a>2021寒假计划1.0</h1><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210124214306736.png" alt></p><blockquote><p><strong>“哪有什么很忙，只是你觉得当下选择做某件事，而非另一件而已。说白了，一切都是你自己的选择。“</strong></p></blockquote><p>从1.25开始放寒假到2.28刚好是整整五周时间（35天840个小时）</p><p>虽然目前不好说3.1能不能正常返校开学，但是这个寒假还是很短暂的，要利用好时间。</p><h2 id="课内学习"><a href="#课内学习" class="headerlink" title="课内学习"></a>课内学习</h2><h3 id="寒假作业"><a href="#寒假作业" class="headerlink" title="寒假作业"></a>寒假作业</h3><p>数据结构</p><ul><li><input disabled type="checkbox"> 实验四</li><li><input disabled type="checkbox"> 小组作业四</li></ul><p>组成原理</p><ul><li><input disabled type="checkbox"> linkpac实验</li><li><input disabled type="checkbox"> 第五章到第八章课本作业题</li></ul><p>概率论</p><ul><li><input disabled type="checkbox"> 假设检验作业题</li></ul><p>离散数学</p><ul><li><input disabled type="checkbox"> 第四章课后练习</li></ul><h2 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h2><h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>美赛（2.4-2.8）</p><p>计赛（2月底收尾）</p><p>创赛（5月底）</p><h3 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h3><ul><li><input disabled type="checkbox"> 计算机网络</li><li><input disabled type="checkbox"> 操作系统</li><li><input disabled type="checkbox"> 数据结构</li><li><input disabled type="checkbox"> 离散数学</li><li><input disabled type="checkbox"> 复变函数</li></ul><h3 id="温习"><a href="#温习" class="headerlink" title="温习"></a>温习</h3><ul><li><input disabled type="checkbox"> 线性代数</li><li><input disabled type="checkbox"> 微积分</li></ul><h3 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h3><h4 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h4><p>7天</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《西瓜书》</p><h4 id="英语CET-6"><a href="#英语CET-6" class="headerlink" title="英语CET-6"></a>英语CET-6</h4><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>3天</p><p><a href="http://laomengit.com/guide/introduction/mobile_system.html" target="_blank" rel="noopener">Flutter实战</a></p><p><a href="https://www.wolai.com/gfDRYkDNaCU1eg9anNvZay" target="_blank" rel="noopener">Flutter资源整理</a></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>3天</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>3天</p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>3天</p><h4 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h4><h4 id="NLP自然语言处理"><a href="#NLP自然语言处理" class="headerlink" title="NLP自然语言处理"></a>NLP自然语言处理</h4><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>1天</p><h4 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h4><p>1天</p><h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><p>四门专业课考试+毛概</p><p>体育乒乓球</p><h2 id="时间安排表"><a href="#时间安排表" class="headerlink" title="时间安排表"></a>时间安排表</h2><table><thead><tr><th>时间阶段</th><th>具体任务安排</th></tr></thead><tbody><tr><td>第一阶段1.25-2.8(前两周)</td><td>1.25-2.1知识准备（2.4-2.8）正式比赛</td></tr><tr><td>第二阶段2.8-2.14</td><td>Flutter和Java</td></tr><tr><td>第三阶段2.15-2.21</td><td>Linux和MySQL</td></tr><tr><td>第四阶段2.22-2.28</td><td>考试复习</td></tr><tr><td>未知阶段3.1-？</td><td></td></tr></tbody></table><h2 id="资料整理归档"><a href="#资料整理归档" class="headerlink" title="资料整理归档"></a>资料整理归档</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><strong>asoc</strong></p><p><strong>gsoc</strong></p>]]></content>
      
      
      <categories>
          
          <category> 假期计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2021/01/22/java/"/>
      <url>/2021/01/22/java/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Java学习之路"><a href="#我的Java学习之路" class="headerlink" title="我的Java学习之路"></a>我的Java学习之路</h1><blockquote><p>工欲善其事必先利其器。</p></blockquote><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>Jdk:可以理解为就是java本身，你写的java程序必须要Jdk才能执行。</p><p>Eclipse：是写Java代码的地方，它集成了调试、运行、管理等功能于一体。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210123093843490.png" alt="Hello World"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何卖出一瓶水</title>
      <link href="/2021/01/15/guan-yu-yi-ping-shui/"/>
      <url>/2021/01/15/guan-yu-yi-ping-shui/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/v2-569c7994e7598714d44790fbacbf065a_b.jpg" alt="看看这些水"></p><p>作为一个卖水的二道贩子，我们也要学会自己使用思维框架了。</p><p>现在我要提出五个观念，并且使用它们来解决这个在推销中极难的问题——如何卖出一瓶水。</p><p>这个问题实际上是这样的：假设你作为HFDP公司商务部门的一员，你要如何重新策划并在上海引入Kristal这种高端水（玻璃瓶装，国外售价3$/L）</p><p>接下来，我会利用查理芒格有用的普遍观念来尝试解决这个问题。</p><blockquote><p><strong>The first helpful notion is that it is usually best to simplify problems by deciding big “no-brainer” questions first.</strong></p><p><strong>The second helpful notion mimics Galileo’s conclusion that scientific realiry is often revealed only by math as if math was the language of God. Galileo’s attitude also works well in messy, practical life.</strong></p><p><strong>The third helpful norion is that it is not enough to think problems through forward.</strong> You must also think in reverse, much like the rustic who wanted ro know where he was going to die so that he’d never go there. </p><p><strong>The fourth helpful noion is that the best and most pracrical wisdom is elementary academic wisdom.</strong> But there is one extremely important qualification: You must think in a multidisciplinary manner. </p><p><strong>The fifth helpful noion is that really big effects, lollapalooza effects, will often come only from large combinations of factors.</strong></p></blockquote><hr><p><a href="https://zhuanlan.zhihu.com/p/36708872" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 商务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Docker学习</title>
      <link href="/2021/01/02/docker/"/>
      <url>/2021/01/02/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要学习Docker"><a href="#为什么要学习Docker" class="headerlink" title="为什么要学习Docker?"></a>为什么要学习Docker?</h2><p>为了解决环境配置问题</p><h2 id="怎样学习使用Docker"><a href="#怎样学习使用Docker" class="headerlink" title="怎样学习使用Docker?"></a>怎样学习使用Docker?</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网安装</a></p><p>Docker CE 的安装请参考官方文档。<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows版本</a></p><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><blockquote><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><p>——阮一峰</p></blockquote><p>就跟git一样，是为了方便我们程序员的powerful tools 之一。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人机共生》</title>
      <link href="/2021/01/01/ren-ji-gong-sheng/"/>
      <url>/2021/01/01/ren-ji-gong-sheng/</url>
      
        <content type="html"><![CDATA[<p><strong>Man-Computer Symbiosis</strong></p><p><strong>J. C. R. Licklider</strong><br>IRE Transactions on Human Factors in Electronics,<br>volume HFE-1, pages 4-11, March 1960</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote><p>Man-computer symbiosis is an expected development in cooperative interaction between men and electronic computers. It will involve very close coupling between the human and the electronic members of the partnership. The main aims are 1) to let computers facilitate formulative thinking as they now facilitate the solution of formulated problems, and 2) to enable men and computers to cooperate in making decisions and controlling complex situations without inflexible dependence on predetermined programs. In the anticipated symbiotic partnership, men will set the goals, formulate the hypotheses, determine the criteria, and perform the evaluations. Computing machines will do the routinizable work that must be done to prepare the way for insights and decisions in technical and scientific thinking. Preliminary analyses indicate that the symbiotic partnership will perform intellectual operations much more effectively than man alone can perform them. Prerequisites for the achievement of the effective, cooperative association include developments in computer time sharing, in memory components, in memory organization, in programming languages, and in input and output equipment.</p></blockquote><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><h2 id="1-1-Symbiosis"><a href="#1-1-Symbiosis" class="headerlink" title="1.1 Symbiosis"></a>1.1 Symbiosis</h2><p>The fig tree is pollinated only by the insect <em>Blastophaga grossorun</em>. The larva of the insect lives in the ovary of the fig tree, and there it gets its food. The tree and the insect are thus heavily interdependent: the tree cannot reproduce wit bout the insect; the insect cannot eat wit bout the tree; together, they constitute not only a viable but a productive and thriving partnership. This cooperative “living together in intimate association, or even close union, of two dissimilar organisms” is called symbiosis [27].</p><p>“Man-computer symbiosis is a subclass of man-machine systems. There are many man-machine systems. At present, however, there are no man-computer symbioses. The purposes of this paper are to present the concept and, hopefully, to foster the development of man-computer symbiosis by analyzing some problems of interaction between men and computing machines, calling attention to applicable principles of man-machine engineering, and pointing out a few questions to which research answers are needed. The hope is that, in not too many years, human brains and computing machines will be coupled together very tightly, and that the resulting partnership will think as no human brain has ever thought and process data in a way not approached by the information-handling machines we know today.</p><h2 id="1-2-Between-“Mechanically-Extended-Man”-and-“Artificial-Intelligence”"><a href="#1-2-Between-“Mechanically-Extended-Man”-and-“Artificial-Intelligence”" class="headerlink" title="1.2 Between “Mechanically Extended Man” and “Artificial Intelligence”"></a>1.2 Between “Mechanically Extended Man” and “Artificial Intelligence”</h2><p>As a concept, man-computer symbiosis is different in an important way from what North [21] has called “mechanically extended man.” In the man-machine systems of the past, the human operator supplied the initiative, the direction, the integration, and the criterion. The mechanical parts of the systems were mere extensions, first of the human arm, then of the human eye. These systems certainly did not consist of “dissimilar organisms living together…” There was only one kind of organism-man-and the rest was there only to help him.</p><p>In one sense of course, any man-made system is intended to help man, to help a man or men outside the system. If we focus upon the human operator within the system, however, we see that, in some areas of technology, a fantastic change has taken place during the last few years. “Mechanical extension” has given way to replacement of men, to automation, and the men who remain are there more to help than to be helped. In some instances, particularly in large computer-centered information and control systems, the human operators are responsible mainly for functions that it proved infeasible to automate. Such systems (“humanly extended machines,” North might call them) are not symbiotic systems. They are “semi-automatic” systems, systems that started out to be fully automatic but fell short of the goal.</p><p>Man-computer symbiosis is probably not the ultimate paradigm for complex technological systems. It seems entirely possible that, in due course, electronic or chemical “machines” will outdo the human brain in most of the functions we now consider exclusively within its province. Even now, Gelernter’s IBM-704 program for proving theorems in plane geometry proceeds at about the same pace as Brooklyn high school students, and makes similar errors.[12] There are, in fact, several theorem-proving, problem-solving, chess-playing, and pattern-recognizing programs (too many for complete reference [1, 2, 5, 8, 11, 13, 17, 18, 19, 22, 23, 25]) capable of rivaling human intellectual performance in restricted areas; and Newell, Simon, and Shaw’s [20] “general problem solver” may remove some of the restrictions. In short, it seems worthwhile to avoid argument with (other) enthusiasts for artificial intelligence by conceding dominance in the distant future of cerebration to machines alone. There will nevertheless be a fairly long interim during which the main intellectual advances will be made by men and computers working together in intimate association. A multidisciplinary study group, examining future research and development problems of the Air Force, estimated that it would be 1980 before developments in artificial intelligence make it possible for machines alone to do much thinking or problem solving of military significance. That would leave, say, five years to develop man-computer symbiosis and 15 years to use it. The 15 may be 10 or 500, but those years should be intellectually the most creative and exciting in the history of mankind.</p><h1 id="2-Aims-of-Man-Computer-Symbiosis"><a href="#2-Aims-of-Man-Computer-Symbiosis" class="headerlink" title="2 Aims of Man-Computer Symbiosis"></a>2 Aims of Man-Computer Symbiosis</h1><p>Present-day computers are designed primarily to solve preformulated problems or to process data according to predetermined procedures. The course of the computation may be conditional upon results obtained during the computation, but all the alternatives must be foreseen in advance. (If an unforeseen alternative arises, the whole process comes to a halt and awaits the necessary extension of the program.) The requirement for preformulation or predetermination is sometimes no great disadvantage. It is often said that programming for a computing machine forces one to think clearly, that it disciplines the thought process. If the user can think his problem through in advance, symbiotic association with a computing machine is not necessary.</p><p>However, many problems that can be thought through in advance are very difficult to think through in advance. They would be easier to solve, and they could be solved faster, through an intuitively guided trial-and-error procedure in which the computer cooperated, turning up flaws in the reasoning or revealing unexpected turns in the solution. Other problems simply cannot be formulated without computing-machine aid. Poincare anticipated the frustration of an important group of would-be computer users when he said, “The question is not, ‘What is the answer?’ The question is, ‘What is the question?’” One of the main aims of man-computer symbiosis is to bring the computing machine effectively into the formulative parts of technical problems.</p><p>The other main aim is closely related. It is to bring computing machines effectively into processes of thinking that must go on in “real time,” time that moves too fast to permit using computers in conventional ways. Imagine trying, for example, to direct a battle with the aid of a computer on such a schedule as this. You formulate your problem today. Tomorrow you spend with a programmer. Next week the computer devotes 5 minutes to assembling your program and 47 seconds to calculating the answer to your problem. You get a sheet of paper 20 feet long, full of numbers that, instead of providing a final solution, only suggest a tactic that should be explored by simulation. Obviously, the battle would be over before the second step in its planning was begun. To think in interaction with a computer in the same way that you think with a colleague whose competence supplements your own will require much tighter coupling between man and machine than is suggested by the example and than is possible today.</p><h1 id="3-Need-for-Computer-Participation-in-Formulative-and-Real-Time-Thinking"><a href="#3-Need-for-Computer-Participation-in-Formulative-and-Real-Time-Thinking" class="headerlink" title="3 Need for Computer Participation in Formulative and Real-Time Thinking"></a>3 Need for Computer Participation in Formulative and Real-Time Thinking</h1><p>The preceding paragraphs tacitly made the assumption that, if they could be introduced effectively into the thought process, the functions that can be performed by data-processing machines would improve or facilitate thinking and problem solving in an important way. That assumption may require justification.</p><h2 id="3-1-A-Preliminary-and-Informal-Time-and-Motion-Analysis-of-Technical-Thinking"><a href="#3-1-A-Preliminary-and-Informal-Time-and-Motion-Analysis-of-Technical-Thinking" class="headerlink" title="3.1 A Preliminary and Informal Time-and-Motion Analysis of Technical Thinking"></a>3.1 A Preliminary and Informal Time-and-Motion Analysis of Technical Thinking</h2><p>Despite the fact that there is a voluminous literature on thinking and problem solving, including intensive case-history studies of the process of invention, I could find nothing comparable to a time-and-motion-study analysis of the mental work of a person engaged in a scientific or technical enterprise. In the spring and summer of 1957, therefore, I tried to keep track of what one moderately technical person actually did during the hours he regarded as devoted to work. Although I was aware of the inadequacy of the sampling, I served as my own subject.</p><p>It soon became apparent that the main thing I did was to keep records, and the project would have become an infinite regress if the keeping of records had been carried through in the detail envisaged in the initial plan. It was not. Nevertheless, I obtained a picture of my activities that gave me pause. Perhaps my spectrum is not typical–I hope it is not, but I fear it is.</p><p>About 85 per cent of my “thinking” time was spent getting into a position to think, to make a decision, to learn something I needed to know. Much more time went into finding or obtaining information than into digesting it. Hours went into the plotting of graphs, and other hours into instructing an assistant how to plot. When the graphs were finished, the relations were obvious at once, but the plotting had to be done in order to make them so. At one point, it was necessary to compare six experimental determinations of a function relating speech-intelligibility to speech-to-noise ratio. No two experimenters had used the same definition or measure of speech-to-noise ratio. Several hours of calculating were required to get the data into comparable form. When they were in comparable form, it took only a few seconds to determine what I needed to know.</p><p>Throughout the period I examined, in short, my “thinking” time was devoted mainly to activities that were essentially clerical or mechanical: searching, calculating, plotting, transforming, determining the logical or dynamic consequences of a set of assumptions or hypotheses, preparing the way for a decision or an insight. Moreover, my choices of what to attempt and what not to attempt were determined to an embarrassingly great extent by considerations of clerical feasibility, not intellectual capability.</p><p>The main suggestion conveyed by the findings just described is that the operations that fill most of the time allegedly devoted to technical thinking are operations that can be performed more effectively by machines than by men. Severe problems are posed by the fact that these operations have to be performed upon diverse variables and in unforeseen and continually changing sequences. If those problems can be solved in such a way as to create a symbiotic relation between a man and a fast information-retrieval and data-processing machine, however, it seems evident that the cooperative interaction would greatly improve the thinking process.</p><p>It may be appropriate to acknowledge, at this point, that we are using the term “computer” to cover a wide class of calculating, data-processing, and information-storage-and-retrieval machines. The capabilities of machines in this class are increasing almost daily. It is therefore hazardous to make general statements about capabilities of the class. Perhaps it is equally hazardous to make general statements about the capabilities of men. Nevertheless, certain genotypic differences in capability between men and computers do stand out, and they have a bearing on the nature of possible man-computer symbiosis and the potential value of achieving it.</p><p>As has been said in various ways, men are noisy, narrow-band devices, but their nervous systems have very many parallel and simultaneously active channels. Relative to men, computing machines are very fast and very accurate, but they are constrained to perform only one or a few elementary operations at a time. Men are flexible, capable of “programming themselves contingently” on the basis of newly received information. Computing machines are single-minded, constrained by their “ pre-programming.” Men naturally speak redundant languages organized around unitary objects and coherent actions and employing 20 to 60 elementary symbols. Computers “naturally” speak nonredundant languages, usually with only two elementary symbols and no inherent appreciation either of unitary objects or of coherent actions.</p><p>To be rigorously correct, those characterizations would have to include many qualifiers. Nevertheless, the picture of dissimilarity (and therefore p0tential supplementation) that they present is essentially valid. Computing machines can do readily, well, and rapidly many things that are difficult or impossible for man, and men can do readily and well, though not rapidly, many things that are difficult or impossible for computers. That suggests that a symbiotic cooperation, if successful in integrating the positive characteristics of men and computers, would be of great value. The differences in speed and in language, of course, pose difficulties that must be overcome.</p><h1 id="4-Separable-Functions-of-Men-and-Computers-in-the-Anticipated-Symbiotic-Association"><a href="#4-Separable-Functions-of-Men-and-Computers-in-the-Anticipated-Symbiotic-Association" class="headerlink" title="4 Separable Functions of Men and Computers in the Anticipated Symbiotic Association"></a>4 Separable Functions of Men and Computers in the Anticipated Symbiotic Association</h1><p>It seems likely that the contributions of human operators and equipment will blend together so completely in many operations that it will be difficult to separate them neatly in analysis. That would be the case it; in gathering data on which to base a decision, for example, both the man and the computer came up with relevant precedents from experience and if the computer then suggested a course of action that agreed with the man’s intuitive judgment. (In theorem-proving programs, computers find precedents in experience, and in the SAGE System, they suggest courses of action. The foregoing is not a far-fetched example. ) In other operations, however, the contributions of men and equipment will be to some extent separable.</p><p>Men will set the goals and supply the motivations, of course, at least in the early years. They will formulate hypotheses. They will ask questions. They will think of mechanisms, procedures, and models. They will remember that such-and-such a person did some possibly relevant work on a topic of interest back in 1947, or at any rate shortly after World War II, and they will have an idea in what journals it might have been published. In general, they will make approximate and fallible, but leading, contributions, and they will define criteria and serve as evaluators, judging the contributions of the equipment and guiding the general line of thought.</p><p>In addition, men will handle the very-low-probability situations when such situations do actually arise. (In current man-machine systems, that is one of the human operator’s most important functions. The sum of the probabilities of very-low-probability alternatives is often much too large to neglect. ) Men will fill in the gaps, either in the problem solution or in the computer program, when the computer has no mode or routine that is applicable in a particular circumstance.</p><p>The information-processing equipment, for its part, will convert hypotheses into testable models and then test the models against data (which the human operator may designate roughly and identify as relevant when the computer presents them for his approval). The equipment will answer questions. It will simulate the mechanisms and models, carry out the procedures, and display the results to the operator. It will transform data, plot graphs (“cutting the cake” in whatever way the human operator specifies, or in several alternative ways if the human operator is not sure what he wants). The equipment will interpolate, extrapolate, and transform. It will convert static equations or logical statements into dynamic models so the human operator can examine their behavior. In general, it will carry out the routinizable, clerical operations that fill the intervals between decisions.</p><p>In addition, the computer will serve as a statistical-inference, decision-theory, or game-theory machine to make elementary evaluations of suggested courses of action whenever there is enough basis to support a formal statistical analysis. Finally, it will do as much diagnosis, pattern-matching, and relevance-recognizing as it profitably can, but it will accept a clearly secondary status in those areas.</p><h1 id="5-Prerequisites-for-Realization-of-Man-Computer-Symbiosis"><a href="#5-Prerequisites-for-Realization-of-Man-Computer-Symbiosis" class="headerlink" title="5 Prerequisites for Realization of Man-Computer Symbiosis"></a>5 Prerequisites for Realization of Man-Computer Symbiosis</h1><p>The data-processing equipment tacitly postulated in the preceding section is not available. The computer programs have not been written. There are in fact several hurdles that stand between the nonsymbiotic present and the anticipated symbiotic future. Let us examine some of them to see more clearly what is needed and what the chances are of achieving it.</p><h2 id="5-1-Speed-Mismatch-Between-Men-and-Computers"><a href="#5-1-Speed-Mismatch-Between-Men-and-Computers" class="headerlink" title="5.1 Speed Mismatch Between Men and Computers"></a>5.1 Speed Mismatch Between Men and Computers</h2><p>Any present-day large-scale computer is too fast and too costly for real-time cooperative thinking with one man. Clearly, for the sake of efficiency and economy, the computer must divide its time among many users. Timesharing systems are currently under active development. There are even arrangements to keep users from “clobbering” anything but their own personal programs.</p><p>It seems reasonable to envision, for a time 10 or 15 years hence, a “thinking center” that will incorporate the functions of present-day libraries together with anticipated advances in information storage and retrieval and the symbiotic functions suggested earlier in this paper. The picture readily enlarges itself into a network of such centers, connected to one another by wide-band communication lines and to individual users by leased-wire services. In such a system, the speed of the computers would be balanced, and the cost of the gigantic memories and the sophisticated programs would be divided by the number of users.</p><h2 id="5-2-Memory-Hardware-Requirements"><a href="#5-2-Memory-Hardware-Requirements" class="headerlink" title="5.2 Memory Hardware Requirements"></a>5.2 Memory Hardware Requirements</h2><p>When we start to think of storing any appreciable fraction of a technical literature in computer memory, we run into billions of bits and, unless things change markedly, billions of dollars.</p><p>The first thing to face is that we shall not store all the technical and scientific papers in computer memory. We may store the parts that can be summarized most succinctly-the quantitative parts and the reference citations-but not the whole. Books are among the most beautifully engineered, and human-engineered, components in existence, and they will continue to be functionally important within the context of man-computer symbiosis. (Hopefully, the computer will expedite the finding, delivering, and returning of books.)</p><p>The second point is that a very important section of memory will be permanent: part indelible <em>memory</em> and part <em>published memory</em>. The computer will be able to write once into indelible memory, and then read back indefinitely, but the computer will not be able to erase indelible memory. (It may also over-write, turning all the 0’s into l’s, as though marking over what was written earlier.) Published memory will be “read-only” memory. It will be introduced into the computer already structured. The computer will be able to refer to it repeatedly, but not to change it. These types of memory will become more and more important as computers grow larger. They can be made more compact than core, thin-film, or even tape memory, and they will be much less expensive. The main engineering problems will concern selection circuitry.</p><p>In so far as other aspects of memory requirement are concerned, we may count upon the continuing development of ordinary scientific and business computing machines There is some prospect that memory elements will become as fast as processing (logic) elements. That development would have a revolutionary effect upon the design of computers.</p><h2 id="5-3-Memory-Organization-Requirements"><a href="#5-3-Memory-Organization-Requirements" class="headerlink" title="5.3 Memory Organization Requirements"></a>5.3 Memory Organization Requirements</h2><p>Implicit in the idea of man-computer symbiosis are the requirements that information be retrievable both by name and by pattern and that it be accessible through procedure much faster than serial search. At least half of the problem of memory organization appears to reside in the storage procedure. Most of the remainder seems to be wrapped up in the problem of pattern recognition within the storage mechanism or medium. Detailed discussion of these problems is beyond the present scope. However, a brief outline of one promising idea, “trie memory,” may serve to indicate the general nature of anticipated developments.</p><p>Trie memory is so called by its originator, Fredkin [10], because it is designed to facilitate retrieval of information and because the branching storage structure, when developed, resembles a tree. Most common memory systems store functions of arguments at locations designated by the arguments. (In one sense, they do not store the arguments at all. In another and more realistic sense, they store all the possible arguments in the framework structure of the memory.) The trie memory system, on the other hand, stores both the functions and the arguments. The argument is introduced into the memory first, one character at a time, starting at a standard initial register. Each argument register has one cell for each character of the ensemble (e.g., two for information encoded in binary form) and each character cell has within it storage space for the address of the next register. The argument is stored by writing a series of addresses, each one of which tells where to find the next. At the end of the argument is a special “end-of-argument” marker. Then follow directions to the function, which is stored in one or another of several ways, either further trie structure or “list structure” often being most effective.</p><p>The trie memory scheme is inefficient for small memories, but it becomes increasingly efficient in using available storage space as memory size increases. The attractive features of the scheme are these: 1) The retrieval process is extremely simple. Given the argument, enter the standard initial register with the first character, and pick up the address of the second. Then go to the second register, and pick up the address of the third, etc. 2) If two arguments have initial characters in common, they use the same storage space for those characters. 3) The lengths of the arguments need not be the same, and need not be specified in advance. 4) No room in storage is reserved for or used by any argument until it is actually stored. The trie structure is created as the items are introduced into the memory. 5) A function can be used as an argument for another function, and that function as an argument for the next. Thus, for example, by entering with the argument, “matrix multiplication,” one might retrieve the entire program for performing a matrix multiplication on the computer. 6) By examining the storage at a given level, one can determine what thus-far similar items have been stored. For example, if there is no citation for Egan, J. P., it is but a step or two backward to pick up the trail of Egan, James … .</p><p>The properties just described do not include all the desired ones, but they bring computer storage into resonance with human operators and their predilection to designate things by naming or pointing.</p><h2 id="5-4-The-Language-Problem"><a href="#5-4-The-Language-Problem" class="headerlink" title="5.4 The Language Problem"></a>5.4 The Language Problem</h2><p>The basic dissimilarity between human languages and computer languages may be the most serious obstacle to true symbiosis. It is reassuring, however, to note what great strides have already been made, through interpretive programs and particularly through assembly or compiling programs such as FORTRAN, to adapt computers to human language forms. The “Information Processing Language” of Shaw, Newell, Simon, and Ellis [24] represents another line of rapprochement. And, in ALGOL and related systems, men are proving their flexibility by adopting standard formulas of representation and expression that are readily translatable into machine language.</p><p>For the purposes of real-time cooperation between men and computers, it will be necessary, however, to make use of an additional and rather different principle of communication and control. The idea may be highlighted by comparing instructions ordinarily addressed to intelligent human beings with instructions ordinarily used with computers. The latter specify precisely the individual steps to take and the sequence in which to take them. The former present or imply something about incentive or motivation, and they supply a criterion by which the human executor of the instructions will know when he has accomplished his task. In short: instructions directed to computers specify courses; instructions-directed to human beings specify goals.</p><p>Men appear to think more naturally and easily in terms of goals than in terms of courses. True, they usually know something about directions in which to travel or lines along which to work, but few start out with precisely formulated itineraries. Who, for example, would depart from Boston for Los Angeles with a detailed specification of the route? Instead, to paraphrase Wiener, men bound for Los Angeles try continually to decrease the amount by which they are not yet in the smog.</p><p>Computer instruction through specification of goals is being approached along two paths. The first involves problem-solving, hill-climbing, self-organizing programs. The second involves real-time concatenation of preprogrammed segments and closed subroutines which the human operator can designate and call into action simply by name.</p><p>Along the first of these paths, there has been promising exploratory work. It is clear that, working within the loose constraints of predetermined strategies, computers will in due course be able to devise and simplify their own procedures for achieving stated goals. Thus far, the achievements have not been substantively important; they have constituted only “demonstration in principle.” Nevertheless, the implications are far-reaching.</p><p>Although the second path is simpler and apparently capable of earlier realization, it has been relatively neglected. Fredkin’s trie memory provides a promising paradigm. We may in due course see a serious effort to develop computer programs that can be connected together like the words and phrases of speech to do whatever computation or control is required at the moment. The consideration that holds back such an effort, apparently, is that the effort would produce nothing that would be of great value in the context of existing computers. It would be unrewarding to develop the language before there are any computing machines capable of responding meaningfully to it.</p><h2 id="5-5-Input-and-Output-Equipment"><a href="#5-5-Input-and-Output-Equipment" class="headerlink" title="5.5 Input and Output Equipment"></a>5.5 Input and Output Equipment</h2><p>The department of data processing that seems least advanced, in so far as the requirements of man-computer symbiosis are concerned, is the one that deals with input and output equipment or, as it is seen from the human operator’s point of view, displays and controls. Immediately after saying that, it is essential to make qualifying comments, because the engineering of equipment for high-speed introduction and extraction of information has been excellent, and because some very sophisticated display and control techniques have been developed in such research laboratories as the Lincoln Laboratory. By and large, in generally available computers, however, there is almost no provision for any more effective, immediate man-machine communication than can be achieved with an electric typewriter.</p><p>Displays seem to be in a somewhat better state than controls. Many computers plot graphs on oscilloscope screens, and a few take advantage of the remarkable capabilities, graphical and symbolic, of the charactron display tube. Nowhere, to my knowledge, however, is there anything approaching the flexibility and convenience of the pencil and doodle pad or the chalk and blackboard used by men in technical discussion.</p><p>1) <em>Desk-Surface Display and Control:</em> Certainly, for effective man-computer interaction, it will be necessary for the man and the computer to draw graphs and pictures and to write notes and equations to each other on the same display surface. The man should be able to present a function to the computer, in a rough but rapid fashion, by drawing a graph. The computer should read the man’s writing, perhaps on the condition that it be in clear block capitals, and it should immediately post, at the location of each hand-drawn symbol, the corresponding character as interpreted and put into precise type-face. With such an input-output device, the operator would quickly learn to write or print in a manner legible to the machine. He could compose instructions and subroutines, set them into proper format, and check them over before introducing them finally into the computer’s main memory. He could even define new symbols, as Gilmore and Savell [14] have done at the Lincoln Laboratory, and present them directly to the computer. He could sketch out the format of a table roughly and let the computer shape it up with precision. He could correct the computer’s data, instruct the machine via flow diagrams, and in general interact with it very much as he would with another engineer, except that the “other engineer” would be a precise draftsman, a lightning calculator, a mnemonic wizard, and many other valuable partners all in one.</p><p>2) <em>Computer-Posted Wall Display:</em> In some technological systems, several men share responsibility for controlling vehicles whose behaviors interact. Some information must be presented simultaneously to all the men, preferably on a common grid, to coordinate their actions. Other information is of relevance only to one or two operators. There would be only a confusion of uninterpretable clutter if all the information were presented on one display to all of them. The information must be posted by a computer, since manual plotting is too slow to keep it up to date.</p><p>The problem just outlined is even now a critical one, and it seems certain to become more and more critical as time goes by. Several designers are convinced that displays with the desired characteristics can be constructed with the aid of flashing lights and time-sharing viewing screens based on the light-valve principle.</p><p>The large display should be supplemented, according to most of those who have thought about the problem, by individual display-control units. The latter would permit the operators to modify the wall display without leaving their locations. For some purposes, it would be desirable for the operators to be able to communicate with the computer through the supplementary displays and perhaps even through the wall display. At least one scheme for providing such communication seems feasible.</p><p>The large wall display and its associated system are relevant, of course, to symbiotic cooperation between a computer and a team of men. Laboratory experiments have indicated repeatedly that informal, parallel arrangements of operators, coordinating their activities through reference to a large situation display, have important advantages over the arrangement, more widely used, that locates the operators at individual consoles and attempts to correlate their actions through the agency of a computer. This is one of several operator-team problems in need of careful study.</p><p>3) <em>Automatic Speech Production and Recognition:</em> How desirable and how feasible is speech communication between human operators and computing machines? That compound question is asked whenever sophisticated data-processing systems are discussed. Engineers who work and live with computers take a conservative attitude toward the desirability. Engineers who have had experience in the field of automatic speech recognition take a conservative attitude toward the feasibility. Yet there is continuing interest in the idea of talking with computing machines. In large part, the interest stems from realization that one can hardly take a military commander or a corporation president away from his work to teach him to type. If computing machines are ever to be used directly by top-level decision makers, it may be worthwhile to provide communication via the most natural means, even at considerable cost.</p><p>Preliminary analysis of his problems and time scales suggests that a corporation president would be interested in a symbiotic association with a computer only as an avocation. Business situations usually move slowly enough that there is time for briefings and conferences. It seems reasonable, therefore, for computer specialists to be the ones who interact directly with computers in business offices.</p><p>The military commander, on the other hand, faces a greater probability of having to make critical decisions in short intervals of time. It is easy to overdramatize the notion of the ten-minute war, but it would be dangerous to count on having more than ten minutes in which to make a critical decision. As military system ground environments and control centers grow in capability and complexity, therefore, a real requirement for automatic speech production and recognition in computers seems likely to develop. Certainly, if the equipment were already developed, reliable, and available, it would be used.</p><p>In so far as feasibility is concerned, speech production poses less severe problems of a technical nature than does automatic recognition of speech sounds. A commercial electronic digital voltmeter now reads aloud its indications, digit by digit. For eight or ten years, at the Bell Telephone Laboratories, the Royal Institute of Technology (Stockholm), the Signals Research and Development Establishment (Christchurch), the Haskins Laboratory, and the Massachusetts Institute of Technology, Dunn [6], Fant [7], Lawrence [15], Cooper [3], Stevens [26], and their co-workers, have demonstrated successive generations of intelligible automatic talkers. Recent work at the Haskins Laboratory has led to the development of a digital code, suitable for use by computing machines, that makes an automatic voice utter intelligible connected discourse [16].</p><p>The feasibility of automatic speech recognition depends heavily upon the size of the vocabulary of words to be recognized and upon the diversity of talkers and accents with which it must work. Ninety-eight per cent correct recognition of naturally spoken decimal digits was demonstrated several years ago at the Bell Telephone Laboratories and at the Lincoln Laboratory [4], [9]. To go a step up the scale of vocabulary size, we may say that an automatic recognizer of clearly spoken alpha-numerical characters can almost surely be developed now on the basis of existing knowledge. Since untrained operators can read at least as rapidly as trained ones can type, such a device would be a convenient tool in almost any computer installation.</p><p>For real-time interaction on a truly symbiotic level, however, a vocabulary of about 2000 words, e.g., 1000 words of something like basic English and 1000 technical terms, would probably be required. That constitutes a challenging problem. In the consensus of acousticians and linguists, construction of a recognizer of 2000 words cannot be accomplished now. However, there are several organizations that would happily undertake to develop an automatic recognize for such a vocabulary on a five-year basis. They would stipulate that the speech be clear speech, dictation style, without unusual accent.</p><p>Although detailed discussion of techniques of automatic speech recognition is beyond the present scope, it is fitting to note that computing machines are playing a dominant role in the development of automatic speech recognizers. They have contributed the impetus that accounts for the present optimism, or rather for the optimism presently found in some quarters. Two or three years ago, it appeared that automatic recognition of sizeable vocabularies would not be achieved for ten or fifteen years; that it would have to await much further, gradual accumulation of knowledge of acoustic, phonetic, linguistic, and psychological processes in speech communication. Now, however, many see a prospect of accelerating the acquisition of that knowledge with the aid of computer processing of speech signals, and not a few workers have the feeling that sophisticated computer programs will be able to perform well as speech-pattern recognizes even without the aid of much substantive knowledge of speech signals and processes. Putting those two considerations together brings the estimate of the time required to achieve practically significant speech recognition down to perhaps five years, the five years just mentioned.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] A. Bernstein and M. deV. Roberts, “Computer versus chess-player,” <em>Scientific American</em>, vol. 198, pp. 96-98; June, 1958.</p><p>[2] W. W. Bledsoe and I. Browning, “Pattern Recognition and Reading by Machine,” presented at the Eastern Joint Computer Conf, Boston, Mass., December, 1959.</p><p>[3] F. S. Cooper, et al., “Some experiments on the perception of synthetic speech sounds,” <em>J. Acoust Soc. Amer.</em>, vol.24, pp.597-606; November, 1952.</p><p>[4] K. H. Davis, R. Biddulph, and S. Balashek, “Automatic recognition of spoken digits,” in W. Jackson, <em>Communication Theory</em>, Butterworths Scientific Publications, London, Eng., pp. 433-441; 1953.</p><p>[5] G. P. Dinneen, “Programming pattern recognition,” <em>Proc. WJCC</em>, pp. 94-100; March, 1955.</p><p>[6] H. K. Dunn, “The calculation of vowel resonances, and an electrical vocal tract,” <em>J. Acoust Soc. Amer.</em>, vol. 22, pp.740-753; November, 1950.</p><p>[7] G. Fant, “On the Acoustics of Speech,” paper presented at the Third Internatl. Congress on Acoustics, Stuttgart, Ger.; September, 1959.</p><p>[8] B. G. Farley and W. A. Clark, “Simulation of self-organizing systems by digital computers.” <em>IRE Trans. on Information Theory</em>, vol. IT-4, pp.76-84; September, 1954</p><p>[9] J. W. Forgie and C. D. Forgie, “Results obtained from a vowel recognition computer program,” <em>J. Acoust Soc. Amer.</em>, vol. 31, pp. 1480-1489; November, 1959</p><p>[10] E. Fredkin, “Trie memory,” <em>Communications of the ACM</em>, Sept. 1960, pp. 490-499</p><p>[11] R. M. Friedberg, “A learning machine: Part I,” <em>IBM J. Res. &amp; Dev.</em>, vol.2, pp.2-13; January, 1958.</p><p>[12] H. Gelernter, “Realization of a Geometry Theorem Proving Machine.” Unesco, NS, ICIP, 1.6.6, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[13] P. C. Gilmore, “A Program for the Production of Proofs for Theorems Derivable Within the First Order Predicate Calculus from Axioms,” Unesco, NS, ICIP, 1.6.14, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[14] J. T. Gilmore and R. E. Savell, “The Lincoln Writer,” Lincoln Laboratory, M. I. T., Lexington, Mass., Rept. 51-8; October, 1959.</p><p>[15] W. Lawrence, et al., “Methods and Purposes of Speech Synthesis,” Signals Res. and Dev. Estab., Ministry of Supply, Christchurch, Hants, England, Rept. 56/1457; March, 1956.</p><p>[16] A. M. Liberman, F. Ingemann, L. Lisker, P. Delattre, and F. S. Cooper, “Minimal rules for synthesizing speech,” <em>J. Acoust Soc. Amer.</em>, vol. 31, pp. 1490-1499; November, 1959.</p><p>[17] A. Newell, “The chess machine: an example of dealing with a complex task by adaptation,” <em>Proc. WJCC</em>, pp. 101-108; March, 1955.</p><p>[18] A. Newell and J. C. Shaw, “Programming the logic theory machine.” <em>Proc. WJCC</em>, pp. 230-240; March, 1957.</p><p>[19] A. Newell, J. C. Shaw, and H. A. Simon, “Chess-playing programs and the problem of complexity,” <em>IBM J. Res &amp; Dev.</em>, vol.2, pp. 320-33.5; October, 1958.</p><p>[20] A. Newell, H. A. Simon, and J. C. Shaw, “Report on a general problem-solving program,” Unesco, NS, ICIP, 1.6.8, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[21] J. D. North, “The rational behavior of mechanically extended man”, Boulton Paul Aircraft Ltd., Wolverhampton, Eng.; September, 1954.</p><p>[22] 0. G. Selfridge, “Pandemonium, a paradigm for learning,” <em>Proc. Symp. Mechanisation of Thought Processes</em>, Natl. Physical Lab., Teddington, Eng.; November, 1958.</p><p>[23] C. E. Shannon, “Programming a computer for playing chess,” <em>Phil. Mag.</em>, vol.41, pp.256-75; March, 1950.</p><p>[24] J. C. Shaw, A. Newell, H. A. Simon, and T. O. Ellis, “A command structure for complex information processing,” <em>Proc. WJCC</em>, pp. 119-128; May, 1958.</p><p>[25] H. Sherman, “A Quasi-Topological Method for Recognition of Line Patterns,” Unesco, NS, ICIP, H.L.5, Internatl. Conf. on Information Processing, Paris, France; June, 1959</p><p>[26] K. N. Stevens, S. Kasowski, and C. G. Fant, “Electric analog of the vocal tract,” <em>J. Acoust. Soc. Amer.</em>, vol. 25, pp. 734-742; July, 1953.</p><p>[27] <em>Webster’s New International Dictionary</em>, 2nd e., G. and C. Merriam Co., Springfield, Mass., p. 2555; 1958.</p><hr><h1 id="中文翻译参考"><a href="#中文翻译参考" class="headerlink" title="中文翻译参考"></a>中文翻译参考</h1><p>摘要</p><p>人机共生是人类和电子计算机之间合作互动的一个预期发展。这将涉及人类和电子设备之间非常密切的耦合。主要目的是1）让计算机促进公式化思维，因为它们现在促进了公式化问题的解决；2）让人类和计算机能够合作做出决策和控制复杂的情况，而不依赖于预先确定的程序。在预期的共生伙伴关系中，人类将设定目标，制定假设，确定标准，并进行评估。计算机将会做一些常规的工作，为人类在技术和科学思考方面的见解和决策做好准备。初步分析表明，共生伙伴关系将比单独的人能更有效地进行智力活动。实现有效合作关系的先决条件包括计算机分时、内存组件、内存组织、编程语言以及输入和输出设备的发展。</p><p>1介绍</p><p>1.1共生</p><p>只有无花果小黄蜂（Blastophaga grossorun）才能帮助无花果树完成授粉。这种昆虫的幼体生活在无花果树的子房中，它们也能在无花果树的子房中找到食物。如此一来，无花果树和无花果小黄蜂便对彼此有着严重的依赖：没有无花果小黄蜂，无花果树就不能结出果实；没有无花果树，无花果小黄蜂也不能获得食物。两者的结合不仅能使彼此生存下去，更能创造一种高产且生机勃勃的合作关系。“两个不同的生物体以亲密合作的方式生活在一起，甚至结成紧密的联盟”，这种合作模式就叫共生。</p><p>人机共生是人机系统的一个子类。有许多人机系统。然而，目前还没有人机共生体。本文的目的是提出这一概念，并希望通过分析人机交互的一些问题，提请人们注意人机工程的适用原则，并指出一些需要研究回答的问题，从而促进人机共生的发展。我们希望，在不太长的时间内，人脑和计算机将紧密结合在一起，由此产生的伙伴关系将会认为，没有人脑能够以我们今天所知的信息处理机器所未有的方式思考和处理数据。</p><p>1.2在“机器增强的人类”和“人工智能”之间</p><p>作为一个概念，人机共生在一个重要的方面与North所称的“机器增强的人类”是不同的。在过去的人机系统中，操作者掌握主动权，提供方向，进行整合，制定标准。系统中机械的部分，首先是人类的胳膊，然后是眼睛的延伸。这些系统当然不是由“生活在一起的不同生物”组成的。只有一种有机体——人，其余的只是为了帮助这个人。</p><p>在某种意义上，任何人造系统都是为了帮助人类，帮助系统外的一个或多个人。然而，如果我们关注系统内的操作人员，我们会发现，在某些技术领域，过去几年发生了巨大的变化。“机器增强”已经取代了人类，转向了自动化，留下来的人更多的是为了帮助，而不是得到帮助。在某些情况下，特别是在以计算机为中心的大型信息和控制系统中，人工操作员主要负责自动化不可行的功能。这种系统（North可能称之为“人类增强的机器”）不是共生系统。它们是“半自动”系统，系统最初是全自动的，但没有达到目标。</p><p>人机共生可能不是复杂技术系统的最终范例。在适当的时候，电子或化学“机器”似乎完全有可能在我们现在专门考虑的大部分功能上超过人脑。即使是现在，Gelernter的IBM - 704平面几何定理证明程序的进度也和布鲁克林高中学生差不多，并且犯了类似的错误。事实上，有几个理论证明、解决问题、下棋和模式识别程序，它们能够在受限制的领域中与人类的智力表现相媲美；而Newell、Simon和Shaw的“一般问题解决器”可能会消除一些限制。简而言之，避免与(其他)人工智能爱好者争论似乎是值得的，因为他们认为在遥远的未来只有机器的统治地位。然而，在此期间，主要的智力进步将会由密切合作的人和计算机来完成，这将会是一个相当长的过渡期。一个多学科的研究小组，研究了空军未来的研究和发展问题，估计在1980年之前，人工智能的发展使机器能够独自思考或解决具有军事意义问题。这将会导致，比如说，5年的时间来发展人机共生，15年的时间来使用它。15年可能是10年或500年，但那些年应该是人类历史上最具创造力和最激动人心的时期。</p><p>2人机共生的目标</p><p>当今的计算机主要是为了解决预先设定的问题或者按照预定的程序处理数据。计算过程可能取决于计算过程中获得的结果，但是所有的替代方案都必须提前预见。（如果出现不可预见的替代方案，整个过程就会停止，等待程序的必要扩展。）预先制定或预先确定的要求有时并没有什么大的缺点。预先制定或预先确定的要求有时并没有什么大的缺点。人们常说，计算机的编程迫使人们要清楚地思考，它会规范思维过程。如果用户能够提前思考他的问题，那么与计算机的共生关系就没有必要了。</p><p>然而，很多问题……很难提前想透彻，回想一下前文对新兴系统的描述。如果能通过与计算机合作，由直觉引导进行试错，暴露出推理过程中的错误，或是揭示解决方案中某些意想不到的转折，就能更快、更好地解决问题。没有计算机辅助，其他问题根本无法解决。庞加莱预见到了一批重要的潜在计算机用户的沮丧，他说，“问题不是，答案是什么？，问题是，问题是什么”。人机共生的主要目的之一是将计算机有效地纳入技术问题的公式化部分。</p><p>另一个主要目标是密切相关的。这是为了有效地将计算机带入必须“实时”进行的思考过程，时间过快，不允许以传统方式使用计算机。想象一下，例如，试图在这样的时间表上借助计算机指挥一场战斗。你今天提出了你的问题。明天你和程序员一起度过。你会得到一张20英尺长的纸，上面写满了数字，这些数字并没有提供最终的解决方案，只是提出了一种应该通过模拟来探索的策略。显然，这场战斗将在其计划的第二步开始之前结束。与电脑互动的思维方式与你与一位同事互动的思维方式是一样的，他的能力补充了你自己的能力，这将要求人与机器之间的耦合比这个例子所建议的和现状可能的要紧密得多。</p><p>3计算机参与公式化和实时思维的需要</p><p>前面的段落默认了这样的假设：如果可以有效地引入到思想过程中，数据处理机器所能执行的功能将会以一种重要的方式改进或促进思考和解决问题。这种假设可能需要正当理由。</p><p>3.1技术思维的初步和非正式工效分析</p><p>尽管有大量关于思考和解决问题的文献，包括对发明过程的大量历史案例研究，但我找不到比对从事科技企业的人的脑力劳动进行工效研究分析更好的东西。因此，在1957年的春天和夏天，我试着记录一个中等技术人员在他认为专注于工作的时间里所做的事情。尽管我意识到取样的不足，但我还是做了自己的研究对象。很明显，我所做的主要事情是保持记录，如果按照最初计划中设想的细节保存记录，这个项目将会变成一个无限倒退。不是。尽管如此，我还是获得了一张让我停下来的活动照片。也许我的范围不典型——我希望不是，但我担心是。</p><p>我85 %的“思考”时间都花在了思考、决策、学习一些我需要知道的事情上。寻找或获取信息的时间比消化信息的时间多得多。几个小时用于绘制图表，其他几个小时用于指导助手如何绘制图表。当图表完成后，两种关系立刻变得明显，但必须进行绘图以使其成为现实。在某一点上，有必要对语音清晰度和语音噪声比相关函数的六个实验测定值进行比较。没有两个实验者使用相同的语音噪声比定义或测量。需要几个小时的计算才能把数据变成可比的形式。当它们处于可比较的形式时，我只花了几秒钟就确定了我需要知道的东西。</p><p>简而言之，在整个研究期间，我的“思考”时间主要用于本质上是文书或机械的活动：搜索、计算、绘图、转换、确定一组假设或假设的逻辑或动态后果，为决策或洞察铺平道路。此外，我对尝试什么和不尝试什么的选择在很大程度上是出于对文书可行性的考虑，而不是智力能力的考虑，这令人尴尬。</p><p>刚刚描述的研究结果传达的主要建议是，在大多数时间里，被称为技术思维的操作都是机器可以比人类更有效地执行的操作。这些操作必须在不同的变量上以不可预见的和不断变化的顺序进行，这一事实带来了严重的问题。然而，如果这些问题能够以在人和快速信息检索和数据处理机器之间建立共生关系的方式得到解决，那么合作互动显然会大大改善思维过程。</p><p>在这一点上，也许应该承认，我们正在使用术语“计算机”来涵盖各种计算、数据处理以及信息存储和检索机器。这类机器的能力几乎每天都在增加。因此，对该类的功能进行一般性陈述是危险的。也许就人的能力发表一般性声明也同样危险。尽管如此，人类和计算机之间在能力上的某些基因型差异确实很突出，并且它们对可能的人机共生的性质和实现这种共生的潜在价值有着影响。</p><p>正如已经以各种方式所说的那样，人类是嘈杂的窄带设备，但是他们的神经系统有很多平行的同时活跃的通道。相对于人类来说，计算机速度非常快而且非常精确，但是它们一次只能执行一个或几个基本操作。人类很灵活，能够根据新收到的信息“不断地自我规划”。计算机是一根筋的，受其“预编程”的约束。人类自然会说冗余性的语言，这些语言围绕着单一的物体和连贯的动作组织起来，使用20到60个基本符号。计算机“自然”会说非冗余语言，通常只有两个基本符号，对单一物体或连贯动作都没有固有的鉴赏能力。</p><p>要严格正确，这些特征必须包括许多限定符。尽管如此，它们所呈现的不同（因此也是潜在的补充）本质上是正确的。计算机可以很容易、很好、很快地做许多对人类来说困难或不可能的事情，而人类可以很容易、很好地做许多对计算机来说困难或不可能的事情，尽管不是很快。这表明，共生合作，如果成功地融合了人和计算机的积极特征，将具有巨大的价值。当然，速度和语言的差异带来了必须克服的困难。</p><p>4预期共生关系中人和计算机的可分离功能</p><p>似乎人类操作员和设备的贡献在许多操作中会如此完全地融合在一起，以至于在分析中很难将它们整齐地分开。情况就是这样；例如，在收集决策依据的数据时，人和计算机都从经验中找到了相关的先例，如果计算机随后提出了一个符合人直觉判断的行动方案。（在定理证明程序中，计算机在经验中找到了先例，在SAGE系统中，它们提出了行动方案。上述内容并不是一个牵强附会的例子。）然而，在其他行动中，人员和设备的贡献在某种程度上是可分离的。</p><p>当然，至少在早期，人类会设定目标并提供动机。他们将提出假设。他们会问问题。他们会想到机制、程序和模型。他们会记得，这样的人早在1947年，或者至少在二战后不久，就对一个感兴趣的主题做了一些可能相关的工作，他们会知道该主题可能在哪些期刊上发表。总的来说，他们会做出近似的、错误的、但领先的贡献，他们会定义标准并充当评估者，判断设备的贡献并指导总体思路。</p><p>此外，当这种情况确实出现时，人类会处理极低概率的情况。（在当前的人机系统中，这是操作员最重要的功能之一。极低概率替代方案的概率之和往往太大，不容忽视。）当计算机没有适用于特定环境的模式或程序时，人们会填补问题解决方案或计算机程序中的空白。</p><p>信息处理设备本身将把假设转换成可测试的模型，然后根据数据对模型进行测试（操作员可以粗略地指定这些数据，并在计算机将它们提交给他审批时确定它们是相关的）。这些设备将回答问题。它将模拟机制和模型，执行程序，并向操作员显示结果。它将转换数据，绘制图表（以人类操作员指定的任何方式“切蛋糕”，或者如果人类操作员不确定他想要什么，那就呈现几种替代方式）。设备将会插入、推断和转换。它将静态方程或逻辑语句转换成动态模型，以便操作员可以检查他们的行为。一般来说，它将执行可例行公事的文书工作，以填补决策之间的间隔。</p><p>此外，只要有足够的基础支持正式的统计分析，计算机将充当统计推断、决策理论或博弈论机器，对建议的行动方案进行初步评估。最后，它将尽可能多地进行诊断、模式匹配和相关性识别，但在这些领域，它将接受一个明显的次要地位。</p><p>5实现人机共生的前提条件</p><p>在前一节中默认的数据处理设备是不可用的。计算机程序尚未编写。事实上，在非共生的当下和预期的共生未来之间存在着一些障碍。让我们研究一下其中的一些障碍，以便更清楚地了解需要什么以及实现这一目标的可能性。</p><p>5.1人与计算机之间的速度不匹配</p><p>现在的大型计算机对于与一个人进行实时合作思考来说，速度太快，成本太高。显然，为了效率和经济，计算机必须在许多用户之间分配时间。分时系统目前正在积极开发中。甚至有一些安排来防止用户“破坏”除了他们自己的个人程序之外的任何东西。</p><p>在10年或15年后的一段时间里，设想一个“思维中心”似乎是合理的，它将结合当今图书馆的功能，以及信息存储和检索的预期进展和本文前面建议的共生功能。这种设想很容易放大成这样的中心网络，通过宽带通信线路相互连接，并通过租用线路服务连接到各个用户。在这样的系统中，计算机的速度将会平衡，巨大的存储器和复杂程序的成本将会除以用户的数量。</p><p>5.2存储器硬件要求</p><p>当我们开始考虑将任何已知的技术文献存储在计算机存储器中时，我们会遇到数十亿比特数据，除非事情发生显着变化，否则将花费数十亿美元。</p><p>首先要面对的是，我们不会将所有的技术和科学论文都存储在计算机存储器中。我们可能会储存概括得最简洁的部分——数量部分和参考文献——但不是全部。书籍是现存最精美、最人性化的组件之一，在人机共生的背景下，它们将继续发挥重要的功能。（希望计算机能加快图书的查找、交付和归还。）</p><p>第二点是，存储器的一个非常重要的部分将是永久的:部分是不可擦除的内存和部分是发布的内存。计算机将能够一次写入不可擦除的内存，然后无限期地读取，但是计算机将无法擦除不可擦除的内存。（它也可能会重写，将所有的0变成1，就像在之前写的东西上做标记一样。）发布的内存将是“只读”内存。它将被引入到已经构建好的计算机中。计算机将能够重复引用它，但不能改变它。随着计算机越来越大，这些类型的内存将变得越来越重要。它们可以做的比核心、薄膜、甚至磁带存储器更紧凑，而且价格也要便宜得多。主要的工程问题将涉及选择电路。</p><p>就内存需求的其他方面而言，我们可以指望普通的科学和商业计算机的持续发展。存储元件有可能变得与处理（逻辑）元件一样快。这一发展将对计算机的设计产生革命性的影响。</p><p>5.3存储组织要求</p><p>人机共生理念中隐含着这样的要求，即信息可以按名称和模式检索，并且可以通过比串行搜索快得多的程序访问。至少有一半的内存组织问题似乎存在于存储过程中。其余大部分似乎都包含在存储机制或介质中的模式识别问题中。对这些问题的详细讨论超出了目前的范围。然而，简要概述一个有希望的想法，即“trie存储”，可能有助于说明预期发展的一般性质。</p><p>Trie存储是由其创始人Fredkin所称的，是因为它被设计成便于检索信息，并且因为分支存储结构在开发的时候类似于一棵树。大多数常见的内存系统在参数指定的位置存储参数的函数。（从某种意义上说，它们根本不存储这些参数。在另一个更现实的意义上，它们将所有可能的参数存储在内存的框架结构中。）另一方面，trie存储系统存储函数和参数。从标准的初始寄存器开始，参数首先被引入内存，一次一个字符。每个参数寄存器都有一个单元格，每个字符都有一个单元格（例如，两个用于二进制形式的信息），每个字符单元都有一个存储空间，用于下一个寄存器的地址。这个参数是通过写一系列地址来存储的，每一个地址都告诉我们在哪里找到下一个地址。在引数的最后，是一个特殊的“结束参数”标记。然后遵循函数的指示，该函数以多种方式中的一种或另一种方式存储，进一步的trie结构或“列表结构”通常是最有效的。</p><p>Trie存储方案对于小内存来说是低效的，但是随着内存大小的增加，它在使用可用存储空间方面变得越来越高效。该方案吸引人的特点是：1）检索过程极其简单。给定参数后，输入第一个字符的标准初始寄存器，并提取第二个字符的地址。然后转到第二个寄存器，获取第三个寄存器的地址，等等。2）如果两个参数具有相同的初始字符，则它们对这些字符使用相同的存储空间。3）参数的长度不必相同，也不必事先指定。4）在实际存储之前，任何参数都不会保留或使用存储空间。trie结构是在项目被引入内存时创建的。5）一个函数可以用作另一个函数的参数，该函数可以用作下一个函数的参数。因此，例如，通过用参数“矩阵乘法”输入，人们可以检索在计算机上执行矩阵乘法的整个程序。6）通过检查给定级别的存储，可以确定迄今为止存储了哪些相似的项目。例如，如果没有引用Egan, J. P.，那么只需要一两步就能找到Egan James的踪迹…….</p><p>刚刚描述的属性并不包括所有想要的属性，但是它们使计算机存储与人类操作者产生共鸣，并且他们倾向于通过命名或指向来指定事物。</p><p>5.4语言问题</p><p>人类语言和计算机语言之间的基本差异可能是真正共生的最严重障碍。然而，令人欣慰的是，通过解释程序，特别是通过汇编或编译程序，如FORTRAN，已经取得了巨大进步，使计算机适应人类语言形式。Shaw，Newell，Simon和Ellis的“信息处理语言（Information Processing Language）”代表了另一种和解方式。而且，在ALGOL和相关系统中，人们通过采用可以轻易翻译成机器语言的表示和表达的标准公式来证明其灵活性。</p><p>然而，为了实现人与计算机之间的实时合作，有必要利用另外一种相当不同的通信和控制原理。可以通过比较通常针对智能人的指令和通常用于计算机的指令来突出这个想法。后者精确地指定了要采取的各个步骤以及采取这些步骤的顺序。前者提出或暗示了一些关于激励或动机的东西，它们提供了一个标准，在这个标准中，指令的执行者将知道完成任务的时间。简而言之：针对计算机的指令指定路线；针对人类的指令指定了目标。</p><p>人类似乎在目标方面比在路线方面更自然，更容易地思考。的确，他们通常知道一些关于旅行或工作路线的信息，但很少有人能从精确制定的行程开始。例如，谁会带着详细的路线说明从波士顿出发去洛杉矶？相反，用Wiener的话来说，前往洛杉矶的人试图不断减少他们还没有被烟雾笼罩的程度。</p><p>通过两种途径来实现计算机指令。第一个涉及解决问题、爬山算法、自组织项目。第二种是预编程段和闭合子程序的实时串联，操作员可以简单地通过名字来指定和调用这些子程序。</p><p>沿着第一条道路，已经有了有希望的探索性工作。很明显，在预定策略的宽松约束下工作，计算机将能够在适当的时候设计和简化自己的程序来实现既定的目标。迄今为止，这些成就并不重要；他们只是“原则上的示范”。然而，其影响深远。</p><p>尽管第二条道路更简单，显然能够更早实现，但它相对被忽视了。Fredkin的trie存储提供了一个有前途的范例。我们可能会在适当的时候看到一个认真努力来开发的计算机程序，这些程序可以像语言的单词和短语一样连接在一起，这样就可以进行任何计算或控制。显然，阻碍这种努力的考虑因素是，这种努力不会产生任何在现有计算机环境中具有重大价值的东西。在没有任何计算机能够对语言做出有意义的反应之前，开发语言是不可取的。</p><p>5.5输入输出设备</p><p>就人机共生的要求而言，似乎最不先进的数据处理部门是处理输入和输出设备的部门，或者从操作员的角度来看，是处理显示和控制的部门。在说了这句话之后，有必要做出符合条件的评论，因为用于高速引入和提取信息的设备工程一直很出色，而且一些非常复杂的显示和控制技术已经在林肯实验室等研究实验室中得到发展。然而，总的来说，在一般可用的计算机中，几乎没有比电动打字机更有效、更即时的人机通信。</p><p>显示器似乎比控制的状态好一些。许多计算机在示波器屏幕上绘制图形，少数计算机利用了字符显示管卓越的图形和符号功能。然而，据我所知，在技术讨论中，没有任何东西能接近铅笔和涂鸦板的灵活性和方便性，或者是人们使用的粉笔和黑板。</p><p>1）桌面显示和控制：当然，为了有效的人机交互，在相同的显示面上，人和电脑需要绘制图形和图画，并在相同的显示面上写注释和方程。这个人应该能够通过绘制图表，以粗糙但快速的方式向计算机展示一个功能。计算机应该阅读这个人的文字，也许是在清楚的大写字母的条件下，并且应该立即在每个手绘符号的位置张贴相应的字符，并将其翻译成精确的字体。有了这种输入输出设备，操作员将很快学会以机器可读的方式书写或打印。他可以编写指令和子程序，将它们设置成适当的格式，并在最终将它们引入计算机的主存储器之前检查它们。他甚至可以像Gilmore和Savell在林肯实验室所做的那样定义新的符号，并将它们直接呈现给计算机。他可以粗略地勾画出一张表格的格式，然后让电脑精确地塑造它。他可以修正计算机的数据，通过流程图指导机器，并且就像通常与其他工程师一样进行交互，除了“其他工程师”将是精确的绘图员，快速的计算器，助记符向导，以及许多其他有价值的合作伙伴。</p><p>2）计算机发布的墙面显示：在一些技术系统中，几个人共同负责控制行为相互影响的车辆。一些信息必须同时呈现给所有人，最好是在一个公共网格上，以协调他们的行动。其他信息仅与一两个操作者相关。如果所有信息都在一个显示器上呈现给所有人，那将只会产生无法解释的混乱。这些信息必须由计算机发布，因为手工绘图太慢，无法保持最新。</p><p>刚才概述的问题现在甚至是一个关键问题，随着时间的推移，它似乎肯定会变得越来越关键。一些设计者相信，基于光阀原理，可以借助脉冲光源和分时观看屏幕来构建具有所需特性的显示器。</p><p>大多数思考过这个问题的人认为，大型显示器应该由单独的显示器控制单元来补充。后者将允许操作者修改墙面显示而不离开他们的位置。出于某些目的，希望操作者能够通过辅助显示器甚至墙面显示与计算机通信。至少有一种提供这种通信的方案似乎是可行的。</p><p>当然，大型墙面显示及其相关系统与计算机和一组人之间的共生合作相关。实验室实验一再表明，操作员非正式的平行安排，通过参考大型位置显示器来协调他们的活动，比更广泛使用的安排具有重要优势，它将操作员定位在各个控制台上，并试图通过计算机代理来关联他们的行动。这是需要仔细研究的几个操作团队问题之一。</p><p>3）自动语音生成和识别：人类操作员和计算机之间的语音通信有多理想和可行？每当讨论复杂的数据处理系统时，都会问这个复杂的问题。与计算机一起工作和生活的工程师对这种愿望持保守态度。在自动语音识别领域有经验的工程师对可行性持保守态度。然而，人们仍然对与计算机对话的想法感兴趣。在很大程度上，这种兴趣源于人们认识到，很难把一名军事指挥官或公司总裁离开他们的工作，教他们打字。如果计算机能够被高层决策者直接使用，那么通过最自然的方式提供通信可能是值得的，即使花费相当大的成本。</p><p>对公司总裁的问题和时间尺度的初步分析表明，他只对作为爱好的计算机的共生关系感兴趣。业务情况通常进展缓慢，以至于有时间进行简报和会议。因此，对于计算机专家而言，与商务办公室中的计算机直接交互似乎是合理的。</p><p>另一方面，军事指挥官在短时间内做出关键决策的可能性更大。人们很容易夸大10分钟战争的概念，但是指望有十分钟以上的时间来做出关键决定是危险的。因此，随着军事系统地面环境和控制中心的能力和复杂性的增长，计算机自动语音生成和识别的真正需求似乎有可能得到发展。当然，如果设备已经被开发、可靠的和可用的，它就会被使用。</p><p>就可行性而言，与自动识别语音相比，语音产生带来的技术性问题不那么严重。一台商用电子数字电压表现在一个数字一个数字地大声读出它的指示。八年或十年，贝尔电话实验室，皇家理工学院（斯德哥尔摩），Signals Research and Development Establishment（Christchurch），耶鲁大学汉斯金实验室和麻省理工学院，Dunn，Fant，Lawrence，Cooper，Stevens和他们的同事，已经展示了一代又一代的可理解的自动发生器。汉斯金实验室的研究已经开发出了一种适合计算机使用的数字代码，这种代码使得自动语音完全可以理解相关的话语。</p><p>自动语音识别的可行性在很大程度上取决于要识别的单词的词汇量以及说话者和口音的多样性。几年前，在贝尔电话实验室和林肯实验室，人们已经证明了百分之九十八的正确识别自然的十进制数字。为了进一步扩大词汇量，我们可以说，现在几乎可以肯定地在现有知识的基础上开发出一种清晰发音的字母数字字符的自动识别器。由于未经训练的操作员读取的速度与训练有素的操作员键入的速度至少一样快，因此这种设备几乎可以在任何计算机安装中使用。</p><p>然而，为了在真正共生的水平上进行实时交互，可能需要大约2000个单词的词汇，例如1000个基本英语单词和1000个专业术语。这是一个具有挑战性的问题。在声学专家和语言学家的共识中，现在还不能完成建立2000个单词的识别器。然而，有几个组织乐意承诺在五年内为这样的词汇开发一个自动识别系统。他们会规定演讲要清晰，听写的风格，没有不寻常的口音。</p><p>尽管对自动语音识别技术的详细讨论超出了目前的范围，但值得注意的是，计算机在自动语音识别器的发展中起着主导作用。他们为当前的乐观情绪提供了动力，或者说是一些人目前的乐观情绪。两三年前，似乎在10年或15年内不会自动识别大量词汇；它将不得不等待语音交流中声学、语音、语言和心理过程的知识的逐渐积累。然而，现在，许多人看到了借助计算机处理语音信号来加速获取这种知识的前景，不少工作者认为，即使没有语音信号和过程的大量实质性知识的帮助，复杂的计算机程序也能像语音模式识别一样表现出色。将这两个考虑因素结合起来，可以将实现实际意义上的语音识别所需的时间估计降低到五年，即刚才提到的五年。</p><hr><h1 id="个人解读"><a href="#个人解读" class="headerlink" title="个人解读"></a>个人解读</h1>]]></content>
      
      
      <categories>
          
          <category> -未来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU机组</title>
      <link href="/2020/11/28/shu-ji-zu/"/>
      <url>/2020/11/28/shu-ji-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理与结构体系"><a href="#计算机组成原理与结构体系" class="headerlink" title="计算机组成原理与结构体系"></a>计算机组成原理与结构体系</h1><h2 id="理论学习"><a href="#理论学习" class="headerlink" title="理论学习"></a>理论学习</h2><p><a href="https://www.bilibili.com/video/BV1BE411D7ii" target="_blank" rel="noopener">b站王道机组课程</a></p><h2 id="实验一二三（实验箱）"><a href="#实验一二三（实验箱）" class="headerlink" title="实验一二三（实验箱）"></a>实验一二三（实验箱）</h2><h2 id="实验四（虚拟机）"><a href="#实验四（虚拟机）" class="headerlink" title="实验四（虚拟机）"></a>实验四（虚拟机）</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>看一遍老师给的教程。（虽然它是一份老掉牙的教程，但是你首先得知道自己要干什么，然后才好跟上大家吐槽的脚步。建议先全部看一遍，而且最后的问题汇总其实更应该放到教程开头才对）</p></li><li><p>最好提前了解一点Linux操作系统的相关知识，不是很清楚也没关系，按照步骤把实验做一遍下来大概也就差不多了。</p></li><li><p>这里是一些可能需要提前在自己电脑上安装好的东西，可能会用到的链接和教程都放在这里了，需要的请自取。</p></li></ul><p><a href="https://blog.csdn.net/hao5119266/article/details/89198275" target="_blank" rel="noopener">VM虚拟机下载及安装教程</a></p><p><a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">Vmware官方</a></p><p><a href="https://vault.centos.org/6.5/isos/x86_64/" target="_blank" rel="noopener">centos6.5下载</a><strong>（版本一致很重要！版本一致很重要！版本一致很重要！）</strong></p><hr><p>重要的事说三遍，这里说的一致是和老师给的教程里使用的版本一致，因为有的同学安装的是centos7或8甚至是Ubuntu（不同版本操作命令可能不同，安装过程也可能不会完全相同），如果你不想花费大量时间在打开CSDN上的话，建议还是装这个CentOS-6.5-x86_64-<strong>LiveCD</strong>。而且这个下载起来也快，只有600多M。之后再按照教程走就会轻松很多，直到你碰上你的第一个问题，最起码你可以不那么困难地迈出第一步。</p><hr><p>下面是几篇避坑的博客，<strong>偷懒最好的办法是一遍就把事情做好</strong>，所以为了省时间还是值得一看的，当然你也可以等遇到问题再来查</p><p><a href="https://zhuanlan.zhihu.com/p/68111471" target="_blank" rel="noopener">精通 VIM ，此文就够了</a>（linux的编辑器，和你以前使用过的编辑器可能完全不一样，做好心理准备）</p><p><a href="https://yuhui.blog.csdn.net/article/details/52325716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai" target="_blank" rel="noopener">虚拟机：三台虚拟机互通且连网</a>（要是早点看到这篇我就不用花那么多时间找其他博客了，感谢原博主帮我找到了我的问题）</p><p><a href="https://blog.csdn.net/mijichui2153/article/details/80918285" target="_blank" rel="noopener">CentOS7虚拟机克隆，且成功互ping</a>（仅供参考）</p><p>最后还是不得不吐槽一下老师给的参考教程版本实在是太老了，虽然我在这个很痛苦的过程中也学到了不少东西，但也带来了很多不必要的困扰，就拿centos6.5这个版本举例，现在都0202年了，官网上有的是centos7和8，那找起6.5来就是一个重复做功的过程，而教程后的链接也是失效的，简直是浪费感情。</p><p>剩下的其实就只要按照老师给的教程来就行了，直到虚拟机之间互通这里，我碰到最麻烦的问题也还是版本的问题，吐槽最多的地方也还是教程太老以及不够仔细。</p><hr><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>下面是我在实验过程中遇到过的一些问题，仅供参考。</p><p>首先还是回到老师给的教程上里面，如果你看的足够仔细就会发现有个地方很奇怪，那就是在修改复制的（或者说克隆）虚拟机ip这里，原来教程这里写的是</p><pre><code>修改ip：vim /etc/sysconfig/network-scripts/ifconfig-eth0将IPADDR=后的ip改为192.168.224.201</code></pre><p>但是在创建第一台虚拟机配置centos网络时是这样的</p><pre><code>配置centos网络：vim /etc/sysconfig/network-scripts/ifcfg-eth0修改（或者说是输入）DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticBROADCAST=192.168.224.225 IPADDR=192.168.224.130 NETMASK=255.255.255.0NETWORK=192.168.224.0 GATEWAY=192.168.224.2 </code></pre><p>同样是改IPADDR，为什么两个文件名不一样呢？（ifconfig-eth0和ifcfg-eth0）</p><p>这里要么是版本的问题，要么就是一个笔误，造成的后果可能就是你三台虚拟机都能ping master而不能实现真正的互通（会显示Unreachable）。</p><p>因为如果你细心的话就会发现当你在复制的虚拟机上打开ifconfig-eth0时，其实是新建了一个名为ifconfig-eth0的文件，而不是打开了复制过来的ifcfg-eth0文件。（可以自己验证一下）这里只需要注意一下即可。</p><p>我遇到的最坑的问题还是下面这个</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/798663-20160711161510686-1749110137.png" alt="直接复制文件导致两台虚拟机Mac相同，即物理地址和备份的虚拟机重复"></p><p>我是按照教程在windows中文件中直接将一个虚拟机进行复制了两份（克隆好像就没有问题），然后用vm打开， 选择我已经复制，结果虚拟机开机的时候出现了上面的日志消息提示，导致了我无法ping 通。解决方法如下（改不了的话先关闭一下虚拟机）： </p><p><a href="https://www.cnblogs.com/nucdy/p/5660701.html" target="_blank" rel="noopener">如何更改Mac地址</a></p><hr><p><strong>ssh无密码验证原理：</strong></p><p>节点A要实现无密码公钥认证连接到节点B上时，节点A是客户端，节点B是服务端，需要在客户端A上生成一个密钥对，包括一个公钥和一个私钥，而后将公钥复制到服务端B上。当客户端A通过ssh连接服务端B时，服务端B就会生成一个随机数并用客户端A的公钥对随机数进行加密，并发送给客户端A。客户端A收到加密数之后再用私钥进行解密，并将解密数回传给B，B确认解密数无误之后就允许A进行连接了。这就是一个公钥认证过程，其间不需要用户手工输入密码。重要过程是将客户端A公钥复制到B上。</p><p><img src="https://m.qpic.cn/psc?/V50yGAmm4Y7rG60gKAT73IXxN50OzhRf/bqQfVz5yrrGYSXMvKr.cqfBUrrv5isfzJMoRkFHPwqDEOOykWN3ExbxXLwX3CIPppXZvOULP*UwfGuI0whImzuhWCI3ZKLgliZeH.HHaIik!/b&bo=gAcPBAAAAAADB64!&rf=viewer_4" alt="第一步就出错了"></p><p>教程里第一步启用shh服务找不到文件，可能是版本不一样所以命令不一样了，不过很神奇的是我在第一台虚拟机上能够使用这条命令，但是复制的那两台上无法成功运行。所以我直接参考了<a href="https://www.cnblogs.com/opsprobe/p/9147934.html" target="_blank" rel="noopener">CentOS6.5下安装、配置SSH</a>（最后是使用putty需要自行安装），只要确认shh正常启用就行。以下是我成功运行的一些命令</p><blockquote><p>1.登录CentOS 6.5系统，使用root用户登录，如果为非root用户则执行 su 或 su - 或 su root 或 su - root 输入root密码切换为root用户。</p><p>2.查看SSH是否安装（检查是否装了SSH包）。<br>输入命令：rpm -qa | grep ssh 或者（rpm -qa | grep openssh）</p><p>3.查看SSH服务是否正在运行。<br>输入命令：/etc/init.d/sshd status 或者（service sshd status）</p><p>4.若CentOS 6.5系统中SSH服务处于非运行状态则使用（service sshd start）命令开启SSH服务；停止SSH服务命令（service sshd stop）；重启SSH服务命令（service sshd restart）。为了演示效果，我这里先停止SSH服务，然后启动SSH服务，再接着重启SSH服务。[service sshd stop] -&gt; [/etc/init.d/sshd status] -&gt; [service sshd start]-&gt; [service sshd restart] -&gt; [/etc/init.d/sshd status] </p><p>[重启后可输入：netstat -antp | grep sshd 查看是否启动22端口]</p><p>5.检查sshd是否在本运行级别下设置为开机启动<br>输入命令：chkconfig –list sshd<br>CentOS 6.5系统中SSH服在本运行级别下已经设置为开机启动,如果没设置启动就使用如下命令[chkconfig –level 2345 sshd on]设置下即可。（每个级别需要分别开启）</p></blockquote><p>【常见的远程SSH登录工具有：securecrt、xshell、putty等..】</p><p><a href="https://blog.csdn.net/wojiuguowei/article/details/79308090" target="_blank" rel="noopener">使用Xshell远程访问虚拟机</a></p><p>先来看看按照老师给的教程能不能幸运地完成实验吧。</p><p>![很不幸，不能](<a href="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc" target="_blank" rel="noopener">https://gitee.com/henry-avery/my_pic_bed/raw/master/psc</a> (1).png)</p><p>最后一条重启命令一看就知道应该是又把service写错成servive了。</p><p>![正常重启](<a href="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc" target="_blank" rel="noopener">https://gitee.com/henry-avery/my_pic_bed/raw/master/psc</a> (2).png)</p><p>之后就是一路采坑，最后也不知道自己怎么搞定的，看了很多博客但好像最后都没怎么用上。</p><p>而且这里具体问题还需要具体解决，可以在这篇博客的评论区把遇到的问题发出来，让大家帮忙看看。</p><p><strong>scp连接远程传输报错The authenticity of host …… can‘t be established.</strong></p><p><a href="https://blog.csdn.net/qq_35022803/article/details/108937779" target="_blank" rel="noopener">解决linux配置ssh免密登录遇到的异常：-bash: cd: /root/.ssh: Not a directory</a></p><p>No such file：可能要先进入子目录（cd .ssh），然后在使用scp命令，否则找不到你要传输的文件</p><hr><p><strong>使用ssh实现windows主机与linxu虚拟机文件互传</strong></p><p>这一步网上教程很多，但是可能还是不能完全符合我们的需求。</p><p>首先在主机上安装SSH Secure Shell，这个软件的下载地址是：<a href="http://ccm.net/download/download-1423-ssh-secure-shell-windows，如果打不开，请自行百度解决。" target="_blank" rel="noopener">http://ccm.net/download/download-1423-ssh-secure-shell-windows，如果打不开，请自行百度解决。</a></p><p>在实现互传文件之前先要令主机和虚拟机ping通，所以在这里先直接测试能不能ping通，别急着关防火墙和调整网络设置，如果之前的操作正确的话是可以直接跳过前两步的。</p><blockquote><p>在cmd中输入ipconfig查看本机ip，在terminal中输入ifconfig查看虚拟机ip</p></blockquote><p><a href="https://blog.csdn.net/jiechuhoudeshang/article/details/94407815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai" target="_blank" rel="noopener">虚拟机和主机相互ping不通方法总结</a></p><p>为了使用虚拟机而关闭防火墙这种因小失大的做法是不大可取的，其实设置防火墙很简单，以win7为例，打开控制面板 &gt; 系统和安全 &gt; windows防火墙 &gt;高级设置 &gt;入站规则 &gt; 文件和打印机共享(回显请求 - ICMPv4-In) （专用，公用） &gt; 右键启用 即可</p><p><strong>注意事项</strong>：直接打开SSH Secure File Transfer输入Hostname和Username然后输入密码。</p><p><strong>注意用户名这里不是master和slave1或2，而是你登录虚拟机时的用户名，</strong>比如我三台虚拟机用户名都是centos，否则用户名和密码不匹配会一直让你输入密码。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc.png" alt="小波男神镇贴"></p><hr><p><strong>RSH互通</strong></p><p>摆脱教程之后说不定还更简单了，而且碰巧找到了一篇可能是前两届某位学长写的博客，补充了没有的rsh部分，有兴趣可以看看，反正我是不想再多看了一眼了。</p><p><a href="https://blog.csdn.net/kingdomkitty/article/details/79897572" target="_blank" rel="noopener">centos6.5 配置ssh与rsh</a></p><hr><p><a href="https://www.cnblogs.com/baimh/p/11139668.html" target="_blank" rel="noopener"><strong>连接外网</strong></a></p><p><strong>下面摘抄了关于网络配置模式的介绍，可以详细了解下，可以对配置更加清晰；</strong></p><blockquote><p>桥接 通过使用物理机网卡 具有单独ip<br>NAT 把物理机为路由器进行上网</p><p>下面是详细的解说：</p><p>VMWare提供了三种工作模式，它们是bridged(bridged模式)、NAT(网络地址转换模式)和host-only(主机模式)。要想在网络管理和维护中合理应用它们，了解一下这三种工作模式。</p><p><strong>1.bridged(桥接模式)</strong></p><p>在bridged模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。在bridged模式下，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信。如果想利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择bridged模式。<br>这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡 绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。<br>使用这种方式很简单，前提是可以得到1个以上的地址。</p><p><strong>2.NAT(网络地址转换模式)</strong></p><p>使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。<br>这种方式也可以实现Host OS与Guest OS的双向访问。但网络内其他机器不能访问Guest OS，Guest OS可通过Host OS用NAT协议访问网络内其他机器。NAT方式的IP地址配置方法是由VMware的虚拟DHCP服务器中分配一个IP ，在这个IP地址中已经设置好路由，就是指向192.168.138.1的。</p><p>如果想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。这种方式下host内部出现了一个虚拟的网卡vmnet8（默认情况下），如果有过 做nat服务器的经验，这里的vmnet8就相当于连接到内网的网卡，而虚拟机本身则相当于运 行在内网上的机器，虚拟机内的网卡（eth0）则独立于vmnet8。发现在这种方式下，vmware自带的dhcp会默认地加载到vmnet8界面上，这样虚拟机就可以使用dhcp服务。更为重要的是，vmware自带了nat服务，提供了从vmnet8到外网的地址转换，所以这种情况是一个实实在在的nat服务器在运行，只不过是供虚拟机用的。</p></blockquote><hr><h2 id="AI科普：NVIDIA自动避障小车Jetbot-amp-口罩识别"><a href="#AI科普：NVIDIA自动避障小车Jetbot-amp-口罩识别" class="headerlink" title="AI科普：NVIDIA自动避障小车Jetbot &amp;口罩识别"></a>AI科普：NVIDIA自动避障小车Jetbot &amp;口罩识别</h2><p>讲师：侯宇涛，英伟达公司GPU/CUDA应用市场总监。何琨，英伟达开发者社区高级培训师。</p><blockquote><p>上机实验口罩识别就只是使用一下他们写的代码，挺无聊的。</p></blockquote><hr><h2 id="实验五OpenMP"><a href="#实验五OpenMP" class="headerlink" title="实验五OpenMP"></a>实验五OpenMP</h2><p><a href="https://zhuanlan.zhihu.com/p/61857547" target="_blank" rel="noopener">OpenMP入门实例与分析</a></p><p><strong>实验目的</strong></p><p>1) 在Linux平台上编译和运行OpenMP程序；</p><p>2) 在Windows平台上编译和运行OpenMP程序。</p><p>3) 掌握OpenMP并行编程基础。</p><p><strong>实验环境</strong></p><p>1) 硬件环境：计算机一台；</p><p>2) 软件环境：Linux、Win2003、GCC、MPICH、VS2008或其他版本Visual Studio；</p><p><strong>实验内容</strong></p><p>Linux下OpenMP程序的编译和运行。OpenMP是一个共享存储并行系统上的应用编程接口，支持C/C++和FORTRAN等语言，编译和运行简单的”Hello World”程序。在Linux下编辑hellomp.c源程序，或在Windows下编辑并通过附件中的FTP工具（端口号：1021）上传，用”gcc -fopenmp -O2 -o hellomp.out hellomp.c”命令编译，用”./hellomp.out”命令运行程序。</p><p>注：在虚拟机中当使用vi编辑文件时，不是以ESC键退出插入模式，可以使用“Ctrl+c”进入命令模式，然后输入wq进行存盘退出。</p><p>Linux下OpenMP环境，需要安装gcc(<strong>此处注意避坑</strong>，6.5版本太老需换源，可参考以下链接提供方法)</p><pre><code>yum intall gcc    (在redhat, centOS 下使用，用root安装，必须保证网络畅通)</code></pre><p><a href="https://blog.csdn.net/weixin_44160584/article/details/110872926?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-2.nonecase" target="_blank" rel="noopener">centos 6.5 yum安装报YumRepo Error: All mirror URLs are not using ftp, http[s] or file</a></p><p><a href="https://bbs.csdn.net/topics/392269634" target="_blank" rel="noopener">Linux中安装gcc出现All mirror URLs are not using ftp,http[s] or file</a></p><blockquote><p>修改镜像配置：vim /etc/yum.repos.d/CentOS-Base.repo</p><p>将配置文件中的#mirrorlist注释掉，取消注销baseurl的行，将$releasever改成你的centos的版本号,可用cat /etc/redhat-release查看</p></blockquote><p>如果能够正常安装好编译器就没有什么问题了，写好代码放在不同地方跑而已。</p><p>测试代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <omp.h>#include <stdio.h>int main(){int nthreads,tid;omp_set_num_threads(8);#pragma omp parallel private(nthreads,tid){tid=omp_get_thread_num();printf("Hello World from OMP thread %d\n",tid);if(tid==0){nthreads=omp_get_num_threads();printf("Number of threads is %d\n",nthreads);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先从本地传到虚拟机上去，编译然后运行正常就OK了。</p><p><strong>实验报告</strong></p><p><strong>实验目的</strong></p><p>1) 在Linux平台上编译和运行OpenMP程序；</p><p>2) 在Windows平台上编译和运行OpenMP程序。</p><p>3) 掌握OpenMP并行编程基础。</p><p><strong>实验环境</strong></p><p>1) 硬件环境：计算机一台；</p><p>2) 软件环境：Linux（centOS6.5）、Win10、GCC、G++、VS2019</p><p><strong>问题描述</strong></p><p>对于一个大向量（所有元素全部大于 0）， 把它的前半部分全部平方，后半部分全部开方取整。</p><p>将所得的新向量中的奇数个数输出。</p><pre class="line-numbers language-c++"><code class="language-c++">vector<int> v_i{}//初始给定大小的大向量（从1e100~1e10000）vector<int> v_ans{};//新生成的向量，大小与向量v_i相同clock_t s, f;//记录时间double duration;//计算时间长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实验过程</strong></p><p>数据量变动，大于cache</p><p>L1缓存256KB，L2缓存1.0MB，L3缓存6.0MB</p><p>纸质打印</p><p><strong>实验结果</strong></p><pre class="line-numbers language-c++"><code class="language-c++">s :0.372000- size of v_ans:        2522907p :1.378000- size of v_ans:        2522907<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码附录</strong></p><pre class="line-numbers language-c++"><code class="language-c++">/*核心代码示例*/    s = clock();//计时开始#pragma omp parallel for reduction(+:cnt_ans) default(shared)  num_threads(10)//openmp并行计算，开启十个线程    for (int i = 0; i < len; i++)    {        auto& e = v_i[i];        int t = 0;        if (i < len / 2)        {            t = pow(e, 2);        }        else        {            t = (int)sqrt(e);        }        if (t % 2 == 1)        {            cnt_ans += 1;//计数器，计算新向量奇数个数        }    }    f = clock();//计时结束    duration = (double)(f - s) / CLOCKS_PER_SEC;//计算计时时间    printf("s :%f\n", duration);//输出并行计算计时时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/yt_42370304/article/details/83904121" target="_blank" rel="noopener">linux 上查询cache 大小的方法</a></p><p><a href="https://blog.csdn.net/azri81226/article/details/101691139?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">并行程序耗时过大问题</a></p><h2 id="实验六HPL安装和测试"><a href="#实验六HPL安装和测试" class="headerlink" title="实验六HPL安装和测试"></a>实验六HPL安装和测试</h2><h3 id="Linpack背景及内容"><a href="#Linpack背景及内容" class="headerlink" title="Linpack背景及内容"></a><strong>Linpack背景及内容</strong></h3><p><a href="https://blog.csdn.net/hanzhenbushihu/article/details/88416724" target="_blank" rel="noopener">HPL与HPCG测试 (一)</a></p><p><a href="https://blog.csdn.net/sishuiliunian0710/article/details/20493101/" target="_blank" rel="noopener"></a></p><p><a href="https://wenku.baidu.com/view/ce44c4a5b8f67c1cfad6b8f8.html" target="_blank" rel="noopener"></a></p><p>（1）背景介绍</p><p>LINPACK全名Linear Equations Package，是近年来较为常用的一种计算机系统性能测试的线性方程程序包，内容包括求解稠密矩阵运算，带状的线性方程，求解最小平方问题以及其它各种矩阵运算。它最早由来自Tennessee 大学的超级计算专家Jack Dongarra提出。程序用FORTRAN编写，在此基础上还有C，JAVA等版本。Linpack使用线性代数方程组，利用选主元高斯消去法在分布式内存计算机上按双精度(64 bits)算法，测量求解稠密线性方程组所需的时间。Linpack的结果按每秒浮点运算次数（flops）表示。第一个Linpack测试报告出现在1979年的Linpack用户手册上，最初LINPACK包并不是要制订一个测试计算机性能的统一标准，而是提供了一些很常用的计算方法的实现程序，但是由于这一程序包被广泛使用，就为通过Linpack 例程来比较不同计算机的性能提供了可能，从而发展出一套完整的Linpack 测试标准。</p><p>（2）测试标准的内容</p><p>LINPACK标准可以解决的问题有：</p><p> 1) 各种矩阵分解(Matrix factorization)，如LU分解，Cholesky分解， Schur，Gauss分解，SVD分解，QR分解，generalized Schur分解等</p><p>2) 矢量运算（Vector operation），如Copy，Add，scalar multiple，Interchange</p><p>3) 存储模式（Storage Modes），如full，banded，symmetric </p><p>Linpack原始版本的问题规模为100×100的矩阵，目前的Linpack测试分成三个层次的问题规模和优化选择： </p><p>—- 100×100的矩阵</p><p>在该测试中，不允许对Linpack测试程序进行任何修改，哪怕是注释行。 所有的优化工作只能在编译器里完成。</p><hr><p>—- 1000×1000的矩阵</p><p>该测试也叫“面向峰值性能的测试”，在该测试中，要求有所放宽，允许对算法和软件进行修改或替换，并尽量利用系统的硬件特点，以达到尽可能高的性能。但是所有的优化都必须保持和标准算法如高斯消去法相同的相对精度，而且必须使用Linpack的主程序进行调用。测试者可修改或替换其中的过程调用例程DGEFA 和DGESL 。其中DGEFA 是Linpack 软件包中标准的高斯消去LU 分解过程，而DGESL 是根据分解后得到的结果回代求解过程。</p><hr><p>—- 针对大规模并行计算系统的测试，即Highly Parallel Computing。</p><p>在这一测试中，问题规模限制被取消，针对现代的并行计算机，要求最宽松，即用户可对任意大小的问题规模，使用任意个数的CPU ，使用各种优化方法（必须基于高斯消去法）来执行该测试程序，寻求最佳的测试结果。</p><p>目前，用Linpack基准测试出的最高性能指标已经成为衡量机器性能的标准之一，这个数字可以作为对系统峰值性能的一个修正。</p><h3 id="HPL基准测试"><a href="#HPL基准测试" class="headerlink" title="HPL基准测试"></a><strong>HPL基准测试</strong></h3><p>（1）概述</p><p>HPL，即High Performance Linpack，目前已经成为国际标准的Linpack基准测试程序，其1.0版于2000年9月发布，是第一个标准的公开版本并行Linpack测试软件包，一般用于全世界TOP500超级计算机上的并行超级计算机排名。HPL测试标准的用户自由度要大很多，使用者可以选择矩阵的规模，分块大小，分解方法等等一系列的各种参数，都是按需要更改的。 </p><p>HPL软件包需要在配备了MPI环境下的系统中才能运行，还需要底层有线性代数子程序包BLAS的支持（或者有另一种向量信号图像处理库VSIPL也可）。</p><p>HPL软件包不仅提供了完整的Linpack测试程序，还进行了全面细致的计时工作，最后可以得到求解的精确性和计算所花费的总时间。该软件在系统上所能达到的最佳性能值适合很多因素有关的。</p><p>（2）主算法</p><p>该软件包是用来求一个N维的线性方程组A x = b的解，首先通过选局部列主元的方法对Nⅹ(N+1)的[A b]系数矩阵进行LU分解成如下形式：</p><p>[A b]=[[L,U] y]</p><p>由于下三角矩阵L因子所作的变换在分解的过程中也逐步应用到b上，所以最后方程组的解x就可以由转化为求解上三角矩阵U作为系数矩阵的线性方程组 U x = y从而得到。</p><p>为了保证良好的负载平衡和算法的可扩展性，数据是以循环块的方式分布到一个P x Q的由所有进程组成的2维网格中。N x (N+1)的系数矩阵首先在逻辑上被分成一个个Nb x Nb大小的数据块，然后循环的分配到P x Q进程网格上去处理。这个分配的工作在矩阵的行、列两个方向同时进行。</p><p>在前面所提到的N，Nb，P，Q都是可以根据集群的具体配置和用户需要而随时修改的，也是HPL测试中十分关键和重要的几个参数。详细内容请看后面。</p><h3 id="HPL的安装及使用"><a href="#HPL的安装及使用" class="headerlink" title="HPL的安装及使用"></a><strong>HPL的安装及使用</strong></h3><p>主要软件包：</p><p>hpl-2.1.tar.gz</p><p>GotoBLAS2-1.13.tar.gz</p><p>openmpi-1.6.5.tar.gz</p><p><strong>HPL的安装过程</strong></p><p>（1）安装gotoblas</p><p>注：出于提高性能的因数，选择GOTO BLAS，作为HPL调用的底层线性代数子程序包</p><p>目前最新版本为GotoBLAS2</p><p>下载GotoBLAS2-1.13.tar.gz</p><p>（网址<a href="https://www.tacc.utexas.edu/tacc-projects/gotoblas2）" target="_blank" rel="noopener">https://www.tacc.utexas.edu/tacc-projects/gotoblas2）</a></p><blockquote><p>这个网址not found，直接在学习通下载</p></blockquote><p>执行步骤：</p><blockquote><p>需要在虚拟机上进行，先把文件传到虚拟机上</p></blockquote><p>在usr/local/mathlib/goto下解压：（随便什么位置应该都可以）</p><p>$ tar -zxvf GotoBLAS2-1.13.tar.gz</p><p>$ cd GotoBLAS2</p><p>$ make  （TARGET=NEHALEM）</p><p>注：可直接输入#make既可 也可自己选择参数 类似</p><p> $ make CC=gcc  BINARY=64 TARGET=NEHALEM </p><p>依次是编译器 库的位数和cpu的类型（architecture），具体可选择的参数可从GotoBLAS2的目录下02QuickInstall.txt的查找</p><p>（3）安装openmpi</p><p>（4）安装HPL</p><p>（5）编译</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU数据结构</title>
      <link href="/2020/11/28/shu-shu-ju-jie-gou/"/>
      <url>/2020/11/28/shu-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外国经典音乐</title>
      <link href="/2020/11/17/wai-guo-jing-dian-yin-le/"/>
      <url>/2020/11/17/wai-guo-jing-dian-yin-le/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐的巴洛克——巴洛克艺术的整体风格"><a href="#音乐的巴洛克——巴洛克艺术的整体风格" class="headerlink" title="音乐的巴洛克——巴洛克艺术的整体风格"></a>音乐的巴洛克——巴洛克艺术的整体风格</h2><h3 id="第一讲-音乐与建筑、音乐与绘画、音乐与宗教"><a href="#第一讲-音乐与建筑、音乐与绘画、音乐与宗教" class="headerlink" title="第一讲 音乐与建筑、音乐与绘画、音乐与宗教"></a><strong>第一讲 音乐与建筑、音乐与绘画、音乐与宗教</strong></h3><p><strong>巴洛克艺术的整体风格</strong> “巴洛克（Baroque） 一词源自葡萄牙文，意为不规则的珍珠。</p><p>18世纪“巴洛克”一词首先用于建筑，被18世纪的文艺理论家用来贬称17世纪以来的意大利建筑、雕刻、绘画等艺术。后来巴罗克一词成为一个时代艺术风格的代名词。</p><p>在艺术史上，巴洛克风格是指17、18世纪一种华丽的建筑风格，表现为精密的雕刻、弯曲的线条和夸张的装饰，这种风格明显和文艺复兴时期的平衡风格形成对比。</p><p><strong>巴洛克建筑、雕塑与绘画</strong></p><p>巴洛克时期的艺术表现的是充满动感的形态和刻意夸张的结构</p><p>德国哲学家谢林把建筑称为“凝固的音乐”，因而音乐也被称为“流动的建筑”。建筑与音乐作为艺术的两个载体，相互关联，相互渗透。建筑和音乐的外在形式可以有很多种，但其中的审美规律和审美意蕴有着异曲同工之意味。</p><p>巴洛克建筑（Baroque Architecture）与巴洛克音乐（ Baroque Music）都冠以“巴洛克”这个定语。一个是空间艺术，一个是时间艺术。这二者互相渗透呈现了巴洛克时代的人文景观。</p><p><strong>音乐中的巴洛克</strong></p><p>   巴洛克时期的艺术特征是高贵庄严，气势雄伟，富有动力，激情和张力。同时期的音乐大体上也具有这些特征。巴洛克音乐时期由于普遍使用数字低音记谱法，因此又称“数字低音时代”。</p><p>   巴洛克时期一般是指1600年到1750年，共150年的历史阶段。其重要的标志是1600年歌剧的诞生，到1750年巴赫逝世为止。</p><p><strong>巴洛克时期代表音乐家</strong></p><p>  像同时代的姊妹艺术一样，巴洛克时期的音乐也充满着激情与色彩，在追求广博与深远的同时，也喜好精致与华丽。在这一个半世纪的音乐历史中，出现大批作曲家，主要代表有：蒙特威尔第、维瓦尔第、吕利、珀塞尔、亨德尔和J.S.巴赫等。他们的创作领域和艺术个性虽然各不相同，但都包含了巴洛克音乐的某些基本特征。</p><p>  音乐在西方文明进程中与宗教文化关系紧密，甚至可以说它就是宗教文化的一部分。圣咏、经文歌、赞美诗、弥散曲等都是宗教音乐文化的主要形式。西方音乐就是在这个基础上发展起来的。</p><p>​    18世纪启蒙时期以后，音乐开始向世俗化发展，艺术的自主性、社会性以及创造性进入蓬勃发展的时期。但宗教音乐仍然占据着一定的地位。从巴洛克时期、古典时期到浪漫时期，众多的音乐大师们给我们留下了极其丰富的宗教音乐的遗产。</p><p><strong>圣咏——宗教音乐重要源头</strong></p><p>   宗教音乐是欧洲艺术音乐的源头。在18世纪以前，欧洲音乐主要以教会音乐为主，而教会音乐则以圣咏为主。圣咏是指单声调，没有固定节拍的宗教歌曲，分东方圣咏和西方圣咏，前者例如亚美尼亚圣咏，拜占庭圣咏等，后者例如安布罗西圣咏，格里高利圣咏等。公元6世纪，教皇格雷高利一世对宗教音乐——圣咏进行了统一。</p><p><strong>管风琴——宗教音乐的象征</strong></p><p>   管风琴在西方音乐中是历史最悠久的键盘乐器。它的体积庞大，构造复杂，通常是固定置放在大教堂或音乐厅里，大型的管风琴可拥有多层键盘和上千根乐管。因此，管风琴的音域宽广，音量洪大、音色多样，气势宏伟，能模仿管弦乐器效果，能演奏丰富的和声，有“乐器之王”之称。</p><p> 管风琴具有雄伟磅礴的气势，肃穆庄严的气氛，其丰富的和声效果绝不逊色于一支管弦乐队，是最能激发人类产生敬畏之情的乐器，也是最具宗教色彩的乐器。</p><p>经典作品赏析：</p><p><strong>管风琴曲《D小调托卡塔与赋格》</strong></p><p>这首作品是德国作曲家、管风琴家 约翰•塞巴斯蒂安•巴赫（Johann Sebastian Bach ，1685-1750）的代表作之一，具有华丽的技巧、风格和雄伟的戏剧情节。是巴赫在1704-1707年间专为阿恩斯塔德教堂的新管风琴所创作的。</p><p>托卡塔（Toccata）是巴洛克时期常用的键盘音乐乐体裁，以炫示即兴创作和表演为主要目的。</p><p>赋格是拉丁文Fuga的音译，意思是“飞翔”、“遁走”。是复调音乐中最复杂而又严谨的曲式体裁，其结构通常包括呈示部、展开部、再现部三部分，基本特点是运用模仿对位法，使一个简短而富有特性的主题在乐曲的各个声部轮流出现，互相模仿，造成力量的不断积聚增长，当乐曲内在的能量完全释放，乐曲便告结束。因此了解主题的性格特点往往是把握整个乐曲的关键。</p><p><strong>清唱剧《弥赛亚》</strong></p><p><strong>英籍德国作曲家</strong>亨德尔（Georg Friedrich Handel，1685-1759）的代表作。亨德尔出生在德国中部的哈雷镇。成年后的亨德尔离开汉堡游历欧洲。最后他选择了英国，并在伦敦定居下来，在这个城市生活了近50年。成为英国音乐界的领军人物，对英国的音乐发生深远的响。</p><p><strong>清唱剧(Oratorio)</strong>是一种从十七世纪发展起来的音乐形式，常以宗教或半宗教故事作为主题，没有复杂的舞台情节而注重音乐的表现。亨德尔的清唱剧由于剧情取材于英国人耳熟能详的圣经故事，且采用英语演唱，因此广受英国人喜爱。1742年，他仅用24天就完成了清唱剧《弥赛亚》的创作。同年这部作品在爱尔兰首府都柏林低调上演，获得了巨大的成功。亨德尔在英国的声誉得到极大的提升，成为英国的音乐生活的核心人物。</p><p> 《弥撒亚》分三部分：第一部分为 [预言与完成] 描写耶稣诞生的预言和他的诞生。第二部分为 [受难与得胜] 描写耶稣四处传播福音和受难。第三部分为 [复活与光荣] 写耶稣显圣复活。全曲包括有序曲、咏叹调、独唱、重唱、合唱、间奏等57首分曲。</p><p>​    这部作品每年圣诞节都在世界各地上演，以庆祝耶稣基督的降生并歌颂他的救世精神。其中“哈里路亚”合唱以其崇高雄浑的旋律，谐和丰满的和声，鲜明活跃的节奏，充分表现出基督教徒对救世主衷心的感恩，以及欢愉喜悦的心情。</p><p>《弥赛亚》中的第44分曲 “哈里路亚”合唱</p><p><strong>巴洛克艺术的共通性</strong></p><p> 巴洛克时期艺术的重要特点之一就是艺术一体化的高度融合和繁荣，无论是建筑、雕塑、绘画、音乐都相互影响，相互融合，所有宏伟建筑都囊括了这些艺术组合。在表现形式上，巴洛克艺术在观念和造型上是大胆的、装饰性的、且气势宏伟、动感强烈、充满活力。</p><h3 id="第二讲-数字与音乐的游戏——巴洛克复调艺术之美"><a href="#第二讲-数字与音乐的游戏——巴洛克复调艺术之美" class="headerlink" title="第二讲 数字与音乐的游戏——巴洛克复调艺术之美"></a>第二讲 数字与音乐的游戏——巴洛克复调艺术之美</h3><p>杜费与经文歌《近日玫瑰开放》</p><p>巴洛克时期的键盘乐器：拨弦古钢琴、击弦古钢琴、近代钢琴（1710）、现代钢琴（1850）</p><p>巴赫与《十二平均律钢琴曲集》——钢琴乐的“旧约全书”</p><p>《C大调前奏曲与赋格》</p><p>约翰·帕赫贝尔与卡农，帕赫贝尔的卡农的全名是《Canon and Gigue in D major for 3 violins and Basso Continuo》（为三把小提琴和通奏低音创作的D大调卡农和吉格舞曲）。</p><p>《G弦上的咏叹调》</p><p>出自巴赫《D大调第3管弦乐组曲》第二乐章“咏叹调”。1871年由德国小提琴家威廉密将其改编成小提琴独奏曲，他将原曲由D大调改为C大调，让乐曲的主旋律完全在小提琴最低的一根弦——G弦上演奏，此曲因而得名“G弦上的咏叹调”：</p><p><strong>复调</strong></p><p>一种“多声部音乐”。作品中含有两条以上（含）独立旋律，通过技术性处理，和谐地结合在一起，这样的音乐就叫做<em>复调</em>音乐。</p><h3 id="第三讲-神性时代的世俗快乐"><a href="#第三讲-神性时代的世俗快乐" class="headerlink" title="第三讲 神性时代的世俗快乐"></a>第三讲 神性时代的世俗快乐</h3><p>世俗歌曲起源：意大利牧歌</p><p><strong>意大利牧歌 蒙特威尔第《残酷的阿马里利》</strong></p><p>文艺复兴时期最后一位伟大的牧歌作曲家，巴洛克早期歌剧奠基人</p><p><strong>法国尚松 雅内坎《百鸟之歌》</strong></p><p><strong>第一部歌剧</strong></p><p>1597利努契尼剧本，佩里作曲《达芙妮》（残片）</p><p>1600利努契尼剧本，佩里和卡契尼作曲《尤里迪西》（Euridice）</p><p><strong>第一座歌剧院</strong>（1637，威尼斯，圣卡西亚诺）</p><p><strong>蒙特威尔第 歌剧《奥菲欧》序曲</strong>(歌剧史上第一部真正意义上的歌剧，1607)</p><p><strong>巴洛克时期主要四大类乐器</strong></p><p>键盘乐器、弦乐器、管乐器、打击乐器</p><p><strong>巴洛克时期的乐曲题体裁</strong></p><p>巴洛克时期奏鸣曲（sonata）巴洛克时期协奏曲（concerto）</p><p>托卡塔（toccata）赋格曲（fugue）前奏曲（prelude）组曲（Dance Suite）</p><p><strong>安东尼奥·维瓦尔第</strong>“红发神父”（1678-1741）</p><p>“快慢快”三乐章结构规范，对巴洛克协奏曲贡献巨大，为古典协奏曲形式打下基础</p><p>维瓦尔第 小提琴协奏曲《四季》（指挥：卡拉扬，小提琴：安妮·索菲·穆特）</p><p>第一乐章：快板</p><p>第二乐章：广板</p><p>第三乐章：快板“田园舞曲”</p><p><strong>亨德尔 管弦乐组曲《水上音乐》</strong></p><h2 id="形式美的时代"><a href="#形式美的时代" class="headerlink" title="形式美的时代"></a>形式美的时代</h2><h3 id="第一讲-十八世纪西方宫廷音乐文化"><a href="#第一讲-十八世纪西方宫廷音乐文化" class="headerlink" title="第一讲 十八世纪西方宫廷音乐文化"></a><strong>第一讲 十八世纪西方宫廷音乐文化</strong></h3><p><strong>约瑟夫·海顿 ——维也纳古典乐派奠基人</strong>（1732-1809）“交响曲之父”</p><p>古典主义（法语：Le Classicisme 英语：Western classical），形成并繁盛于17世纪的法国，从古希腊罗马文化里面吸取艺术形式和题材，主张拥护中央集权，尊崇王权，歌颂君主；崇尚理性，克制个人情欲，有严格的艺术规范和标准。</p><p>注重形式优雅与和谐的美。</p><p>古典乐派（18世纪中叶-19世纪30年代）</p><p><strong>第45交响曲“告别”末乐章</strong></p><p>引发思考：古典主义时期音乐家社会身份、音乐家与雇主的关系</p><p><strong>交响曲</strong></p><p>第一乐章：快板，奏鸣式</p><p>第二乐章：广板行板或广板，奏鸣式或主题与变奏形式</p><p>第三乐章：带三声中部的小步舞曲</p><p>第四乐章：快板或比第一章更快的急板</p><p>乐队编制以弦乐四声部为基础，双管制的管弦乐体制在海顿手里成型</p><p><strong>海顿 第94交响曲“惊愕”第二乐章片段</strong></p><p>引发思考：古典主义时期音乐的功能：娱乐社交</p><p><strong>海顿 弦乐四重奏 NO.76-3 “皇帝”第二乐章</strong></p><h3 id="第二讲-纯音乐之美在形式中自由飞扬"><a href="#第二讲-纯音乐之美在形式中自由飞扬" class="headerlink" title="第二讲 纯音乐之美在形式中自由飞扬"></a><strong>第二讲 纯音乐之美在形式中自由飞扬</strong></h3><p><strong>沃尔夫冈阿马德乌斯莫扎特</strong>（Wolfgang Amadeus Mozart，1756-1791）</p><p>萨尔茨堡与维也纳</p><p><strong>莫扎特 D小调第20钢琴协奏曲</strong></p><p>第一乐章：快板</p><p>第二乐章：慢板，浪漫曲</p><p>第三乐章：快板，回旋曲</p><p><strong>莫扎特 A大调第五小提琴协奏曲</strong></p><p><strong>莫扎特 第40交响曲</strong></p><p>第一乐章：很快的快板 G小调 2/4 奏鸣曲式</p><p>第二乐章：行板 降E大调 6/8 奏鸣曲式</p><p>第三乐章：小快板 G小调 3/4 小步舞曲</p><p>第四乐章：很快的快板 G小调 2/2 奏鸣曲式</p><p><strong>小夜曲或嬉游曲</strong></p><p>主要是指供娱乐的，室内重奏乐队演奏的多乐章组曲，主题朴素民歌风，情绪轻松活泼</p><p><strong>莫扎特 G大调弦乐小夜曲</strong></p><p>第一乐章：快板，奏鸣曲式</p><p>第二乐章：行板，浪漫曲</p><p>第三乐章：小快板，小步舞曲</p><p>第四乐章：快板，回旋曲</p><h3 id="第三讲-音乐戏剧的天才禀赋"><a href="#第三讲-音乐戏剧的天才禀赋" class="headerlink" title="第三讲 音乐戏剧的天才禀赋"></a>第三讲 音乐戏剧的天才禀赋</h3><p><strong>莫扎特的歌剧</strong></p><p>意大利喜歌剧：《费加罗的婚礼》《唐璜》《女人心》</p><p>德国歌唱剧：《魔笛》《后宫诱逃》</p><p>正歌剧：《伊多美纽斯》《狄多的仁慈》</p><p><strong>莫扎特 歌剧《费加罗的婚礼》男中音选段 费加罗“你不要再去做情郎”</strong></p><p><strong>莫扎特</strong> <strong>歌剧《费加罗的婚礼》女高音二重唱“微风轻拂的时光”</strong></p><h2 id="奏响时代最强音"><a href="#奏响时代最强音" class="headerlink" title="奏响时代最强音"></a>奏响时代最强音</h2><h3 id="第一讲-音符迸发出的思想火花"><a href="#第一讲-音符迸发出的思想火花" class="headerlink" title="第一讲 音符迸发出的思想火花"></a>第一讲 音符迸发出的思想火花</h3><p><strong>路德维希·范·贝多芬</strong>(1770-1872)——集古典音乐之大成，开浪漫主义之先河</p><p>波恩时期与维也纳早中晚期，谐虐曲取代小步舞曲，主要作品歌剧《费德里奥》艺术歌曲《远方的爱人》宗教性合唱《庄严弥撒》</p><p><strong><em>贝多芬的交响曲</em></strong></p><p><strong>贝多芬 第三交响曲 “英雄” 第一乐章片断</strong></p><p>贝多芬 第五交响曲 “命运”第一乐章</p><p>贝多芬 第六交响曲“田园”第一乐章</p><p>贝多芬 第九交响曲 “合唱交响曲” 第四乐章片断</p><h3 id="第二讲-用音乐的力和美颂扬全人类最高理想"><a href="#第二讲-用音乐的力和美颂扬全人类最高理想" class="headerlink" title="第二讲 用音乐的力和美颂扬全人类最高理想"></a>第二讲 用音乐的力和美颂扬全人类最高理想</h3><p><strong><em>贝多芬的钢琴奏鸣曲</em></strong></p><p><strong>贝多芬 C小调第八钢琴奏鸣曲 “悲怆” 第一乐章</strong></p><p>贝多芬 第十四钢琴奏鸣曲 “月光”</p><p>贝多芬 D小调第十七钢琴奏鸣曲 “暴风雨”</p><p>贝多芬 第五钢琴协奏曲 “皇帝”第三乐章</p><p><strong>贝多芬弦乐四重奏 Op.59 ‘Rasumovsky’ No.2-4</strong></p><h2 id="音乐史上的“狂飙时代”"><a href="#音乐史上的“狂飙时代”" class="headerlink" title="音乐史上的“狂飙时代”"></a>音乐史上的“狂飙时代”</h2><p><strong>狂飙突进运动</strong>（<a href="https://baike.baidu.com/item/德语/240836" target="_blank" rel="noopener">德语</a>：Sturm und Drang）是指1760年代晚期到1780年代早期德国<a href="https://baike.baidu.com/item/新兴资产阶级/1831940" target="_blank" rel="noopener">新兴资产阶级</a>城市青年所发动的一次文学解放运动，也是德国启蒙运动的第一次高潮。这个时期，是文艺形式从<a href="https://baike.baidu.com/item/古典主义/202936" target="_blank" rel="noopener">古典主义</a>向<a href="https://baike.baidu.com/item/浪漫主义/214808" target="_blank" rel="noopener">浪漫主义</a>过渡时的阶段，也可以说是幼稚时期的浪漫主义。其名称来源于剧作家<a href="https://baike.baidu.com/item/克林格/13868929" target="_blank" rel="noopener">克林格</a>的戏剧“狂飙突进”，但其中心代表人物是<a href="https://baike.baidu.com/item/歌德/63083" target="_blank" rel="noopener">歌德</a>和<a href="https://baike.baidu.com/item/席勒/3020501" target="_blank" rel="noopener">席勒</a>，歌德的《<a href="https://baike.baidu.com/item/少年维特的烦恼" target="_blank" rel="noopener">少年维特的烦恼</a>》是其典型代表作品，表达的是人类内心感情的冲突和奋进精神。这次运动是由一批市民阶级出身的青年德国作家发起的，他们受到<a href="https://baike.baidu.com/item/启蒙时代/29262" target="_blank" rel="noopener">启蒙时代</a>影响，推崇天才，创造性的力量，并把其作为其<a href="https://baike.baidu.com/item/美学" target="_blank" rel="noopener">美学</a>观点的核心。狂飙突进时期的作家受到当时<a href="https://baike.baidu.com/item/启蒙运动/119997" target="_blank" rel="noopener">启蒙运动</a>的影响，特别是受到了<a href="https://baike.baidu.com/item/卢梭/193632" target="_blank" rel="noopener">卢梭</a>哲学思想的影响，他们歌颂“天才”，主张“自由”、“个性解放”，提出了“返回自然”的口号。但另一方面这些年轻作家反对启蒙运动时期的社会关系，驳斥了过分强调<a href="https://baike.baidu.com/item/理性/576586" target="_blank" rel="noopener">理性</a>的观点。这个运动持续了将近二十多年，从1765年到1795年，然后被成熟的<a href="https://baike.baidu.com/item/浪漫主义运动/10620044" target="_blank" rel="noopener">浪漫主义运动</a>所取代。</p><h3 id="第一讲-音乐中的幻想与狂想"><a href="#第一讲-音乐中的幻想与狂想" class="headerlink" title="第一讲 音乐中的幻想与狂想"></a>第一讲 音乐中的幻想与狂想</h3><p><strong>柏辽兹《幻想交响曲》第四乐章（柏林爱乐乐团 杨松斯指挥）</strong></p><p>恋人主题“固定乐思”</p><p><strong>李斯特</strong>（Franz Liszt，1811-1886）</p><p>匈牙利钢琴家、作曲家、指挥家，浪漫主义音乐代表人物，被誉为“钢琴之王”。</p><p>帕格尼尼的《第二小提琴协奏曲》与李斯特的音乐会练习曲《钟》</p><p><strong>李斯特 交响诗《前奏曲》</strong></p><p>引子：疑问动机，主部：年轻人对爱情的憧憬，展开部：暴风雨的来临，插部：田园曲，再现部，副部：爱情主题变为威严的进行曲，主部：年轻人在爱情中经历了考验重新恢复青春</p><p><strong>李斯特《匈牙利狂想曲》第二首</strong>“猫和老鼠”</p><p><strong>交响诗</strong></p><hr><h3 id="第二讲-音乐中抒情与激情"><a href="#第二讲-音乐中抒情与激情" class="headerlink" title="第二讲 音乐中抒情与激情"></a>第二讲 音乐中抒情与激情</h3><p><strong>门德尔松 《仲夏夜之梦》序曲</strong></p><p><em><em>舒伯特 艺术歌曲《小夜曲》 </em></em></p><p>舒伯特 艺术歌曲《魔王》</p><p><strong>舒曼 《a小调钢琴协奏曲》</strong></p><p>舒曼 钢琴作品《童年情景》之《梦幻曲》</p><h3 id="第三讲-浪漫狂潮中的孤独与坚守"><a href="#第三讲-浪漫狂潮中的孤独与坚守" class="headerlink" title="第三讲 浪漫狂潮中的孤独与坚守"></a>第三讲 浪漫狂潮中的孤独与坚守</h3><p><strong>肖邦</strong>（Fryderyk Chopin，1810-1849）</p><p><strong>肖邦 “革命”练习曲</strong></p><p>肖邦 降E大调夜曲 Op.9 No.2</p><p>肖邦 “黑键”练习曲 Op.10 No.5</p><p><strong>约翰内斯·勃拉姆斯</strong>——“最后的古典主义音乐家”</p><p>勃拉姆斯 第一交响曲 第一乐章——“贝多芬第十交响曲”</p><p>勃拉姆斯 艺术歌曲《摇篮曲》</p><p>勃拉姆斯 第五匈牙利舞曲 管弦乐版</p><p>勃拉姆斯 第一匈牙利舞曲 双钢琴</p><h3 id="第四讲-歌剧艺术的辉煌与绽放（一）"><a href="#第四讲-歌剧艺术的辉煌与绽放（一）" class="headerlink" title="第四讲 歌剧艺术的辉煌与绽放（一）"></a>第四讲 歌剧艺术的辉煌与绽放（一）</h3><p><strong>歌剧</strong></p><p>歌剧（英文：opera，意大利语：opera）是一门西方舞台艺术，简单而言就是主要或完全以歌唱和音乐来交代和表达剧情的戏剧（是唱出来而不是说出来的戏剧）。歌剧在17世纪，即1600年前后，出现在意大利<a href="https://baike.baidu.com/item/佛罗伦萨/32608" target="_blank" rel="noopener">佛罗伦萨</a>，源自<a href="https://baike.baidu.com/item/古希腊戏剧/1978649" target="_blank" rel="noopener">古希腊戏剧</a>的剧场音乐。歌剧的演出和戏剧的所需一样，都要凭借剧场的典型元素，如背景、<a href="https://baike.baidu.com/item/戏服/880548" target="_blank" rel="noopener">戏服</a>以及表演等。</p><p><strong>浪漫主义时期歌剧的繁荣</strong></p><p>歌剧序曲、间奏曲、咏叹调、重唱合唱</p><p><strong><em>19世纪意大利歌剧</em></strong></p><p><strong>乔阿基诺·安东尼奥·罗西尼</strong>（17952-1868）</p><p><strong>罗西尼 歌剧《塞维利亚理发师》 费加罗咏叹调“快给忙人让路”</strong></p><p>罗西尼 歌剧《威廉退尔》序曲 （片段）</p><p><strong>朱塞佩·威尔第</strong>（1813-1901）</p><p>威尔第 歌剧《纳布科》 合唱“飞吧，思想，展开金色的翅膀”</p><p>威尔第 歌剧《茶花女》选段“饮酒歌”</p><p>威尔第 歌剧《阿依达》  “凯旋”片段</p><p><strong>真实主义</strong></p><hr><p><strong>贾科莫·普契尼</strong>（1858-1924）</p><p>早期歌剧《曼侬·列斯科》中期《艺术家的生涯》《托斯卡》《蝴蝶夫人》晚期《西部女郎》《外套》（真实主义）《姜尼·斯基基》（仅有喜歌剧）<strong>《图兰朵》</strong></p><p>普契尼 歌剧《蝴蝶夫人》巧巧桑咏叹调“晴朗的一天”</p><p><strong>普契尼 歌剧《图兰朵》王子咏叹调“今夜无人入眠”</strong></p><h3 id="第五讲-歌剧艺术的辉煌与绽放（二）"><a href="#第五讲-歌剧艺术的辉煌与绽放（二）" class="headerlink" title="第五讲 歌剧艺术的辉煌与绽放（二）"></a>第五讲 歌剧艺术的辉煌与绽放（二）</h3><p><strong><em>喜歌剧</em></strong></p><hr><p><strong><em>法国抒情歌剧</em></strong></p><hr><p>托马、古诺、乔治·比才、圣桑、马斯涅</p><p>奥芬·巴赫 歌剧《地狱中的奥菲欧》序曲片段</p><p><strong>古诺 歌剧《浮士德》士兵合唱</strong></p><p><strong>《卡门》</strong>——“主导动机”</p><p>比才 歌剧《卡门》序曲</p><p><strong>比才 歌剧《卡门》 卡门的咏叹调“哈巴涅拉”</strong></p><p>比才 歌剧《卡门》 “斗牛士之歌”</p><p><strong>19世纪德国歌剧</strong></p><p><strong>瓦格纳</strong>（Richard Wagner，1813-1883）</p><p>瓦格纳 歌剧《尼伯龙根的指环》之《女武神》“女武神的骑行”</p><p><strong>瓦格纳 歌剧《罗恩格林》选段“婚礼进行曲”</strong></p><hr><h2 id="音乐中的民族旋风"><a href="#音乐中的民族旋风" class="headerlink" title="音乐中的民族旋风"></a>音乐中的民族旋风</h2><h3 id="第一讲-乐声中的森林、河流、晨曦、阳光"><a href="#第一讲-乐声中的森林、河流、晨曦、阳光" class="headerlink" title="第一讲 乐声中的森林、河流、晨曦、阳光"></a>第一讲 乐声中的森林、河流、晨曦、阳光</h3><p><strong>十九世纪民族乐派</strong></p><p>俄罗斯——格林卡，五人团</p><p>捷克——斯美塔纳，德沃夏克</p><p>挪威——格里格</p><p>芬兰——西贝柳斯</p><p>格里格《培尔·金特组曲》第一组曲 之 “晨曲”</p><p>格里格《培尔·金特组曲》第一组曲 之 “阿尼特拉舞曲”</p><p><strong>格里格《培尔·金特组曲》第二组曲 之 “索尔维格之歌”（第五首）</strong>    </p><p>西贝柳斯 交响诗《芬兰颂》</p><h3 id="第二讲-异国他乡的母国情怀"><a href="#第二讲-异国他乡的母国情怀" class="headerlink" title="第二讲 异国他乡的母国情怀"></a>第二讲 异国他乡的母国情怀</h3><p><strong>捷克作曲家德沃夏克</strong></p><p>《幽魂曲》,《水仙花》女高音咏叹调“月亮颂”</p><p><strong>德沃夏克 第九交响曲 “自新大陆”</strong>（版本：卡尔· 伯姆 指挥 维也纳爱乐乐团演奏）</p><p>斯美塔那 歌剧《被出卖的新嫁娘》序曲</p><p>斯美塔那 交响诗套曲《我的祖国》第二乐章《伏尔塔瓦河》</p><h2 id="欧亚风情画"><a href="#欧亚风情画" class="headerlink" title="欧亚风情画"></a>欧亚风情画</h2><h3 id="第一讲-业余出身的“专业”作曲家"><a href="#第一讲-业余出身的“专业”作曲家" class="headerlink" title="第一讲 业余出身的“专业”作曲家"></a>第一讲 业余出身的“专业”作曲家</h3><p><strong><em>五人团</em></strong></p><hr><p><strong>穆索尔斯基钢琴组曲 《图画展览会》（管弦乐版）”基辅大门”</strong></p><p>格林卡 歌剧《鲁斯兰与柳德米拉》序曲</p><p>里姆斯基-科萨科夫 交响组曲《舍赫拉查德》（又名《天方夜谭》）</p><p><strong><em>交响音画</em></strong></p><hr><p><strong>鲍罗丁 交响音画《在中亚细亚草原上》</strong></p><h3 id="第二讲-“悲情大师”的世纪绝唱"><a href="#第二讲-“悲情大师”的世纪绝唱" class="headerlink" title="第二讲 “悲情大师”的世纪绝唱"></a>第二讲 “悲情大师”的世纪绝唱</h3><p><strong>彼得·伊里奇·柴可夫斯基</strong>（1840-1893）——古典浪漫结合</p><p>《第四交响曲》《第五交响曲》《第六交响曲》圆舞曲替代谐虐曲</p><p>柴科夫斯基 第六交响曲“悲怆”第一乐章</p><p>柴科夫斯基 第一钢琴协奏曲 第一乐章</p><h3 id="第三讲-俄罗斯的舞剧音乐王国"><a href="#第三讲-俄罗斯的舞剧音乐王国" class="headerlink" title="第三讲 俄罗斯的舞剧音乐王国"></a>第三讲 俄罗斯的舞剧音乐王国</h3><p>柴科夫斯基的《天鹅湖》《胡桃夹子》《睡美人》</p><p><strong>柴可夫斯基 舞剧《天鹅湖》“主题”</strong></p><p>柴可夫斯基 舞剧《天鹅湖》“白天鹅和王子双人舞”</p><p>柴可夫斯基 舞剧《天鹅湖》“四小天鹅舞”</p><p>柴可夫斯基 舞剧《天鹅湖》“黑天鹅32圈转”</p><p>柴可夫斯基 舞剧《天鹅湖》“西班牙舞”“拿波里舞”</p><p>柴可夫斯基 舞剧《胡桃夹子》配乐 “糖梅仙子之舞”</p><p>柴可夫斯基 舞剧《胡桃夹子》配乐“花之圆舞曲” Waltz of the Flowers</p><p>柴可夫斯基 舞剧《睡美人》“婚礼大双人舞“ （双人舞-王子-公主-双人舞）</p><h2 id="从“印象”到“音响”（略）"><a href="#从“印象”到“音响”（略）" class="headerlink" title="从“印象”到“音响”（略）"></a>从“印象”到“音响”（略）</h2><h3 id="音响中五光十色的“印象”"><a href="#音响中五光十色的“印象”" class="headerlink" title="音响中五光十色的“印象”"></a>音响中五光十色的“印象”</h3><p><strong><em>印象主义</em></strong></p><p><strong>德彪西</strong>（1862-1918）</p><p>德彪西 管弦乐前奏曲《牧神午后》</p><p>德彪西 钢琴前奏曲《亚麻色头发的少女》</p><p>德彪西 钢琴曲《月光》‘</p><p>拉威尔 管弦乐曲《波莱罗舞曲》</p><hr><h2 id="课程回顾与总结"><a href="#课程回顾与总结" class="headerlink" title="课程回顾与总结"></a>课程回顾与总结</h2><h3 id="音乐家和音乐主题"><a href="#音乐家和音乐主题" class="headerlink" title="音乐家和音乐主题"></a>音乐家和音乐主题</h3><p>（1）古代音乐</p><p>西方最早的弦乐器是里拉琴，又称诗琴。</p><p>（2）中纪音乐</p><p>（3）文艺复兴时期的音乐</p><p>这一时期的乐派有尼德兰乐派（勃艮第乐派和法一佛兰德乐派）、罗马乐派、威尼斯乐派。</p><p>（4）巴洛克时期的音乐</p><p>①欧洲历史上的第一部歌剧是由里努契尼写脚本、佩里作曲的《达芙妮》，但是乐谱已失传。现存的第一部歌剧是《优丽狄茜》，由里努契尼写脚本、佩里和卡契尼作曲。</p><p>②清唱剧又叫圣剧、神剧，17世纪诞生于意大利，是一种宗教性的大型声乐体裁。创作清唱剧的最重要的作曲家是卡里西米和亨德尔。</p><p>③巴赫，德国作曲家，代表作品有《平均律钢琴曲集》《赋格的艺术》《b小调弥撒曲》《马太受难乐》等。</p><p>（5）古典主义时期的音乐</p><p>①维也纳古典时期的代表作曲家是海顿、莫扎特和贝多芬，称他们为“维也纳三杰”。</p><p>②海顿是古典维也纳乐派的奠基者，被誉为“交响曲之父”“弦乐四重奏之父”。代表作有12首“伦敦”交响曲，清唱剧《创世纪》和《四季》等。</p><p>③莫扎特是西方音乐史上最富有智慧的音乐家，被誉为“音乐神童”，代表作品有歌剧《后宫诱逃》《费加罗的婚礼》《唐璜》《魔笛》，钢琴奏鸣曲《G大调弦乐小夜曲》等。</p><p>④贝多芬被誉为“乐圣”，他在后期虽然两耳失聪，但仍然坚持音乐创作，代表作品有钢琴奏鸣曲《悲怆》《月光》《暴风雨》《黎明》《热情》，交响曲《第三交响曲“英雄”》《第五交响曲“命运”》《第六交响曲“田园”》《第九交响曲“合唱”》，歌剧《费德里奥》等。</p><p>（6）浪漫主义时期的音乐</p><p>①韦伯，德国浪漫主义歌剧奠基人。</p><p>②舒伯特，德奥艺术歌曲之王，代表作品有艺术歌曲《野玫瑰》《魔王》《鳟鱼》，声乐套曲《美丽的磨坊姑娘》《冬之旅》，钢琴小品《音乐的瞬间》等。</p><p>③门德尔松，德国作曲家，首创钢琴体裁“无词歌”。</p><p>④舒曼，德国作曲家、钢琴家、音乐评论家，代表作品有钢琴套曲《狂欢节》《童年情景》，声乐套曲《桃金娘》《诗人之恋》等。</p><p>⑤肖邦，波兰钢琴家、作曲家，被誉为“钢琴诗人”，是较早将东欧民间音乐融入西方音乐艺术的大师。</p><p>⑥李斯特，匈牙利钢琴家、作曲家、指挥家，被誉为“钢琴之王”。</p><p>⑦古诺，法国作曲家，代表作品有《浮土德》《罗密欧与朱丽叶》等。</p><p>⑧比才，法国作曲家，代表作品有歌剧《卡门》等。</p><p>⑨柴可夫斯基，俄国作曲家，代表作品有歌剧《叶甫盖尼·奥涅金》《黑桃皇后》，舞剧《天鹅湖》《睡美人》《胡桃夹子》，《第六“悲怆”交响曲》《1812序曲》等</p><p>（7）民族主义音乐</p><p>①俄国民族乐派的奠基人是格林卡和达尔戈梅斯基。格林卡是俄国民族歌剧的创始人，被称为“俄罗斯民族音乐之父”。</p><p>②帕修斯是芬兰民族乐派的创始人，“芬兰歌剧之父”，代表作品是第一部芬兰歌剧《卡尔王之猎》。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h3 id="形式与体裁"><a href="#形式与体裁" class="headerlink" title="形式与体裁"></a>形式与体裁</h3><p>1．曲调：具有歌唱性的器乐曲，常用于18世纪的组曲中。</p><p>2．阿勒曼德：17世纪盛行于法国和英国的舞曲体裁，四拍子，节奏平稳，速度较慢，常用于组曲。同样的名称在19世纪指流行于瑞士乡村的三拍子轻快舞曲，它是华尔兹的前身。</p><p>3．赞美歌：英国基督教教会仪式所用音乐，有独唱、合唱形式，歌词大多取自圣经，用英语演唱，一般用管风琴伴奏。</p><p>4．咏叹调：独唱曲，是歌剧、清唱剧等大型声乐作品中的重要段落，也可以是独立的作品。具有高超的演唱技巧和幅度较大的情感抒发。</p><p>5．叙事歌：</p><p>（1）13、14世纪的法国世俗歌曲；</p><p>（2）19世纪盛行于德国的具有叙事性的歌曲，内容常与民间故事、传奇有关；</p><p>（3）19世纪抒情浪漫的器乐曲，如肖邦和勃拉姆斯的钢琴作品。</p><p>6．芭蕾舞剧：由舞蹈演员身着剧装在音乐伴奏下表演的戏剧。起源于文艺复兴时期的意大利，后传入法国获得极大发展。最初的法国芭蕾舞剧音乐不仅有器乐，还有歌唱和朗诵，因此可看作是歌剧的前身（当时的歌剧中也有芭蕾舞，此传统一直延续到19世纪末，并影响到意大利歌剧）。19世纪中叶以后出现大量优秀的芭蕾舞剧音乐，如柴可夫斯基的《天鹅湖》、斯特拉文斯基的《火鸟》等。</p><p>7．船歌：来源于威尼斯船夫歌曲的器乐曲（钢琴曲为多，也有管弦乐曲），6/8或12/8拍，速度和缓，通常是在荡漾的节奏韵律之上有一条歌唱性的悠扬曲调。</p><p>8．摇篮曲：安静温和的声乐或器乐小曲，节奏有如摇篮缓缓摆动。</p><p>9．布鲁斯：又译蓝调。美国爵士乐的一种风格，源于黑人灵歌。通常为十二小节，节奏平稳，速度较慢，其名称来源于别具特色的常降低半音的大调第三和第七级音。</p><p>10．波莱罗：西班牙舞曲，三拍子，稳定的中速，用响板敲击具有特性的节奏。拉威尔的管弦乐《波莱罗舞曲》是最著名的作品，肖邦也写有这种风格的钢琴曲。</p><p>11．布列：</p><p>（1）盛行于17和18世纪的法国舞曲，速度较快，通常为2/2拍。</p><p>（2）现流行于法国中部奥弗涅山区的三拍子舞曲。</p><p>12．康康：19世纪末盛行于法国的舞曲，快速，2/4拍，热烈而粗俗。最著名的是奥芬巴赫所作轻歌剧《地狱中的奥菲欧》中的康康舞曲。</p><p>13．卡农：“规律”，一种二声部或更多声部的复调音乐形式，当一个声部的旋律出现之后，另外的声部紧跟模仿。它可以是一首独立乐曲的形式，也可在大型作品中出现局部性的卡农写法。</p><p>14．康塔塔：又译大合唱。盛行于17世纪和18世纪上半叶的多乐章声乐作品，包括独唱的宣叙调、咏叹调，重唱，合唱，由管弦乐队伴奏，与清唱剧相类似，但规模较小。有宗教的也有世俗内容的。巴赫留存于世的二百余部康塔塔是经典之作。</p><p>15．随想曲：</p><p>（1）16世纪末至17世纪较为自由的赋格性质器乐曲，多为古钢琴作品；</p><p>（2）技巧性练习曲，如帕格尼尼的《24首小提琴随想曲》；</p><p>（3）19世纪用于形式较为自由的乐曲，常借用著名曲调为主题，如柴可夫斯基的管弦乐曲《意大利随想曲》。</p><p>16．夏空：又译恰空。盛行于17世纪的风格庄重的三拍子舞曲，也是一种复调音乐形式，即在固定的主题或一连串固定的和声进行之上作多次变奏。</p><p>17．室内乐：指适合在室内而不是大厅由少数人演奏的器乐曲，早期曾包括声乐。主要体裁是数种重奏，最常见的是古典时期的弦乐四重奏、钢琴五重奏等。现在虽常在音乐厅演奏这类作品，但依然保持原有的细腻亲切的特性。</p><p>18．众赞歌：基督新教（路德教派）的赞美诗曲调，最早出版于1524年。宗教改革者马丁-路德将其作为改革手段之一（他本人还曾创作过一些）。其特点为：采用本国语演唱，曲调大多选自朴素通俗的民歌和古老的圣歌。起初为单声部，后来出现了主旋律在最高声部的四部合唱式以及复调形式。17、18世纪众赞歌成为重要的音乐创作源泉，如巴赫的管风琴众赞歌前奏曲、众赞歌变奏曲以及大量宗教康塔塔中都以众赞歌旋律为素材。</p><p>19．众赞歌前奏曲：以众赞歌为素材的管风琴曲通称，盛行于17、18世纪。在路德教派的教堂仪式中，会众唱赞美歌之前要先由管风琴将其旋律演奏一遍。演奏者可将旋律作自由变奏，这种做法逐渐形成了众赞歌前奏曲体裁。</p><p>20．协奏曲：也称作独奏协奏曲，是一件独奏乐器和管弦乐队的协奏。形成于18世纪，通常为快－慢－快三个乐章。在莫扎特奠定的古典协奏曲模式中，第一乐章有两个呈示部，即乐队先呈示主题，然后由主奏乐器在乐队伴奏下带有变化地再次呈示主题；第一乐章（有时也在末乐章）将近结束处有华彩乐段，即主奏乐器单独演奏的炫技性段落。19世纪逐渐不再遵循这种模式。</p><p>21．大协奏曲：盛行于17世纪和18世纪初的多乐章作品，是由几件乐器组成的独奏小组和管弦乐队的协奏。主奏组大多由小提琴、长笛、双簧管、大提琴、古钢琴组成，通常为2-5件乐器，它们细腻纤巧的音响与宏亮的乐队合奏形成鲜明对比。</p><p>22．库朗：盛行于17和18世纪初的活泼的三拍子舞曲，常用于组曲。</p><p>23．恰尔达什：又译查尔达什。匈牙利舞曲，由缓慢而忧郁的lassan段和快速热烈的friss段构成。李斯特的《第二匈牙利狂想曲》即典型的恰尔达什舞曲。</p><p>24．嬉游曲：盛行于18世纪末的轻松怡情的多乐章室内乐或小乐队作品。在莫扎特的嬉游曲中，也有些比较深刻严肃。</p><p>25．二重协奏曲：两件独奏乐器与乐队的协奏曲。如勃拉姆斯《小提琴与大提琴二重协奏曲》。</p><p>26．二重奏：供两人演奏（演唱）的形式，二个声部不分主次，可有伴奏或无伴奏。器乐二重奏（除钢琴二重奏外）还专门称做duo。</p><p>27．练习曲：专为练习乐器演奏技巧而作的乐曲。19世纪肖邦、李斯特、德彪西等人加强了这种体裁的艺术性，使之成为音乐会上的正式曲目。这类作品称为音乐会练习曲。</p><p>28．凡丹戈：活泼的西班牙舞曲，快速、三拍子，用响板和吉他伴奏。</p><p>29．幻想曲：器乐曲，总体特点是形式上自由不拘，带有幻想的性质。</p><p>（1）文艺复兴时期指不采用舞曲形式或变奏手法而采用复调技巧自由写作的器乐曲。</p><p>（2）巴洛克时期即兴性的键盘或琉特琴乐曲，如巴赫的《半音阶幻想曲》。</p><p>（3）古典主义时期在写法上比奏鸣曲更为自由的大型作品。</p><p>（4）浪漫时期带有幻想色彩的乐曲。</p><p>（5）根据现成主题（民歌、他人音乐素材）所写的乐曲，如李斯特《根据贝利尼歌剧&lt;梦游女&gt;主题而作的幻想曲》等。</p><p>30．法朗多尔：古老的法国舞曲，目前仍流行于普罗旺斯一带。6/8拍，也有2/4拍，如比才管弦乐组曲《阿莱城姑娘》中的《法朗多尔舞曲》。</p><p>31．弗拉门科：盛行于西班牙南部安达卢西亚的歌舞体裁，用吉他伴奏，常常带有悲伤意味。在西班牙吉他作品中弗拉门科是一种典型风格。</p><p>32．赋格：在一个主题上构成的多声部（至少二声部）复调作品。单声部的主题在原调上出现之后，另外的声部依次进行模仿。主题在全曲多次出现，中间有数个间插段，它们大多采用主题片断作素材，在不同调性上进行丰富多样的变化，也可引进新材料。最后一次主题在原调上完整出现，便告结束。赋格可用于一部独立的作品，也可用于一部大作品的局部，称作赋格段。</p><p>33．加伏特：盛行于17世纪的法国舞曲，传入宫廷后，成为当时各种作品中不可或缺的形式，如歌剧、组曲中常有加伏特舞曲。快速，4/4拍。</p><p>34．格里高利圣咏：又译素歌。罗马教会所保存并沿用至今的最古老的宗教歌曲集，以教皇格里高利一世命名。单声部旋律，节奏自由，以拉丁文歌词的抑扬顿挫为依据。</p><p>分为两大类：</p><p>（1）用于教堂举行弥撒的成套圣咏，内容集中于耶稣最后的晚餐与受难；</p><p>（2）用于修道院每天不同时辰祈祷的日课圣咏。</p><p>35．哈巴涅拉：又译阿伐奈拉。起源于古巴哈瓦那的舞曲，较慢的二拍子，第一拍为切分音。19世纪传入西班牙</p><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>音乐常识经典!<br>这些都是平时老师上课提到的一些比较常识的东西，有很多都是经典。</p><ol><li>三大安魂曲是指哪三首呢<br>三大安魂曲是指莫札特的《Ｄ小调安魂曲》、威尔第的《安魂曲》和佛瑞的《安魂曲 》。</li><li>三大神剧是指哪三首呢<br> 三大神剧是指韩德尔的《弥赛亚》、海顿的《创世纪》和门德尔松的《伊利亚 》</li><li>中国乐器有哪几类呢<br> 中国乐器依八音分类法分为金、石、丝、竹、匏、土、革、木八种</li><li>中国传统音乐如何分类呢<br> 中国传统音乐分为民间歌曲，民间歌舞，民间曲艺，民间戏曲，民间器乐！</li><li>西方乐器如何分类呢<br>西方乐器总括分为擦弦、木管、铜管及敲击四大类</li><li>五大纲琴协奏曲是指哪几首呢<br>贝多芬的《第五号降Ｅ大调钢琴协奏曲“皇帝”》、柴可夫斯基的《第一号降Ｂ大调钢琴协奏曲》、拉赫曼尼诺夫的《第二号Ｃ小调钢琴协奏曲》、舒曼的《Ａ小调钢琴协奏曲》和李斯特的《降Ｅ大调钢琴协奏曲合称为“五大纲琴协奏曲”》其实还有拉赫曼尼诺夫的《第三钢琴协奏曲》这是公认的世界最难钢琴曲。</li><li>六大交响曲是指哪几首呢<br> 六大交响曲包含了贝多芬的《第六田园交响曲》、《第五命运交响曲》、舒伯特的《第八未完成交响曲》、德沃夏克的《新世界交响曲》、柴可夫斯基的《悲怆交响曲》和柏辽兹的《幻想交响曲》</li><li>四大小提琴协奏曲是哪几首呢<br>贝多芬的《Ｄ大调小提琴协奏曲》、门德尔松的《Ｅ小调小提琴协奏曲》、柴可夫斯基的《Ｄ大调小提琴协奏曲》和布拉姆斯的《Ｄ大调小提琴协奏曲》并称为四大小提琴协奏曲 ，老师提的问题，很遗憾当时没有答上。</li><li>音乐史上的3B（4B）是指哪些人呢<br>布拉姆斯（Brahms, Johannes）、巴赫（Bach, Johann Sebastian）与贝多芬（Beethoven, Ludwig van）三人并称为音乐史上的3B，若是4B就要另加巴尔托克（Bartok, Bela）</li><li>音乐的新旧约是指什么呢<br>在音乐史上，通常我们会把巴赫的，《钢琴十二平均律曲集》比喻为旧约圣经，且把贝多芬的《三十二首钢琴奏鸣曲》比喻为新约圣经 ，这是去年考试没有答上的问题！</li><li>约翰·斯特劳斯家族的音乐家.小约翰·斯特劳斯(圆舞曲之王），老约翰·斯特劳斯（圆舞曲之父），其最出名的作品《拉德斯基进行曲》是每年维也纳新年音乐会的押尾曲目.爱德华·斯特劳斯。</li><li>谁是歌曲之王呢<br>  奥地利的舒伯特（Schubert, Franz (Peter)）因为留有超过六百首的歌曲而被称为歌曲之王 。代表曲目有《野玫瑰》，《魔王》 等，套曲有《冬之旅》，《美丽的磨坊女》。</li><li>谁是“交响曲之父”<br>  “交响曲之父”指的是海顿（Haydn, Franz Joseph）。由于当时的人们总把音乐会当作打瞌睡的场所，海顿创作了在漫长的宁静之后突然钟鼓齐鸣的“惊愕”交响曲 ，还是四重奏之父。</li><li>谁是“协奏曲之父”呢？<br>  “协奏曲之父”就是因一头红发而被称为“红发教士”的韦瓦尔第代表曲目《四季》</li><li>谁是“音乐之父”呢？<br>  “音乐之父”就是出身于音乐世家的巴赫。</li><li>谁是“音乐神童”呢？<br>  “音乐神童”就是从小就到处旅行演奏并创作的莫札特</li><li>谁是“神剧之父”呢？<br> “神剧之父”指的是神剧“弥赛亚”的作者亨德尔《弥赛亚》–《哈里路亚》。</li><li>谁是音乐史上的“乐圣”呢？<br>  “乐圣”是指丧失听力的贝多芬。</li><li>谁是“钢琴诗人”呢？<br>  波兰作曲家萧邦，被视为钢琴音乐最伟大的作曲家，通常被誉为“钢琴诗人”</li><li>十二平均律是由谁首创？</li></ol><p>中国十二平均律是由明代朱载堉首创，西洋十二平均律是由德国巴赫首创</p><p>21.交响诗是由谁首创？</p><p>交响诗是由李斯特首创，他曾受业于彻尔尼 ！</p><p>22.世界三大芭蕾舞剧为何？</p><p>世界三大芭蕾舞剧为柴可夫斯基所做的天鹅湖，睡美人及胡桃钳子</p><p>23.音乐史上最早的第一部协奏曲为何？</p><p>音乐史上最早的第一部协奏曲为科赖里所做的大协奏曲</p><p>24.古代组曲的顺序为何？</p><p>古代组曲的顺序为阿勒曼 库朗 萨拉邦 吉格</p><p>25.法国歌剧的创始人是谁？</p><p>法国歌剧的创始人是卢利</p><p>26.在西洋音乐史上有哪几位作曲家是二十世纪新音乐的开创者？</p><p>在西洋音乐史上被称为是二十世纪新音乐的开创者有德彪西、荀白克及斯特拉文斯基</p><p>27.何谓俄国五人组（强力集团）？</p><p>鲍罗丁、巴拉基列夫、居伊、穆索斯基及里姆斯基.科萨可夫被称为俄国五人组</p><p>31·谁有和声学之父之称？</p><p>法国了作曲家及理论家拉莫Rameau,Jean-Philippe (1683-1764) 有和声学之父之称，他是巴洛克时期的作曲家</p><p>32·何谓清唱剧？</p><p>清唱剧通常已故视为题材，有角色但无布景与动作的音乐</p><p>33·何谓巴黎六人组？</p><p>巴黎六人组(Les Six)为米约(Milhaud)、普朗克(Poulence)、奥里克(Auric)、迪霍(Durey)、塔乐费尔(Tailleferre)、奥乃格(Honnegar)</p><p>34·有哪些作曲家曾经编写管弦乐曲“罗密欧与朱丽叶”？</p><p>普罗科菲耶夫(Prokofiev)、柴可夫斯基(Tchaikovsky)、柏辽兹(Berlioz)三人均曾编写过管弦乐曲“罗密欧与朱丽叶”</p><p>35·谁是进行曲之王？</p><p>美国作曲家，致力于军乐队的发展，发明苏沙低音号的苏沙</p><p>36·谁是俄国音乐之父？</p><p>采用俄罗斯民谣作为主题运用欧洲式的音乐手法，创作许多民族性的音乐是俄国作曲家葛令卡</p><p>37·简谱是由谁创立的?？</p><p>简谱是由法国的医生兼音乐理论家舒威以音乐教育为目的(Cheve, Emile-Joseph-Maurice 1804～1864)所创立，所以这种简谱又称为”舒威谱式”。以阿拉伯数字中的1、2、3、4、5、6、7</p><p>38.一些美誉：音乐诗人–舒曼。</p><p>清唱剧大师–亨德尔。</p><p>乐剧工匠–瓦格纳</p><p>指挥界帝王–卡拉扬</p><p>歌剧之王–威尔第</p><p>男高音歌王–卡鲁索</p><p>高音之王–帕瓦罗蒂</p><p>小提琴之王–帕格尼尼</p><p>歌剧界女王–卡拉斯</p><p>钢琴之王（标题交响诗之父）–李斯特</p><p>现代管弦乐之父–柏辽兹</p><p>印象派大师–德彪西</p><p>法国音乐之父–保尔·莫里亚</p><p>俄罗斯音乐之父–格林卡</p><p>神弓–海菲兹</p><p>音乐绘画大师–穆索尔斯基</p><p>捷克音乐之父–德沃夏克</p><p>新捷克音乐之父–斯美塔纳</p><p>民族乐派大师–格里格</p><p>当代钢琴泰斗–鲁宾斯坦</p><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><h4 id="听辨题"><a href="#听辨题" class="headerlink" title="听辨题"></a>听辨题</h4><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%A4%96%E5%9B%BD%E7%BB%8F%E5%85%B8%E9%9F%B3%E4%B9%90%5C1.png" alt="1"></p><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%A4%96%E5%9B%BD%E7%BB%8F%E5%85%B8%E9%9F%B3%E4%B9%90%5C2.png" alt="2"></p><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><h4 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h4><h3 id="期中作业（莫扎特传电影影评or音乐会）"><a href="#期中作业（莫扎特传电影影评or音乐会）" class="headerlink" title="期中作业（莫扎特传电影影评or音乐会）"></a>期中作业（莫扎特传电影影评or音乐会）</h3><p><strong>《Amadeus》观后感</strong></p><p>关于电影。</p><p>影片中的沃尔夫冈·阿马德乌斯·莫扎特与安东尼奥·萨列里两人。</p><p>一个是上帝的宠儿，一个是信仰上帝最终却与上帝反目。</p><p>萨列里第一次遇见莫扎特是在一个非常喜剧的场景之下，那是一次大主教的宫廷乐会，萨列里因为好奇去寻找莫扎特，寻找无果于是去偷吃甜品，此时莫扎特正好在追逐嬉戏中出现了，而萨列里躲在一旁观察着他。</p><p>虽然该电影以莫扎特的中间名命名，但主角其实是莫扎特的对手——萨列里，而从萨列里的视角中，我也试着从旁观者的角度去看待莫扎特这个神话一般的音乐家。</p><p>电影主要讲述了年迈七十的维也纳宫廷乐师萨列里回忆起三十年前因嫉妒莫扎特的才华，数次从其音乐事业中作梗，精神折磨莫扎特并将其“谋杀”的故事。</p><p>莫扎特的音乐天赋和宫廷乐师父亲的严厉指导让他六岁就能写出协奏曲曲，十一岁创作了第一部歌剧，十七岁就在萨尔兹堡大主教的宫廷乐队里担任首席乐师。</p><p>而萨列里则远不如莫扎特幸运，虽然他出生在一个富商家庭，可是家里没人懂音乐，内心对音乐的渴望对他来说反而是一种折磨。直到父亲突然去世之后，萨列里才有机会挣脱束缚去学习音乐，并靠着自己的努力当上了宫廷乐长，所以他虔诚地信仰上帝。</p><p>其实萨列里更像是我们生活中的大多数人，一步步实现自己梦想的同时却又无可避免地沦为平庸，但他从未放弃对音乐的热爱，所以在遇见莫扎特的时候他又怎么能不心生嫉妒呢？他遇见的是一个幸运的音乐天才，一个只为热爱音乐而生的上帝宠儿，莫扎特可以一边放荡不羁，同时轻松地创造出吸引人的音乐。</p><p>就像德国诗人歌德曾评价莫扎特的那样：神的创造力在人间的化身，他的音乐才华是神送来的。</p><p>对于萨列里来说，莫扎特的音乐才华确实是一种打击，但同时由于他自己对音乐的热爱，他对莫扎特的嫉妒中其实也有着一种惺惺相惜。压倒骆驼最后的那根稻草，或许是他自己爱的人被莫扎特夺走的那一刻，从那一刻起，他开始彻头彻尾地嫉恨莫扎特的才华。</p><p>也难怪萨列里后来会与上帝反目，觉得上帝从未爱过世人，因为如果祂爱过，那为什么不多带点人去享享福呢，或者每个人轮着来也可以。</p><p>可是从来没有这样过。</p><p>所以我每次看到甜品出现的场景，都好像能听见有人在轻声低语“生活已经那么苦了，还是给自己加点糖吧。”</p><p>结尾处萨列里说，我代表世界所有的庸才。上帝宽恕你们。</p><p>其实看到电影结尾我反而没有多少讨厌萨列里，可能是因为他已经得到了应该得到的惩罚，并且用了一生来承受它。</p><p>但或许这也正应了那句话：人世间的苦难见多了，对那些即使是做错了事的人，也再难以说出活该二字。</p><p>关于音乐</p><p>算上这部传记电影的话，我也已经看过不少音乐相关的电影了，比如《海上钢琴师1900》《爆裂鼓手》等等，无一例外的是，我们都能从中感受到它们想向观众传达的那种特殊的情感，那就是对音乐极致般的热爱，而对音乐的热爱影响着音乐家们的一生，同时也影响了我们所有人的一生。</p><p>从电影刚开头牧师破门而入看到萨列里自杀，随即镜头切换到街上，维也纳夜晚的街头，行色匆匆，同时浮现出片名《Amadeus》，莫扎特第二十五交响曲奏起，仅凭音乐就能够感受到电影导演的用心良苦。</p><p>从萨列里面对年轻牧师回忆当初，第一首莫扎特《小夜曲》的出现使萨列里内心中仇恨的种子展露开始，再到他嘲讽莫扎特执意创作德语歌剧《后宫诱逃》、阻止《费加罗的婚礼》的上演、观看《唐璜》想到用莫扎特父亲来压垮莫扎特，音乐一步步推动着二人之间的矛盾和冲突，直至最后《安魂曲》宣告落幕，将莫扎特一生中最著名的音乐和歌剧作品贯穿全局，最终直指人物内心。</p><p>如果是对莫扎特本人或者对他的音乐有更深入了解的话，这部电影或许更加能够触动人心，而这其实也是艺术的魅力所在。无论是音乐、电影还是艺术作品，所有的艺术形式所传达出来的情感，都需要进行所谓的“二次加工”，不同的人甚至是同一个人在不同时期对同一作品会有不同的感触。我想，这或许也是它们能恒久流传至今的原因之一。</p><p>作为音乐家的莫扎特的确伟大，因为他的音乐至今仍能触动人们的心灵。</p><p>但就像他自己说的那样，“我是个低俗的人呢，但我的音乐绝不低俗”，他在音乐之外的生活上可能也只是一个普普通通的人，无法事事做到完美，而能够勇敢地面对生活不轻易屈服，并且一直对音乐报以热爱，这大概也是他人生之所以伟大的原因之一。</p><p>影片最后一幕，又响起了莫扎特那标志性的笑声，他仿佛带着他的音乐穿越时空而来，三个小时的电影已经结束，但他好像还在说：</p><p>“但我绝不会屈服，我会一直坚持，直到到达我音乐的尽头，直到你们的心里。”</p><p>​    “我，沃尔夫冈·阿玛多伊兹·莫扎特，在遭受羞辱与背叛后，向各位致敬。”</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读一篇科研论文</title>
      <link href="/2020/10/09/ru-he-yue-du-ke-yan-lun-wen/"/>
      <url>/2020/10/09/ru-he-yue-du-ke-yan-lun-wen/</url>
      
        <content type="html"><![CDATA[<h2 id="检索论文"><a href="#检索论文" class="headerlink" title="检索论文"></a>检索论文</h2><p>知网（学校资源库）、知乎、各大顶会……</p><h2 id="下载论文"><a href="#下载论文" class="headerlink" title="下载论文"></a>下载论文</h2><p><a href="https://tool.yovisun.com/scihub/" target="_blank" rel="noopener">sci-hub</a></p><h2 id="阅读论文"><a href="#阅读论文" class="headerlink" title="阅读论文"></a>阅读论文</h2><blockquote><p>拿到一篇文献后，不妨先问自己几个问题：</p><p><strong>（1）这篇文章属于什么领域或方向？</strong></p><p><strong>（2）解决了什么问题？为什么这个问题这么重要？</strong></p><p><strong>（3）使用了什么方法和模型？为什么这个方法可以解决这个问题？</strong></p><p><strong>（4）核心结论是什么？下一步还可以怎么做？</strong></p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="信号处理课程论文报告"><a href="#信号处理课程论文报告" class="headerlink" title="信号处理课程论文报告"></a>信号处理课程论文报告</h3><h4 id="报告要求"><a href="#报告要求" class="headerlink" title="报告要求"></a>报告要求</h4><p>The project report requires you to conduct a comprehensive self-proposed survey research on recent developments in the signal processing. The research topics can be relevant to the materials in your oral presentation, but not limited. You should focus on a particular topic with <strong><em>\</em>only one**</strong> particular <strong><em>\</em>journal**</strong> paper. The journal paper should be published in recent two years (2019-2020). The page limit of final project is between 10-15 with at least 10 references.</p><p><strong><em>\</em>Language:**</strong>    Mandarin (Suggested) or English (Optimal)</p><p><strong><em>\</em>Submission:**</strong> All the project report should be submitted before <strong><em>\</em>Week 11 (Nov 15th).**</strong> The upload files should include the checking report of your academic integrity, with overlapping rate less than <strong><em>\</em>20%**</strong>. <strong>Fail to upload the plagiarism checking report will not get the marks in your final exam.</strong></p><p><strong><em>\</em>Academic**</strong> <strong><em>\</em>Integrity:**</strong>    All the final report should avoid plagiarism, collusion and misconduct, which will include the checking report from the online academic integrity system. For the Mandarin version, please click    <a href="http://www.biguolunwen.com/?aid=983" target="_blank" rel="noopener">http://www.biguolunwen.com/?aid=983</a> or scan the QR code.  For English version,  please click    <a href="http://www.turnitin.com.cn/" target="_blank" rel="noopener">http://www.turnitin.com.cn/</a> or other system.</p><h4 id="选取论文"><a href="#选取论文" class="headerlink" title="选取论文"></a>选取论文</h4><p><strong><em>《Invertible Image Rescaling》</em></strong></p><p><strong>ECCV2020oral 可逆的图像变换</strong></p><p>论文地址：<a href="https://arxiv.org/pdf/2005.05650.pdf" target="_blank" rel="noopener"><strong>https://arxiv.org/pdf/2005.05650.pdf</strong></a></p><p>源码地址：<a href="https://github.com/pkuxmq/Invertible-Image-Rescaling" target="_blank" rel="noopener"><strong>https://github.com/pkuxmq/Invertible-Image-Rescaling</strong></a></p><h4 id="前言概述部分"><a href="#前言概述部分" class="headerlink" title="前言概述部分"></a>前言概述部分</h4><p>本文是对ECCV 2020 Oral论文《<strong>Invertible Image Rescaling</strong>》的解读。这篇论文提出了通过构建可逆缩放网络模型（IRN，Invertible Rescaling Net）来解决图像压缩或缩放后的还原问题，并且介绍了其相关构建方法和原理，可以从本质上缓解求解不适定问题（ill-posed problem）带来的困难。相对于前人完全忽视图像缩放中不适定问题的做法，其效果上的提升也非常显著。信息丢失(Information Loss)所导致的不适定问题（ill-posed）在现实中也大量存在，该论文提供的对丢失信息（Lost Information）进行建模的视角，相信可以对类似任务也有一定的参考价值。</p><h4 id="解读主体部分"><a href="#解读主体部分" class="headerlink" title="解读主体部分"></a>解读主体部分</h4><p><strong>研究背景</strong></p><p>信号在我们的日常生活中随处可见，例如：声音、图像、视频等。然而在信号的传输或存储过程中，往往会面临信号失真、质量变差等问题。比如，为了让图片能够适配各种不同分辨率的屏幕或者是为了节省图片的存储空间，高分辨率的图片通常会被缩减规模成低分辨率的图片，而在这个过程中发生了信息的损失，因此新的问题也随之而来，在图片被降低分辨率之后，如果要再次放大图片，就需要想办法恢复原来图片的分辨率和细节。</p><p>然而，在此之前传统的图片缩放方法由于损失了图片的高频信息所以并不是单映射的（non-injective），这就导致了图片缩减（downscale）后再扩大（upscale）的病态问题（ill-posed problem），即对降采样后图片的原图求解的病态(ill-posed)问题。</p><p>这是一个病态问题的原因是在降采样的过程中存在信息丢失(information loss)，以至于无法很好地还原回原图。而前人的做法一般是使用一个超分辨率的卷积神经网络，尝试从大量的数据中强行学习低分辨率到高分辨率的映射关系；或者使用encoder网络对原图进行降采样，同时使用decoder网络还原图片，二者进行联合训练(jointly training)达到更好的效果。但以上这些方法都没有从本质上解决病态问题，效果也不尽如人意。因此我们需要更好的方法来解决病态问题。</p><h4 id="报告PPT部分"><a href="#报告PPT部分" class="headerlink" title="报告PPT部分"></a>报告PPT部分</h4><p>不知道同学们平日里上网有没有遇到过这种情况：自己精心拍摄的高清照片/视频，想发给朋友or分享到朋友圈/微博/抖音/知乎，结果上传文件之后，直接被无良服务器压成超低分辨率渣画质。甚至有些图片/表情包在经过多次传播之后，画质已经糊到惨不忍睹。</p><p>其实，图片的降采样(缩放)可以说是对数字图像最常见的操作了，它的用处多种多样：压缩图片尺寸、节省服务器存储or带宽、适配不同分辨率的屏幕等等。像现在服务器资源这么贵，大家发微博/知乎也不交钱，顶多给各位多塞点广告，所以高清图片和视频自然是能压则压，能分得清张一山和夏雨就可以了。</p><p>如何恢复降采样后的图片是图像处理中一个非常有挑战的问题，一直没有被很好的解决。今天给大家介绍一篇在ECCV2020上最新的Oral工作，巧妙地尝试从本质上解决这个问题。</p><hr><p>这种情况是由于程序为了减轻服务器端的传输和存储压力，主动对信号进行了采样、压缩等操作，而这些操作会不可避免地引起信息丢失（information loss）的问题，造成对原始信号还原的挑战性。直到今天，信息丢失问题仍没有被很好地解决。</p><hr><p>……</p><hr><h4 id="补充文献资料部分"><a href="#补充文献资料部分" class="headerlink" title="补充文献资料部分"></a>补充文献资料部分</h4><h5 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h5><p><a href="https://zhuanlan.zhihu.com/p/22450818" target="_blank" rel="noopener">形象易懂讲解算法I——小波变换</a></p><blockquote><p>于是小波变换的出发点和STFT还是不同的。<strong>STFT是给信号加窗，分段做FFT</strong>；而小波直接把傅里叶变换的基给换了——将<strong>无限长的三角函数基</strong>换成了<strong>有限长的会衰减的小波基</strong>。这样<strong>不仅能够获取频率</strong>，还可以<strong>定位到时间</strong>了~</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/xiaobobianhuan.jpg" alt="xiaobobianhuan"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/xiaobo.jpg" alt="小波"></p><h5 id="可逆神经网络模型（Invertible-NN-INN）"><a href="#可逆神经网络模型（Invertible-NN-INN）" class="headerlink" title="可逆神经网络模型（Invertible NN, INN）"></a>可逆神经网络模型（Invertible NN, INN）</h5><p><a href="https://lilianweng.github.io/lil-log/2018/10/13/flow-based-deep-generative-models.html" target="_blank" rel="noopener">可逆神经网络模型</a></p><p><a href="https://zhuanlan.zhihu.com/p/268242678" target="_blank" rel="noopener">神经网络的可逆形式</a></p><p><a href="https://www.jianshu.com/p/37c482fe4d2a" target="_blank" rel="noopener">可逆神经网络 Invertible Neural Networks</a></p><p>对于一些问题，研究人员建立了复杂的理论模型，用于实现隐式参数到可测量值的映射，这种映射称之为前向过程。逆向过程即根据测量值得到隐式参数，这也是实际需要解决的问题。但是逆向过程难以解决，因为在前向过程中丢失了一些关键信息。</p><p>如果直接用传统神经网络去训练逆向过程，则效果会很受限，因为逆向过程为一对多映射。神经网络训练出的模型，最好情况是识别最可能的解决方案；最差情况是采用多种解决方案的平均值。</p><p>INN 有三个特征：（i）从输入到输出的映射是双射的，即它的逆存在（ii）正向和反向映射都是有效可计算的（iii）映射具有易处理的雅可比行列式，因此概率可以通过变量公式明确转换。</p><p>标准NN v.s. INN</p><p>标准 NN 直接对逆向过程进行训练，但其需要一个监督损失（SL）项，来区分真正的 x 与预测的 x（我们可以暂时把 SL 理解为一个确定的代价函数），而 y-&gt;x 这种一对多映射使得传统 NN 受到很大限制。INN 只对前向过程使用 SL，而由于并没有一个确定的 x 值，因此预测的 x 属于无监督损失（USL），需要遵循之前的 p(x)；另外，潜在变量 z 需要服从高斯分布，也是属于 USL。</p><p>由于在前向过程中会丢失一些信息，因此引入了额外的潜在输出变量 z，被训练去抓获与 x 有关的但并未包含在 y 内的信息。此外，需要训练网络根据高斯分布对 p(z) 进行调整。即，p(x|y) 被调整为一个确定的函数 x = g(y,z)，这个函数将已知的分布 p(z) 在满足 y 的情况下转换到 x 空间。</p><h5 id="Encoder-Decoder-网络"><a href="#Encoder-Decoder-网络" class="headerlink" title="Encoder-Decoder 网络"></a>Encoder-Decoder 网络</h5><p><a href="https://blog.csdn.net/qq_38906523/article/details/79838000" target="_blank" rel="noopener">Encoder-Decoder模型</a></p><p>所谓<strong>encoder-decoder模型，又叫做编码-解码模型。这是一种应用于seq2seq问题的模型</strong>。</p><p>那么seq2seq又是什么呢？简单的说，就是根据一个输入序列x，来生成另一个输出序列y。seq2seq有很多的应用，例如翻译，文档摘取，问答系统等等。在翻译中，输入序列是待翻译的文本，输出序列是翻译后的文本；在问答系统中，输入序列是提出的问题，而输出序列是答案。</p><p>为了解决seq2seq问题，有人提出了encoder-decoder模型，也就是编码-解码模型。所谓编码，就是将输入序列转化成一个固定长度的向量；解码，就是将之前生成的固定向量再转化成输出序列。 </p><p><strong>encoder-decoder模型虽然非常经典，但是局限性也非常大</strong>。最大的局限性就在于编码和解码之间的唯一联系就是一个固定长度的语义向量C。也就是说，编码器要将整个序列的信息压缩进一个固定长度的向量中去。但是这样做有两个弊端，一是语义向量无法完全表示整个序列的信息，还有就是先输入的内容携带的信息会被后输入的信息稀释掉，或者说，被覆盖了。输入序列越长，这个现象就越严重。这就使得在解码的时候一开始就没有获得输入序列足够的信息， 那么解码的准确度自然也就要打个折扣了</p><h5 id="不适定问题-ill-posed-problem"><a href="#不适定问题-ill-posed-problem" class="headerlink" title="不适定问题(ill-posed problem)"></a>不适定问题(ill-posed problem)</h5><p><a href="https://blog.csdn.net/leviopku/article/details/89296455" target="_blank" rel="noopener">计算机视觉中的不适定问题</a></p><p>适定问题(well-posed problem)和不适定问题(ill-posed problem)都是数学领域的术语。</p><p>前者需满足三个条件，若有一个不满足则称为”ill-posed problem”：</p><blockquote><p>a solution exists   </p><p> 解必须存在</p><ol start="2"><li>the solution is unique    </li></ol><p>解必须唯一</p><ol start="3"><li>the solution’s behavior changes continuously with the initial conditions. </li></ol><p>解能根据初始条件连续变化，不会发生跳变，即解必须稳定</p></blockquote><p>上述来自wiki。</p><hr><p>图像处理中不适定问题（ill posed problem）或称为反问题（inverse Problem）的研究从20世纪末成为国际上的热点问题，成为现代数学家、计算机视觉和图像处理学者广为关注的研究领域。数学和物理上的反问题的研究由来已久，法国数学家阿达马早在19世纪就提出了不适定问题的概念:称一个数学物理定解问题的解存在、唯一并且稳定的则称该问题是适定的（Well Posed）.如果不满足适定性概念中的上述判据中的一条或几条，称该问题是不适定的。典型的图像处理不适定问题包括：图像去噪（Image De-nosing），图像恢复（Image Restorsion），图像放大（Image Zooming），图像修补（Image Inpainting），图像去马赛克（image Demosaicing），图像超分辨(Image super-resolution )等。<br>迄今为止，人们已经提出许多方法来解决图像处理中的不适定性。但是如何进一步刻画图像的边缘、纹理和角形等图像中重要视觉几何结构，提高该类方法在噪声抑制基础上有效保持结构和纹理能力是有待深入研究的问题。</p><hr><h5 id="Super-Resolution（超分辨率）"><a href="#Super-Resolution（超分辨率）" class="headerlink" title="Super Resolution（超分辨率）"></a>Super Resolution（超分辨率）</h5><p><a href="https://blog.csdn.net/shenziheng1/article/details/72818588/" target="_blank" rel="noopener">漫谈深度学习在Super Resolution（超分辨率）领域上的应用</a></p><p><a href="https://blog.csdn.net/sinat_39372048/article/details/81628945" target="_blank" rel="noopener">超分辨率技术（Super-Resolution, SR）</a></p><p>超分辨率技术（Super-Resolution, SR）是指从观测到的低分辨率图像重建出相应的高分辨率图像，在监控设备、卫星图像和医学影像等领域都有重要的应用价值。</p><hr><p>Super Resolution（SR），这个方向做的事情是给你一张低分辨率的小图（Low Resolution，LR），通过算法将这张LR放大成一张高分辨率的大图（High Resolution，HR）。这个事情乍一听挺简单的，普通的插值算法即可胜任，其实大有玄机，主要的难点在于细节的恢复，如下两张图，第一张图是原图，第二张图是将原图进行3倍下采样后，用Bicubic插值算法[1]进行SR恢复的图像，从图像整体来看，第二张图比第一张图要显得糊一些，如果将蝴蝶的翅膀纹路放大看可以发现，第二张图的细节已经很不清晰，纹路间的边缘已经模糊。这正是SR这个方向所面临的挑战。</p><hr><h2 id="论文查重"><a href="#论文查重" class="headerlink" title="论文查重"></a>论文查重</h2><p><a href="http://www.biguolunwen.com/" target="_blank" rel="noopener">中文论文查重</a></p><p><a href="http://www.turnitin.com.cn/" target="_blank" rel="noopener">英文论文查重</a></p><blockquote><p>竟然是按字符数收费，查了我二十几块钱，简直无语了，参考文献篇篇标红，把参考文献删了才能过。</p><p>一次及其糟糕的查重体验。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 论文 </tag>
            
            <tag> 信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS使用技巧</title>
      <link href="/2020/10/07/vs-shi-yong-ji-qiao/"/>
      <url>/2020/10/07/vs-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="VS常用快捷键"><a href="#VS常用快捷键" class="headerlink" title="VS常用快捷键"></a>VS常用快捷键</h2><h3 id="变量-方法-类-相关操作"><a href="#变量-方法-类-相关操作" class="headerlink" title="[变量/方法/类] 相关操作"></a>[变量/方法/类] 相关操作</h3><blockquote><p>Ctrl + R,Ctrl + R ：变量/方法/类[重命名]</p><p>Alt+F12: ：变量/方法/类[查看相关定义(Esc退出)]</p></blockquote><h3 id="·-光标移动"><a href="#·-光标移动" class="headerlink" title="· 光标移动"></a>· 光标移动</h3><blockquote><p>Ctrl + ← / → ：按单词移动光标</p><p>Ctrl + Home / End ：移动到文档前端/末尾</p><p>Page Up/Down ：快速移动到下一页</p></blockquote><h3 id="·-文本选择"><a href="#·-文本选择" class="headerlink" title="· 文本选择"></a>· 文本选择</h3><blockquote><p>Shift + ← / → ：按字符选择文本</p><p>Ctrl + Shift + ← / → ：按单词选择文本</p><p>Ctrl + W ：选择整个单词</p><p>Shift + Home/End ：选择光标位置到本行开头/结尾的所有文本</p><p>Ctrl + Shift + Home/End ：选择光标位置到文档开头/结尾的所有文本</p></blockquote><h3 id="·-复制删除文本"><a href="#·-复制删除文本" class="headerlink" title="· 复制删除文本"></a>· 复制删除文本</h3><blockquote><p>Ctrl + Shift + V ：可选择进几次的复制内容</p><p>Ctrl + D ：快速复制一行</p><p>Shift + Delete ：删除整行</p><p>Ctrl + Delete/Backspace ：删除整个单词[从前往后/从后往前]<br>Ctrl + Enter ：在上面插入空白行[实用]<br>Ctrl + Shift + Enter ：在下面插入空白行</p></blockquote><h3 id="·-格式化代码-注释"><a href="#·-格式化代码-注释" class="headerlink" title="· 格式化代码/注释"></a>· 格式化代码/注释</h3><blockquote><p>tab ：向后缩进指定tab空间</p><p>Shift + tab ：向前缩进指定tab空间</p><p>Ctrl + K,Ctrl + D ：格式化整个文档</p><p>Ctrl + K,Ctrl + F ：格式化选中行</p><p>Ctrl + K,Ctrl + C ：注释选中行</p><p>Ctrl + K,Ctrl + U ：取消注释选中行</p><p>[工具] Power Tool for Visual Studio ：保存时格式化文档/删除未引用命名空间/重新排序命名空间</p><p>[下载] 扩展-&gt;搜索Power Command</p></blockquote><h3 id="·-跳转-展开-折叠代码"><a href="#·-跳转-展开-折叠代码" class="headerlink" title="· 跳转/展开/折叠代码"></a>· 跳转/展开/折叠代码</h3><blockquote><p>Ctrl + G ：指定跳转到某行</p><p>Ctrl + M,Ctrl + M ：展开/折叠光标所在位置的代码块</p><p>Ctrl + M,Ctrl + O ：折叠整个文档的代码块</p><p>Ctrl + M,Ctrl + L ：展开整个文档的代码块</p><p>Ctrl + K,Ctrl + S ：包裹选中的代码</p></blockquote><h3 id="·-代码片段"><a href="#·-代码片段" class="headerlink" title="· 代码片段"></a>· 代码片段</h3><blockquote><p>prop/propfull + tab + tab ：生成字段属性<br>try/tryf/class/interface/foreach/for/while/switch + tab + tab ：快捷生成相应的代码片段模板</p></blockquote><h3 id="·-选项卡和窗口"><a href="#·-选项卡和窗口" class="headerlink" title="· 选项卡和窗口"></a>· 选项卡和窗口</h3><blockquote><p>Ctrl + Tab ：正序切换选项卡</p><p>Ctrl + Shift + Tab ：倒序切换选项卡</p><p>Ctrl + F6 ：导航到下一个选项卡</p><p>Ctrl + Shift + F6 ：导航到前一个选项卡</p><p>Ctrl + F4 ：关闭当前选项卡</p><p>Alt + W + L ：关闭所有选项卡</p><p>Shift + Alt + Enter ：关闭所有选项卡</p><p>Ctrl + Alt + L : 解决方案资源管理器</p><p>Ctrl + ,Ctrl + M ：团队资源管理器</p><p>Ctrl + ,Ctrl + E ：错误列表</p><p>Ctrl + ,Ctrl + E ：任务列表</p><p>Ctrl + Alt + O ：输出窗口</p></blockquote><h3 id="·-查找替换"><a href="#·-查找替换" class="headerlink" title="· 查找替换"></a>· 查找替换</h3><blockquote><p>Ctrl + F ：查找</p><p>Ctrl + H ：查找+替换</p><p>F3 ：查找下一个</p><p>Shift + F3 ：查找上一个</p></blockquote><h3 id="·-运行和调试"><a href="#·-运行和调试" class="headerlink" title="· 运行和调试"></a>· 运行和调试</h3><blockquote><p>F5 ：调试</p><p>Ctrl + F5 ：运行（非调试）</p><p>Shift + F5 ：结束调试</p><p>F10 ：多步调试</p><p>F11 ：单步调试</p><p>Shift + F11 ：跳出当前调试的方法体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git和Github</title>
      <link href="/2020/10/03/guan-yu-git-he-github/"/>
      <url>/2020/10/03/guan-yu-git-he-github/</url>
      
        <content type="html"><![CDATA[<h2 id="关于廖雪峰的Git教程小结"><a href="#关于廖雪峰的Git教程小结" class="headerlink" title="关于廖雪峰的Git教程小结"></a>关于廖雪峰的Git教程小结</h2><p><img src="https://pic1.zhimg.com/v2-49c265e6c878e26b314702d1f1cb9ee4_b.jpg" alt="img"></p><ol><li><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol></li></ol><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p><h2 id="关于Github的使用"><a href="#关于Github的使用" class="headerlink" title="关于Github的使用"></a>关于Github的使用</h2><p><a href="https://zhuanlan.zhihu.com/p/89607964" target="_blank" rel="noopener">Github进行fork后如何与原仓库同步</a></p><p><a href="https://blog.csdn.net/zhongzunfa/article/details/80344585?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">Github fork 别人的项目源作者更新后如何同步更新</a></p><h2 id="关于Git命令"><a href="#关于Git命令" class="headerlink" title="关于Git命令"></a>关于Git命令</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Linux私房菜</title>
      <link href="/2020/09/26/wo-de-linux-si-fang-cai/"/>
      <url>/2020/09/26/wo-de-linux-si-fang-cai/</url>
      
        <content type="html"><![CDATA[<h2 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h2><p>在腾讯云买了一年的服务器和域名（henryavery.cn）,接下来要正式开始学习Linux操作系统了，在此之前先复习一下计算机概论，也顺便为下次自己装机做准备。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django后续</title>
      <link href="/2020/09/19/django-hou-xu/"/>
      <url>/2020/09/19/django-hou-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="Django后续"><a href="#Django后续" class="headerlink" title="Django后续"></a>Django后续</h1><blockquote><p>Web应用程序的核心是让任何用户都能够注册账户并能够使用它，不管用户身处何方。</p></blockquote><h2 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h2><p>创建表单、实现用户的使用功能、Django防范常见攻击、用户身份验证系统……总之就是让用户都能正常使用</p><h3 id="让用户能够输入数据"><a href="#让用户能够输入数据" class="headerlink" title="让用户能够输入数据"></a>让用户能够输入数据</h3><h4 id="添加新的主题和条目、编辑条目"><a href="#添加新的主题和条目、编辑条目" class="headerlink" title="添加新的主题和条目、编辑条目"></a>添加新的主题和条目、编辑条目</h4><p>表单，url模式，视图函数views，创建模板并链接到页面。</p><p>GET请求与POST请求，POST用于提交表单，GET用于从服务器读取数据。</p><blockquote><p>from django.urls import reverse</p><p>需要</p></blockquote><h3 id="创建用户账户"><a href="#创建用户账户" class="headerlink" title="创建用户账户"></a>创建用户账户</h3><p>建立一个用户注册和身份验证系统，先创建一个新的应用程序，然后修改模型Topic</p><h4 id="应用程序users"><a href="#应用程序users" class="headerlink" title="应用程序users"></a>应用程序users</h4><pre class="line-numbers language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py startapp users<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、将应用程序添加到settings</p><p>2、修改根目录urls.py使其包含将为应用程序定义的URL</p><h4 id="用户登录、注销与注册"><a href="#用户登录、注销与注册" class="headerlink" title="用户登录、注销与注册"></a>用户登录、注销与注册</h4><p>要老命了，百度了一下午，我愿称其为Django新版本(3.x)踩坑记录。</p><p>我还是直接把代码上传到GitHub上好了，要改的地方实在太多了。</p><h3 id="让用户拥有自己的数据"><a href="#让用户拥有自己的数据" class="headerlink" title="让用户拥有自己的数据"></a>让用户拥有自己的数据</h3><p>用户需要专属学习笔记</p><h4 id="使用-login-required限制访问"><a href="#使用-login-required限制访问" class="headerlink" title="使用@login_required限制访问"></a>使用@login_required限制访问</h4><p>全面限制。装饰器（decorator）是放在函数定义前的指令，修改函数代码的行为。</p><h4 id="数据关联用户"><a href="#数据关联用户" class="headerlink" title="数据关联用户"></a>数据关联用户</h4><ol><li>修改模型Topic</li><li>确定当前有哪些用户（启动Django shell）</li><li>迁移数据库</li></ol><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>当执行 python manage.py shell 出现错误：TypeError: <strong>init</strong>() missing 1 required positional argument: ‘on_delete’</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>定义外键的时候需要加上 on_delete=;<br>即：<code>contract = models.ForeignKey(Contract, on_delete=models.CASCADE)</code></p><h5 id="原因如下："><a href="#原因如下：" class="headerlink" title="原因如下："></a>原因如下：</h5><p>django 升级到2.0之后,表与表之间关联的时候,必须要写on_delete参数,否则会报异常:<br>TypeError: init() missing 1 required positional argument: ‘on_delete’</p><p>on_delete各个参数的含义如下：</p><pre><code>    on_delete=None,               # 删除关联表中的数据时,当前表与其关联的field的行为    on_delete=models.CASCADE,     # 删除关联数据,与之关联也删除    on_delete=models.DO_NOTHING,  # 删除关联数据,什么也不做    on_delete=models.PROTECT,     # 删除关联数据,引发错误ProtectedError    # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_NULL, blank=True, null=True)    on_delete=models.SET_NULL,    # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理）    # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_DEFAULT, default=&#39;默认值&#39;)    on_delete=models.SET_DEFAULT, # 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值,一对一同理）    on_delete=models.SET,         # 删除关联数据,     a. 与之关联的值设置为指定值,设置：models.SET(值)     b. 与之关联的值设置为可执行对象的返回值,设置：models.SET(可执行对象)1234567891011</code></pre><hr><blockquote><p>由于多对多(ManyToManyField)没有 on_delete 参数,所以以上只针对外键(ForeignKey)和一对一(OneToOneField)</p></blockquote><h4 id="完善用户功能"><a href="#完善用户功能" class="headerlink" title="完善用户功能"></a>完善用户功能</h4><p>只允许用户访问自己的主题，保护用户的主题和页面，将主题关联到当前用户。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token comment" spellcheck="true"># 确认请求的主题属于当前用户</span>    <span class="token keyword">if</span> topic<span class="token punctuation">.</span>owner <span class="token operator">!=</span> request<span class="token punctuation">.</span>user<span class="token punctuation">:</span>        <span class="token keyword">raise</span> Http404<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于某些原因（主要是“网络原因”和Windows系统的差别），后续Heroku注册和服务器部署继续太过麻烦，于是我决定换个思路，等搞清楚云服务器怎么用再试着部署到自己的服务器上，也许之后可以去备个案然后解析域名，这样就能真正上线使用了（有没有用户另说）</p><p>而且由于我的目的是正常使用应用程序，使用Bootstrap库设置应用程序的样式来进行美化，在目前阶段卡那里也就缺少必要了，可以在解决部署之后再完善。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的“学习笔记”项目就暂告一段落了，虽然我也还不想就这样结项，但是有必要进行这段时间以来的学习总结了。</p><p>首先，整个项目都是基于python开发的，并且主要是用到了Django框架——一套用于开发交互式网站的工具（还有很多类似）</p><p>虽然不是第一次接触到前端开发，但确实是第一次一个人上手开发一整个Web应用程序，借此我也大概了解了Web的整个开发流程，并且接触到了数据库和服务器的使用。</p><p>包括第一次接触正则表达式，创建表单（提交数据）以及模型定义（继承类）。</p><p>用Django创建网页三步走：定义URL，编写视图和模板。</p><p>然后让数据关联用户，功能齐备后，美化以及部署还有待完成。</p><p>最最重要的，还是在本次项目开发过程中所学到和实践使用的东西。</p><p>比如再次深入体会到使用git进行版本控制能够带来的方便，而且通过项目实践也接触到了很多之前不明白也不知道的新东西。</p><p>比如vim编辑器（举例而言，还有很多），虽然目前可能还不会使用，但就好像埋下了一颗种子，将来总有一天会生根发芽。</p><p>再就是实践过程中学到的一些习惯和方法。</p><p>根据自己的兴趣开发有意义的项目。</p><p>只要有机会，就向别人发出邀请，根据反馈改进程序。</p><p>遇到棘手问题时，想办法寻求帮助。首先认清形势（想要做什么？已尝试那些方式？结果如何？）橡皮鸭子调试法。</p><p>再试试，歇一会。</p><p>正确使用在线搜索解决问题，直接搜索报错消息，看别人的博客里的解决方案。</p><p>Stack Overflow 和官方文档文库，reddit和IRC（还没用过）</p><p>用什么学什么的精神。</p><p>peace！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门</title>
      <link href="/2020/09/11/django-ru-men/"/>
      <url>/2020/09/11/django-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Django入门"><a href="#Django入门" class="headerlink" title="Django入门"></a>Django入门</h1><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>先建立项目规范（先要立好规矩），再建立虚拟环境，以便在其中创建项目。</p><h3 id="制定规范"><a href="#制定规范" class="headerlink" title="制定规范"></a>制定规范</h3><p>只把这个项目的一些明确目标列出来，突出开发重点。</p><p>规范如下：</p><p>开始编写一个名为“学习笔记”的Web应用程序，让用户能够记录感兴趣的主题，并在学习每个主题的过程中添加日志条目。“学习笔记”的主页对这个网站进行描述，并邀请用户注册或登录。用户登录后，就可以创建主题、添加新条目以及阅读既有的条目。</p><p>学习新的主题时，记录学到的知识可以帮助跟踪和复习这些知识。优秀的应用程序让这个记录的过程简单易行。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Python从入门到实践》</p><p><a href="https://www.jianshu.com/p/c92345eea6b4" target="_blank" rel="noopener">Django新版本(2.x)踩坑记录</a></p><p><a href="https://blog.csdn.net/u012084802/article/details/79625428" target="_blank" rel="noopener">Python练习Django项目——学习笔记</a></p><p><a href="https://www.jianshu.com/p/b3267d16c245" target="_blank" rel="noopener">Python编程从入门到实践：Web应用程序 - Django入门</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">HTML 教程</a></p><p><a href="https://docs.djangoproject.com/en/2.2/ref/templates/language/#templates" target="_blank" rel="noopener">Django 官网文档 The Django template language</a></p><p><a href="https://docs.djangoproject.com/en/1.8/ref/templates/" target="_blank" rel="noopener">Django模板文档</a></p><h3 id="建立虚拟环境并激活"><a href="#建立虚拟环境并激活" class="headerlink" title="建立虚拟环境并激活"></a>建立虚拟环境并激活</h3><p>虚拟环境是系统的一个位置，把它隔离出来，这是必须的返校隔离措施，之后我们还要把它公之于众——部署到服务器上。</p><p>刚刚开始问题就出现了，Windows要怎么终端切换到目录来着？之前外星人入侵的项目明明用过，给忘了。之前就是只看了一眼，没有动手去做，所以才拖了这么久，这次让我一鼓作气搞定。</p><pre><code>C:\Users\ASUS&gt;d:D:\&gt;cd learning_logD:\learning_log&gt;</code></pre><p>原来切换目录这么简单，我只是还不会用（心虚，这我都不记得了，原因还是以前都没怎么认真用过电脑）</p><p>还有一个很蠢的问题也解决了，之前下载的是Anaconda 3，用的也一直是Anaconda 的Prompt，我这次直接cmd能有用才怪。不过好在总算是可以继续了。</p><p>现在我们为项目新建了一个目录， 将其命名为learning_log，使用如下命令成功创建名为ll_env的虚拟环境：</p><pre><code>python -m venv ll_env</code></pre><p>建立虚拟环境后， (Windows系统下)成功使用下面的命令激活它：</p><pre><code>ll_env\Scripts\activate</code></pre><p>要停止的话，使用终止命令deactivate</p><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><p>出问题了就重新来过，建立虚拟环境然后激活,然后再安装Django包：</p><pre><code>(ll_env) (base) D:\learning_log&gt; pip install DjangoCollecting Django</code></pre><p>下载可能有点慢，要等一会。</p><p>记住，Django仅在虚拟环境处于活动状态才可用。</p><p>嘛，就知道没有这么简单，下载失败了，这次又是哪里出了问题呢？更新了一下pip的版本重新下载。</p><pre><code>(ll_env) (base) D:\learning_log&gt;pip install DjangoCollecting Django  Downloading https://files.pythonhosted.org/packages/01/a5/fb3dad18422fcd4241d18460a1fe17542bfdeadcf74e3861d1a2dfc9e459/Django-3.1.1-py3-none-any.whl (7.8MB)     |████████████████████████████████| 7.8MB 12kB/sCollecting pytz (from Django)  Downloading https://files.pythonhosted.org/packages/4f/a4/879454d49688e2fad93e59d7d4efda580b783c745fd2ec2a3adf87b0808d/pytz-2020.1-py2.py3-none-any.whl (510kB)     |████████████████████████████████| 512kB 9.5kB/sCollecting asgiref~=3.2.10 (from Django)  Downloading https://files.pythonhosted.org/packages/d5/eb/64725b25f991010307fd18a9e0c1f0e6dff2f03622fc4bcbcdb2244f60d6/asgiref-3.2.10-py3-none-any.whlCollecting sqlparse&gt;=0.2.2 (from Django)  Downloading https://files.pythonhosted.org/packages/85/ee/6e821932f413a5c4b76be9c5936e313e4fc626b33f16e027866e1d60f588/sqlparse-0.3.1-py2.py3-none-any.whl (40kB)     |████████████████████████████████| 40kB 7.8kB/sInstalling collected packages: pytz, asgiref, sqlparse, DjangoSuccessfully installed Django-3.1.1 asgiref-3.2.10 pytz-2020.1 sqlparse-0.3.1WARNING: You are using pip version 19.2.3, however version 20.2.3 is available.You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command.</code></pre><p>原来是pip命令需要更新了，按照提示更新版本就成功了。</p><h3 id="创建项目以及数据库"><a href="#创建项目以及数据库" class="headerlink" title="创建项目以及数据库"></a>创建项目以及数据库</h3><pre><code>django-admin.py startproject learning_log .</code></pre><p>新建一个名为learning_log的项目，不知道又出什么问题，先到这吧，睡了睡了。</p><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h4><p>在prompt命令窗口执行上面的命令，会打开 django-admin.py 源代码</p><h4 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h4><p>*.py 的默认打开方式为 pycharm。所以自然直接打开，我没有安装pycharm，所以是用vscode打开的。</p><h4 id="3-解决"><a href="#3-解决" class="headerlink" title="3 解决"></a>3 解决</h4><p>修改一下命令</p><pre><code>django-admin startproject [项目名] .</code></pre><p>执行成功后，输入ls命令（Windows对应dir）就会发现 Django 新建好了需要的文件</p><table><thead><tr><th align="center">文件名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">settings.py</td><td align="center">指定Django如何与你的系统交互以及如何管理项目，修改其中一些设置， 并添加一些设置</td></tr><tr><td align="center">urls.py</td><td align="center">告诉Django应创建哪些网页来响应浏览器请求</td></tr><tr><td align="center">wsgi.py</td><td align="center">帮助Django提供它创建的文件， 这个文件名是web server gateway interface（Web服务器网关接口 ） 的首字母缩写。</td></tr></tbody></table><p>一大早起来直接查命令哪里出了问题，一下就解决了。接下来建立一个数据库。在这里更新了一下Django的版本。然后dir查看一下，确认后启动一个服务器，查看系统中的项目，按照响应操作打开生成的页面。</p><pre><code>python manage.py migratepython manage.py runserver</code></pre><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%9F%BA%E4%BA%8EDjango%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%5C%E9%A1%B5%E9%9D%A2.png" alt="生成页面"></p><p>至此，这个项目成功建立了，耶！</p><h2 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h2><p>打开另一个终端，切换到manage.py所在目录，激活虚拟环境，执行命令startapp。</p><h3 id="定义模型并激活"><a href="#定义模型并激活" class="headerlink" title="定义模型并激活"></a>定义模型并激活</h3><p>模型告诉Django如何处理应用程序中存储的数据。 在代码层面， 模型就是一个类， 包含属性和方法。</p><p><strong>models.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment" spellcheck="true"># Create your models here.</span><span class="token comment" spellcheck="true"># 创建了一个名为Topic 的类， 它继承了Model ——Django中一个定义了模型基本功能的类。 Topic 类只有两个属性： text 和date_added 。</span><span class="token keyword">class</span> <span class="token class-name">Topic</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' 用户学习的主题'''</span>    text <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 属性text是一个CharField——由字符或文本组成的数据</span>    <span class="token comment" spellcheck="true"># https://docs.djangoproject.com/en/1.8/ref/models/fields</span>    <span class="token comment" spellcheck="true"># Django Model Field Reference 用于熟悉模型中可使用的各种字段，自己开发时可能会用到</span>    date_added <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实参auto_add_now=True 让Django将这个属性自动设置成当前日期和时间。</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""返回模型的字符串表示"""</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每当需要修改“学习笔记”管理的数据时， 都采取如下三个步骤： 修改models.py； 对learning_logs 调用makemigrations ； migrate让Django迁移项目。</p><pre class="line-numbers language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py makemigrations learning_logs<span class="token comment" spellcheck="true"># 让Django修改数据库， 使其能够存储与模型Topic 相关的信息</span><span class="token comment" spellcheck="true"># 命令makemigrations 让Django确定该如何修改数据库， 使其能够存储与定义的新模型相关联的数据。</span>python manage<span class="token punctuation">.</span>py migrate<span class="token comment" spellcheck="true"># 应用这种迁移， 让Django替我们修改数据库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Django-管理网站"><a href="#Django-管理网站" class="headerlink" title="Django 管理网站"></a>Django 管理网站</h3><p>为应用程序定义模型时，Django提供的管理网站（admin site）让你能够轻松地处理模型。网站的管理员可使用管理网站，但普通用户不能使用。</p><h4 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h4><pre><code>(ll_env)learning_log&gt;python manage.py createsuperuser❶ Username (leave blank to use &#39;ehmatthes&#39;): ll_admin❷ Email address:❸ Password:  Password (again):  Superuser created successfully.</code></pre><h4 id="向管理网站注册模型"><a href="#向管理网站注册模型" class="headerlink" title="向管理网站注册模型"></a><strong>向管理网站注册模型</strong></h4><p> Django自动在管理网站中添加了一些模型，如User 和Group ，但对于我们创建的模型，必须手工进行注册。我们创建应用程序learning_logs 时，Django在models.py所在的目录中创建了一个名为admin.py的文件。</p><h4 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h4><p>在网站上测试添加主题“Chess”和“Rock Climbing”</p><h3 id="定义并迁移模型Entry"><a href="#定义并迁移模型Entry" class="headerlink" title="定义并迁移模型Entry"></a>定义并迁移模型Entry</h3><p>要记录学到的国际象棋和攀岩知识，需要为用户可在学习笔记中添加的条目定义模型。每个条目都与特定主题相关联，这种关系被称为多对一关系，即多个条目可关联到同一个主题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment" spellcheck="true"># Model是Django中一个定义了模型基本功能的类</span><span class="token keyword">class</span> <span class="token class-name">Topic</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token operator">-</span><span class="token operator">-</span>snip<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""学到的有关某个主题的具体知识"""</span>    topic <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>Topic<span class="token punctuation">,</span>on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span>    text <span class="token operator">=</span> models<span class="token punctuation">.</span>TextField<span class="token punctuation">(</span><span class="token punctuation">)</span>    date_added <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        verbose_name_plural <span class="token operator">=</span> <span class="token string">'entries'</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"..."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性topic 是一个ForeignKey 实例，外键是一个数据库术语，引用了数据库中的另一条记录； </p><p>这些代码将每个条目关联到特定的主题。每个主题创建时，都给它分配了一个键（或ID）。 需要在两项数据之间建立联系时，Django使用与每项信息相关联的键。Django2.0版本外键要求添加on_delete参数。</p><p>在Entry 类中嵌套了Meta 类。Meta 存储用于管理模型的额外信息，设置一个特殊属性，让Django需要时使用Entries表示多个条目，没有这个类将使用Entrys来表示多个条目。</p></blockquote><p>没有看明白这些想说明什么，往后看应该就会知道了。接下来迁移数据库。生成新的迁移文件。</p><p>添加一个模型，就迁移一次数据库。过程：修改models.py，执行命令python manage.py makemigrations app_name ，再执行命令python manage.py migrate 。</p><h3 id="向管理网站注册Entry"><a href="#向管理网站注册Entry" class="headerlink" title="向管理网站注册Entry"></a>向管理网站注册Entry</h3><p>修改admin.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> learning_logs<span class="token punctuation">.</span>models <span class="token keyword">import</span> Topic<span class="token punctuation">,</span> Entryadmin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Topic<span class="token punctuation">)</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Entry<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Django-shell"><a href="#Django-shell" class="headerlink" title="Django shell"></a>Django shell</h3><pre><code>python manage.py shell</code></pre><blockquote><p>Cr+Z,回车退出</p></blockquote><p>用于测试和排除故障的理想之地</p><p><a href="https：//docs.djangoproject.com/en/7.8/topics/db/queries">更多关于如何查询数据的文档</a></p><h2 id="创建网页：学习笔记主页"><a href="#创建网页：学习笔记主页" class="headerlink" title="创建网页：学习笔记主页"></a>创建网页：学习笔记主页</h2><p>定义URL、编写视图和编写模板。</p><p>urls -&gt; views -&gt; html  添加网页步骤。</p><h3 id="映射URL"><a href="#映射URL" class="headerlink" title="映射URL"></a>映射URL</h3><blockquote><p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫<em>URL</em>（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址。</p></blockquote><p>实际的URL模式是一个对函数url的调用，这个函数接受三个实参。</p><pre class="line-numbers language-python"><code class="language-python">urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">#主页</span>    <span class="token comment" spellcheck="true">#第一个是正则表达式，r让Python将接下来的字符串视为原始字符串，引号正则表达式始于和终于何处</span>    <span class="token comment" spellcheck="true">#第二个实参指定了要调用的视图函数</span>    <span class="token comment" spellcheck="true">#第三个实参将这个URL模式的名称指定为index</span>    path<span class="token punctuation">(</span>r<span class="token string">''</span><span class="token punctuation">,</span>views<span class="token punctuation">.</span>index<span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式（regex），这是个什么鬼东西？相信后面还会有很多见面的机会……</p><blockquote><p>请求的URL与正则表达式匹配时调用视图函数</p></blockquote><h3 id="编写视图和模板"><a href="#编写视图和模板" class="headerlink" title="编写视图和模板"></a>编写视图和模板</h3><p>默认的urls.py包含在文件夹learning_log中， 现在需要在文件夹learning_logs中创建另一个urls.py文件：<strong>(注意关于 Django版本更新,书上的代码需做相应修改)</strong></p><p>打开项目主文件夹learning_log中的文件urls.py， 修改为<br> <strong>learning_log/urls.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> pathurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true"># 该模块定义了可在管理网站中请求的所有URL</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'learning_logs.urls'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'learning_logs'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 代码包含实参namespace ， 让我们能够将learning_logs 的URL同项目中的其他URL区分开来</span><span class="token punctuation">]</span><span class="token triple-quoted-string string">'''Django版本更新,书上的代码需做相应修改书中源代码：from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [    url(r'^admin/', include(admin.site.urls)),    url(r'', include('learning_logs.urls', namespace='learning_logs')),]应改为：from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    path('', include('learning_logs.urls', namespace='learning_logs')),]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的urls.py包含在文件夹learning_log中， 现在需要在文件夹learning_logs中创建另一个urls.py文件：(注意关于 Django版本更新,书上的代码需做相应修改)<br> <strong>learning_logs/urls.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""定义learning_logs的URL模式"""</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span>re_path<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> viewsapp_name<span class="token operator">=</span><span class="token string">'learning_logs'</span> <span class="token comment" spellcheck="true"># 不能少 ，否则runserver的时候就会出错</span><span class="token comment" spellcheck="true"># https://docs.djangoproject.com/en/2.2/ref/urls/#module-django.urls.conf</span>urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># 主页</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>index<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># Django将在文件views.py中查找函数index()</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># urls -> views -> html  添加网页步骤</span><span class="token triple-quoted-string string">'''Django版本更新,书上的代码需做相应修改书中源代码：from django.conf.urls import urlfrom . import viewsurlpatterns = [     # Home page.    url(r'^$', views.index, name='index'),    # Show all topics.    url(r'^topics/$', views.topics, name='topics'),    # Detail page for a single topic.    url(r'^topics/(?P&lt;topic_id>\d+)/$', views.topic, name='topic'),]应改为：from django.urls import pathfrom . import viewsapp_name='learning_logs'urlpatterns = [    # 主页    path('', views.index, name='index'),    # 显示所有的主题    path('topics/', views.topics, name='topics'),    # 特定主题的详细页面    path("topics/(?P&lt;topic_id>\d+)/", views.topic, name='topic'),]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建其他网页"><a href="#创建其他网页" class="headerlink" title="创建其他网页"></a>创建其他网页</h2><p>确定创建网页的流程后，可以扩充“学习笔记”项目了。</p><p>接下来要创建两个显示数据的页面。</p><p>所以先创建一个父模板，其他模板都将继承它。</p><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><h4 id="父模板"><a href="#父模板" class="headerlink" title="父模板"></a>父模板</h4><p>这个文件包含所有页面都有的元素； 其他的模板都继承base.html。 当前， 所有页面都包含的元素只有顶端的标题。 将在每个页面中包含这个模板， 因此将这个标题设置为到主页的链接：</p><pre class="line-numbers language-html"><code class="language-html">{% raw %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{% url <span class="token punctuation">'</span>learning_logs:index<span class="token punctuation">'</span> %}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Learning Log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% block content %}{% endblock content %}{% endraw %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板标签用(<strong>{ % % }</strong>)表示，生成一个URL。</p><p>在简单的HTML页面中，用锚标签定义链接：</p><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link_url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>link text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要修改项目中的URL，只需要修改urls.py中的URL模式。</p><h4 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h4><p>重新编写index.html,使其继承base.html。</p><h3 id="显示所有主题的页面"><a href="#显示所有主题的页面" class="headerlink" title="显示所有主题的页面"></a>显示所有主题的页面</h3><p>urls -&gt; views -&gt; html 添加网页步骤</p><p>下面来写一个显示全部主题的页面和一个显示特定主题中条目的页面。</p><pre><code>name &#39;request&#39; is not defined</code></pre><p><strong>views.py</strong></p><p>def topics(request) 写错成 def topics(reqest)了</p><h3 id="显示特定主题的页面"><a href="#显示特定主题的页面" class="headerlink" title="显示特定主题的页面"></a>显示特定主题的页面</h3><pre><code>Reverse for &#39;topic&#39; with arguments &#39;(&#39;&#39;,)&#39; not found. 1 pattern(s) tried: [&#39;topics/(?P&lt;topic_id&gt;\\d+)/$&#39;]</code></pre><p>return render(request, ‘learning_logs/topic.html’,context)</p><p>写成了</p><p>return render(request, ‘learning_logs/topics.html’,context)</p><pre class="line-numbers language-python"><code class="language-python">  <span class="token comment" spellcheck="true"># 特定主题的详细页面</span>  <span class="token comment" spellcheck="true"># 错误</span>  <span class="token comment" spellcheck="true"># path("topics/(?P&lt;topic_id>\d+)/", views.topic, name='topic'),</span>  <span class="token comment" spellcheck="true"># 正确</span>  re_path<span class="token punctuation">(</span>r<span class="token string">'^topics/(?P&lt;topic_id>\d+)/$'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'topic'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># ?P&lt;topic_id> 将匹配的值存储到topic_id 中； 而表达式\d+ 与包含在两个斜杆内的任何数字都匹配， 不管这个数字为多少位。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天首先学习了如何使用Django框架来创建Web程序应用，相信其他语言或者框架都是大同小异。</p><p>然后制定了项目规范，列出参考资料，最后在项目完成后需要鸣谢。</p><p>在虚拟环境中安装Django，创建一个项目，并且核实已经成功立项。</p><p>学习如何创建应用程序，以及如何定义表示应用程序数据的模型。</p><p>学习了数据库，以及在修改模型后让Django来迁移数据库。</p><p>创建了可管理网站的超级用户，并使用管理网站输入了一些数据。</p><p>探索Django Shell，它能够让我在终端对话处理项目数据，排除障碍。</p><p>学习了如何定义URL、创建网络视图以及编写网页的模板。最后还使用了模板继承，让各个模板简化，使修改网站变得更加容易。</p><p>遇上了劲敌“正则表达式”和“URL模式”，而且由于Django版本更新，url（）和path（）等函数更是变得乱七八糟，最后还是靠着上网看别人写的博客才K.O了它们。</p><hr><p>下一次，我们将创建对用户友好而直观的网页，让用户无需管理网站就可以使用“学习笔记”。</p><p>我们还将添加一个用户注册系统，让用户能够注册和创建自己的学习笔记。</p><blockquote><p>“让任意数量的用户都能与之交互，是Web应用程序的核心所在。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习</title>
      <link href="/2020/09/11/matlab-xue-xi/"/>
      <url>/2020/09/11/matlab-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一周信号处理实验课"><a href="#第一周信号处理实验课" class="headerlink" title="第一周信号处理实验课"></a>第一周信号处理实验课</h2><h3 id="上课学习"><a href="#上课学习" class="headerlink" title="上课学习"></a>上课学习</h3><p>学校东区计算机学院708机房没有安装好MATLAB，而且有些机位不能联网，上课简单介绍了一下MATLAB和课后作业。</p><p>下次上课带自己的电脑去。</p><hr><h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>一些MATLAB的简单操作，课程报告第二周后再提交。</p><p>回去在自己电脑上安装好MATLAB，学校网速太慢了，而且还不稳定，百度云限速。</p><p>MATLAB安装办法自己网上找。</p><hr><h3 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h3><p><a href="https://www.bilibili.com/video/BV1GJ41137UH" target="_blank" rel="noopener">MATLAB教程_台大郭彦甫（14课=15h）</a></p><hr><h2 id="MATLAB学习"><a href="#MATLAB学习" class="headerlink" title="MATLAB学习"></a>MATLAB学习</h2><p>百度云下了我两天两夜，终于下载安装好了。</p><p>明天开始学。</p><hr><p>学了半天，看了两节课，还是不会做作业……</p><hr><h2 id="第五周信号处理实验课"><a href="#第五周信号处理实验课" class="headerlink" title="第五周信号处理实验课"></a>第五周信号处理实验课</h2><h3 id="Command-conv"><a href="#Command-conv" class="headerlink" title="Command conv"></a><strong>Command conv</strong></h3><p><em>First rule</em>: The two signals (input and impulse response) should be defined in the <strong>same time interval</strong>. </p><p><em>Second rule</em>: When a signal consists of <strong>multiple parts</strong>, the time intervals in which each part is defined must <strong>not overlap</strong>.</p><p><em>Third rule</em>: The output of the conv command has to be <strong>multiplied with the time step</strong> used in the definition of the input and impulse response signals, in order to correctly compute the output of the system. </p><p><em>Fourth rule</em>: The output of the system is plotted in the <strong>double time interval</strong> of the one in which the input and impulse response signals are defined.</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%1st  way</span> t1<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">0.01</span><span class="token punctuation">;</span> t2<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> t3<span class="token operator">=</span><span class="token number">2.01</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span> t<span class="token operator">=</span><span class="token punctuation">[</span>t1 t2 t3<span class="token punctuation">]</span><span class="token punctuation">;</span> x1<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x2<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x3<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">=</span><span class="token punctuation">[</span>x1 x2 x3<span class="token punctuation">]</span><span class="token punctuation">;</span> h<span class="token operator">=</span>x<span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token function">conv</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">axis</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">6</span> <span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'y(t)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%the two signals</span> figure <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token number">0</span><span class="token operator">-</span>t<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'x(t)'</span><span class="token punctuation">,</span><span class="token string">'h(t-\tau)=h(0-\tau)'</span><span class="token punctuation">)</span> <span class="token function">ylim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> figure <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">-</span>t<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token function">ylim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'x(t)'</span><span class="token punctuation">,</span><span class="token string">'h(t-\tau)=h(2-\tau)'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%2nd  way</span> figure t<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> x<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> h<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token function">conv</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'y(t)'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Other-command"><a href="#Other-command" class="headerlink" title="Other command"></a>Other command</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">% syms</span><span class="token comment" spellcheck="true">% Create symbolic variables and functions</span><span class="token comment" spellcheck="true">% 符号变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>hold on是当前轴及图像保持而不被刷新，准备接受此后将绘制的图形，多图共存。即，启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。</p><p>hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即，关闭图形保持功能。</p><hr><p>area(x, y)：该函数以参数x和y绘制面积图。如果x和y为向量，则相当于函数plot(x, y)，并将0到y之间进行了填充。如果参数y为矩阵，则将y的每一列绘制面积图并进行累计求和。<br>area(y)：如果参数y为向量，则绘制面积图；如果y为矩阵则绘制每一列的面积图之和。</p><hr><p>simplify的调用格式为：simplify(S)，对表达式S进行化简</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Signal Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛启航</title>
      <link href="/2020/09/11/mei-sai-qi-hang/"/>
      <url>/2020/09/11/mei-sai-qi-hang/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="美国大学生数学建模竞赛（MCM-ICM）"><a href="#美国大学生数学建模竞赛（MCM-ICM）" class="headerlink" title="美国大学生数学建模竞赛（MCM/ICM）"></a>美国大学生数学建模竞赛（MCM/ICM）</h3><p>美国大学生数学建模竞赛（MCM/ICM）由美国数学及其应用联合会主办，是唯一的国际性数学建模竞赛，也是世界范围内最具影响力的数学建模竞赛。赛题内容涉及经济、管理、环境、资源、生态、医学、安全、等众多领域。竞赛要求三人（本科生）为一组，在四天时间内，就指定的问题完成从建立模型、求解、验证到论文撰写的全部工作，体现了参赛选手研究问题、解决方案的能力及团队合作精神。 为现今各类<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B" target="_blank" rel="noopener">数学建模竞赛</a>之鼻祖。</p><hr><h3 id="报名须知"><a href="#报名须知" class="headerlink" title="报名须知"></a>报名须知</h3><p>组队要求：三人（本科生）为一组（模型搭建，模型实现，论文写作）</p><p>比赛时间：2021年•2月4日——2月8日，在四天时间内，一般都是早晨到早晨，要安排好比赛的时间。比赛以美国东部时间为准，其比北京时间晚了大约13个小时。</p><p>竞赛开始时间：2021年2月4日 下午5点（美国东部时间）（北京时间2月5日早上6点）</p><p>竞赛截止：2021年2月8日 下午8点（美国东部时间）（北京时间2月9日早上9点）</p><p>论文提交截止时间：2021年2月8日 下午9点（美国东部时间）（北京时间2月9日早上10点）</p><p>竞赛结果：2021年4月30日之前</p><p>比赛题目：一共分为6种题型。分别为：连续型、离散型、大数据、运筹学/网络科学、环境科学、政策。</p><p>奖项设置及获奖比例：特等奖（Outstanding Winner） 0.14%，特等奖提名奖（Finalist） 0.17%，一等奖（Meritorious Winner）7%左右，二等奖（Honorable Mentioned） 15%左右，成功参与奖也叫三等奖（Successful Participant）</p><hr><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><h3 id="信息入口"><a href="#信息入口" class="headerlink" title="信息入口"></a>信息入口</h3><p><a href="https://www.zhihu.com/question/19714813" target="_blank" rel="noopener">知乎：如何入门参与数学建模？</a></p><hr><h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><p>写作软件：latex</p><p>编程软件：Matlab</p><p>公式编辑器：Mathtype</p><p>画图：Visio，亿图</p><hr><h3 id="数模学习"><a href="#数模学习" class="headerlink" title="数模学习"></a>数模学习</h3><p>书籍推荐：《数学建模》 姜启源 ，《数学建模算法与应用》司守奎</p><hr><h3 id="其他准备"><a href="#其他准备" class="headerlink" title="其他准备"></a>其他准备</h3><p>论文写作：往届获奖论文，论文模板等</p><p>经典的算法：待补充</p><hr><h3 id="学术搜索引擎"><a href="#学术搜索引擎" class="headerlink" title="学术搜索引擎"></a>学术搜索引擎</h3><p>1、<a href="https://link.zhihu.com/?target=http%3A//scholar.google.com/" target="_blank" rel="noopener">http://scholar.google.com/</a> </p><p>2、<a href="https://link.zhihu.com/?target=http%3A//qns.cc/" target="_blank" rel="noopener">http://qns.cc/</a> </p><p>后起之秀，科研人员的良好助手，上此网站的90%是从事科研的学生与老师。其词典搜索集成了目前市面上最好的在线英汉写作及科研词典，用此搜索引擎写作英文论文相当方便；其文献搜索集成了目前最优秀的数据库。</p><p>3、<a href="https://link.zhihu.com/?target=http%3A//www.scirus.com" target="_blank" rel="noopener">http://www.scirus.com</a> </p><p>Scirus是目前互联网上最全面、综合性最强的科技文献搜索引擎之一，由Elsevier科学出版社开发，用于搜索期刊和专利，效果很不错！Scirus覆盖的学科范围包括：农业与生物学，天文学，生物科学，化学与化工，计算机科学，地球与行星科学，经济、金融与管理科学，工程、能源与技术，环境科学，语言学，法学，生命科学，材料科学，数学，医学 ，神经系统科学，药理学，物理学，心理学，社会与行为科学，社会学等。</p><p>4、sci-hub</p><h3 id="关于Latex"><a href="#关于Latex" class="headerlink" title="关于Latex"></a>关于Latex</h3><p><a href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener">一份其实很短的 LaTeX 入门文档</a></p><p>在文档类 <code>article</code>/<code>ctexart</code> 中，定义了五个控制序列来调整行文组织结构。他们分别是</p><ul><li><code>\section{·}</code></li><li><code>\subsection{·}</code></li><li><code>\subsubsection{·}</code></li><li><code>\paragraph{·}</code></li><li><code>\subparagraph{·}</code></li></ul><pre class="line-numbers language-tex"><code class="language-tex">\documentclass{article}% 这里是导言区% 中英文混排% \documentclass[UTF8]{ctexart}% 数学模式\usepackage{amsmath}\begin{document}% 行内式Einstein 's $E=mc^2$.% 行间式\[ E=mc^2. \]% 根式与分式$\sqrt{x}$, $\frac{1}{2}$.\[ \sqrt{x}, \]\[ \frac{1}{2}. \]% 上下标，下标是_\[ z = r\cdot e^{2\pi i}. \]% 运算符\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;\geq\; \leq\; \neq\; \approx \; \equiv \]% 大型运算符$ \sum_{i=1}^n i\quad \prod_{i=1}^n $$ \sum\limits _{i=1}^n i\quad \prod\limits _{i=1}^n $\[ \lim_{x\to0}x^2 \quad \int_a^b x^2 dx \]\[ \lim\nolimits _{x\to0}x^2\quad \int\nolimits_a^b x^2 dx \]% 多重积分\[ \iint\quad \iiint\quad \iiiint\quad \idotsint \]% 定界符（括号等）\lvert\rvert\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]\[ \Biggl \{\biggl \{\Bigl \{\bigl \{\{x\}\bigr \}\Bigr \}\biggr \}\Biggr\} \]\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]% 省略号\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad\vdots\quad \ddots \]% 矩阵\[ \begin{pmatrix} a&b\\c&d \end{pmatrix} \quad\begin{bmatrix} a&b\\c&d \end{bmatrix} \quad\begin{Bmatrix} a&b\\c&d \end{Bmatrix} \quad\begin{vmatrix} a&b\\c&d \end{vmatrix} \quad\begin{Vmatrix} a&b\\c&d \end{Vmatrix} \]Marry has a little matrix $ ( \begin{smallmatrix} a&b\\c&d \end{smallmatrix} ) $.% 多行公式% 如果不需要编号，可以使用 multline* 环境代替\begin{multline}x = a+b+c+{} \\d+e+f+g\end{multline}% 对齐\[\begin{aligned}x ={}& a+b+c+{} \\&d+e+f+g\end{aligned}\]% 公式组% 无需对齐的公式组可以使用 gather 环境% 需要对齐的公式组可以使用 align 环境% 如果不需要编号可以使用带星花的版本\begin{gather}a = b+c+d \\x = y+z\end{gather}\begin{align}a &= b+c+d \\x &= y+z\end{align}% 分段函数\[ y= \begin{cases}-x,\quad x\leq 0 \\x,\quad x>0\end{cases} \]% 图片%\documentclass{article}%\usepackage{graphicx}%\begin{document}%\includegraphics{a.jpg}% \includegraphics[width = .8\textwidth]{a.jpg}% 控制大小%\end{document}% 表格\begin{tabular}{|l|c|r|} \hlinesys& release& editor\\ \hlineWindows & MikTeX & TexMakerX \\ \hlineUnix/Linux & teTeX & Kile \\ \hlineMac OS & MacTeX & TeXShop \\ \hlineuniverse& TeX Live & TeXworks \\ \hline\end{tabular}% 浮动体\begin{figure}[htbp]% [htbp]用来指定插图的理想位置，% 这几个字母分别代表 here, top, bottom, float page\centering% \centering 用来使插图居中% \includegraphics{a.jpg}\caption{the truth}% \caption 命令设置插图标题\label{fig:myphoto}% 注意 \label 应该放在标题命令之后\end{figure}\end{document}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h2><h3 id="2020美赛C题（9-25）"><a href="#2020美赛C题（9-25）" class="headerlink" title="2020美赛C题（9.25）"></a>2020美赛C题（9.25）</h3><hr><p><a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">麻省理工公开课：线性代数</a></p><p>第一次刷题试水，需要补一下数学，再补一下排版和画图</p><hr><h3 id="2020美赛D题（12-16）"><a href="#2020美赛D题（12-16）" class="headerlink" title="2020美赛D题（12.16）"></a>2020美赛D题（12.16）</h3><h4 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h4><p><a href="https://www.bilibili.com/video/BV1j7411W7FP/?spm_id_from=trigger_reload" target="_blank" rel="noopener">美赛latex排版b站视频</a></p><p><a href="https://liam.page/2016/01/27/how-to-use-mcmthesis/" target="_blank" rel="noopener">如何使用美赛模板 mcmthesis</a></p><p><a href="https://github.com/latexstudio-org/mcmthesis" target="_blank" rel="noopener">模板下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> 美赛 </tag>
            
            <tag> 数模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机书单</title>
      <link href="/2020/09/02/ji-suan-ji-shu-dan/"/>
      <url>/2020/09/02/ji-suan-ji-shu-dan/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>《现代操作系统》Andrew S.Tanenbaum &amp; Herbert Bos   </p><p>​    </p><p>《鸟哥的Linux私房菜》</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>《计算机网络》James F. Kurose &amp; Keith W.Ross</p><p>《图解TCP\IP》</p><p>《图解HTTP》</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>《大话数据结构》</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>《Python从入门到实践》</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>《Java核心技术卷Ⅰ》</p><p>《深入理解Java虚拟机》</p><h4 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h4><p>《Go语言实战》</p><p>​      </p><h4 id="程序员人生"><a href="#程序员人生" class="headerlink" title="程序员人生"></a>程序员人生</h4><p>《代码整洁之道》</p><p>​       </p><p>吴军老师的书</p><p>《浪潮之巅》</p><p>​     </p><p>《数学之美》</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《数据挖掘——实用机器学习技术》</p><p>《机器学习实战》</p><p>《机器学习》（西瓜书）周志华</p>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 书 </tag>
            
            <tag> 待更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从1开始写Blog</title>
      <link href="/2020/08/31/cong-1-kai-shi-xie-blog/"/>
      <url>/2020/08/31/cong-1-kai-shi-xie-blog/</url>
      
        <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrENiK9j7bR9qXYA11EY4TsPRZJqdImIwU1LgreNkyYn04*MFe2ZNrTrthPykK2B.ahOc0P5g1Gp1rjyBsYJnDKjU!/r" alt></p><h2 id="从1开始写Blog"><a href="#从1开始写Blog" class="headerlink" title="从1开始写Blog"></a>从1开始写Blog</h2><h3 id="写给自己"><a href="#写给自己" class="headerlink" title="写给自己"></a>写给自己</h3><h4 id="博客是什么"><a href="#博客是什么" class="headerlink" title="博客是什么"></a>博客是什么</h4><p>参见我的<a href="https://henry-avery.github.io/friends/" target="_blank" rel="noopener">友情链接</a>里的博客以及其他知名博客</p><p><a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="https://coolshell.cn/" target="_blank" rel="noopener">陈皓&amp;酷壳</a></p><p><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a></p><p><a href="https://lepture.com/" target="_blank" rel="noopener">LEPTURE</a></p><p><a href="http://www.yinwang.org/" target="_blank" rel="noopener">王垠</a></p><h4 id="要怎么写博客"><a href="#要怎么写博客" class="headerlink" title="要怎么写博客"></a>要怎么写博客</h4><p><a href="https://blog.huihut.com/2017/01/25/MarkdownTutorial/#urllink" target="_blank" rel="noopener">Markdown 简易入门教程</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰写的Git教程</a></p><p>建议window系统先参考教程安装好Git bash</p><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a></p><h4 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h4><p>可以看看《暗时间》作者刘未鹏写的这篇博客文章</p><p><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）写博客</a></p><p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrEElfJNrKjuyWae8U.db2Cr12qAfm0jJPNi8jwmhLjXfrKEBE9HoyGNcJKjczdR*jtuu3yOjfUe79vJswISqmipY!/r" alt="黄金圈法则"></p><h3 id="写给同类"><a href="#写给同类" class="headerlink" title="写给同类"></a>写给同类</h3><h4 id="为什么写博客"><a href="#为什么写博客" class="headerlink" title="为什么写博客"></a>为什么写博客</h4><p>种下一棵树最好的时间是十年以前，其次是现在。</p><p>阅读和学习是输入，写作和实践是输出，都是我们了解这个世界的途径。</p><p>阅读和写作、策划组织都是一个人的心智体现。不断阅读就需要不断主动思考，将思考的过程和结果写出来，不仅能够提高自己的心智，提高组织策划的能力，也能为他人提供参考。</p><p>为了不断超越自己。</p><p>Challenge the status quo</p><h4 id="怎么写博客"><a href="#怎么写博客" class="headerlink" title="怎么写博客"></a>怎么写博客</h4><p>搭建好博客，写下去。每周至少写完一篇发到博客上。所以平时需要多写，每天都至少要写三十分钟。</p><h4 id="博客写什么"><a href="#博客写什么" class="headerlink" title="博客写什么"></a>博客写什么</h4><p>可能写一写日常生活里值得思考的小事，或者是技术上解决的问题和信息资源的整理。</p><hr><h2 id="各种报错"><a href="#各种报错" class="headerlink" title="各种报错"></a>各种报错</h2><p><strong>hexo s</strong>报错</p><pre><code>FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error:  [Line 78, Column 29] expected variable end</code></pre><p>解决办法：<br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">官网描述</a></p><p>翻译过来就是： 转义内容 Hexo使用Nunjucks渲染帖子（较早的版本使用Swig，它们具有相似的语法）。</p><p>用<code>{ { } }</code>或<code>{ ％ ％ }</code>包装的内容将被解析，并可能导致问题。</p><p>您可以使用原始标签插件包装敏感内容。<br>找到正文里面<code>{ {</code>、<code>} }</code>、<code>{ %</code>、<code>% }</code>这样的语句，作如下修改：</p><pre><code>{% raw %}//敏感内容前加上这个Hello {{ sensitive }}l/敏感内容被包装在中间{% endraw %}    //敏感内容后加上这个</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一复盘总结</title>
      <link href="/2020/08/25/da-yi-fu-pan-zong-jie/"/>
      <url>/2020/08/25/da-yi-fu-pan-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1456606483&auto=1&height=66"></iframe></div><p><img src="https://i.loli.net/2020/08/23/iPFjVSvNz416AQn.jpg" alt></p><hr><blockquote><p>在大二开学之前把大一复盘总结完成，拖了两个礼拜了还没写,可能拖延症又犯了。</p></blockquote><h1 id="我的大一"><a href="#我的大一" class="headerlink" title="我的大一"></a>我的大一</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrEDmlLxX5p3JcMGVqq00maXeZj1EL0BlNZ39Ez98p56TknxscaiaPIitxGWIdZhgwdciiCH25KkO0BNthc.zunsQ!/r" alt="从这里开始，十八岁收到的生日礼物是大学录取通知书"></p><p>​    </p><h3 id="2019上半年"><a href="#2019上半年" class="headerlink" title="2019上半年"></a>2019上半年</h3><p>8.27  <strong>初见上大</strong></p><p>9月-11月  <strong>秋季学期</strong></p><p>11月-12月  <strong>冬季学期前六周</strong></p><p>​    </p><p>小插曲  <strong>COVID-19</strong></p><p>​    </p><hr><p>​    </p><h3 id="2020上半年"><a href="#2020上半年" class="headerlink" title="2020上半年"></a>2020上半年</h3><p>1月  <strong>寒假生活</strong></p><p>2月  <strong>疫情影响居家网课</strong></p><p>3月-7月  <strong>冬季学期春季学期网课考试分流</strong></p><p>8月  <strong>计算机实训+十天暑假</strong></p><p>8.27 <strong>返校换寝</strong></p><blockquote><p>再见了，大一！</p></blockquote><hr><h2 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h2><p>到了大学的第三周之后开始<strong>早睡早起</strong>，一开始是因为看了张萌姐姐写的《人生效率手册》，富兰克林自传里的时间规划，后来又认识了一个知乎大V王振宇，我也切身体会到了每天早上多出来三个小时自由时间到带来的好处，喜欢上了每天早起写作的感觉，就一直坚持了下来，慢慢也就形成了习惯。</p><p><strong>阅读，写书评</strong>。因为小木屋的返现活动要打卡80天，所以借此机会认真写了一些书评，不过大多数都还是很水的。但是养成了借书看书的习惯。每个月去图书馆借一次书，制定了500本书的大学四年阅读计划。按照《如何阅读一本书》训练自己的阅读能力。商业科技政治文学历史哲学均有涉猎，尤其喜欢各种传记。</p><p><strong>写作，运营公众号</strong>。通过公众号了解互联网运营中的各种策略和技巧，以管窥豹。对于流量有了更清晰的认识，不止是知乎和b站、抖音短视频等等。理解更重要的是内容创作，从每周一更到后来每月一更，不同的阶段有不同的感悟。开始用心留意之前生活中可能并不在意的东西。写作反过来又推动阅读的需求，形成欧皇飞轮，良性循环反馈。</p><p><strong>做计划，复盘总结</strong>。不停尝试新事物，把想做的事情和没做完的事情列出来，在下一个月一项一项去完成。总结自己一个月里值得记录的事情。不断更新，有了自己的个人宪法和复盘系统。每周的日程规划也帮助我很好地处理各种看似不可能完成的任务。形成了自己完成计划的个人习惯。</p><p><strong>时间管理</strong>，其实就是做计划的一部分。主要是花在手机屏幕上的时间太多，使用番茄TODO和手机应用限时减少手机使用时间。不打游戏，不把时间花在没有意义的事情上。</p><p><strong>跑步。</strong>之前是想以参加一次半马为目标，中秋节晚上跑了人生的第一个10公里，那天在宿舍看完《搏击俱乐部》，绕着学校跑了三四圈，一个小时，喜欢上了多巴胺刺激大脑的这种感觉，每个月都会跑个三四十公里，可能还是跑量不够，也没控制配速，所以速度提升不大。后来开始健身，更多了解相关知识，改变了把长跑当做训练目标的想法，制定了自己的健身计划，以提升力量为主。居家半年买了一对哑铃自己在家训练，由于器材有限主要锻炼的是前臂。效果没有达到想象中的好。但是运动成了很好的放松方式，大大提升了我的生活质量。</p><p><strong>写日记。</strong>其实也没什么好记的，有时候就是写一句话，感触深的时候写一大段直抒胸臆，晚上睡觉做的梦记录下来留作写作素材。虽然想要借此训练写作，但实施起来还是有困难，原因在于没有认真考虑过把写日记当成一项任务安排进每天的日程里。目前没有在日记里写过多少有价值的东西，最多是我自己的一些片段回忆。</p><hr><h2 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h2><p>在更……</p><hr><h2 id="信息篇"><a href="#信息篇" class="headerlink" title="信息篇"></a>信息篇</h2><h3 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h3><blockquote><p>​    “信息管理就是拓宽信道，即打开新的信息入口，接受新的信息；然后整合你收集到的信息，即对无用的信息进行降噪，并且对有用的信息进行排序，提高查找信息的效率。”</p></blockquote><hr><h3 id="信息入口"><a href="#信息入口" class="headerlink" title="信息入口"></a>信息入口</h3><h4 id="我的书单"><a href="#我的书单" class="headerlink" title="我的书单"></a>我的书单</h4><ul><li>计算机书单</li><li>待更……</li></ul><p>​    </p><h4 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h4><ul><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1ex411u7GV" target="_blank" rel="noopener">CS183B@Stanford/YC创业课</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">【英字】MIT公开课 概率论</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1Kt411h7Ep" target="_blank" rel="noopener">【公开课】耶鲁大学：博弈论（中英双语字幕）</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1as411o7tU" target="_blank" rel="noopener">國立清華大學開放課：科幻概論——主講：鄭運鴻</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1gE411M7Eg" target="_blank" rel="noopener">【吴恩达亲授】适用于所有人的人工智能课程（中字）</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1JE411g7XF" target="_blank" rel="noopener">李宏毅2020机器学习深度学习(完整版)国语</a></li></ul><h4 id="手机app"><a href="#手机app" class="headerlink" title="手机app"></a>手机app</h4><ul><li>豆瓣、知乎</li><li>微信读书、京东读书（校园版）、藏书馆</li><li>得到、喜马拉雅、每日英语听力</li><li>一席、TED、b站</li><li>微信公众号</li></ul><h4 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h4><ul><li>收藏网址书签<ul><li><a href="https://b-ok.cc/" target="_blank" rel="noopener">英文原版电子书1</a></li><li><a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">英文原版电子书2</a></li><li><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学MOOC</a></li><li><a href="https://open.163.com/" target="_blank" rel="noopener">网易公开课</a></li><li>优质博客</li></ul></li></ul><h4 id="社交通讯APP"><a href="#社交通讯APP" class="headerlink" title="社交通讯APP"></a>社交通讯APP</h4><ul><li>Tim</li><li>微信</li><li>QQ    </li></ul><hr><h2 id="启航篇"><a href="#启航篇" class="headerlink" title="启航篇"></a>启航篇</h2><p>待更……</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
