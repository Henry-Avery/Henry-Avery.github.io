<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于神经网络与深度学习</title>
      <link href="/2021/06/25/deeplearning/"/>
      <url>/2021/06/25/deeplearning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小时候，每个人都会鼓励不断成长</p><p>变成一个心智成熟，不在耍小孩子脾气的人</p><p>但是，<strong>很少有人鼓励继续成长</strong></p><p><strong>变成一个怀疑和抵制社会错误潮流的人</strong></p><p>——保罗•格雷厄姆《黑客与画家》</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong>课程</strong></p><p><a href="https://www.bilibili.com/video/BV164411b7dx?p=1" target="_blank" rel="noopener">b站[中英字幕]吴恩达机器学习系列课程</a></p><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习</a></p><p><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera深度学习</a></p><blockquote><p>主成分数据选择那里有一节课没有字幕，建议移步Coursera</p></blockquote><p><strong>黄海广笔记</strong></p><p><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener"><strong>Coursera深度学习教程中文笔记</strong></a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>斯坦福大学2014（吴恩达）机器学习教程中文笔记</strong></a></p><p><strong>其他</strong></p><p><a href="https://henryavery.cn/2021/01/25/ml/">我的机器学习笔记</a></p><p><a href="https://nndl.github.io/" target="_blank" rel="noopener">神经网络与深度学习邱席鹏</a></p><blockquote><p>27个小时，集中时间的话三天左右看完。估计分散在一周时间内吧。</p></blockquote><h1 id="第一门课-神经网络和深度学习-Neural-Networks-and-Deep-Learning"><a href="#第一门课-神经网络和深度学习-Neural-Networks-and-Deep-Learning" class="headerlink" title="第一门课 神经网络和深度学习(Neural Networks and Deep Learning)"></a>第一门课 神经网络和深度学习(Neural Networks and Deep Learning)</h1><h2 id="第一周：深度学习引言-Introduction-to-Deep-Learning"><a href="#第一周：深度学习引言-Introduction-to-Deep-Learning" class="headerlink" title="第一周：深度学习引言(Introduction to Deep Learning)"></a><strong>第一周：深度学习引言(Introduction to Deep Learning)</strong></h2><h2 id="第二周：神经网络的编程基础-Basics-of-Neural-Network-programming"><a href="#第二周：神经网络的编程基础-Basics-of-Neural-Network-programming" class="headerlink" title="第二周：神经网络的编程基础(Basics of Neural Network programming)"></a>第二周：神经网络的编程基础(Basics of Neural Network programming)</h2><h3 id="2-1-二分类-Binary-Classification"><a href="#2-1-二分类-Binary-Classification" class="headerlink" title="2.1 二分类(Binary Classification)"></a><strong>2.1 二分类(Binary Classification)</strong></h3><h3 id="2-2-逻辑回归-Logistic-Regression"><a href="#2-2-逻辑回归-Logistic-Regression" class="headerlink" title="2.2 逻辑回归(Logistic Regression)"></a><strong>2.2 逻辑回归(Logistic Regression)</strong></h3><h3 id="2-3-逻辑回归的代价函数（Logistic-Regress）"><a href="#2-3-逻辑回归的代价函数（Logistic-Regress）" class="headerlink" title="2.3 逻辑回归的代价函数（Logistic Regress）"></a><strong>2.3 逻辑回归的代价函数（Logistic Regress）</strong></h3><p>损失函数又叫做误差函数，用来衡量算法的运行情况，Loss function</p><p>练样本中表现如何，为了衡量算法在全部训练样本上的表现如何，我们需要定义一个算法的代价函数cost function</p><h3 id="2-4-梯度下降法（Gradient-Descent）"><a href="#2-4-梯度下降法（Gradient-Descent）" class="headerlink" title="2.4 梯度下降法（Gradient Descent）"></a><strong>2.4 梯度下降法（Gradient Descent）</strong></h3><h3 id="2-9-逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）"><a href="#2-9-逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）" class="headerlink" title="2.9 逻辑回归中的梯度下降（Logistic Regression Gradient Descent）"></a><strong>2.9 逻辑回归中的梯度下降（Logistic Regression Gradient Descent）</strong></h3><h3 id="2-10-m-个样本的梯度下降-Gradient-Descent-on-m-Examples"><a href="#2-10-m-个样本的梯度下降-Gradient-Descent-on-m-Examples" class="headerlink" title="2.10  m 个样本的梯度下降(Gradient Descent on m Examples)"></a><strong>2.10  m 个样本的梯度下降(Gradient Descent on m Examples)</strong></h3><h3 id="2-11-向量化-Vectorization"><a href="#2-11-向量化-Vectorization" class="headerlink" title="2.11 向量化(Vectorization)"></a><strong>2.11 向量化(Vectorization)</strong></h3><h3 id="2-13-向量化逻辑回归-Vectorizing-Logistic-Regression"><a href="#2-13-向量化逻辑回归-Vectorizing-Logistic-Regression" class="headerlink" title="2.13 向量化逻辑回归(Vectorizing Logistic Regression)"></a><strong>2.13 向量化逻辑回归(Vectorizing Logistic Regression)</strong></h3><h3 id="2-14-向量化-logistic-回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）"><a href="#2-14-向量化-logistic-回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）" class="headerlink" title="2.14 向量化 logistic 回归的梯度输出（Vectorizing Logistic Regression’s Gradient）"></a><strong>2.14 向量化 logistic 回归的梯度输出（Vectorizing Logistic Regression’s Gradient）</strong></h3><h2 id="第三周：浅层神经网络-Shallow-neural-networks"><a href="#第三周：浅层神经网络-Shallow-neural-networks" class="headerlink" title="第三周：浅层神经网络(Shallow neural networks)"></a>第三周：浅层神经网络(Shallow neural networks)</h2><h3 id="3-1-神经网络概述（Neural-Network-Overview）"><a href="#3-1-神经网络概述（Neural-Network-Overview）" class="headerlink" title="3.1 神经网络概述（Neural Network Overview）"></a><strong>3.1 神经网络概述（Neural Network Overview）</strong></h3><h3 id="3-2-神经网络的表示（Neural-Network-Representation）"><a href="#3-2-神经网络的表示（Neural-Network-Representation）" class="headerlink" title="3.2 神经网络的表示（Neural Network Representation）"></a><strong>3.2 神经网络的表示（Neural Network Representation）</strong></h3><h3 id="3-3-计算一个神经网络的输出（Computing-a-Neural-Network’s-output）"><a href="#3-3-计算一个神经网络的输出（Computing-a-Neural-Network’s-output）" class="headerlink" title="3.3 计算一个神经网络的输出（Computing a Neural Network’s output）"></a><strong>3.3 计算一个神经网络的输出（Computing a Neural Network’s output）</strong></h3><h3 id="3-4-多样本向量化（Vectorizing-across-multiple-examples）"><a href="#3-4-多样本向量化（Vectorizing-across-multiple-examples）" class="headerlink" title="3.4 多样本向量化（Vectorizing across multiple examples）"></a><strong>3.4 多样本向量化（Vectorizing across multiple examples）</strong></h3><h3 id="3-5-向量化实现的解释（Justification-for-vectorized-implementation）"><a href="#3-5-向量化实现的解释（Justification-for-vectorized-implementation）" class="headerlink" title="3.5 向量化实现的解释（Justification for vectorized implementation）"></a><strong>3.5 向量化实现的解释（Justification for vectorized implementation）</strong></h3><h3 id="3-6-激活函数（Activation-functions）"><a href="#3-6-激活函数（Activation-functions）" class="headerlink" title="3.6 激活函数（Activation functions）"></a><strong>3.6 激活函数（Activation functions）</strong></h3><p><strong>tanh</strong>函数或者双曲正切函数是总体上都优于<strong>sigmoid</strong>函数的激活函数。</p><p><strong>sigmoid</strong>函数和<strong>tanh</strong>函数两者共同的缺点是，在$z$特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于0，导致降低梯度下降的速度。</p><p>在机器学习另一个很流行的函数是：修正线性单元的函数（<strong>ReLu</strong>）</p><p>如果输出是0、1值（二分类问题），则输出层选择<strong>sigmoid</strong>函数，然后其它的所有单元都选择<strong>Relu</strong>函数。</p><p>这是很多激活函数的默认选择，如果在隐藏层上不确定使用哪个激活函数，那么通常会使用<strong>Relu</strong>激活函数。有时，也会使用<strong>tanh</strong>激活函数，但<strong>Relu</strong>的一个优点是：当$z$是负值的时候，导数等于0。</p><p>这里也有另一个版本的<strong>Relu</strong>被称为<strong>Leaky Relu</strong>。</p><p>当$z$是负值时，这个函数的值不是等于0，而是轻微的倾斜。</p><p>如图。（图在心中）</p><p>两者的优点是：</p><p>第一，在$z$的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个<strong>if-else</strong>语句，而<strong>sigmoid</strong>函数需要进行浮点四则运算，在实践中，使用<strong>ReLu</strong>激活函数神经网络通常会比使用<strong>sigmoid</strong>或者<strong>tanh</strong>激活函数学习的更快。</p><p>第二，<strong>sigmoid</strong>和<strong>tanh</strong>函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而<strong>Relu</strong>和<strong>Leaky ReLu</strong>函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，<strong>Relu</strong>进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而<strong>Leaky ReLu</strong>不会有这问题)</p><p>$z$在<strong>ReLu</strong>的梯度一半都是0，但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。</p><p>快速概括一下不同激活函数的过程和结论。</p><p><strong>sigmoid</strong>激活函数：除了输出层是一个二分类问题基本不会用它。</p><p><strong>tanh</strong>激活函数：<strong>tanh</strong>是非常优秀的，几乎适合所有场合。</p><p><strong>ReLu</strong>激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用<strong>ReLu</strong>或者<strong>Leaky ReLu</strong>。</p><h3 id="3-7-为什么需要非线性激活函数？（why-need-a-nonlinear-activation-function-）"><a href="#3-7-为什么需要非线性激活函数？（why-need-a-nonlinear-activation-function-）" class="headerlink" title="3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?）"></a><strong>3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?）</strong></h3><h3 id="3-8-激活函数的导数（Derivatives-of-activation-functions）"><a href="#3-8-激活函数的导数（Derivatives-of-activation-functions）" class="headerlink" title="3.8 激活函数的导数（Derivatives of activation functions）"></a><strong>3.8 激活函数的导数（Derivatives of activation functions）</strong></h3><h3 id="3-9-神经网络的梯度下降（Gradient-descent-for-neural-networks）"><a href="#3-9-神经网络的梯度下降（Gradient-descent-for-neural-networks）" class="headerlink" title="3.9 神经网络的梯度下降（Gradient descent for neural networks）"></a><strong>3.9 神经网络的梯度下降（Gradient descent for neural networks）</strong></h3><h3 id="3-10（选修）直观理解反向传播（Backpropagation-intuition）"><a href="#3-10（选修）直观理解反向传播（Backpropagation-intuition）" class="headerlink" title="3.10（选修）直观理解反向传播（Backpropagation intuition）"></a><strong>3.10（选修）直观理解反向传播（Backpropagation intuition）</strong></h3><p>看懂逻辑回归就清楚了，主要是梯度下降用到loss function对某参数的导数来更新，求导就是链式法则，神经网络就是矩阵求导。</p><h3 id="3-11-随机初始化（Random-Initialization）"><a href="#3-11-随机初始化（Random-Initialization）" class="headerlink" title="3.11 随机初始化（Random+Initialization）"></a><strong>3.11 随机初始化（Random+Initialization）</strong></h3><p>如果$W$很大，$z$就会很大或者很小，因此这种情况下你很可能停在<strong>tanh</strong>/<strong>sigmoid</strong>函数的平坦的地方(见图3.8.2)，这些地方梯度很小也就意味着梯度下降会很慢，因此学习也就很慢。</p><p>事实上有时有比0.01更好的常数，当你训练一个只有一层隐藏层的网络时（这是相对浅的神经网络，没有太多的隐藏层），设为0.01可能也可以。但当你训练一个非常非常深的神经网络，你可能要试试0.01以外的常数。下一节课我们会讨论怎么并且何时去选择一个不同于0.01的常数，但是无论如何它通常都会是个相对小的数。</p><h2 id="第四周：深层神经网络-Deep-Neural-Networks"><a href="#第四周：深层神经网络-Deep-Neural-Networks" class="headerlink" title="第四周：深层神经网络(Deep Neural Networks)"></a>第四周：深层神经网络(Deep Neural Networks)</h2><h3 id="4-1-深层神经网络（Deep-L-layer-neural-network）"><a href="#4-1-深层神经网络（Deep-L-layer-neural-network）" class="headerlink" title="4.1 深层神经网络（Deep L-layer neural network）"></a>4.1 深层神经网络（Deep L-layer neural network）</h3><h3 id="4-2-前向传播和反向传播（Forward-and-backward-propagation）"><a href="#4-2-前向传播和反向传播（Forward-and-backward-propagation）" class="headerlink" title="4.2 前向传播和反向传播（Forward and backward propagation）"></a>4.2 前向传播和反向传播（Forward and backward propagation）</h3><h3 id="4-3-深层网络中的前向传播（Forward-propagation-in-a-Deep-Network）"><a href="#4-3-深层网络中的前向传播（Forward-propagation-in-a-Deep-Network）" class="headerlink" title="4.3 深层网络中的前向传播（Forward propagation in a Deep Network）"></a>4.3 深层网络中的前向传播（Forward propagation in a Deep Network）</h3><h3 id="4-4-核对矩阵的维数（Getting-your-matrix-dimensions-right）"><a href="#4-4-核对矩阵的维数（Getting-your-matrix-dimensions-right）" class="headerlink" title="4.4 核对矩阵的维数（Getting your matrix dimensions right）"></a>4.4 核对矩阵的维数（Getting your matrix dimensions right）</h3><h3 id="4-5-为什么使用深层表示？（Why-deep-representations-）"><a href="#4-5-为什么使用深层表示？（Why-deep-representations-）" class="headerlink" title="4.5 为什么使用深层表示？（Why deep representations?）"></a>4.5 为什么使用深层表示？（Why deep representations?）</h3><h3 id="4-6-搭建神经网络块（Building-blocks-of-deep-neural-networks）"><a href="#4-6-搭建神经网络块（Building-blocks-of-deep-neural-networks）" class="headerlink" title="4.6 搭建神经网络块（Building blocks of deep neural networks）"></a>4.6 搭建神经网络块（Building blocks of deep neural networks）</h3><h3 id="4-7-参数VS超参数（Parameters-vs-Hyperparameters）"><a href="#4-7-参数VS超参数（Parameters-vs-Hyperparameters）" class="headerlink" title="4.7 参数VS超参数（Parameters vs Hyperparameters）"></a>4.7 参数VS超参数（Parameters vs Hyperparameters）</h3><h3 id="4-8-深度学习和大脑的关联性（What-does-this-have-to-do-with-the-brain-）"><a href="#4-8-深度学习和大脑的关联性（What-does-this-have-to-do-with-the-brain-）" class="headerlink" title="4.8 深度学习和大脑的关联性（What does this have to do with the brain?）"></a>4.8 深度学习和大脑的关联性（What does this have to do with the brain?）</h3><h1 id="第二门课-改善深层神经网络：超参数调试、正则化以及优化-Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization"><a href="#第二门课-改善深层神经网络：超参数调试、正则化以及优化-Improving-Deep-Neural-Networks-Hyperparameter-tuning-Regularization-and-Optimization" class="headerlink" title="第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)"></a>第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)</h1><h2 id="第一周：深度学习的实践层面-Practical-aspects-of-Deep-Learning"><a href="#第一周：深度学习的实践层面-Practical-aspects-of-Deep-Learning" class="headerlink" title="第一周：深度学习的实践层面(Practical aspects of Deep Learning)"></a>第一周：深度学习的实践层面(Practical aspects of Deep Learning)</h2><h3 id="1-1-训练，验证，测试集（Train-Dev-Test-sets）"><a href="#1-1-训练，验证，测试集（Train-Dev-Test-sets）" class="headerlink" title="1.1 训练，验证，测试集（Train / Dev / Test sets）"></a>1.1 训练，验证，测试集（Train / Dev / Test sets）</h3><p>比如我们有100万条数据，那么取1万条数据便足以进行评估，找出其中表现最好的1-2种算法。同样地，根据最终选择的分类器，测试集的主要目的是正确评估分类器的性能，所以，如果拥有百万数据，我们只需要1000条数据，便足以评估单个分类器，并且准确评估该分类器的性能。假设我们有100万条数据，其中1万条作为验证集，1万条作为测试集，100万里取1万，比例是1%，即：训练集占98%，验证集和测试集各占1%。对于数据量过百万的应用，训练集可以占到99.5%，验证和测试集各占0.25%，或者验证集占0.4%，测试集占0.1%。</p><p>根据经验，我建议大家要确保验证集和测试集的数据来自<strong>同一分布</strong>，关于这个问题我也会多讲一些。因为你们要用验证集来评估不同的模型，尽可能地优化性能。如果验证集和测试集来自同一个分布就会很好。</p><h3 id="1-2-偏差，方差（Bias-Variance）"><a href="#1-2-偏差，方差（Bias-Variance）" class="headerlink" title="1.2 偏差，方差（Bias /Variance）"></a>1.2 偏差，方差（Bias /Variance）</h3><p>高偏差（<strong>high bias</strong>）的情况，我们称为“欠拟合”（<strong>underfitting</strong>）。</p><p>方差较高（<strong>high variance</strong>），数据过度拟合（<strong>overfitting</strong>）。</p><p>理解偏差和方差的两个关键数据是训练集误差（<strong>Train set error</strong>）和验证集误差（<strong>Dev set error</strong>）</p><p>假定训练集误差是1%，为了方便论证，假定验证集误差是11%，可以看出训练集设置得非常好，而验证集设置相对较差，我们可能过度拟合了训练集，在某种程度上，验证集并没有充分利用交叉验证集的作用，像这种情况，我们称之为“高方差”。</p><p>通过查看训练集误差和验证集误差，我们便可以诊断算法是否具有高方差。也就是说衡量训练集和验证集误差就可以得出不同结论。</p><p>假设训练集误差是15%，我们把训练集误差写在首行，验证集误差是16%，假设该案例中人的错误率几乎为0%，人们浏览这些图片，分辨出是不是猫。算法并没有在训练集中得到很好训练，如果训练数据的拟合度不高，就是数据欠拟合，就可以说这种算法偏差比较高。相反，它对于验证集产生的结果却是合理的，验证集中的错误率只比训练集的多了1%，所以这种算法偏差高，因为它甚至不能拟合训练集</p><p>再举一个例子，训练集误差是15%，偏差相当高，但是，验证集的评估结果更糟糕，错误率达到30%，在这种情况下，我会认为这种算法偏差高，因为它在训练集上结果不理想，而且方差也很高，这是方差偏差都很糟糕的情况。</p><h3 id="1-3-机器学习基础（Basic-Recipe-for-Machine-Learning）"><a href="#1-3-机器学习基础（Basic-Recipe-for-Machine-Learning）" class="headerlink" title="1.3 机器学习基础（Basic Recipe for Machine Learning）"></a>1.3 机器学习基础（Basic Recipe for Machine Learning）</h3><h3 id="1-4-正则化（Regularization）"><a href="#1-4-正则化（Regularization）" class="headerlink" title="1.4 正则化（Regularization）"></a>1.4 正则化（Regularization）</h3><p>深度学习可能存在过拟合问题——高方差，有两个解决方法，<strong>一个是正则化，另一个是准备更多的数据</strong>，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。</p><blockquote><p>今天上午起晚了，进度拖慢了，然后又改了一手cnn模型的代码。明天上午再看。今天晚上休息一会。</p></blockquote><h3 id="1-5-为什么正则化有利于预防过拟合呢？（Why-regularization-reduces-overfitting-）"><a href="#1-5-为什么正则化有利于预防过拟合呢？（Why-regularization-reduces-overfitting-）" class="headerlink" title="1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）"></a>1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）</h3><h3 id="1-6-dropout-正则化（Dropout-Regularization）"><a href="#1-6-dropout-正则化（Dropout-Regularization）" class="headerlink" title="1.6 dropout 正则化（Dropout Regularization）"></a>1.6 dropout 正则化（Dropout Regularization）</h3><p>除了$L2$正则化，还有一个非常实用的正则化方法——“<strong>Dropout</strong>（随机失活）”</p><h3 id="1-7-理解-dropout（Understanding-Dropout）"><a href="#1-7-理解-dropout（Understanding-Dropout）" class="headerlink" title="1.7 理解 dropout（Understanding Dropout）"></a>1.7 理解 dropout（Understanding Dropout）</h3><p><strong>Dropout</strong>可以随机删除网络中的神经单元，他为什么可以通过正则化发挥如此大的作用呢？</p><p>直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，通过传播所有权重，<strong>dropout</strong>将产生收缩权重的平方范数的效果，和之前讲的$L2$正则化类似；实施<strong>dropout</strong>的结果实它会压缩权重，并完成一些预防过拟合的外层正则化；$L2$对不同权重的衰减是不同的，它取决于激活函数倍增的大小。</p><h3 id="1-8-其他正则化方法（Other-regularization-methods）"><a href="#1-8-其他正则化方法（Other-regularization-methods）" class="headerlink" title="1.8 其他正则化方法（Other regularization methods）"></a>1.8 其他正则化方法（Other regularization methods）</h3><h3 id="1-9-归一化输入（Normalizing-inputs）"><a href="#1-9-归一化输入（Normalizing-inputs）" class="headerlink" title="1.9 归一化输入（Normalizing inputs）"></a>1.9 归一化输入（Normalizing inputs）</h3><h3 id="1-10-梯度消失-梯度爆炸（Vanishing-Exploding-gradients）"><a href="#1-10-梯度消失-梯度爆炸（Vanishing-Exploding-gradients）" class="headerlink" title="1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）"></a>1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）</h3><h3 id="1-11-神经网络的权重初始化（Weight-Initialization-for-Deep-NetworksVanishing-Exploding-gradients）"><a href="#1-11-神经网络的权重初始化（Weight-Initialization-for-Deep-NetworksVanishing-Exploding-gradients）" class="headerlink" title="1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing / Exploding gradients）"></a>1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing / Exploding gradients）</h3><h3 id="1-12-梯度的数值逼近（Numerical-approximation-of-gradients）"><a href="#1-12-梯度的数值逼近（Numerical-approximation-of-gradients）" class="headerlink" title="1.12 梯度的数值逼近（Numerical approximation of gradients）"></a>1.12 梯度的数值逼近（Numerical approximation of gradients）</h3><h3 id="1-13-梯度检验（Gradient-checking）"><a href="#1-13-梯度检验（Gradient-checking）" class="headerlink" title="1.13 梯度检验（Gradient checking）"></a>1.13 梯度检验（Gradient checking）</h3><h3 id="1-14-梯度检验应用的注意事项（Gradient-Checking-Implementation-Notes）"><a href="#1-14-梯度检验应用的注意事项（Gradient-Checking-Implementation-Notes）" class="headerlink" title="1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes）"></a>1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes）</h3><h2 id="第二周：优化算法-Optimization-algorithms"><a href="#第二周：优化算法-Optimization-algorithms" class="headerlink" title="第二周：优化算法 (Optimization algorithms)"></a>第二周：优化算法 (Optimization algorithms)</h2><h3 id="2-1-Mini-batch-梯度下降（Mini-batch-gradient-descent）"><a href="#2-1-Mini-batch-梯度下降（Mini-batch-gradient-descent）" class="headerlink" title="2.1 Mini-batch 梯度下降（Mini-batch gradient descent）"></a>2.1 Mini-batch 梯度下降（Mini-batch gradient descent）</h3><p>首先，如果训练集较小，直接使用<strong>batch</strong>梯度下降法，样本集较小就没必要使用<strong>mini-batch</strong>梯度下降法，你可以快速处理整个训练集，所以使用<strong>batch</strong>梯度下降法也很好，这里的少是说小于2000个样本，这样比较适合使用<strong>batch</strong>梯度下降法。不然，样本数目较大的话，一般的<strong>mini-batch</strong>大小为64到512，考虑到电脑内存设置和使用的方式，如果<strong>mini-batch</strong>大小是2的$n$次方，代码会运行地快一些，64就是2的6次方，以此类推，128是2的7次方，256是2的8次方，512是2的9次方。所以我经常把<strong>mini-batch</strong>大小设成2的次方。</p><p><strong>mini-batch</strong>梯度下降法比<strong>batch</strong>梯度下降法运行地更快。</p><h3 id="2-2-理解mini-batch梯度下降法（Understanding-mini-batch-gradient-descent）"><a href="#2-2-理解mini-batch梯度下降法（Understanding-mini-batch-gradient-descent）" class="headerlink" title="2.2 理解mini-batch梯度下降法（Understanding mini-batch gradient descent）"></a>2.2 理解mini-batch梯度下降法（Understanding mini-batch gradient descent）</h3><p>使用<strong>batch</strong>梯度下降法时，每次迭代你都需要历遍整个训练集，可以预期每次迭代成本都会下降，所以如果成本函数$J$是迭代次数的一个函数，它应该会随着每次迭代而减少，如果$J$在某次迭代中增加了，那肯定出了问题，也许你的学习率太大。</p><p>使用<strong>mini-batch</strong>梯度下降法，如果你作出成本函数在整个过程中的图，则并不是每次迭代都是下降的</p><p>另一个极端情况，假设<strong>mini-batch</strong>大小为1，就有了新的算法，叫做随机梯度下降法，每个样本都是独立的<strong>mini-batch</strong></p><h3 id="2-3-指数加权平均数（Exponentially-weighted-averages）"><a href="#2-3-指数加权平均数（Exponentially-weighted-averages）" class="headerlink" title="2.3 指数加权平均数（Exponentially weighted averages）"></a>2.3 指数加权平均数（Exponentially weighted averages）</h3><p>指数加权平均数经常被使用，再说一次，它在统计学中被称为指数加权移动平均值，我们就简称为指数加权平均数。通过调整这个参数（$\beta$），或者说后面的算法学习，你会发现这是一个很重要的参数，可以取得稍微不同的效果，往往中间有某个值效果最好</p><h3 id="2-4-理解指数加权平均数（Understanding-exponentially-weighted-averages）"><a href="#2-4-理解指数加权平均数（Understanding-exponentially-weighted-averages）" class="headerlink" title="2.4 理解指数加权平均数（Understanding exponentially weighted averages）"></a>2.4 理解指数加权平均数（Understanding exponentially weighted averages）</h3><p>指数加权平均数公式的好处之一在于，它占用极少内存，电脑内存中只占用一行数字而已，然后把最新数据代入公式，不断覆盖就可以了，正因为这个原因，其效率，它基本上只占用一行代码，计算指数加权平均数也只占用单行数字的存储和内存，当然它并不是最好的，也不是最精准的计算平均数的方法。如果你要计算移动窗，你直接算出过去10天的总和，过去50天的总和，除以10和50就好，如此往往会得到更好的估测。但缺点是，如果保存所有最近的温度数据，和过去10天的总和，必须占用更多的内存，执行更加复杂，计算成本也更加高昂。</p><h3 id="2-5-指数加权平均的偏差修正（Bias-correction-in-exponentially-weighted-averages）"><a href="#2-5-指数加权平均的偏差修正（Bias-correction-in-exponentially-weighted-averages）" class="headerlink" title="2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages）"></a>2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages）</h3><p>有个办法可以修改这一估测，让估测变得更好，更准确，特别是在估测初期，也就是不用$v_{t}$，而是用$\frac{v_{t}}{1- \beta^{t}}$，t就是现在的天数。</p><p>在机器学习中，在计算指数加权平均数的大部分时候，大家不在乎执行偏差修正，因为大部分人宁愿熬过初始时期，拿到具有偏差的估测，然后继续计算下去。如果你关心初始时期的偏差，在刚开始计算指数加权移动平均数的时候，偏差修正能帮助你在早期获取更好的估测。</p><h3 id="2-6-动量梯度下降法（Gradient-descent-with-Momentum）"><a href="#2-6-动量梯度下降法（Gradient-descent-with-Momentum）" class="headerlink" title="2.6 动量梯度下降法（Gradient descent with Momentum）"></a>2.6 动量梯度下降法（Gradient descent with Momentum）</h3><p>还有一种算法叫做<strong>Momentum</strong>，或者叫做动量梯度下降法，运行速度几乎总是快于标准的梯度下降算法，简而言之，基本的想法就是计算梯度的指数加权平均数，并利用该梯度更新你的权重</p><p>另一个看待问题的角度是，在纵轴上，你希望学习慢一点，因为你不想要这些摆动，但是在横轴上，你希望加快学习，你希望快速从左向右移，移向最小值，移向红点。</p><p>想象你有一个碗，你拿一个球，微分项给了这个球一个加速度，此时球正向山下滚，球因为加速度越滚越快，而因为$\beta$ 稍小于1，表现出一些摩擦力，所以球不会无限加速下去，所以不像梯度下降法，每一步都独立于之前的步骤，你的球可以向下滚，获得动量，可以从碗向下加速获得动量。我发现这个球从碗滚下的比喻，物理能力强的人接受得比较好，但不是所有人都能接受，如果球从碗中滚下这个比喻，你理解不了，别担心。</p><p>最后我们来看具体如何计算，算法在此。</p><p>你有两个超参数，学习率$a$以及参数$\beta$，$\beta$控制着指数加权平均数。$\beta$最常用的值是0.9，我们之前平均了过去十天的温度，所以现在平均了前十次迭代的梯度。实际上$\beta$为0.9时，效果不错，你可以尝试不同的值，可以做一些超参数的研究，不过0.9是很棒的鲁棒数。</p><h3 id="2-7-RMSprop"><a href="#2-7-RMSprop" class="headerlink" title="2.7 RMSprop"></a>2.7 RMSprop</h3><p>你们知道了动量（<strong>Momentum</strong>）可以加快梯度下降，还有一个叫做<strong>RMSprop</strong>的算法，全称是<strong>root mean square prop</strong>算法，它也可以加速梯度下降，我们来看看它是如何运作的。</p><p>该算法会照常计算当下<strong>mini-batch</strong>的微分$dW$，$db$，所以我会保留这个指数加权平均数，我们用到新符号$S_{dW}$，而不是$v_{dW}$，因此$S_{dW}= \beta S_{dW} + (1 -\beta) {dW}^{2}$，澄清一下，这个平方的操作是针对这一整个符号的，这样做能够保留微分平方的加权平均数，同样$S_{db}= \beta S_{db} + (1 - \beta){db}^{2}$，再说一次，平方是针对整个符号的操作。</p><p>接着<strong>RMSprop</strong>会这样更新参数值，$W:= W -a\frac{dW}{\sqrt{S_{dW}}}$，$b:=b -\alpha\frac{db}{\sqrt{S_{db}}}$，我们来理解一下其原理。记得在横轴方向或者在例子中的$W$方向，我们希望学习速度快，而在垂直方向，也就是例子中的$b$方向，我们希望减缓纵轴上的摆动，所以有了$S_{dW}$和$S_{db}$，我们希望$S_{dW}$会相对较小，所以我们要除以一个较小的数，而希望$S_{db}$又较大，所以这里我们要除以较大的数字，这样就可以减缓纵轴上的变化。你看这些微分，垂直方向的要比水平方向的大得多，所以斜率在$b$方向特别大，所以这些微分中，$db$较大，$dW$较小，因为函数的倾斜程度，在纵轴上，也就是b方向上要大于在横轴上，也就是$W$方向上。$db$的平方较大，所以$S_{db}$也会较大，而相比之下，$dW$会小一些，亦或$dW$平方会小一些，因此$S_{dW}$会小一些，结果就是纵轴上的更新要被一个较大的数相除，就能消除摆动，而水平方向的更新则被较小的数相除。</p><p>所以<strong>RMSprop</strong>跟<strong>Momentum</strong>有很相似的一点，可以消除梯度下降中的摆动，包括<strong>mini-batch</strong>梯度下降，并允许你使用一个更大的学习率$a$，从而加快你的算法学习速度。</p><h3 id="2-8-Adam-优化算法-Adam-optimization-algorithm"><a href="#2-8-Adam-优化算法-Adam-optimization-algorithm" class="headerlink" title="2.8 Adam 优化算法(Adam optimization algorithm)"></a>2.8 Adam 优化算法(Adam optimization algorithm)</h3><p>在深度学习的历史上，包括许多知名研究者在内，提出了优化算法，并很好地解决了一些问题，但随后这些优化算法被指出并不能一般化，并不适用于多种神经网络，时间久了，深度学习圈子里的人开始多少有些质疑全新的优化算法，很多人都觉得动量（<strong>Momentum</strong>）梯度下降法很好用，很难再想出更好的优化算法。所以<strong>RMSprop</strong>以及<strong>Adam</strong>优化算法（<strong>Adam</strong>优化算法也是本视频的内容），就是少有的经受住人们考验的两种算法，已被证明适用于不同的深度学习结构，这个算法我会毫不犹豫地推荐给你，因为很多人都试过，并且用它很好地解决了许多问题。</p><h3 id="2-9-学习率衰减-Learning-rate-decay"><a href="#2-9-学习率衰减-Learning-rate-decay" class="headerlink" title="2.9 学习率衰减(Learning rate decay)"></a>2.9 学习率衰减(Learning rate decay)</h3><h3 id="2-10-局部最优的问题-The-problem-of-local-optima"><a href="#2-10-局部最优的问题-The-problem-of-local-optima" class="headerlink" title="2.10 局部最优的问题(The problem of local optima)"></a>2.10 局部最优的问题(The problem of local optima)</h3><p>首先，你不太可能困在极差的局部最优中，条件是你在训练较大的神经网络，存在大量参数，并且成本函数$J$被定义在较高的维度空间。</p><p>第二点，平稳段是一个问题，这样使得学习十分缓慢，这也是像<strong>Momentum</strong>或是<strong>RMSprop</strong>，<strong>Adam</strong>这样的算法，能够加速学习算法的地方。在这些情况下，更成熟的优化算法，如<strong>Adam</strong>算法，能够加快速度，让你尽早往下走出平稳段。</p><h2 id="第三周-超参数调试、Batch正则化和程序框架（Hyperparameter-tuning）"><a href="#第三周-超参数调试、Batch正则化和程序框架（Hyperparameter-tuning）" class="headerlink" title="第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）"></a>第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）</h2><h3 id="3-1-调试处理（Tuning-process）"><a href="#3-1-调试处理（Tuning-process）" class="headerlink" title="3.1 调试处理（Tuning process）"></a>3.1 调试处理（Tuning process）</h3><h3 id="3-2-为超参数选择合适的范围（Using-an-appropriate-scale-to-pick-hyperparameters）"><a href="#3-2-为超参数选择合适的范围（Using-an-appropriate-scale-to-pick-hyperparameters）" class="headerlink" title="3.2 为超参数选择合适的范围（Using an appropriate scale to pick hyperparameters）"></a>3.2 为超参数选择合适的范围（Using an appropriate scale to pick hyperparameters）</h3><h3 id="3-3-超参数调试的实践：Pandas-VS-Caviar（Hyperparameters-tuning-in-practice-Pandas-vs-Caviar）"><a href="#3-3-超参数调试的实践：Pandas-VS-Caviar（Hyperparameters-tuning-in-practice-Pandas-vs-Caviar）" class="headerlink" title="3.3 超参数调试的实践：Pandas VS Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar）"></a>3.3 超参数调试的实践：Pandas VS Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar）</h3><h3 id="3-4-归一化网络的激活函数（Normalizing-activations-in-a-network）"><a href="#3-4-归一化网络的激活函数（Normalizing-activations-in-a-network）" class="headerlink" title="3.4 归一化网络的激活函数（Normalizing activations in a network）"></a>3.4 归一化网络的激活函数（Normalizing activations in a network）</h3><h3 id="3-5-将-Batch-Norm-拟合进神经网络（Fitting-Batch-Norm-into-a-neural-network）"><a href="#3-5-将-Batch-Norm-拟合进神经网络（Fitting-Batch-Norm-into-a-neural-network）" class="headerlink" title="3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）"></a>3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）</h3><h2 id="3-6-Batch-Norm-为什么奏效（Why-does-Batch-Norm-work-）"><a href="#3-6-Batch-Norm-为什么奏效（Why-does-Batch-Norm-work-）" class="headerlink" title="3.6 Batch Norm 为什么奏效（Why does Batch Norm work?）"></a>3.6 Batch Norm 为什么奏效（Why does Batch Norm work?）</h2><h3 id="3-7-测试时的-Batch-Norm（Batch-Norm-at-test-time）"><a href="#3-7-测试时的-Batch-Norm（Batch-Norm-at-test-time）" class="headerlink" title="3.7 测试时的 Batch Norm（Batch Norm at test time）"></a>3.7 测试时的 Batch Norm（Batch Norm at test time）</h3><h3 id="3-8-Softmax-回归（Softmax-regression）"><a href="#3-8-Softmax-回归（Softmax-regression）" class="headerlink" title="3.8 Softmax 回归（Softmax regression）"></a>3.8 Softmax 回归（Softmax regression）</h3><h3 id="3-9-训练一个-Softmax-分类器（Training-a-Softmax-classifier）"><a href="#3-9-训练一个-Softmax-分类器（Training-a-Softmax-classifier）" class="headerlink" title="3.9 训练一个 Softmax 分类器（Training a Softmax classifier）"></a>3.9 训练一个 Softmax 分类器（Training a Softmax classifier）</h3><h3 id="3-10-深度学习框架（Deep-Learning-frameworks）"><a href="#3-10-深度学习框架（Deep-Learning-frameworks）" class="headerlink" title="3.10 深度学习框架（Deep Learning frameworks）"></a>3.10 深度学习框架（Deep Learning frameworks）</h3><h3 id="3-11-TensorFlow"><a href="#3-11-TensorFlow" class="headerlink" title="3.11 TensorFlow"></a>3.11 TensorFlow</h3><blockquote><p>今天晚上多花了点时间，把进度提前推一点，BN是重点，明天回过头来再看看。明天再刷一天就进入cv了。</p></blockquote><h1 id="第三门课-结构化机器学习项目（Structuring-Machine-Learning-Projects）"><a href="#第三门课-结构化机器学习项目（Structuring-Machine-Learning-Projects）" class="headerlink" title="第三门课 结构化机器学习项目（Structuring Machine Learning Projects）"></a>第三门课 结构化机器学习项目（Structuring Machine Learning Projects）</h1><h2 id="第一周-机器学习（ML）策略（1）（ML-strategy（1））"><a href="#第一周-机器学习（ML）策略（1）（ML-strategy（1））" class="headerlink" title="第一周 机器学习（ML）策略（1）（ML strategy（1））"></a>第一周 机器学习（ML）策略（1）（ML strategy（1））</h2><h3 id="1-1-为什么是ML策略？（Why-ML-Strategy-）"><a href="#1-1-为什么是ML策略？（Why-ML-Strategy-）" class="headerlink" title="1.1 为什么是ML策略？（Why ML Strategy?）"></a>1.1 为什么是ML策略？（Why ML Strategy?）</h3><h3 id="1-2-正交化（Orthogonalization）"><a href="#1-2-正交化（Orthogonalization）" class="headerlink" title="1.2 正交化（Orthogonalization）"></a>1.2 正交化（Orthogonalization）</h3><p>所以正交化的概念是指，你可以想出一个维度，这个维度你想做的是控制转向角，还有另一个维度来控制你的速度，那么你就需要一个旋钮尽量只控制转向角，另一个旋钮，在这个开车的例子里其实是油门和刹车控制了你的速度。但如果你有一个控制旋钮将两者混在一起，比如说这样一个控制装置同时影响你的转向角和速度，同时改变了两个性质，那么就很难令你的车子以想要的速度和角度前进。然而正交化之后，正交意味着互成90度。设计出正交化的控制装置，最理想的情况是和你实际想控制的性质一致，这样你调整参数时就容易得多。可以单独调整转向角，还有你的油门和刹车，令车子以你想要的方式运动。</p><h3 id="1-3-单一数字评估指标（Single-number-evaluation-metric）"><a href="#1-3-单一数字评估指标（Single-number-evaluation-metric）" class="headerlink" title="1.3 单一数字评估指标（Single number evaluation metric）"></a>1.3 单一数字评估指标（Single number evaluation metric）</h3><h3 id="1-4-满足和优化指标（Satisficing-and-optimizing-metrics）"><a href="#1-4-满足和优化指标（Satisficing-and-optimizing-metrics）" class="headerlink" title="1.4 满足和优化指标（Satisficing and optimizing metrics）"></a>1.4 满足和优化指标（Satisficing and optimizing metrics）</h3><p>总结一下，如果你需要顾及多个指标，比如说，有一个优化指标，你想尽可能优化的，然后还有一个或多个满足指标，需要满足的，需要达到一定的门槛。现在你就有一个全自动的方法，在观察多个成本大小时，选出”最好的”那个。现在这些评估指标必须是在训练集或开发集或测试集上计算或求出来的。所以你还需要做一件事，就是设立训练集、开发集，还有测试集。</p><h3 id="1-5-训练-开发-测试集划分（Train-dev-test-distributions）"><a href="#1-5-训练-开发-测试集划分（Train-dev-test-distributions）" class="headerlink" title="1.5 训练/开发/测试集划分（Train/dev/test distributions）"></a>1.5 训练/开发/测试集划分（Train/dev/test distributions）</h3><h3 id="1-6-开发集和测试集的大小（Size-of-dev-and-test-sets）"><a href="#1-6-开发集和测试集的大小（Size-of-dev-and-test-sets）" class="headerlink" title="1.6 开发集和测试集的大小（Size of dev and test sets）"></a>1.6 开发集和测试集的大小（Size of dev and test sets）</h3><h3 id="1-7-什么时候该改变开发-测试集和指标？（When-to-change-dev-test-sets-and-metrics）"><a href="#1-7-什么时候该改变开发-测试集和指标？（When-to-change-dev-test-sets-and-metrics）" class="headerlink" title="1.7 什么时候该改变开发/测试集和指标？（When to change dev/test sets and metrics）"></a>1.7 什么时候该改变开发/测试集和指标？（When to change dev/test sets and metrics）</h3><p>所以方针是，如果你在指标上表现很好，在当前开发集或者开发集和测试集分布中表现很好，但你的实际应用程序，你真正关注的地方表现不好，那么就需要修改指标或者你的开发测试集。换句话说，如果你发现你的开发测试集都是这些高质量图像，但在开发测试集上做的评估无法预测你的应用实际的表现。因为你的应用处理的是低质量图像，那么就应该改变你的开发测试集，让你的数据更能反映你实际需要处理好的数据。</p><p>但总体方针就是，如果你当前的指标和当前用来评估的数据和你真正关心必须做好的事情关系不大，那就应该更改你的指标或者你的开发测试集，让它们能更够好地反映你的算法需要处理好的数据。</p><h3 id="1-8-为什么是人的表现？（Why-human-level-performance-）"><a href="#1-8-为什么是人的表现？（Why-human-level-performance-）" class="headerlink" title="1.8 为什么是人的表现？（Why human-level performance?）"></a>1.8 为什么是人的表现？（Why human-level performance?）</h3><h3 id="1-9-可避免偏差（Avoidable-bias）"><a href="#1-9-可避免偏差（Avoidable-bias）" class="headerlink" title="1.9 可避免偏差（Avoidable bias）"></a>1.9 可避免偏差（Avoidable bias）</h3><p>这个差值，贝叶斯错误率或者对贝叶斯错误率的估计和训练错误率之间的差值称为可避免偏差，你可能希望一直提高训练集表现，直到你接近贝叶斯错误率，但实际上你也不希望做到比贝叶斯错误率更好，这理论上是不可能超过贝叶斯错误率的，除非过拟合。而这个训练错误率和开发错误率之前的差值，就大概说明你的算法在方差问题上还有多少改善空间。</p><h3 id="1-10-理解人的表现（Understanding-human-level-performance）"><a href="#1-10-理解人的表现（Understanding-human-level-performance）" class="headerlink" title="1.10 理解人的表现（Understanding human-level performance）"></a>1.10 理解人的表现（Understanding human-level performance）</h3><h3 id="1-11-超过人的表现（Surpassing-human-level-performance）"><a href="#1-11-超过人的表现（Surpassing-human-level-performance）" class="headerlink" title="1.11 超过人的表现（Surpassing human- level performance）"></a>1.11 超过人的表现（Surpassing human- level performance）</h3><h3 id="1-12-改善你的模型的表现（Improving-your-model-performance）"><a href="#1-12-改善你的模型的表现（Improving-your-model-performance）" class="headerlink" title="1.12 改善你的模型的表现（Improving your model performance）"></a>1.12 改善你的模型的表现（Improving your model performance）</h3><p>所以我想要让一个监督学习算法达到实用，基本上希望或者假设你可以完成两件事情。首先，你的算法对训练集的拟合很好，这可以看成是你能做到可避免偏差很低。还有第二件事你可以做好的是，在训练集中做得很好，然后推广到开发集和测试集也很好，这就是说方差不是太大。</p><p>可以修正可避免偏差问题，比如训练更大的网络或者训练更久。还有一套独立的技巧可以用来处理方差问题，比如正则化或者收集更多训练数据。</p><p>总结一下前几段视频我们见到的步骤，如果你想提升机器学习系统的性能，我建议你们看看训练错误率和贝叶斯错误率估计值之间的距离，让你知道可避免偏差有多大。换句话说，就是你觉得还能做多好，你对训练集的优化还有多少空间。然后看看你的开发错误率和训练错误率之间的距离，就知道你的方差问题有多大。换句话说，你应该做多少努力让你的算法表现能够从训练集推广到开发集，算法是没有在开发集上训练的。</p><p>如果你想用尽一切办法减少可避免偏差，我建议试试这样的策略：比如使用规模更大的模型，这样算法在训练集上的表现会更好，或者训练更久。使用更好的优化算法，比如说加入<strong>momentum</strong>或者<strong>RMSprop</strong>，或者使用更好的算法，比如<strong>Adam</strong>。你还可以试试寻找更好的新神经网络架构，或者说更好的超参数。这些手段包罗万有，你可以改变激活函数，改变层数或者隐藏单位数，虽然你这么做可能会让模型规模变大。或者试用其他模型，其他架构，如循环神经网络和卷积神经网络。在之后的课程里我们会详细介绍的，新的神经网络架构能否更好地拟合你的训练集，有时也很难预先判断，但有时换架构可能会得到好得多的结果。</p><p>另外当你发现方差是个问题时，你可以试用很多技巧，包括以下这些：你可以收集更多数据，因为收集更多数据去训练可以帮你更好地推广到系统看不到的开发集数据。你可以尝试正则化，包括$L2$正则化，<strong>dropout</strong>正则化或者我们在之前课程中提到的数据增强。同时你也可以试用不同的神经网络架构，超参数搜索，看看能不能帮助你，找到一个更适合你的问题的神经网络架构。</p><h2 id="第二周：机器学习策略（2）-ML-Strategy-2"><a href="#第二周：机器学习策略（2）-ML-Strategy-2" class="headerlink" title="第二周：机器学习策略（2）(ML Strategy (2))"></a>第二周：机器学习策略（2）(ML Strategy (2))</h2><h3 id="2-1-进行误差分析（Carrying-out-error-analysis）"><a href="#2-1-进行误差分析（Carrying-out-error-analysis）" class="headerlink" title="2.1 进行误差分析（Carrying out error analysis）"></a>2.1 进行误差分析（Carrying out error analysis）</h3><p>总结一下，进行错误分析，你应该找一组错误样本，可能在你的开发集里或者测试集里，观察错误标记的样本，看看假阳性（<strong>false positives</strong>）和假阴性（<strong>false negatives</strong>），统计属于不同错误类型的错误数量。在这个过程中，你可能会得到启发，归纳出新的错误类型，就像我们看到的那样。如果你过了一遍错误样本，然后说，天，有这么多<strong>Instagram</strong>滤镜或<strong>Snapchat</strong>滤镜，这些滤镜干扰了我的分类器，你就可以在途中新建一个错误类型。总之，通过统计不同错误标记类型占总数的百分比，可以帮你发现哪些问题需要优先解决，或者给你构思新优化方向的灵感。在做错误分析的时候，有时你会注意到开发集里有些样本被错误标记了，这时应该怎么做呢？</p><h3 id="2-2-清除标注错误的数据（Cleaning-up-Incorrectly-labeled-data）"><a href="#2-2-清除标注错误的数据（Cleaning-up-Incorrectly-labeled-data）" class="headerlink" title="2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）"></a>2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）</h3><p>如果你还记得设立开发集的目标的话，开发集的主要目的是，你希望用它来从两个分类器$A$和$B$中选择一个。所以当你测试两个分类器$A$和$B$时，在开发集上一个有2.1%错误率，另一个有1.9%错误率，但是你不能再信任开发集了，因为它无法告诉你这个分类器是否比这个好，因为0.6%的错误率是标记出错导致的。那么现在你就有很好的理由去修正开发集里的错误标签，因为在右边这个样本中，标记出错对算法错误的整体评估标准有严重的影响。而左边的样本中，标记出错对你算法影响的百分比还是相对较小的。</p><p>现在如果你决定要去修正开发集数据，手动重新检查标签，并尝试修正一些标签，这里还有一些额外的方针和原则需要考虑。首先，我鼓励你不管用什么修正手段，都要同时作用到开发集和测试集上，我们之前讨论过为什么，开发和测试集必须来自相同的分布。开发集确定了你的目标，当你击中目标后，你希望算法能够推广到测试集上，这样你的团队能够更高效的在来自同一分布的开发集和测试集上迭代。如果你打算修正开发集上的部分数据，那么最好也对测试集做同样的修正以确保它们继续来自相同的分布。所以我们雇佣了一个人来仔细检查这些标签，但必须同时检查开发集和测试集。</p><h3 id="2-3-快速搭建你的第一个系统，并进行迭代（Build-your-first-system-quickly-then-iterate）"><a href="#2-3-快速搭建你的第一个系统，并进行迭代（Build-your-first-system-quickly-then-iterate）" class="headerlink" title="2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）"></a>2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）</h3><p>如果你想搭建全新的机器学习程序，就是快速搭好你的第一个系统，然后开始迭代。我的意思是我建议你快速设立开发集和测试集还有指标，这样就决定了你的目标所在，如果你的目标定错了，之后改也是可以的。但一定要设立某个目标，然后我建议你马上搭好一个机器学习系统原型，然后找到训练集，训练一下，看看效果，开始理解你的算法表现如何，在开发集测试集，你的评估指标上表现如何。当你建立第一个系统后，你就可以马上用到之前说的偏差方差分析</p><p>建立这个初始系统的所有意义在于，它可以是一个快速和粗糙的实现（<strong>quick and dirty implementation</strong>），你知道的，别想太多。初始系统的全部意义在于，有一个学习过的系统，有一个训练过的系统，让你确定偏差方差的范围，就可以知道下一步应该优先做什么，让你能够进行错误分析，可以观察一些错误，然后想出所有能走的方向，哪些是实际上最有希望的方向。</p><p>你的主要目标是弄出能用的系统，你的主要目标并不是发明全新的机器学习算法，这是完全不同的目标，那时你的目标应该是想出某种效果非常好的算法。</p><h3 id="2-4-使用来自不同分布的数据，进行训练和测试（Training-and-testing-on-different-distributions）"><a href="#2-4-使用来自不同分布的数据，进行训练和测试（Training-and-testing-on-different-distributions）" class="headerlink" title="2.4 使用来自不同分布的数据，进行训练和测试（Training and testing on different distributions）"></a>2.4 使用来自不同分布的数据，进行训练和测试（Training and testing on different distributions）</h3><p>将两组数据合并在一起，这样你就有21万张照片，你可以把这21万张照片随机分配到训练、开发和测试集中。</p><h3 id="2-5-数据分布不匹配时，偏差与方差的分析（Bias-and-Variance-with-mismatched-data-distributions）"><a href="#2-5-数据分布不匹配时，偏差与方差的分析（Bias-and-Variance-with-mismatched-data-distributions）" class="headerlink" title="2.5 数据分布不匹配时，偏差与方差的分析（Bias and Variance with mismatched data distributions）"></a>2.5 数据分布不匹配时，偏差与方差的分析（Bias and Variance with mismatched data distributions）</h3><p>我们继续用猫分类器为例，我们说人类在这个任务上能做到几乎完美，所以贝叶斯错误率或者说贝叶斯最优错误率，我们知道这个问题里几乎是0%。所以要进行错误率分析，你通常需要看训练误差，也要看看开发集的误差。比如说，在这个样本中，你的训练集误差是1%，你的开发集误差是10%，如果你的开发集来自和训练集一样的分布，你可能会说，这里存在很大的方差问题，你的算法不能很好的从训练集出发泛化，它处理训练集很好，但处理开发集就突然间效果很差了。</p><p>但如果你的训练数据和开发数据来自不同的分布，你就不能再放心下这个结论了。特别是，也许算法在开发集上做得不错，可能因为训练集很容易识别，因为训练集都是高分辨率图片，很清晰的图像，但开发集要难以识别得多。所以也许软件没有方差问题，这只不过反映了开发集包含更难准确分类的图片。所以这个分析的问题在于，当你看训练误差，再看开发误差，有两件事变了。首先算法只见过训练集数据，没见过开发集数据。第二，开发集数据来自不同的分布。而且因为你同时改变了两件事情，很难确认这增加的9%误差率有多少是因为算法没看到开发集中的数据导致的，这是问题方差的部分，有多少是因为开发集数据就是不一样。</p><p>为了弄清楚哪个因素影响更大，如果你完全不懂这两种影响到底是什么，别担心我们马上会再讲一遍。但为了分辨清楚两个因素的影响，定义一组新的数据是有意义的，我们称之为训练-开发集，所以这是一个新的数据子集。我们应该从训练集的分布里挖出来，但你不会用来训练你的网络。</p><p>我们说人类水平错误率是4%的话，你的训练错误率是7%，而你的训练-开发错误率是10%，而开发错误率是12%，这样你就大概知道可避免偏差有多大。因为你知道，你希望你的算法至少要在训练集上的表现接近人类。而这大概表明了方差大小，所以你从训练集泛化推广到训练-开发集时效果如何？而这告诉你数据不匹配的问题大概有多大。技术上你还可以再加入一个数字，就是测试集表现，我们写成测试集错误率，你不应该在测试集上开发，因为你不希望对测试集过拟合。但如果你看看这个，那么这里的差距就说明你对开发集过拟合的程度。所以如果开发集表现和测试集表现有很大差距，那么你可能对开发集过拟合了，所以也许你需要一个更大的开发集，对吧？要记住，你的开发集和测试集来自同一分布，所以这里存在很大差距的话。如果算法在开发集上做的很好，比测试集好得多，那么你就可能对开发集过拟合了。如果是这种情况，那么你可能要往回退一步，然后收集更多开发集数据。</p><h3 id="2-6-处理数据不匹配问题（Addressing-data-mismatch）"><a href="#2-6-处理数据不匹配问题（Addressing-data-mismatch）" class="headerlink" title="2.6 处理数据不匹配问题（Addressing data mismatch）"></a>2.6 处理数据不匹配问题（Addressing data mismatch）</h3><p>如果您的训练集来自和开发测试集不同的分布，如果错误分析显示你有一个数据不匹配的问题该怎么办？这个问题没有完全系统的解决方案，但我们可以看看一些可以尝试的事情。如果我发现有严重的数据不匹配问题，我通常会亲自做错误分析，尝试了解训练集和开发测试集的具体差异。技术上，为了避免对测试集过拟合，要做错误分析，你应该人工去看开发集而不是测试集。</p><p>通过人工数据合成，你可以快速制造更多的训练数据，就像真的在车里录的那样，那就不需要花时间实际出去收集数据，比如说在实际行驶中的车子，录下上万小时的音频。所以，如果错误分析显示你应该尝试让你的数据听起来更像在车里录的，那么人工合成那种音频，然后喂给你的机器学习算法，这样做是合理的。</p><p>我们谈到其中一种办法是人工数据合成，人工数据合成确实有效。在语音识别中。我已经看到人工数据合成显著提升了已经非常好的语音识别系统的表现，所以这是可行的。但当你使用人工数据合成时，一定要谨慎，要记住你有可能从所有可能性的空间只选了很小一部分去模拟数据。</p><h3 id="2-7-迁移学习（Transfer-learning）"><a href="#2-7-迁移学习（Transfer-learning）" class="headerlink" title="2.7 迁移学习（Transfer learning）"></a>2.7 迁移学习（Transfer learning）</h3><p>深度学习中，最强大的理念之一就是，有的时候神经网络可以从一个任务中习得知识，并将这些知识应用到另一个独立的任务中。所以例如，也许你已经训练好一个神经网络，能够识别像猫这样的对象，然后使用那些知识，或者部分习得的知识去帮助您更好地阅读x射线扫描图，这就是所谓的迁移学习。</p><p>那么迁移学习什么时候是有意义的呢？迁移学习起作用的场合是，在迁移来源问题中你有很多数据，但迁移目标问题你没有那么多数据。例如，假设图像识别任务中你有1百万个样本，所以这里数据相当多。可以学习低层次特征，可以在神经网络的前面几层学到如何识别很多有用的特征。但是对于放射科任务，也许你只有一百个样本，所以你的放射学诊断问题数据很少，也许只有100次$X$射线扫描，所以你从图像识别训练中学到的很多知识可以迁移，并且真正帮你加强放射科识别任务的性能，即使你的放射科数据很少。</p><h3 id="2-8-多任务学习（Multi-task-learning）"><a href="#2-8-多任务学习（Multi-task-learning）" class="headerlink" title="2.8 多任务学习（Multi-task learning）"></a>2.8 多任务学习（Multi-task learning）</h3><p>最后多任务学习往往在以下场合更有意义，当你可以训练一个足够大的神经网络，同时做好所有的工作，所以多任务学习的替代方法是为每个任务训练一个单独的神经网络。所以不是训练单个神经网络同时处理行人、汽车、停车标志和交通灯检测。你可以训练一个用于行人检测的神经网络，一个用于汽车检测的神经网络，一个用于停车标志检测的神经网络和一个用于交通信号灯检测的神经网络。那么研究员<strong>Rich Carona</strong>几年前发现的是什么呢？多任务学习会降低性能的唯一情况，和训练单个神经网络相比性能更低的情况就是你的神经网络还不够大。但如果你可以训练一个足够大的神经网络，那么多任务学习肯定不会或者很少会降低性能，我们都希望它可以提升性能，比单独训练神经网络来单独完成各个任务性能要更好。</p><h3 id="2-9-什么是端到端的深度学习-（What-is-end-to-end-deep-learning-）"><a href="#2-9-什么是端到端的深度学习-（What-is-end-to-end-deep-learning-）" class="headerlink" title="2.9 什么是端到端的深度学习?（What is end-to-end deep learning?）"></a>2.9 什么是端到端的深度学习?（What is end-to-end deep learning?）</h3><p>研究人员发现，比起一步到位，一步学习，把这个问题分解成两个更简单的步骤。首先，是弄清楚脸在哪里。第二步是看着脸，弄清楚这是谁。这第二种方法让学习算法，或者说两个学习算法分别解决两个更简单的任务，并在整体上得到更好的表现。</p><p>为什么两步法更好呢？实际上有两个原因。一是，你解决的两个问题，每个问题实际上要简单得多。但第二，两个子任务的训练数据都很多。具体来说，有很多数据可以用于人脸识别训练，对于这里的任务1来说，任务就是观察一张图，找出人脸所在的位置，把人脸图像框出来，所以有很多数据，有很多标签数据$(x,y)$，其中$x$是图片，$y$是表示人脸的位置，你可以建立一个神经网络，可以很好地处理任务1。然后任务2，也有很多数据可用，今天，业界领先的公司拥有，比如说数百万张人脸照片，所以输入一张裁剪得很紧凑的照片，比如这张红色照片，下面这个，今天业界领先的人脸识别团队有至少数亿的图像，他们可以用来观察两张图片，并试图判断照片里人的身份，确定是否同一个人，所以任务2还有很多数据。相比之下，如果你想一步到位，这样$(x,y)$的数据对就少得多，其中$x$是门禁系统拍摄的图像，$y$是那人的身份，因为你没有足够多的数据去解决这个端到端学习问题，但你却有足够多的数据来解决子问题1和子问题2。</p><p>实际上，把这个分成两个子问题，比纯粹的端到端深度学习方法，达到更好的表现。不过如果你有足够多的数据来做端到端学习，也许端到端方法效果更好。但在今天的实践中，并不是最好的方法。</p><h3 id="2-10-是否要使用端到端的深度学习-（Whether-to-use-end-to-end-learning-）"><a href="#2-10-是否要使用端到端的深度学习-（Whether-to-use-end-to-end-learning-）" class="headerlink" title="2.10 是否要使用端到端的深度学习?（Whether to use end-to-end learning?）"></a>2.10 是否要使用端到端的深度学习?（Whether to use end-to-end learning?）</h3><p>这里是应用端到端学习的一些好处，首先端到端学习真的只是让数据说话。所以如果你有足够多的$(x,y)$数据，那么不管从$x$到$y$最适合的函数映射是什么，如果你训练一个足够大的神经网络，希望这个神经网络能自己搞清楚，而使用纯机器学习方法，直接从$x$到$y$输入去训练的神经网络，可能更能够捕获数据中的任何统计信息，而不是被迫引入人类的成见。</p><p>端到端深度学习的第二个好处就是这样，所需手工设计的组件更少，所以这也许能够简化你的设计工作流程，你不需要花太多时间去手工设计功能，手工设计这些中间表示方式。</p><p>那么缺点呢？这里有一些缺点，首先，它可能需要大量的数据。要直接学到这个$x$到$y$的映射，你可能需要大量$(x,y)$数据。我们在以前的视频里看过一个例子，其中你可以收集大量子任务数据，比如人脸识别，我们可以收集很多数据用来分辨图像中的人脸，当你找到一张脸后，也可以找得到很多人脸识别数据。但是对于整个端到端任务，可能只有更少的数据可用。所以$x$这是端到端学习的输入端，$y$是输出端，所以你需要很多这样的$(x,y)$数据，在输入端和输出端都有数据，这样可以训练这些系统。这就是为什么我们称之为端到端学习，因为你直接学习出从系统的一端到系统的另一端。</p><p>另一个缺点是，它排除了可能有用的手工设计组件。机器学习研究人员一般都很鄙视手工设计的东西，但如果你没有很多数据，你的学习算法就没办法从很小的训练集数据中获得洞察力。所以手工设计组件在这种情况，可能是把人类知识直接注入算法的途径，这总不是一件坏事。我觉得学习算法有两个主要的知识来源，一个是数据，另一个是你手工设计的任何东西，可能是组件，功能，或者其他东西。所以当你有大量数据时，手工设计的东西就不太重要了，但是当你没有太多的数据时，构造一个精心设计的系统，实际上可以将人类对这个问题的很多认识直接注入到问题里，进入算法里应该挺有帮助的。</p><p>如果你在构建一个新的机器学习系统，而你在尝试决定是否使用端到端深度学习，我认为关键的问题是，你有足够的数据能够直接学到从$x$映射到$y$足够复杂的函数吗？我还没有正式定义过这个词“必要复杂度（<strong>complexity needed</strong>）”。但直觉上，如果你想从$x$到$y$的数据学习出一个函数，就是看着这样的图像识别出图像中所有骨头的位置，那么也许这像是识别图中骨头这样相对简单的问题，也许系统不需要那么多数据来学会处理这个任务。或给出一张人物照片，也许在图中把人脸找出来不是什么难事，所以你也许不需要太多数据去找到人脸，或者至少你可以找到足够数据去解决这个问题。相对来说，把手的X射线照片直接映射到孩子的年龄，直接去找这种函数，直觉上似乎是更为复杂的问题。如果你用纯端到端方法，需要很多数据去学习。</p><p>所以这个例子就表明了，如果你想使用机器学习或者深度学习来学习某些单独的组件，那么当你应用监督学习时，你应该仔细选择要学习的$x$到$y$映射类型，<strong>这取决于那些任务你可以收集数据。</strong></p><blockquote><p>6.25 刚好到周五结束前三门课程，周末可以再把后续的cv的CNN模型和nlp序列模型看完，然后就可以马上自己动手实践了。其实这样看一遍只相当于是简单预习，完全谈不上学完，只有自己一边实践一边学才能真正学会。后两门才是重头，前面都是机器学习课程里曾经涉及过的或者相关的基础内容，这样复习一边前面知识一边继续前进，这个进度很舒服。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU智科大二夏季学期游戏开发</title>
      <link href="/2021/06/23/shugame/"/>
      <url>/2021/06/23/shugame/</url>
      
        <content type="html"><![CDATA[<h1 id="SHU智科大二夏季学期大作业"><a href="#SHU智科大二夏季学期大作业" class="headerlink" title="SHU智科大二夏季学期大作业"></a>SHU智科大二夏季学期大作业</h1><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1431351640&auto=1&height=66"></iframe></div><blockquote><p><strong>免费帮Wilson老师宣传一下他写的歌，开了自动播放</strong></p></blockquote><h2 id="关于课程"><a href="#关于课程" class="headerlink" title="关于课程"></a>关于课程</h2><h3 id="课程基本情况"><a href="#课程基本情况" class="headerlink" title="课程基本情况"></a>课程基本情况</h3><p>课程时间：2021.6.21~2021.7.16，共 4 周。</p><p>课程对象：以计算机工程与科学学院智能科学与技术专业 2019 级学生为主，学生共 82 人。</p><p>教学方式：课堂教学，上机实验。</p><p>指导教师：沈俊。</p><h3 id="课程目的"><a href="#课程目的" class="headerlink" title="课程目的"></a><strong>课程目的</strong></h3><p>《智能系统联合大作业》安排在夏季学期进行，是理论联系实际的重要实践性教学环节。通过课程学习</p><p>和实践，学生了解利用人工智能解决实际问题的过程。树立良好的设计方法，巩固有关深度学习的知识，加深专业知识的了解，扩大专业知识面，培养和提高发现问题、认识问题、分析问题及解决问题的能力以及表达能力和协作工作能力，为后续有关专业课程的学习奠定基础。</p><h3 id="课程内容与要求"><a href="#课程内容与要求" class="headerlink" title="课程内容与要求"></a><strong>课程内容与要求</strong></h3><p>《智能系统联合大作业》课程总共有 82 个学生，进行游戏开发理论与实践内容的学习、项目实训和比赛。最后完成大作业报告。</p><h3 id="大作业的实施安排和考核办法"><a href="#大作业的实施安排和考核办法" class="headerlink" title="大作业的实施安排和考核办法"></a><strong>大作业的实施安排和考核办法</strong></h3><p>《智能系统联合大作业》动员时间安排在 6 月 21 日上午 10：30-11：00，在计 J101 阶梯教室介绍《智能系统联合大作业》的主要目的、要求和内容。前三周的课程安排：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210623191923977.png" alt="满满四周到军训"></p><h3 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h3><h4 id="6-21"><a href="#6-21" class="headerlink" title="6.21"></a><strong>6.21</strong></h4><p>账号获取，密码：v9raYAJyL0</p><p>游戏引擎</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/1sdfa.png" alt="1s做一个游戏，还要压缩大小命名不重复图片才能上传"></p><p>视角qweasd，shift加速移动</p><p>快捷键，f查找对象，CTRL固定位置移动，布尔值（右上角蓝色图标）</p><p>Play，注意play状态下所做更改不保存</p><p>编辑栏，最上方，</p><p>物体属性</p><p>World Hierarchy，儿子跟着爸爸走</p><p>Coordinate 一个相对于爸爸一个相对于世界</p><p>Architype游戏原型库，你的背包，怪物们</p><h4 id="6-22"><a href="#6-22" class="headerlink" title="6.22"></a>6.22</h4><blockquote><p>休息一天，下午去听Intel宣讲会，后续怎么上课拿那个学分还是没说。怕是被骗了。</p></blockquote><h4 id="6-23"><a href="#6-23" class="headerlink" title="6.23"></a><strong>6.23</strong></h4><h5 id="LUA基础"><a href="#LUA基础" class="headerlink" title="LUA基础"></a>LUA基础</h5><p>举几个游戏逻辑的例子：被攻击掉血，拾取装备，获得buff等</p><blockquote><p>一句话总结：当某个情况发生时，某个对象的某个属性发生了某种<strong>变化</strong>。</p></blockquote><ul><li>找到某个对象</li></ul><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--</span><span class="token comment" spellcheck="true">--[[注释]]</span><span class="token keyword">local</span> B<span class="token operator">=</span>script<span class="token punctuation">.</span>Parent<span class="token keyword">local</span> UItext<span class="token operator">=</span> script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>SurfaceGUI<span class="token punctuation">.</span>Text<span class="token function">print</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>方法</th><th>具体代码</th><th>注意事项</th></tr></thead><tbody><tr><td>从外到内获取</td><td>local Object = world.cube</td><td>虽然在层级管理其中 World 的 W 是大写的，但是在脚本应用时，需要使用小写 w</td></tr><tr><td>从内到外获取</td><td>local Object = Script.Parent</td><td>如果物体之间没有层级关系，也可以用此方法获取。例如 Script.Parent.Parent.Sky 即可获取 Sky 节点</td></tr></tbody></table><ul><li>改变属性</li></ul><table><thead><tr><th>类型</th><th>属性例子</th><th>具体代码案例</th></tr></thead><tbody><tr><td>三维向量</td><td>Position/Size/LinearVelocity 等</td><td>节点.Position = Vector3(1,1,1)</td></tr><tr><td>二维向量</td><td>UI 组件的 Size/Pivot/Offset 等</td><td>节点.Offset = Vector2(1,1)</td></tr><tr><td>欧拉角度</td><td>Rotation</td><td>节点.Rotation = EulerDegree(1,1,1)</td></tr><tr><td>bool 开关</td><td>Visible/IsStatic/Block 等</td><td>节点.Visible = false</td></tr><tr><td>颜色</td><td>Color</td><td>节点.Color = Color(255,255,255,255)</td></tr><tr><td>String 字符串</td><td>Text</td><td>节点.Text = ‘Click Here’</td></tr><tr><td>列表枚举</td><td>HealthDisplayMode 等有下拉选项的属性</td><td>节点.HealthDisplayMode = Enum.HealthDisplayMode.Always</td></tr></tbody></table><pre class="line-numbers language-lua"><code class="language-lua">B<span class="token punctuation">.</span>Position<span class="token operator">=</span><span class="token function">Vector3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span>Rotation<span class="token operator">=</span><span class="token function">EulerDegree</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span>IsStatic <span class="token operator">=</span> <span class="token keyword">false</span>B<span class="token punctuation">.</span>Shape <span class="token operator">=</span> Enum<span class="token punctuation">.</span>ShapeType<span class="token punctuation">.</span>ConeB<span class="token punctuation">.</span>Color <span class="token operator">=</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>UIText<span class="token punctuation">.</span>Text<span class="token operator">=</span><span class="token string">'shanghaidaxue'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>检测某个情况发生</li></ul><pre class="line-numbers language-lua"><code class="language-lua"><span class="token keyword">local</span> Exp <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">if</span> Exp<span class="token operator">></span><span class="token number">100</span> <span class="token keyword">then</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"shenji"</span><span class="token punctuation">)</span><span class="token keyword">elseif</span> Exp<span class="token operator">>=</span><span class="token number">200</span> <span class="token keyword">then</span> <span class="token comment" spellcheck="true">--逻辑bug</span>    <span class="token function">print</span> <span class="token punctuation">(</span><span class="token string">"boss战斗"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token keyword">end</span><span class="token keyword">local</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token keyword">while</span> a<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">do</span>    <span class="token function">print</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>    a<span class="token operator">=</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token keyword">end</span><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token keyword">do</span>    <span class="token function">print</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">local</span> Tab <span class="token operator">=</span> <span class="token punctuation">{</span>Attack<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>Defence <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>Tab<span class="token punctuation">)</span> <span class="token keyword">do</span>    <span class="token comment" spellcheck="true">--print(k,v)</span>    <span class="token function">print</span><span class="token punctuation">(</span>k<span class="token operator">..</span><span class="token string">"is"</span><span class="token operator">..</span>v<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--function</span><span class="token keyword">function</span> <span class="token function">Double</span><span class="token punctuation">(</span>Arg1<span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Double"</span><span class="token punctuation">,</span>Arg1<span class="token punctuation">,</span><span class="token string">"="</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> Arg1 <span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">end</span><span class="token keyword">local</span> result<span class="token operator">=</span><span class="token function">Double</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--匿名函数</span><span class="token keyword">function</span> <span class="token function">testfun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span>fun<span class="token punctuation">)</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fun</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">end</span><span class="token keyword">end</span>tab<span class="token operator">=</span><span class="token punctuation">{</span>key1<span class="token operator">=</span><span class="token string">"val1"</span><span class="token punctuation">,</span>key2<span class="token operator">=</span><span class="token string">"val2"</span><span class="token punctuation">}</span><span class="token function">testfun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span>    <span class="token keyword">return</span> key<span class="token operator">..</span><span class="token string">"="</span><span class="token operator">..</span>val<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token punctuation">)</span>       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如何使用API</strong></p><pre class="line-numbers language-lua"><code class="language-lua">Obj<span class="token punctuation">.</span>OnCollisionBegin<span class="token punctuation">:</span>Connect<span class="token comment" spellcheck="true">--记录跟不上了，还是自己看文档吧</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://api.projectdavinci.com/Davinci_0.12.0.58352/index.md" target="_blank" rel="noopener">api文档</a></p><h5 id="模板地图"><a href="#模板地图" class="headerlink" title="模板地图"></a>模板地图</h5><p>一个素材库，之后会发给我们</p><h5 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h5><blockquote><p><strong>成功才是成功之母。</strong></p><p>——吴军(yyds)</p></blockquote><p>ps：《蚁》，Wilson老师写的歌，下课走的太快的可能没听到（笑）。</p><h4 id="6-24"><a href="#6-24" class="headerlink" title="6.24"></a>6.24</h4><p>老师：橙汁</p><p><strong>游戏引擎</strong></p><p>早期：只能制作单个游戏，缺点：硬编码数据，大量特例代码，逻辑耦合，可拓展性弱。</p><p>中期：mod形式开发，街机游戏</p><p>后期：商业游戏引擎（复用性）</p><p><strong>游戏工程结构</strong></p><p>DCC，digital computer creation，模型动画图片音频等。</p><p>文本资产，代码配置表等。</p><p>工程结构，场景结构icon其他文件等。</p><p><strong>游戏脚本</strong></p><p>两种脚本，数据定义语言，组件事件。运行时脚本语言。</p><p><strong>达芬奇引擎</strong></p><p>Bomberman工程解析</p><p>玩法调研：炸弹堂，平面地图，炸弹，可破坏方块，倒计时，周围玩家数据，有局的概念，缩圈</p><p>增加死亡计数</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--Player下增加了LifeWatcher</span><span class="token keyword">local</span> lifeRemain <span class="token operator">=</span> script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>lifeRemain<span class="token keyword">local</span> curLife <span class="token operator">=</span> lifeRemain<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--增加屏幕UI，左上角UI组件，加一个figure和text，双击加入视角，导入了一张外部资源图片，直接用pic替换figure，lifevalue设成Archetype，加到screenGUI</span>world<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>localPlayer<span class="token punctuation">.</span>Name <span class="token comment" spellcheck="true">--记得有点快</span><span class="token keyword">function</span> <span class="token function">ValueChangeEvent</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span>new<span class="token punctuation">)</span>    <span class="token keyword">if</span> new <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new <span class="token operator">></span> <span class="token number">3</span> <span class="token keyword">then</span>        <span class="token keyword">return</span>    <span class="token keyword">end</span>    world<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>new<span class="token keyword">end</span>    lifeRemain<span class="token punctuation">.</span>OnValueChanged<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>ValueChangeEvent<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--写错成OnValueChange</span><span class="token keyword">function</span> <span class="token function">onHit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   lifeRemain<span class="token punctuation">.</span>Value<span class="token operator">=</span>ligeRemain<span class="token punctuation">.</span>Value<span class="token operator">-</span><span class="token number">1</span><span class="token keyword">end</span>localPlayer<span class="token punctuation">.</span>OnDead<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>onHit<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--作业：</span><span class="token comment" spellcheck="true">--1、修改这个功能，使其可用</span><span class="token comment" spellcheck="true">--2、实现镜头抖动</span><span class="token comment" spellcheck="true">-- Tween：ShakeProperty()</span><span class="token comment" spellcheck="true">-- local MainCamera = world.CurrentCamera 官网了解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>达芬奇比赛报名（7.10截止，7.20开发，8.19提交）</p><p><a href="https://davinci.lilith.com/2021/" target="_blank" rel="noopener">报名链接</a></p><h4 id="6-25"><a href="#6-25" class="headerlink" title="6.25"></a>6.25</h4><h5 id="Lua语言"><a href="#Lua语言" class="headerlink" title="Lua语言"></a>Lua语言</h5><p>lua驱动c语言执行，小巧。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">-- 初始化表</span>mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">-- 指定值</span>mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"Lua"</span><span class="token comment" spellcheck="true">-- 移除引用</span>mytable <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token comment" spellcheck="true">-- lua 垃圾回收会释放内存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--数组</span>array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Lua"</span><span class="token punctuation">,</span> <span class="token string">"Tutorial"</span><span class="token punctuation">}</span><span class="token keyword">for</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">do</span>   <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--迭代器</span>array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Google"</span><span class="token punctuation">,</span> <span class="token string">"Runoob"</span><span class="token punctuation">}</span><span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token keyword">do</span>   <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--[[下面我们看看泛型 for 的执行过程：首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。第三，将迭代函数返回的值赋给变量列表。第四，如果返回的第一个值为nil循环结束，否则执行循环体。第五，回到第二步再次调用迭代函数]]</span><span class="token comment" spellcheck="true">-- 简单的 table</span>mytable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 的类型是 "</span><span class="token punctuation">,</span><span class="token function">type</span><span class="token punctuation">(</span>mytable<span class="token punctuation">)</span><span class="token punctuation">)</span>mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"Lua"</span>mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"修改前"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 1 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- alternatetable和mytable的是指同一个 table</span>alternatetable <span class="token operator">=</span> mytable<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"alternatetable 索引为 1 的元素是 "</span><span class="token punctuation">,</span> alternatetable<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> alternatetable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>alternatetable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"修改后"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 释放变量</span>alternatetable <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"alternatetable 是 "</span><span class="token punctuation">,</span> alternatetable<span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- mytable 仍然可以访问</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 索引为 wow 的元素是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">[</span><span class="token string">"wow"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>mytable <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mytable 是 "</span><span class="token punctuation">,</span> mytable<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 用途</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>table.concat (table [, sep [, start [, end]]]):</strong>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td></tr><tr><td align="left">2</td><td align="left"><strong>table.insert (table, [pos,] value):</strong>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td></tr><tr><td align="left">3</td><td align="left"><strong>table.maxn (table)</strong>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</td></tr><tr><td align="left">4</td><td align="left"><strong>table.remove (table [, pos])</strong>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td></tr><tr><td align="left">5</td><td align="left"><strong>table.sort (table [, comp])</strong>对给定的table进行升序排序。</td></tr></tbody></table><pre class="line-numbers language-lua"><code class="language-lua">table<span class="token punctuation">.</span><span class="token function">sort</span> <span class="token punctuation">(</span>table<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>i<span class="token operator">></span>b<span class="token punctuation">,</span>i     <span class="token keyword">end</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--拆包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--Modelscript,在script中调用</span><span class="token keyword">local</span> module <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">--function module:foo()</span><span class="token comment" spellcheck="true">--    print('foo in module')</span><span class="token comment" spellcheck="true">--end</span><span class="token keyword">return</span> module<span class="token comment" spellcheck="true">--Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"&lt;模块名>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--require "&lt;模块名>"</span><span class="token comment" spellcheck="true">--执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个script去require，model相当于是单例，全局唯一。</p><h5 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h5><p>本地事件系统</p><p>游戏开始玩家进入。。。反正就是游戏流程</p><p>CollisionEvent</p><p>KeyBoardEvent，Booster</p><p>ps：test下local多玩家测试</p><p>物理检测，碰撞事件，射线检测</p><p>world.OnRenderStepped:Connect(Update)，按帧数检测，fps=60，16.67ms。</p><h5 id="游戏系统和框架"><a href="#游戏系统和框架" class="headerlink" title="游戏系统和框架"></a>游戏系统和框架</h5><p>脚本间通信，require(“MyAsset/ModuleAsset”)：foo()</p><p>Global:相当于library，全局</p><h4 id="第一周作业：炸弹人2-0"><a href="#第一周作业：炸弹人2-0" class="headerlink" title="第一周作业：炸弹人2.0"></a>第一周作业：炸弹人2.0</h4><h5 id="镜头抖动"><a href="#镜头抖动" class="headerlink" title="镜头抖动"></a><strong>镜头抖动</strong></h5><p>之前那个小作业别忘了。</p><p>直接在world下的script里写。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--服务器脚本，等它几秒构建好world之后加入角色（这时才加入相机，否则会print出nil，后面函数报错，不信可以试试）</span><span class="token keyword">local</span> MainCamera <span class="token operator">=</span> world<span class="token punctuation">.</span>CurrentCamera<span class="token comment" spellcheck="true">--print(MainCamera)</span><span class="token comment" spellcheck="true">--local Obj=MainCamera</span><span class="token keyword">local</span> ObjTweener <span class="token operator">=</span> Tween<span class="token punctuation">:</span><span class="token function">ShakeProperty</span><span class="token punctuation">(</span>MainCamera<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"Distance"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">--看api文档和教程，相机有很多参数</span><span class="token comment" spellcheck="true">--构造一个值插值器</span><span class="token comment" spellcheck="true">--local Middle = ObjTweener:GetValue(5)  </span><span class="token comment" spellcheck="true">--获得插值器在一个周期中，第5秒    PropertyDictionary的取值</span>ObjTweener<span class="token punctuation">:</span><span class="token function">Play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">--播放这个动画</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>– Tween：ShakeProperty()<br>– local MainCamera = world.CurrentCamera 官网了解</p><p>看了也不会系列。。。。还是得问。。。。</p></blockquote><hr><p>Davinci编辑器为开发者提供了6种摄像机类型，不同的摄像机会以不同的视角观察游戏场景。</p><p><strong>ps:摄像机通用属性</strong></p><p>以下列表为所有类型的摄像机都拥有的属性：</p><table><thead><tr><th>属性名称</th><th>说明</th></tr></thead><tbody><tr><td>Order</td><td>数字越大的越在上层</td></tr><tr><td>Rotation</td><td>相机的旋转角度</td></tr><tr><td>ViewPortHeight</td><td>视角高度（只读）</td></tr><tr><td>ViewPortWidth</td><td>视角宽度（只读）</td></tr><tr><td>NearClip</td><td>最小视距，可视的最近距离</td></tr><tr><td>FarClip</td><td>最大视距，可视的最远距离</td></tr><tr><td>FieldofView</td><td>可视范围的角度大小</td></tr><tr><td>CameraMode</td><td>镜头的类型（总共有6种类型，下文章会细说）</td></tr><tr><td>CursorLock</td><td>是否锁定鼠标光标</td></tr><tr><td>Paues</td><td>打开后，此镜头下听到的音效将会全部停止播放</td></tr><tr><td>Volume</td><td>此镜头听到的音效大小</td></tr><tr><td>CollisionGroup</td><td>摄像机盒子的碰撞组</td></tr></tbody></table><h5 id="完成玩家生命与淘汰系统"><a href="#完成玩家生命与淘汰系统" class="headerlink" title="完成玩家生命与淘汰系统"></a><strong>完成玩家生命与淘汰系统</strong></h5><p>Player加一个lifeRemain的intvalue，初始值设为3。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210627205820.png" alt></p><p>world下建立一个LifeBoard的文件夹，放一个screenUI，先命名为P4,在P4下再加一张底图，底图下加两个Text，一个叫name1放名字，一个叫life接收生命值lifeRemain。最后改Player的script。</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--Player的script下，只能改变自己的lifeboard，别人的还要多人测试，这个P4就有点难办，不懂玩家加入的原理，没想法，先留着</span><span class="token keyword">local</span> lifeRemain <span class="token operator">=</span> script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>lifeRemain<span class="token keyword">local</span> curLife <span class="token operator">=</span> lifeRemain<span class="token punctuation">.</span>Valueworld<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>Image<span class="token punctuation">.</span>name1<span class="token punctuation">.</span>Text<span class="token operator">=</span>localPlayer<span class="token punctuation">.</span>Nameworld<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>Image<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>curLife<span class="token keyword">function</span> <span class="token function">ValueChangeEvent</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span>new<span class="token punctuation">)</span>    <span class="token keyword">if</span> new <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new <span class="token operator">></span> <span class="token number">3</span> <span class="token keyword">then</span>        <span class="token comment" spellcheck="true">--localPlayer.bombRemain.Value=-1</span>        <span class="token comment" spellcheck="true">--不知道怎么设计淘汰，设定炸弹数为负，三条命死完，进入观战模式，不能放炸弹</span>        <span class="token keyword">return</span>    <span class="token keyword">end</span>    world<span class="token punctuation">.</span>LifeBoard<span class="token punctuation">.</span>P4<span class="token punctuation">.</span>Image<span class="token punctuation">.</span>life<span class="token punctuation">.</span>Text<span class="token operator">=</span>new<span class="token keyword">end</span>    <span class="token function">print</span><span class="token punctuation">(</span>lifeRemain<span class="token punctuation">.</span>Value<span class="token punctuation">)</span>lifeRemain<span class="token punctuation">.</span>OnValueChanged<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>ValueChangeEvent<span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">onHit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   lifeRemain<span class="token punctuation">.</span>Value<span class="token operator">=</span>lifeRemain<span class="token punctuation">.</span>Value<span class="token operator">-</span><span class="token number">1</span><span class="token keyword">end</span>localPlayer<span class="token punctuation">.</span>OnDead<span class="token punctuation">:</span><span class="token function">Connect</span><span class="token punctuation">(</span>onHit<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决玩家重复扔炸弹的问题"><a href="#解决玩家重复扔炸弹的问题" class="headerlink" title="解决玩家重复扔炸弹的问题"></a><strong>解决玩家重复扔炸弹的问题</strong></h5><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--LocalScript</span><span class="token keyword">function</span> <span class="token function">PressFire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">--设置一个叫bombRemain的value值限制player放炸弹数目</span>    <span class="token keyword">local</span> Bomb_num<span class="token operator">=</span>script<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>Parent<span class="token punctuation">.</span>bombRemain    <span class="token comment" spellcheck="true">--print (Bomb_num)</span>    <span class="token keyword">if</span> Bomb_num<span class="token punctuation">.</span>Value <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">then</span>        <span class="token function">DropBomb</span><span class="token punctuation">(</span>localPlayer<span class="token punctuation">.</span>Position<span class="token punctuation">)</span>        Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">=</span>Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">-</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">--print (Bomb_num.Value)</span>        <span class="token keyword">if</span> Bomb_num<span class="token punctuation">.</span>Value <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">=</span>Bomb_num<span class="token punctuation">.</span>Value<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true">--强行等3s后恢复</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--4:玩家不能无限放炸弹,所以要限制一下DropBomb函数的调用</span><span class="token comment" spellcheck="true">--放炸弹还要检测是否那个位置已经有炸弹了，但是不知道根据位置检测对象的函数是什么？</span><span class="token comment" spellcheck="true">--也许可以先往一个方向偏移一下，再往反方向Raycast检测</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://api.projectdavinci.com/Davinci_0.12.0.58352/Physics.md#luacastresult-raycast(vector3-startpos%2Cvector3-targetpos%2Cbool-debugdraw)" target="_blank" rel="noopener">Raycast API</a></p><h5 id="实现炸弹攻击距离"><a href="#实现炸弹攻击距离" class="headerlink" title="实现炸弹攻击距离"></a><strong>实现炸弹攻击距离</strong></h5><p>每个箱子增加可能掉落道具物品。</p><p>1、在Architect的Box下新建一个NodeObject，叫BoxBuff，再加一个model（cube或者胶囊体，随便什么都行），model下加一个CollisionEvent。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210627205859.png" alt></p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">---------------------------------------------------------------</span><span class="token comment" spellcheck="true">-- Collisionevent is triggered when script.Parent interact with a collision(enter, continue, leave)</span><span class="token comment" spellcheck="true">-- CollisionType : collision type</span><span class="token comment" spellcheck="true">--   Enum.CollisionEventType.Enter</span><span class="token comment" spellcheck="true">--   Enum.CollisionEventType.Leave</span><span class="token comment" spellcheck="true">-- HitObject : the other object that contact with script.Parent</span><span class="token comment" spellcheck="true">-- HitPoint : collision point </span><span class="token comment" spellcheck="true">-- HitNormal : collision normal</span><span class="token comment" spellcheck="true">---------------------------------------------------------------</span><span class="token keyword">if</span> CollisionType <span class="token operator">==</span> Enum<span class="token punctuation">.</span>CollisionEventType<span class="token punctuation">.</span>Enter <span class="token keyword">and</span> HitObject<span class="token punctuation">:</span><span class="token function">IsA</span><span class="token punctuation">(</span><span class="token string">"PlayerInstance"</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    script<span class="token punctuation">.</span>Parent<span class="token punctuation">:</span><span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token keyword">then</span>        <span class="token comment" spellcheck="true">-- 炸弹攻击距离有上限</span>        localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value<span class="token operator">=</span>localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在世界中创建folder: BoxBuff，存放待会加入的道具</p><p>3、修改木箱爆炸程序：Box-Box-Collider-BomHit</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--[BombHit]</span><span class="token comment" spellcheck="true">--加一句在同一位置创建一个buff</span><span class="token keyword">local</span> number<span class="token operator">=</span>math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 通过随机数设置是否爆道具</span><span class="token keyword">if</span> number <span class="token operator">&lt;</span><span class="token number">150</span> <span class="token keyword">then</span>     <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    <span class="token keyword">local</span> BB <span class="token operator">=</span> world<span class="token punctuation">:</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token string">"BoxBuff"</span><span class="token punctuation">,</span><span class="token string">"BoxBuff"</span><span class="token punctuation">,</span> world<span class="token punctuation">.</span>BoxBuff<span class="token punctuation">,</span> Root<span class="token punctuation">.</span>Position<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">--删除木箱</span>Root<span class="token punctuation">:</span><span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、Player下新建数值AttackDistance，初始值设成1，修改炸弹的一生，让它从人物身上获取攻击值。</p><p>在Player-Local-BomberGameGUI-DropBomb-Localscript中修改对应部分为以下：</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">--是谁放的炸弹</span><span class="token keyword">local</span> Owner <span class="token operator">=</span> BombRoot<span class="token punctuation">.</span>Owner<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--炸弹的攻击距离</span><span class="token comment" spellcheck="true">--local AttackDistance = BombRoot.AttackDistance.Value</span><span class="token keyword">local</span> AttackDistance <span class="token operator">=</span> localPlayer<span class="token punctuation">.</span>AttackDistance<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--延迟时间</span><span class="token keyword">local</span> SafetyTime <span class="token operator">=</span> BombRoot<span class="token punctuation">.</span>SafetyTime<span class="token punctuation">.</span>Value<span class="token comment" spellcheck="true">--这样炸弹攻击值就只能从人物身上获取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错：原因是world.staticspace这个节点下对象是静态的，运行时不能移动或调用函数，一般放场景用，不知道我写在box里关checkboard什么事了。反正不影响功能实现，但是还有个小问题，就是人物在吃边缘道具的时候容易跳出地图，然后就跳不回来了。。。。懒得设计属性值了，就这样吧。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Snipaste_2021-06-27_19-55-10.png" alt></p><hr><p>限制玩家扔炸弹数量，实现道具：炸弹仓扩容，炸弹和特效使用对象池优化，设计自己的技能系统（可选）</p><blockquote><p>”今天的作业哦！！！！周日前同学们发到邮箱：<a href="mailto:irislan@lilith.com" target="_blank" rel="noopener">irislan@lilith.com</a>“——莉莉丝·喵莉丝</p><p>“建议大家全部做完”——莉莉丝·雪花</p><p>烦，没时间做啊，哪个好心人能拉我一把？</p><p>哦，原来还是我自己拉自己，那没事了。</p></blockquote><h3 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h3><p><a href="https://www.projectdavinci.com/dev/1/Script" target="_blank" rel="noopener">Davici编辑器教程</a></p><p><a href="https://bbs.projectdavinci.com/" target="_blank" rel="noopener">论坛</a></p><p><a href="https://api.projectdavinci.com/Davinci_0.12.0.58352/index.md" target="_blank" rel="noopener">api文档</a></p><p><a href="https://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">LUA菜鸟教程</a></p><p><a href="https://davinci.lilith.com/2021/" target="_blank" rel="noopener">达芬奇游戏比赛报名链接</a></p><h2 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2><p>《生命3.0》，可能包含玄幻、科幻、哲学等元素。在Intel那个无聊的宣讲会上看那本《游戏改变世界》，突然来的灵感。欢迎头脑风暴。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/s29983520.jpg" alt="又是一本我高中看过的书"></p><blockquote><p><strong>“回到现在，找寻过去，拯救未来。”</strong></p></blockquote><h2 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h2><p><a href="https://www.zhihu.com/question/20957940/answer/21415083" target="_blank" rel="noopener">知乎问题：为什么越来越多的大学生沉溺于游戏？</a></p><p>推荐看一下赞同数最高2.4w的回答，这里我也截取过来了。</p><blockquote><p>作者：迷踪<br>链接：<a href="https://www.zhihu.com/question/20957940/answer/21415083" target="_blank" rel="noopener">https://www.zhihu.com/question/20957940/answer/21415083</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>因为<strong>所有游戏的设计</strong>都是<strong>冲着“人性的弱点”</strong>来的。</p><p>1、即时反馈<br>你在游戏中的任何操作，都会立马<strong>视觉化</strong>、<strong>数据化</strong>地显示出来。</p><p>不要小看每次砍怪物头上飚出的数字，不要小看出招的音效，不要小看伤血的红字和加魔的蓝字，它们都给玩家提供了最最直观即时的反馈。<br>为什么即时反馈是有效的？因为，<strong>即时反馈提供给玩家一种可控感</strong>。（有个段子说：电梯里的关门键其实根本无效，但光是这个装饰用的按键却实实在在可以增加乘客的可控感，进而产生心理上的安抚效应，不易烦躁。——感谢</p><p><a href="http://www.zhihu.com/people/eb1ad61d75938cd3023387dfb610073d" target="_blank" rel="noopener">@地铁风</a></p><p>提供的信息：美国的电梯门规定必须是那样的，见<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Placebo_button" target="_blank" rel="noopener">Placebo button</a> 但中国的大部分电梯门按钮是实际有效的。）</p><p>对比现实生活中的学习——听课并不能让你直观看到经验值增长，看书也听不到书本被砍翻的惨叫，被游戏吊高胃口的学生自然觉得无聊、没劲。</p><p>2、多重系统，多样玩法，小目标渐进<br>相信你一定有这样的体验：哎呀，今天先玩到这样吧。但只差7%就升级了，要不就想打到升级吧！啊呀，打到稀有宝石，可以镶嵌武器了，赶紧去收集一下需要的素材。好朋友上线了，约了去打副本……打完了正好零点，又有新任务！……</p><p>无穷循环。</p><p>为了将玩家牢牢栓在游戏里，游戏不止提供升级体验，还提供各种全方位多角度的玩法。总能让你找到一个10分钟左右的小目标，不断去完成它，获得完成时的成就感。一旦得到这个成就感，为了维持这种欣快的感觉，玩家又迫不及待地投入了下一个小目标。</p><p>如此算来，平均10分钟一个小高潮，学习又怎么比得过它？</p><p>3、成就感</p><ul><li>内在激励</li></ul><p>内在激励简单来说，就是一种自我能力的确认——这件事我喜欢，我做了，我克服了困难，我完成，我开心。<br>为什么简单的小游戏，比如扫雷、连连看会让人上瘾一般一盘又一盘玩下去？<br>因为它设置了<strong>恰到好处的困难让你证明你有能力破解它</strong>。感受到这种力量，你就想一再体验。（还记得刚才那个电梯按钮的例子么？对，这也是一种可控感的体现。）</p><ul><li>称号</li></ul><p>完成了某种成就就会被记录。除了网游，现在还有谁会拼命找理由就为了给你发小红花？</p><ul><li>展示</li></ul><p>可能生活中一个普通小职员在游戏里就是一呼百应的公会老大。<br>这种权力和万众仰慕的感觉也是现实生活中的“稀缺资源”。<br>举个栗子：史玉柱在《我的营销心得》中提到，《征途》在情人节推出1元的虚拟玫瑰花，最后卖了可能有5000万。为什么？因为他提供了“展示”——只要送99朵以上，就上公告。</p><p>4、协作和献身<br>俗话说：人生有四铁——一起同过窗，一起扛过枪，一起嫖过娼，一起分过赃。说的就是，<strong>当人和人一起经历过情绪的大起伏，就会产生更亲密的关系</strong>。</p><p>但大学生活能提供的供人情绪起伏的活动太少，导致同窗关系质量严重下降。取而代之的，变成“<strong>一起上过网</strong>”，在游戏里组队、团战、城战、洗白、pvp……虽然所有活动都建立在虚拟的网络游戏上，但产生的<strong>情感联系</strong>却是真实的。<br>甚至，游戏还能提供现代社会稀缺的“庄严”和“意义”感。呵呵，为自己公会牺牲过的童鞋都懂的。</p><p>一边是活色生香的鲜活情感，一边按部就班的麻木生活，大学又怎么跟剑三或者魔兽比呢？</p><p>===============================================<br>另外再补充一点：</p><p>5、简化世界，路径清晰<br>据说现代的关键词是“迷茫”，游戏的设计就是为了<strong>解除“迷茫”</strong>。</p><p>游戏体系在不断的研究和发展演进中，已经形成一套<strong>将现实生活总结简化的图谱、话语体系</strong>。<br>你要做什么，怎么做，做到后有什么结果，全部都清楚地向你敞开。只需照着地图、攻略，就能达到你所期望的目标。</p><p>往大里说，所有人都追求“<strong>对世界的理解</strong>”，而这种欲望，在游戏中能得到最大限度的满足。甚至已经反过来影响现实。<br>请看下图，这是一张微博上流传滴现实职业进阶图，or技能树。</p><p><img src="https://pic2.zhimg.com/50/4e5807a47b1ec28661baa39a13c544d8_hd.jpg?source=1940ef5c" alt></p><p>有木有突然觉得“一切尽在掌握”？^++++^</p><p>=================================<br>以上，是我的粗浅分析。</p><p>如果对这个问题有兴趣，强烈推荐一本神书！<br>《<a href="https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10828002/" target="_blank" rel="noopener">游戏改变世界 (豆瓣)</a>》</p><p><img src="https://pic4.zhimg.com/80/1103272922f636cc05c7b8c2017da578_720w.jpg?source=1940ef5c" alt="在读"></p><p>本书前言就提出：</p><blockquote><p>游戏满足了现实世界无法满足的真实人类需求，带来了现实世界提供不了的奖励，它们以现实世界做不到的方式教育我们，鼓励我们，打动我们，以现实世界实现不了的方式把我们联系在一起，我们很“饥渴”，游戏填饱了我们，对更满意工作的饥渴，对强烈族群感的饥渴以及对更有意义的人生的饥渴。</p></blockquote><p>书中的分析和例子都十分精彩，推荐阅读。</p><hr><p>本来看到</p><p><a href="http://www.zhihu.com/people/f385565c9ce9a5f852b0b6624732e69a" target="_blank" rel="noopener">@吴遇安</a></p><p>的答案，觉得已经不再需要回答了。</p><p>不过感觉对于提主提出的“心理学角度”有欠缺，斗胆补充了这篇答案。</p><p>十分感谢大家的点赞。</p><p>作为知乎新人能得到接近三位数的赞，实在是……太赞了！<del>(≧▽≦)/</del></p><p><del>下面是更新</del></p><p>一开始我读《游戏改变世界》，完全只是想了解一下游戏设计中针对人类心理机制的原理，没想到，读完后，发现这本书，其实是一本谈“如何用<strong>游戏设计中的珍贵经验</strong>来<strong>改造现实生活</strong>”的未来学著作。</p><p>也就是说，当我们分析完游戏针对“人性弱点”的设计原理后，并不是要唾弃一口“万恶的游戏”，然后就能认清它的“丑恶”面目从此幡然醒悟天天向上了。</p><p>我们应该从中学习，<strong>学习游戏设计的精神、精髓</strong>，将它应用在我们的生活、学习上，<strong>让生活、学习也借此变得让人上瘾</strong>——这才是我们做此长篇大论分析的原因所在！（下面这部分特别想写给评论中的</p><p><a href="http://www.zhihu.com/people/f31b277fa45e6b6c9b520e9d2dbf6df9" target="_blank" rel="noopener">@贺Cancy</a></p><p>童鞋，让我们一起奔向让人上瘾的学习生活吧！<del>(≧▽≦)/</del>）</p><p>书中作者举了个很有趣的栗子，我尽量用最简单的话描述一下：</p><p>作者在一次演讲中说：“要是在这场演讲中我每次冒出一个聪明设想，都能加1点智力就好了，或者至少在当众演讲方面能多加几点。哪怕我喜欢喜欢演讲，演讲本身还是一件让人精疲力竭的活动。要是能在这个时候，看到PPT上弹出一些“+1”的提示框，一定能带给我不少激励。”</p><p>几天后，作者收到了一份电子邮件。你猜上面写着什么？</p><blockquote><p>“你的一位朋友XX，承认你的一些强项，并为之+1点。具体来说，他们认可的是以下这些属性：<br>+1智力<br>+1公众演讲<br>+1启发<br>恭喜！日安。”</p></blockquote><p>原来是一位听众，受了作者的启发，在网上做了一个小程序，让每个人都可以为别人送上“+1”，还可以附上理由。你可以在网站上内建的37种不同的个人强项中选择一项或者几项“+1”，网站就会自动给对方发一封电子邮件。如果对方在网站上注册，别人赠送的分数就会累加。</p><p>看到这里我突然想到，如果腾讯把“朋友标签”改成这个“+1”系统该多么好玩？每个人都可以给自己的QQ好友打分。这样，当你听一个失恋的朋友打电话跟你哭诉1小时后，你就可以期待她会记得送你一个“爱心”的“+1”。</p><p>如此一来，在游戏之外，在现实之中，我们也可以通过游戏规则的设定和帮助来将我们的行动、成绩、效果可视化、数值化，建立即时反馈，形成一系列能满足成就感的小任务，建立联系……也就是说，能让现实变得跟游戏一样一样的！</p><p>事实上，知乎不已经成功地应用了“+1”这个系统吗？</p><p>如果没有知乎系统中提供的“+1赞同”，我想，我恐怕是无法静下心来花两三个小时梳理我对这个问题的看法，并将之系统表述出来的吧？<br>正是由于每个人点点鼠标，花时间阅读、评论，知乎才有游戏上瘾般的魔力，吸引大家来分享知识和见解，产生高质量的回答啊：）</p><p>但，我认为这还不是现实游戏化的最终形态。</p><p>还记得我一直在强调游戏提供给人“控制感”这一条吗？</p><p>是的，最终形态，就是：<strong>你来设计游戏，你来设计目标，你来设计进程、系统、称号、奖励，你来给自己发小红花，你来给自己“+1”。</strong></p><p>下面是我的一个尝试的企图，抛砖引玉一下哈：</p><p>——————</p><blockquote><p>【成为写作之神 游戏设计】</p></blockquote><blockquote><p>目标：攒够10000分，成为写作之神！</p></blockquote><blockquote><p>计分方式：</p></blockquote><blockquote><ul><li>写作书1000字5分</li><li>小说1000字5分</li><li>回答知乎问题2分</li><li>读书半个小时写笔记2分，光读书要一个小时1分</li><li>观影笔记，3分</li><li>一条原创微博1分</li><li>把最近总结的理论说给一个人听 2分</li><li>其他特殊任务，特殊计分（比如突然要写个书评、写个歌词什么的）</li><li>看电影看休闲小说要用分数来购买时间，1分半小时。</li></ul></blockquote><blockquote><p>每天基本分数是10分，达到就可以解锁成就。</p></blockquote><blockquote><p>每累计到100分，可抽奖一次，用两个骰子，抽到数字就是粉丝数，粉丝数代表地位称号。</p></blockquote><p>——————</p><p>在给自己设计游戏的时候，关键并不在于设计的系统有多完美，最关键的是，给自己另一种看待现实、掌握现实的方式。</p><p>写到这里，突然想起了一个故事：幼儿园老师发现一个小朋友在厕所门口憋着不肯进，老师很奇怪，就问小朋友怎么回事。小朋友脸涨得通红，委屈地说“在家里上完厕所，妈妈都会给我鼓掌。”老师怎么劝小朋友，都木有用，最后老师突然灵机一动说：“这里没有妈妈给你鼓掌，那你自己给自己鼓掌好吗？”小朋友一听，就高高兴兴进去了。出来后，自豪地给自己用力鼓了三下掌。</p><p>你是那个等着妈妈给你鼓掌，别人给你点赞的人呢？还是那个，学会用力给自己鼓掌的小朋友？<br>结果如何先不去管，做了就先给自己点个赞如何？</p><p>以上。<br>希望能带给大家一点启发。</p><p>=====</p><p>ps：哪怕只是改变一下词语系统，都可以让我们转换思维、调整心态——</p><p>我会告诉你，自从我们公司把去办公室请老板签字叫做“去刷boss”后，整个气氛都欢乐了很多、积极了很多吗？哈哈~</p><p>2014-1-6 修改</p><p>【增加一个课堂运用游戏化思维的案例，from《游戏化思维》p172-173，略有改写】<br>受到《魔兽世界》的启发，印第安纳大学的经济学教授爱德华·卡斯特纳瓦开始改革课程。<br>他宣布，所有来上课的学生都可以获得“经验值”，课堂陈述被称为“游戏任务”，考试被称为“打怪”，而家庭作业则变成了“锻造”。学生被分为不同的合作小组，简称“游戏公会”。</p><p>结果，这门课称为学校的明星课程，学生的出勤率和学习效果都得到了显著的提高。</p><p>学校的课程协调官员感慨道：“这门课程所包含的元素是学生们熟悉、喜爱并且更加容易接受的，它给平常的过程换上了崭新的面貌，可以说真正地做到了寓教于乐。作为教育工作者，你必须时刻提醒自己，<strong>你的学生是游戏的一代、社交媒体的一代</strong>。”</p><p>2014-7-25 修改</p><p>【2015-03-10 感谢知乎日报推荐，再补充一点】</p><p>6、随机性<br>为什么卡牌游戏风靡日本，抽卡已经变成了“氪金”？因为它运用了<strong>随机性。</strong></p><p>关于随机性的强大魔力，有个实验是这样的，具体资料恕我暂时没找到，全凭记忆写下，欢迎大家给我提供：<br>科学家给鸟一个按钮，只要它按下就能吃到饲料，而另外一只鸟得到的按钮，产生的结果是随机性的，也就是说，可能有饲料，也可能没饲料。结果，比起前者的淡定，后者完全对按钮<strong>上瘾</strong>了，不断去按按钮，甚至都不为了吃饲料。<br>仔细想想，从进化角度来说，对随机性上瘾也是符合逻辑的——对于生物延续来说，食物是非常重要的资源，一旦得到就意味着生命可以延续，因此，生命机制本身的首要命令就是要最大限度保证食物来源。随机性，就好比草原上的花豹去追羚羊，可能追得到也可能追不到，也好比猴子去果树上找果子，可能找得到也可能找不到，于是，就需要生命体付出更多努力，来确保最终获得食物。为了防止生物体太容易放弃努力，生物基因中直接刻印了对随机性的偏好，也就是上瘾机制，让生物对此乐此不疲——也成了现在游戏性中的一大杀手锏。<br>抽卡让人上瘾的原因中，隐藏着随机性这个杀手，同样的，在“开宝箱”“抽奖”“牌类”游戏中，无不隐藏着随机性的惊喜。<br>这也是游戏让人上瘾的重要原因之一。</p><p>ps：在这里推荐一下《创造力》这本书。本书中提到的创造过程中的“心流”概念，也很适合用在游戏上瘾的迷狂状态上。</p><p><img src="https://pic4.zhimg.com/50/80cf5a19223cbac41a9edd4f341cb68d_hd.jpg?source=1940ef5c" alt></p><p>下面是书中提到的“心流”状态9个特征，也回答了“创造性为什么产生愉悦”这个问题，和我上面提出的5条游戏上瘾机制基本都能对应上，也附在这里，给大家做个参考。更具体的内容，欢迎大家自主阅读：</p><ol><li>每一步都有明确的目标。</li><li>对行动有迅速的反馈。</li><li>在挑战和技巧之间有一种平衡。</li><li>行动和意识相融合。即全神贯注，意识和行动都只有一个共同目标。</li><li>摒除杂念，只有当下，使我们摆脱了在日常生活中导致压抑和焦虑的害怕。</li><li>根本不担心失败。</li><li>自我意识消失。自我通过创造这种全神贯注进而遗忘自我的活动得到扩展。</li><li>时间感被歪曲。</li><li>行为具有自身的目的。做一件事最大的报酬就是做它时获得的体验。</li></ol><p>=====这里是补充结束的分割线=====</p></blockquote><p>《游戏改变世界》这本书我去年看了两三章英文版的，后来实在没有动力看下去，这次正好可以趁这个机会快速看完中文版，对游戏进行一次自己的思考。</p><h2 id="关于开源"><a href="#关于开源" class="headerlink" title="关于开源"></a>关于开源</h2><p>关于这次学校夏季大作业我有一个大胆的开源想法。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code01装机记</title>
      <link href="/2021/06/19/code01/"/>
      <url>/2021/06/19/code01/</url>
      
        <content type="html"><![CDATA[<h2 id="Code01"><a href="#Code01" class="headerlink" title="Code01"></a>Code01</h2><h3 id="装机流程"><a href="#装机流程" class="headerlink" title="装机流程"></a>装机流程</h3><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>浏览器：Chrome，自带的Microsoft Edge</p><p>社交通信：qq，tim，wechat</p><p>办公：WPS</p><p>笔记：幕布，Typora</p><p>安全：火绒</p><p>工具：桌面日历，Snipaste截屏，</p><p>其他：百度网盘，网易云音乐</p><p>vpn：clash装上后Chrome就可以同步了</p><p>编程：Github Desktop，Docker</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>VS2019</p><p>Anaconda3：打不开…………………………………………………..</p><p>Pycharm-&gt;tensorflow1.0</p><p>Android Studio</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASC2022</title>
      <link href="/2021/06/17/asc2022/"/>
      <url>/2021/06/17/asc2022/</url>
      
        <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a><strong>资料</strong></h2><p><a href="http://www.asc-events.org/ASC20-21/Trainingcamp.php" target="_blank" rel="noopener">Trainingcamp</a></p><p><a href="http://www.asc-events.org/ASC20-21/" target="_blank" rel="noopener">报名时间9.28</a></p><p><a href="http://www.asc-events.org/" target="_blank" rel="noopener">ASC官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASC竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5月复盘</title>
      <link href="/2021/05/28/2021-5/"/>
      <url>/2021/05/28/2021-5/</url>
      
        <content type="html"><![CDATA[<h1 id="五月复盘（5-29）"><a href="#五月复盘（5-29）" class="headerlink" title="五月复盘（5.29）"></a>五月复盘（5.29）</h1><h2 id="本月关键词：书生"><a href="#本月关键词：书生" class="headerlink" title="本月关键词：书生"></a>本月关键词：书生</h2><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/61B5F56593130168941A5433E69AE478.jpg" alt="上大日出"></p><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p>“<strong>我每晚入睡，就是死去。我每日醒来，就是重生。</strong>“</p><p><strong>——甘地</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>期末复习</strong></p><p>搞了一堆报告，还有一堆没去打印，也不想再写了，没意义。</p><p>比较有意义的大概是《禅与摩托车》的读书报告和人工智能历史的PPT，但也没什么大用。</p><p>五月末尾第九周开始认真复习，第八周周末好像除了一个六级口语以外基本上就荒废了。</p><p>整理离散和信息论的笔记，矩阵代数就算了。</p><p><strong>英语</strong></p><p>15h，大概做了不到两套卷子，剩下四五套估计做不完了，下个月最后还是想搏一把，把听力听完再把阅读练手，考完期末周末花一天是啊金复习，单词第十周过完。虽然六级也挺无所谓的，真正的重心还是得放在期末考试上，学累了就看会英语阅读。</p><p><strong>其他</strong></p><p>算法：待完成，买了个acwing的基础课，什么算法都没学。</p><p>基本上乱七八糟的任务都搞了个七七八八。一些无关轻重的东西，本来是想五一搞完，结果还是拖到了月底，主要是五一也太放松了。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>主要是打球，考试练习差不多了，但是发球还是不稳，没法给别人喂球，还是得练。跑步上个月一口气跑完30km要求之后就没怎么去跑，时间大概是花在了睡懒觉上，晚上睡不着早上起不来，其他时候又很热很热不适合跑步。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>当当云电子书阅读《不可能犯罪：完美嫌疑人》2h，25w字陈研一悬疑小说</p><p>重读江南《龙与少年游》3.5h，江南老贼真的适合写随笔，他笔下的青春离他可能很远，但离我们很近。</p><p>《天阿降临》《长夜余火》7h不知道哪来的时间看小说。一本乌贼一本烟雨江南，睡不着然后听着听着有困意才睡，无任何催眠效果，可能只是大脑觉得有人说话就会分散注意力，不会想东想西，就不会思考孤独。</p><p>漫画《镖人》180话，中午午休都看这些娱乐放松的东西，然后就没时间练习英语阅读了，很困就不会想看。</p><p><strong>写作</strong></p><p>读书报告</p><p>论文翻译</p><p>这学期所有报告。</p><p>今年读书笔记完成进度：2/5。</p><p><strong>观影</strong></p><p>《唐人街探案3》一直听说，都不太想特意去看的电影，在舅舅家打发时间。</p><p>《社交网络》关于Facebook起家之路，马克·扎克伯格的成长之路。这些天才的故事，天生具有神秘的吸引力，只需要一点点艺术加工，就能成为一部好的电影。</p><p>《你丫闭嘴》b站东北话版本，下饭片，好在不收费。</p><p>《模仿游戏》关于人工智能之父艾伦图灵在军情六处破解密码，卷福有点出戏，很喜欢一句话，往往是非凡之人能够成就非凡之事。</p><p>《她Her》关于人类与人工智能之间的孤独爱情，可能有点没头没尾的美国科幻。</p><p>《扫黑：决战》想看很久但最后还是没去电影院，网上有枪版，不如不看。</p><p>6h日剧《xx导演》</p><p>b站动漫，刃牙，打斗番。</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>好像基金这个月涨了小三百，不是很关注，之前一直小亏的状态，但是亏得也不多就没管。</p><p>吃饭开销有点大。买了个200大洋的床帘，改善睡眠质量，很贵但是效果奇好。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>我发现高年级研讨课这种东西可能就是屁用没有，真正的目的只是让你多认识点同专业的同学，但是如果有一个不会调动气氛的老师，就会起不到这个效果。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>早起看日出，调整作息，下半年要做到早起，早起是对自己人生的最大浪漫。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>无，这个月本来还想看两周算法，太懒了，没有动力，所以才买个课逼自己一把。</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于读研。美赛居然可以保研加分，虽然看上去我还是要在各方面继续努力才有可能有机会，不过一开始就是准备自己考研的，所以无所谓，还是跟随自己的本心去做，考研也还是准备着。魏晓老师说本科生没必要花大力气和时间就只为了发论文，发论文实验室把结果做出来几天就写好了，但是写代码和做项目基本功对于本科生来说更重要，什么时候就应该做什么事情，我觉得说的很对。而且之后不管是找工作还是说考研，代码和算法能力都很重要，更不要说以后要自己创业的话，代码必定是绕不开的，开始的时候也只能是自己一个人苦战，所以一定要有提高全栈能力的决心，毕竟创业就是一个人内心爆发全面的战争，除了自己没人能够帮自己。在和老舅交流之后，我读研的想法也是更坚定了一些，但是有些细节的东西反而边迷茫了，思考了一个月，确定了自己之后要在国内读研，不是北京就是上海，高中清北复交的目标还是得实现一下。上水课的时候看了看北大软微和人大高瓴，但是还是不确定自己要去读专硕还是读学硕。我读研的目标还不是很清晰，各个方面的原因都会有，我只知道要为自己将来创业做铺垫，因此平台也很重要。在上海读书这几年或许已经教会了我不少东西，也许也是时候该朝着北京前进了。</p><p>第二件事，关于作息。老实说这个月都没怎么休息好，早起打卡已经一年了，但是自己的状态远不如一年前开始所期望的那样好，感觉很迷茫。晚上睡不着所以早早躺下休息思考，第二天四点起床去看学校里的日出，回想起了自己想要早起的原因，就是那种早起把控时间的感觉，为了早起晚上下课回来后也抓紧时间的感觉，这会让我觉得很充实。因为室友都是很晚睡，老张甚至有的时候两三点才睡，下午他还会睡一两个小时，所以我突发奇想跟他们同步，第一次去了a楼通宵自习室自习，才发现原来十二点的校园居然比早上5点的校园还热闹。但是我发现这种作息还是不适合我，主要是晚上休息不好，早上也起不来，或许一个人外出租房的话会好一点，不然的话还是早睡早起适合我。</p><p>第三件事，关于生活。上海租房实在太贵了，之前室友咽炎晚上咳嗽很严重，就考虑了是不是能出去租房的问题，大半夜三点还没睡着，索性爬起床来，立马打开电脑查附近的租房房价，这一点我都不得不佩服自己的行动力，看完价格我就又躺回去了。虽然网上价格不是很贵但是不确定是否真实，第二天找了一个应该是中介的人咨询，学校附近房价在1500-3000，远一点的地方有更便宜的房源，但和网上标的有出入，价格超过我的预期，顿时感觉到了生活的压力，想想自己直到目前也没有一笔可靠的收入来源就很迷茫。想想目前搬出去的话也不是很有必要，而且也不方便，大三后面考研的话可能会和同学出去合租吧，到时候再说。也有可能是我自己想多了，哪怕自己再怎么吃穿不愁，习惯还是会让我小心翼翼。这种生活压力同样也是一种动力来源吧。突然想到那个人生如书的计划可以改个名字，就先叫“SHU生”好了，暑假要加紧把demo搞出来。</p><p>第四件事，关于良知。我的理解，良质就是佛，是道，是王阳明思想中的“良知”，它是对西方传统哲学中二分对立的反思，或者叫发展。<em>良质是一种思想和陈述的特质，我们不能经由思考的方式了解它，因为要给它定义是一种僵硬而正式的思考过程，良质是无法被界定的。</em><br><em>良质不会单独与主观或客观发生关系，而是只在这两者产生关系的时候才会出现，也就是说在主观和客观交会的那一刹那。</em>“他所提倡的良质就是这里所谓的道，是所有宗教的原创力，不管是东方或是欧美，不管是过去还是现在，是一切的知识，是所有的一切。”哲学就是研究人性最深处的东西，哲学因此也令人着迷。良知就是人的本心，是良知让人能够分辨善恶，所以人性本善和人性本恶都不对，暑假是时候翻出《中国哲学简史》好好思考一下了，可以再写一篇读书笔记。</p><p>第五件事，关于行为。网易云有一个随机生成性格报告，做到了一次很好的宣传。不得不说人的行为有时候真的很神奇，比如这种明明知道是利用了人类心理漏洞的操作只要再加上从众心理以及社会效应就能赶着人往坑里跳，以后要想办法利用这一点，留待思考。</p><p>第六件事，关于计划。今年的年计划做的很粗糙，甚至可以说没怎么认真设计，于是实施起来很困难，再加上每周复盘改成了每月复盘，周期或许有点太长，后面半年改成半月一次复盘。主要是不太愿意再像大一那样花费大量时间在写作各种东西上面了，这也是一个痛点。</p><p>第七件事，关于英语。自己英语口语好像一直都不太行，看b站一个up主和外国人对话的视频，发现好像说出口也没这么难，就在网上找了个omegle 全球随机匿名聊天的网站，遇到了一个非洲老哥，比我大五六岁人也很nice，和他聊得很久，体验还不错。后来还遇到了同样想在这个网站上学口语的中国学生，好像是在国外读书，也有韩国的小姐姐，在一边打工一边准备入学。不过上面女生还是比较少的，而且我好像口语还没好到能和那些母语英语的小姐姐胡吹乱侃。不得不说，这个世界真的很大，英语可以让人见识到更大的世界。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>ASC世界大学生超级计算机竞赛，6月去找沈文枫老师，好像之前开源社区的沈扬华学长15年参加过还拿过奖？得去问问他</p><p><a href="https://zhuanlan.zhihu.com/p/74028717" target="_blank" rel="noopener">OS:mit6.828</a></p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《禅与摩托车维修艺术》</title>
      <link href="/2021/05/14/shan-yu-mo-tuo-che/"/>
      <url>/2021/05/14/shan-yu-mo-tuo-che/</url>
      
        <content type="html"><![CDATA[<h2 id="《Zen-and-the-Art-of-Motorcycle-Maintenance》"><a href="#《Zen-and-the-Art-of-Motorcycle-Maintenance》" class="headerlink" title="《Zen and the Art of Motorcycle Maintenance》"></a>《Zen and the Art of Motorcycle Maintenance》</h2><blockquote><p>罗曼<strong>·</strong>罗兰曾经说过：<strong>这个世界上只有一种真正的英雄主义，就是认识了生活的真相之后依然热爱生活。</strong></p></blockquote><p>这本小说出版于1960年代，作者罗伯特<strong>·</strong>波西格（1928-2017 Robert M. Pirsig），15岁即考入明尼苏达大学，主修化学，并对哲学产生浓厚兴趣，后前往印度学习东方哲学。回国后，在当地大学担任写作课教师。1961年，他被诊断为偏执型精神分裂症和临床忧郁症，被多次送进精神病院，备受折磨，接受过28次电击疗法。1968年出院后，他带着儿子克里斯，进行了一次长途摩托车旅行。他把旅行的感受和思考，写成了这本《禅与摩托车维修艺术》（Zen and the Art of Motorcycle Maintenance）。</p><p>它曾被《时代》周刊评选为1970年代最有影响力的十本书之一，霍金、乔布斯等人对这本书倍加推崇。</p><p>在我看来，这本书的神奇之处在于它集小说、传记、哲学于一体，将风格、氛围完全迥异的两条故事线完美地融合在一起。</p><p>读后细想，感觉父子旅行的部分写得有点像《瓦尔登湖》——本书中也多次提到这部自然主义的文学名著。他们穿过广袤的沙漠和草原，沿途的高山和湖泊、经历过雨中露营，公路上修车……在远离市嚣中寻找内心的纯净和生活的真谛。有趣的是，它对摩托车构造和维修过程的详述，像极了梭罗在瓦尔登湖边挖垄种地，对各种昆虫、种子、生长过程、田间劳作极尽详细的描述，二者有异曲同工之妙。</p><p>而斐德洛的那条线，我觉得很像《月亮与六便士》里的情节，两个主人公的遭遇何其类似，那个为了追求崇高艺术理想的画家，即使穷困潦倒，无人肯定，依旧不为所动，锲而不舍，离群索居在太平洋的一座小岛上，最后终于开悟，达到至高境界，在墙壁上留下最伟大的画作之后，结束了一生。而斐德洛所追求的“良质（quality）”也是他对世界的终极解释。</p><p>何为良质？书中花了大量的篇幅来探讨。</p><p><em>良质是一种思想和陈述的特质，我们不能经由思考的方式了解它，因为要给它定义是一种僵硬而正式的思考过程，良质是无法被界定的。</em><br><em>良质不会单独与主观或客观发生关系，而是只在这两者产生关系的时候才会出现，也就是说在主观和客观交会的那一刹那。</em></p><p>我的理解，良质就是佛，是道，是王阳明思想中的“良知”，它是对西方传统哲学中二分对立的反思，或者叫发展。</p><p>仅此而已，说实话，以我目前所学所知，以及对生活本身的思考深度，对书中关于哲学部分的理解要达到1/3都挺难的，且要建立在多次研读的基础上。好在，它是将旅行中的现实困境和哲学的思考相互关联来写的，对理解会略有帮助。</p><hr><blockquote><p>上面这段转自知乎用户【老土】的介绍，我觉得很有共鸣，而且介绍的到位，也对我对此书的理解有所帮助,下面是我的阅读笔记。</p></blockquote><hr><blockquote><p>《禅与摩托车维修艺术》：“<strong>仓促本身就是最要不得的态度。当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。</strong>”</p><p><strong>“你必须先压制住自己的看法，否则你就无法读下去，它是一个比沟里的死水还要沉闷的东西，你会读到化油器、齿轮、压缩机等等，活塞、火花塞、进气等等，如果从浪漫的角度来看就会觉得非常沉闷、丑陋而且十分笨拙，浪漫的人很少能突破这一点。”</strong></p><p><strong>当你急着奔向未来的时候，说明你已经不喜欢现在了。</strong>——《禅与摩托车维修艺术》</p></blockquote><h3 id="关于哲学"><a href="#关于哲学" class="headerlink" title="关于哲学"></a>关于哲学</h3><p><strong>禅与摩托车维修艺术22节</strong></p><p>“斐德洛一句一句地念，一行一行地念，发现它们正符合他的意思，只不过他表达得很僵化，而《道德经》中却说得非常清楚而准确，这就是他一直想说的，只是此刻却从不同的背景，用不同的语言说出来。他从另一座山谷看到这一座山谷的景象，他所说的不是陌生人所讲的故事，他本身也是山谷的一部分。<br>他所提倡的良质就是这里所谓的道，是所有宗教的原创力，不管是东方或是欧美，不管是过去还是现在，是一切的知识，是所有的一切。”</p><p>在我看来，良质就是佛，是道，是王阳明思想中的“良知”，它是对西方传统哲学中二分对立的反思，或者叫发展。</p><p>在我第一次读冯友兰先生的《中国哲学简史》时，就曾被中国古代哲学中的道家思想所吸引。“道可道，非常道。名可名，非常名。”简简单单十二字，就使斐德洛立刻明白自己要说的，要找的恰恰就在这里。[1]</p><p>从书中提到良质开始一直读到这一段《道德经》，想到了《中国哲学简史》中对“道”的阐述，我才终于恍然大悟，对于“道生一，一生二，二生三，三生万物。”有了更深刻的理解，也总算知道了原来良质早就存在于我的思想之中。</p><p>虽然我没能读完过《传习录》，但结合王阳明知行合一的思想，更加确信书中良质与“良知”有着某种联系，这不是巧合，很可能译者在翻译时也和我一样认为良知和良质其实就是同一件事，因此才作此音译。王阳明说，每个人的心中都有良知，只不过有的人的良知可能被蒙蔽了。“不虑而知为良知”恰恰与斐德洛说的良质不可定义吻合，就好像二者之间的区别其实只不过是同一事物的中文名和英文名一样，名虽不同，实则相同。</p><p>说实话，以我目前所学所知，以及对生活本身的思考深度，对书中关于哲学部分的理解要达到三分之一都挺难的，且要建立在多次研读的基础上。好在，《禅与摩托车维修艺术》是将旅行中的现实困境和哲学的思考相互关联来写的，这对我的理解有所帮助。</p><h3 id="关于科学"><a href="#关于科学" class="headerlink" title="关于科学"></a>关于科学</h3><p><strong>禅与摩托车维修艺术20节</strong></p><p>“发明者的真实工作在于选择这些组合，以便减少无用者，或者设法避免制造它们的麻烦，而指引这选择的规则是极其精致讲究的。几乎不可能精确地描述它们: 它们必须被感觉而非被陈述。……彭加列说，“潜意识自我”注视着一个问题的一大串解决方案，但是只是有趣的可以闯进意识领域内。数学解答是由潜意识自我所选择的，是基于“数学之美”，数字与形式的和谐，以及几何学的优雅。彭加列说：“这是一种所有数学家都知道的真实的美感，可是世俗者对此是如此无知以至于经常想笑。”但是这和谐、这美丽，是它整个的核心。”</p><p>我们从小开始学习数学等自然科学，随着学历的提升，我们会愈发发现数学教学方法有一定的局限性。我们从课堂上学习了各种公理、定理、定律、法则，老师也会教我们各种做题的“小技巧”，但是考试结果出来，个人分数之间的差距还是非常明显。表面上来看原因很简单：即使上了同样的课，从课本上看到了同样的知识，面对一道同样的数学题，有人稍微想一想就有“好”的思路，有人笔头咬烂也无从下手。</p><p>这种现象在数学证明中尤为明显，本书中也提到了这个问题(22节)。我们需要把一些现象“伪装”成公理，然后以此为基础证明其他定理。如果选择的公理是片面的甚至是错误的，那么以此公理得出的其他定理也会是片面甚至错误的。比如欧几里得第五公设就是片面的，得出的几何学局限在平面。当放宽第五公设的约束时，我们可以得到全新的几何学——黎曼几何学。当数学家或学生做数学证明的时候，他们面对的是无数条可行的路线，在开始时他们无法准确知道哪一条路是“好”的，哪一条路会引向死胡同。优秀的数学家和学生往往可以精准的感知出可行的道路，选择“好”的公理，找到“好”的证明路线。这种对“好”的感知，也就是感受数学之美。</p><p>良质不仅存在于理科之中，工科的发展同样也需要良质。就比如我们计算机学科，哪些算法是好的，哪些设计是好的，其实一开始都没有人知道。冯·诺依曼之前仍有其他的计算机架构，今天计算机的组成也在不断地更新换代，根据摩尔定律每隔18个月硬件存储容量就会翻一番，而今天摩尔定律正在逐渐失效。就好像所有学科一样，计算机学科自身也在不断发展，而推动它发展的真是我们书中说的良质，或者说是美感。</p><h3 id="关于旅行与读书"><a href="#关于旅行与读书" class="headerlink" title="关于旅行与读书"></a>关于旅行与读书</h3><p><strong>禅与摩托车维修艺术4节</strong></p><p>“我想你可以称之为个性，每一部摩托车都有它自己的个性，也可称之为你对这一部车子所有直觉的总和。这种个性常会改变，多会变得更糟，但常常也会变得出人意料地好，培养这种车子的个性正是维修保养的真正目的。新的车子就好像美丽的陌生人，按照他们所受的待遇，要不就很快会退化成别扭的人或是跛子，要不就变成健康、脾气好、长久的朋友，而我这部车虽然遭受过那些所谓师傅的毒手，但是似乎已经完全修复了，而且愈来愈不需要修理。”</p><pre><code>其实作者所说的摩托车就好比人生，而每个人人生中两个最重要的组成部分——旅行和读书——也都有它们独特的个性。</code></pre><p>古语云：“读万卷书不如行万里路。”换成今天的话来说就是肉体与灵魂总有一个要在路上。每一个人都有它自己的个性，每一本书也有它自己的个性，而不同的人读不同的书，就是在陪着作者进行不同的旅行。同一个人从同一本书中读出来的内容也会是常读常新的，旧的思考会被新的思考所代替，可是读者仍然会继续重温这同一本书。就好像旅人的旅行接触到了很多，也失去了很多，但还是在继续，就好像电影的结尾，经历种种，还是会背上背包，骑上摩托车。毕竟还有没有去过的地方，毕竟还有那么多耗尽一生想看也看不完的书，有些地方不一定会再回去，但还有更多想去的地方，所以能出发的时候还是要出发。这也许就是为什么波西格愿意一直不停地走，并且能够耐心维修摩托车的原因之一吧。</p><p>要我说，书上文章是案头之山水，天下山水是地上之文章，都可以快人眼目，陶冶情操，尤其后者，白看不收钱，不看白不看。</p><h3 id="关于何为良质"><a href="#关于何为良质" class="headerlink" title="关于何为良质"></a>关于何为良质</h3><p>何为良质？我认为这是书中最重要的一个问题，而且书中也花了大量的篇幅来探讨。</p><p>“良质是一种思想和陈述的特质，我们不能经由思考的方式了解它，因为下定义是一种严格而规范的思考过程，所以良质无法被定义。”[6]</p><p>这是作者给出的回答，每位不同背景，不同文化，使用不同语言的读者可能都会得到不同的答案，然而这正是良质存在的意义，对于我而言，良质是存在于万物之中的“道”，也是存在于人心中的“良知”，除此之外，无法用更多的言语去给良质下定义。</p><p>可以这么说，良质就是良知，是是非之心，是每个人先天的判断力和道德感。它包含良心，又不止于良心。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这本小说出版于1960年代，作者罗伯特·波西格（1928-2017 Robert M. Pirsig），15岁即考入明尼苏达大学，主修化学，并对哲学产生浓厚兴趣，后前往印度学习东方哲学。回国后，在当地大学担任写作课教师。1961年，他被诊断为偏执型精神分裂症和临床忧郁症，被多次送进精神病院，备受折磨，接受过28次电击疗法。1968年出院后，他带着儿子克里斯，进行了一次长途摩托车旅行。他把旅行的感受和思考，写成了这本《禅与摩托车维修艺术》（Zen and the Art of Motorcycle Maintenance）。</p><p>它曾被《时代》周刊评选为1970年代最有影响力的十本书之一，霍金、乔布斯等人对这本书倍加推崇。</p><p>在我看来，这本书的神奇之处在于它集小说、传记、哲学于一体，将两条不同的故事线完美地融合在一起。</p><p>读后细想，感觉父子旅行的部分写得有点像《瓦尔登湖》——本书中也多次提到这部自然主义的文学名著。他们穿过广袤的沙漠和草原，沿途的高山和湖泊、经历过雨中露营，公路上修车……在远离城市喧嚣中寻找内心的纯净和生活的真谛。有趣的是，它对摩托车构造和维修过程的详述，像极了梭罗在瓦尔登湖边种地，对各种昆虫、种子、生长过程、田间劳作极尽详细的描述，二者有异曲同工之妙。</p><p>而斐德洛的那条线，我觉得很像《月亮与六便士》里的情节，两个主人公的遭遇何其类似，那个为了追求崇高艺术理想的画家，即使穷困潦倒，无人肯定，依旧不为所动，锲而不舍，离群索居在太平洋的一座小岛上，最后终于开悟，达到至高境界，在墙壁上留下最伟大的画作之后，结束了一生。而斐德洛所追求的“良质（quality）”也是他对世界的终极解释。</p><hr><p><strong>参考文献：</strong>（宋体加粗小四）</p><p>顺序要根据引用先后顺序排列，序码用[1][2]。格式如：</p><p>[1] 冯友兰.《中国哲学简史》[M]. 北京: 北京大学出版社，2010:1-209</p><p>[2] 吕峥. 《明朝一哥王阳明》[M]. 北京：中国友谊出版公司，2020：156-189</p><p>[3] 罗伯特·M·波西格. 《万里任禅游》[M]. 重庆: 重庆出版社，2006: 146</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《穷查理宝典》</title>
      <link href="/2021/05/05/poorchalie/"/>
      <url>/2021/05/05/poorchalie/</url>
      
        <content type="html"><![CDATA[<h2 id="《Poor-Charlie’s-Almanack》"><a href="#《Poor-Charlie’s-Almanack》" class="headerlink" title="《Poor Charlie’s Almanack》"></a>《Poor Charlie’s Almanack》</h2><p>![](C:/Users/ASUS/Documents/Tencent Files/849095098/Image/C2C/CCC959C92434111CDA1F65DBFB4BF837.jpg)</p><p>我第一次听说查理·芒格是在巴菲特的传记《滚雪球》里，于是两个年轻人就像命中注定一样相见，此后便开启了一段传奇。</p><p>最初，两人只是互相分享好的投资机会，直到蓝筹印花公司的投资奠定了二人的合作基础。这是一家经营折扣优惠券的公司，当时该公司已经过了发展黄金期，再加上管理层的保守，所以股价很低，而且由于公司内部改组导致当时的股东不能完全的控制公司。芒格关注到了蓝筹印花公司账面上充沛的现金，便推荐巴菲特极力关注该公司。后来，他们买入了大量的股票，直接进入了蓝筹印花公司的董事会，并开始为公司的浮存金寻找优良的投资渠道，开展了一系列投资并购。最终，他们大获成功，不仅赚到了不菲的收益而且逐步建立起了正向的现金循环。</p><p>如果说巴菲特像一团火，疾驰着卷席一切他所能得到的资源，那芒格就平静的像一汪水，无声无息，但一旦奔腾起来，就是无可阻挡的山洪。</p><p>而且就像巴菲特说的那样，芒格是个聪明人，透过《穷查理宝典》我也得以窥见他的智慧和思考。</p><p>特别是他谈到了多元思维模型的一章，话轻描淡的一句话都是一本书的内容。</p><p>举一个书中的例子：“如果你们懂得基本的心理学原理，就能理解人们做不到这一点的原因，其实很简单：大脑的神经系统是经过长期的基因和文化进化而来的。它并不是费马—帕斯卡的系统。”</p><p>看完这句话很有可能一头雾水，因为你还需要自行去理解心理学原理、大脑的神经系统、费马帕斯卡系统等。</p><p>这句话提及的3个原理，你都能找到相关的书籍去进行进一步理解。</p><p>这大概也是很多人看了这本书之后会觉得，看不懂说什么，也不看懂他的厉害之处。但就是莫名觉得很厉害的样子。</p><p>再举一个类似的例子就是《富爸爸穷爸爸》这本书，想要掌握这本书的精髓，必须要额外花时间理解会计、投资、法律、营销。</p><p>但是这些知识属于这本书的拓展，你不去补充，读这本书实际用途几乎不大，只能停留在思维上的一些改变，虽然这对第一次接触理财的我来说意义同样重大。</p><p>还有一处，书中写到：“巴菲特拥有许多优势，其中之一就是他能够自动地根据决策树理论和基本的排列组合原理来思考问题。而且它也并不难理解。”</p><p>但你必须对会计有足够的理解，才能明白它的局限——因为会计虽然是起点，但它只是一种粗略的估算。<br>而且其中还谈到了决策树理论、排列组合原理、会计等日常可能不太会接触到的知识面。</p><p>以上两句话信息量已经很大了，更可怕的是，这本书是由11个演讲集合而成，这也只是当中一讲的一小部分而已。</p><p>这本书更有说服力的地方在于，作者本人已经96岁了，而且特别有钱，他没有夹杂任何私人利益在书中，纯粹地把毕生所学分享出来而已，我们这个时代，又老又有钱又有智慧又低调的人，真心不多。</p><p>顺便一提，查理芒格本人掌握了100多种思维模型，书中提到了十多个比较重要的。</p><p>在具体谈思维模型之前，我觉得更加重要的是，要学会运用在生活中，直到发生某件事情后，脑海中能够瞬间想到这些思维模型，并加以运用，这样才会有用。</p><p>很多思维模型或多或少，我们从小的教育，或者经验的总结都顺便用过，但会比较模糊，造成你用起来不够快，还有信心不足。</p><p>比如物理学的临界质量概念。高中物理3-5的课本里我们就已经学过这个概念了，只是当时是为了应付高考，从没有想过还能用在生活中的哪些地方。</p><p>某些事物的改变并不是慢慢改变的，而是一旦达到一个临界点，他就会发生质变，就像是水到100度才会变成水蒸气一样。</p><p>这个理论有点像“一万小时定律”，一般人想要改变自己在某一方面取得成功，起码需要1万个小时的时间去训练。</p><p>生活中很多例子都是如此，例如学英语，前期学了很长时间都改变不大，但突然有一天就突然开窍了，对英语的掌握能力大大提升。</p><p>原本每天写作特别困难，我大一的时候就坚持一个月早起写作，想到什么写什么，突然有段日子发现，写作变得非常容易，一上来就起码能写个上千字，老师布置的小论文都是几个早上或者一个下午就能搞定，而且写作还成为了我思考的工具，通过写的方式，不断把学到的内容进行深入理解。</p><p>李笑来《把时间当作朋友》中也提出类似的概念「七年就是一辈子」，我们在7年中不断对一件事情持续努力，往往会有比较惊人的成绩。</p><p>这个理论和有一句话特别相似：人总是高估自己一年能做的事情，低估10年能做的事情。</p><p>我们一定要坚持做好一件事情，等待跳跃性的改变到来。</p><p>仔细想想我和芒格有着不少的共同爱好，或者说我向他学习到了不少东西，比如我们都是个人传记爱好者。从高中开始我就喜欢上了各种形形色色的人物传记。</p><p>比如我的精神导师和查理·芒格的偶像一样都是本杰明.富兰克林，我也是因为读过《富兰克林自传》所以才崇拜富兰克林并把他当为自己的精神楷模的。</p><p>而他不仅钦佩与崇拜这位伟大的人物，并且还以富兰克林为人生的标杆来指导自己的行为。富兰克林的职业生涯横跨多个领域，主张思考不同学科之间的联系以培养思维方式。查理·芒格也认为，投资者应该糅合来自各个传统学科的分析工具、方法公式，这些学科包括：历史、心理、生理、数学、工程、生物、物理、化学、统计、经济等。其理论基础是：几乎每个系统都受到多种因素的影响，所以若要理解这样的系统，就必须熟练地运用来自不同学科的多元思维方式，这样才能激发出lollapalooza。</p><p>关于查理·芒格我能写的实在太多太多，甚至根本停不下来，但是可以用查理最经典的一句话来总结——“我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的——没有，一个都没有。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。”</p><p>查理把大量时间都花费在了心无旁骛的阅读上，这大概就是查理卓越思维能力的来源，这也正是我从书中学到的最重要的一点。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4月复盘</title>
      <link href="/2021/04/30/2021-4/"/>
      <url>/2021/04/30/2021-4/</url>
      
        <content type="html"><![CDATA[<h1 id="四月复盘（4-30）"><a href="#四月复盘（4-30）" class="headerlink" title="四月复盘（4.30）"></a>四月复盘（4.30）</h1><h2 id="本月关键词：时间赛跑"><a href="#本月关键词：时间赛跑" class="headerlink" title="本月关键词：时间赛跑"></a>本月关键词：时间赛跑</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>我要和生活再死磕几年。</strong><br><strong>要么我就毁灭，要么我就注定铸就辉煌。</strong><br><strong>如果有一天，你发现我在平庸面前低了头，</strong><br><strong>请向我开炮。</strong><br>——凯鲁亚克《在路上》</p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>学习</strong></p><ul><li>英语</li></ul><p>大英赛C组初赛</p><p>备考六级：翻译20+，听力*6，作文还没开始，cloze有点难，阅读刷完无压力，四套真题，小阅读不能着急，时间够阅读没问题，听力认真看一遍能降低错误率，现在大概是在错4个左右。</p><p>下个月翻译要计时。真题阅读好好做，还剩四十天，再过三周考口语。</p><ul><li>数学</li></ul><p>复习线性代数，如果开卷考试的话矩阵也不难。信息论学得都能题目还得自己做一遍，反正好玩。</p><ul><li>CS</li></ul><p><a href="https://henryavery.cn/2021/04/17/docker2021/">Docker</a></p><p>wechaty聊天机器人，搞半天，认识到读文档的重要性，以及搞清一些基础原理才能实现代码跑起来，否则就是抓瞎。</p><p>错过了一次蓝桥杯，300块没时间准备，觉得这些比赛都好贵</p><p><strong>比赛</strong></p><p>美赛F奖</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7TZ3TR7S%5DNYLXM1O~~LGQ%0.png" alt="lucky"></p><p>美赛复盘还没写。。。。</p><p><strong>项目</strong></p><p>ocr文本抽取标题，大数据project。</p><p>创新创业项目无进展。找到一篇naacl2021相关的论文。逻辑推理问题模型。</p><p>标了十多个小时数据，一个周末直接没了，本来的计划冗余全用在这里了。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>40+km</p><p>考虑是不是能参加一次半马。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>《禅与摩托车维修艺术》读书报告待上传</p><p>《韦尔奇自传》英文版，50/557</p><p><strong>电影</strong></p><p>《超脱》一部国外关于老师的电影。男演员还演过《钢琴师》。</p><p>《流浪猫鲍勃》关于人的自救，人和猫的温馨故事。</p><p>《窃听风暴》完全没看懂。</p><p>《除暴》想看的，比较下饭。</p><p>一周一部电影，还算比较合适了。</p><p><strong>写作</strong></p><p>人工智能与认知科学1956-1970简史ppt</p><p>人工智能研讨ppt</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>基金不亏了，虽然没什么用。先存着，打算暑假换设备了。</p><p>投资150买衣服，150买书。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>每两周出去开一次小灶。</p><p>搜集出国留学以及读研相关信息。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2021-4.jpg" alt="2021-4"></p><p>每天睡7个小时ok，有三分之一赖床不应该。娱乐可以尝试缩减到15h，每天四小时的日常过久，午休正常，时间控制在20-30min。</p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>Docker学习</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于荣誉。</p><p>第二件事，关于攒劲。</p><p>第三件事，关于跑步。</p><p>第四件事，关于准备。</p><p>第五件事，关于选择。</p><p>第六件事，关于放假。</p><p>第七件事，关于拖拉。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p>神经网络学习</p><p>算法学习</p><p>Flutter学习</p><p>把积压一大堆杂七杂八的作业消掉。</p><p><strong>作业</strong></p><p>数据结构：小组项目三，hash查找 </p><p><strong>ppt</strong></p><p><del>人工智能进展nlp研讨ppt</del></p><p>数据结构PPT</p><p><strong>项目报告Project</strong></p><p>大数据20p</p><p><strong>论文paper</strong></p><p><del>大数据10p</del></p><p><strong>阅读报告</strong></p><p><del>《穷查理》2k</del></p><p>《禅与摩托车维修艺术》3k</p><p><strong>调研报告</strong></p><p>投资与理财调查报告</p><p>思修实践</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker2021</title>
      <link href="/2021/04/17/docker2021/"/>
      <url>/2021/04/17/docker2021/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要学习Docker"><a href="#为什么要学习Docker" class="headerlink" title="为什么要学习Docker?"></a>为什么要学习Docker?</h2><p>为了解决环境配置问题</p><h2 id="怎样学习使用Docker"><a href="#怎样学习使用Docker" class="headerlink" title="怎样学习使用Docker?"></a>怎样学习使用Docker?</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网安装</a></p><p>Docker CE 的安装请参考官方文档。<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows版本</a></p><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><blockquote><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><p>——阮一峰</p></blockquote><p>就跟git一样，是为了方便我们程序员的powerful tools 之一。</p><hr><h2 id="Datawhale的组队学Docker"><a href="#Datawhale的组队学Docker" class="headerlink" title="Datawhale的组队学Docker"></a>Datawhale的组队学Docker</h2><h3 id="启航"><a href="#启航" class="headerlink" title="启航"></a>启航</h3><blockquote><p>通过本次docker的组队学习，我们希望你能学到以下几个方面的能力：</p></blockquote><ul><li>了解什么是docker</li><li>docker镜像是怎么构建的</li><li>如何运行一个docker容器</li><li>docker之间的网络通信是怎么样的</li><li>docker中的数据如何做持久化存储</li><li>如何通过docker compose管理自己的项目</li><li>如何将自己的个人项目打造成容器化部署的形式</li></ul><h3 id="简介与安装"><a href="#简介与安装" class="headerlink" title="简介与安装"></a>简介与安装</h3><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言 (opens new window)</a>进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup (opens new window)</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace (opens new window)</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">OverlayFS (opens new window)</a>类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS (opens new window)</a>等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术 (opens new window)</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC (opens new window)</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer (opens new window)</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC (opens new window)</a>和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd (opens new window)</a>。</p><p>比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><strong>虚拟机</strong>在宿主机(host)中的OS上面是hypervisor(hypervisor)，然后依次建立虚拟机，虚拟化的仓库，然后安装程序。但是对于<strong>Docker</strong>来说，在宿主机(host)中的OS上面是Docker Engine，然后直接在Doker Engine安装应用。</p><h3 id="Docker三大基本概念"><a href="#Docker三大基本概念" class="headerlink" title="Docker三大基本概念"></a>Docker三大基本概念</h3><ul><li><p><strong>镜像</strong>（<code>Image</code>）</p></li><li><p><strong>容器</strong>（<code>Container</code>）</p></li><li><p><strong>仓库</strong>（<code>Repository</code>）</p></li></ul><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h5 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h5><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS (opens new window)</a>的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的<strong>实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是<strong>进程</strong>，但与直接在宿主host执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间 (opens new window)</a>。</p><blockquote><p><strong>名称空间</strong>是<a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="noopener">Linux 内核</a>的一个特征，它划分了内核资源，使一组<a href="https://en.wikipedia.org/wiki/Process_(computing)" target="_blank" rel="noopener">过程</a>看到一组资源，而另一组进程看到一组不同的资源。该功能的工作原理是为一组资源和流程设置相同的命名空间，但这些命名空间是指不同的资源。资源可能存在于多个空间中。此类资源示例包括流程 ID、主机名、用户 ID、文件名称以及与网络访问相关的一些名称以及<a href="https://en.wikipedia.org/wiki/Interprocess_communication" target="_blank" rel="noopener">处理间通信</a>。</p></blockquote><p>因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://vuepress.mirror.docker-practice.com/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者 <a href="https://vuepress.mirror.docker-practice.com/data_management/bind-mounts.html" target="_blank" rel="noopener">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h4 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://vuepress.mirror.docker-practice.com/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h5 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h5><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器 (opens new window)</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器 (opens new window)</a>等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://vuepress.mirror.docker-practice.com/install/mirror.html" target="_blank" rel="noopener">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务 (opens new window)</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场 (opens new window)</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云镜像库 (opens new window)</a>等。</p><h5 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h5><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry (opens new window)</a>镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://vuepress.mirror.docker-practice.com/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><blockquote><p>开始学习前，我C盘已经不够10个G了，不知道能不能撑住。所以……</p><p>虚拟机的默认存储位置是C:\Users\Administrator.docker\machine\machines ，后期docke镜像文件会不断增加，为了给系统盘减负，最好将磁盘移动到其他位置。</p><p>ps:不想开虚拟机所以就在Windows上折腾了，能hello-world很开心</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210414201843575.png" alt="hello"></p><h4 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p><strong>获取镜像</strong></p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到</p><p>比如：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker pull ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>列出镜像</strong></p><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><p><strong>删除本地镜像</strong></p><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker image rm [选项] <镜像1> [<镜像2> ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Untagged 和 Deleted</strong></p><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210414202719907.png" alt="我这就是"></p><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><pre><code>$ docker image rm $(docker image ls -q redis)</code></pre><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><pre><code>$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></pre><blockquote><p>然而我并没有用Linux，而且也没看懂Linux命令</p></blockquote><p><strong>Dockerfile制作镜像</strong></p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><pre><code>$ mkdir mynginx$ cd mynginx$ touch Dockerfile</code></pre><blockquote><p>我打开了vm打算装个乌班图重新开始。或者再在Windows上尝试一下</p></blockquote><p><a href="https://blog.csdn.net/zzq060143/article/details/91050272?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">Windows上docker使用教程</a></p><blockquote><p>touch好像是Linux命令，我直接在mynginx创建一个文件然后记事本打开输入。这里你可以换成echo test&gt; Dockerfile，就会生成Dockerfile 文件。</p></blockquote><p>其内容为：</p><pre><code>FROM nginxRUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><p><strong>FROM 指定基础镜像</strong></p><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><pre><code>FROM scratch...</code></pre><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><p><strong>RUN 执行命令</strong></p><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><pre><code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><pre><code>FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install</code></pre><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><pre><code>FROM debian:stretchRUN set -x; buildDeps=&#39;gcc libc6-dev make wget&#39; \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \    &amp;&amp; mkdir -p /usr/src/redis \    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \    &amp;&amp; make -C /usr/src/redis \    &amp;&amp; make -C /usr/src/redis install \    &amp;&amp; rm -rf /var/lib/apt/lists/* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r /usr/src/redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><blockquote><p>Linux命令也能先看看，继续</p></blockquote><p><strong>构建镜像</strong></p><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><pre><code>$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kBStep 1 : FROM nginx ---&gt; e43d811ce2f4Step 2 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html ---&gt; Running in 9cdc27646c7b ---&gt; 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c</code></pre><blockquote><p>我在这遇到个小问题，ERROR [internal] load metadata for docker.io/library/nginx:latest，怀疑是挂了梯子的原因，关了代理之后就正常了。</p></blockquote><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><blockquote><p>wait for 4 minutes</p></blockquote><p><strong>镜像构建上下文（Context）</strong></p><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><pre><code>COPY ./package.json /app/</code></pre><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><pre><code>$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB...</code></pre><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><blockquote><p>更多关于Dockerfile的内容可以移步：<a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/" target="_blank" rel="noopener">Dockerfile详解</a>，不过更多的内容还是大家在实践中逐渐熟悉，这样才能更了解里面的含义。</p></blockquote><p><strong>跨平台构建镜像</strong></p><p>在日常的工作中，我们常常有需求将一个程序运行在不同架构CPU的设备上，尤其在嵌入式领域，我们常常接触的各种开发板、路由器往往都是使用ARM架构的芯片，而我们日常开发的设备都是在x86平台。我们在x86平台写的程序需要运行在使用ARM芯片的开发板上，这时候就需要跨CPU构建程序。</p><p>总的来说跨平台构建程序有以下几种方式。</p><ul><li>直接在目标硬件编译 这是最直接的方法</li><li>使用交叉编译器 交叉编译器是专门为在给定的系统平台上运行而设计的编译器，作用是可以在一种CPU架构上编译出另一个CPU架构的可执行文件。最普遍的例子，开发人员开发安卓应用的时候几乎都在X86的平台上开发构建，但安卓应用很明显是ARM架构的，这其中就是交叉编译器在起作用</li><li>模拟目标硬件 模拟目标硬件最常见的开源模拟器是QEMU，QEMU是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道</li><li>通过binfmt_misc模拟目标硬件的用户空间 QEMU 除了可以模拟完整的操作系统之外，还有另外一种模式叫用户态模式（User mod）。该模式下 QEMU 将通过 binfmt_misc 在 Linux 内核中注册一个二进制转换处理程序，并在程序运行时动态翻译二进制文件，根据需要将系统调用从目标 CPU 架构转换为当前系统的 CPU 架构。最终的效果看起来就像在本地运行目标 CPU 架构的二进制文件。 通过 QEMU 的用户态模式，我们可以创建轻量级的虚拟机（chroot 或容器），然后在虚拟机系统中编译程序，和本地编译一样简单轻松。</li></ul><blockquote><p>好像目前我没法实操</p></blockquote><p><strong>构建跨架构的Docker镜像</strong></p><p>先跳过了</p><p><strong>镜像存储位置</strong></p><p>在操作系统中(Linux)，默认情况下 Docker 容器的存放位置在 /var/lib/docker 目录下面，可以通过命令查看</p><pre><code>docker info | grep &quot;Docker Root Dir&quot;</code></pre><p>我们使用docker pull 下载的镜像，都会存在这个目录下，当下载的镜像过多，或容器运行过程中产生大量数据导致存储容量不足时，可以修改镜像储存的位置，有以下几种方式修改docker默认储存位置</p><p><strong>使用软链接</strong></p><ul><li>首先停止docker 进程</li><li>然后进行链接</li></ul><pre><code>#stop$ sudo systemctl stop docker#move$ mv /var/lib/docker /data/docker#ln$ ln -sf /data/docker /var/lib/docker</code></pre><ul><li>然后移动整个 /var/lib/docker 目录到空间比较大的目的路径。这时候启动 Docker 时发现存储目录依旧是 /var/lib/docker 目录，但是实际上是存储在数据盘 /data/docker 上了。</li></ul><p><strong>指定容器启动参数</strong></p><ul><li>在配置文件中指定容器启动的参数 –graph=/var/lib/docker 来指定镜像和容器存放路径。Docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致。在 Ubuntu 中的位置是 /etc/default/docker 文件，在 CentOS 中的位置是 /etc/sysconfig/docker 文件。</li></ul><pre><code>#Cent 7# 更改储存位置$ vi /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --graph /new-path/dockersudo systemctl restart docker </code></pre><ul><li>如果 Docker 的版本是 1.12 或以上的，可以修改或新建 daemon.json 文件。修改后会立即生效，不需重启 Docker 服务。</li></ul><pre><code># 修改配置文件$ vim /etc/docker/daemon.json{    &quot;registry-mirrors&quot;:        [&quot;http://7e61f7f9.m.daocloud.io&quot;],    &quot;graph&quot;: &quot;/new-path/docker&quot;}</code></pre><p><strong>System 下创建配置文件</strong></p><ul><li>在 /etc/systemd/system/docker.service.d 目录下创建一个 Drop-In 文件 docker.conf，默认 docker.service.d 文件夹不存在，必须先创建它。创建 Drop-In 文件的原因，是我们希望 Docker服务使用 docker.conf 文件中提到的特定参数，将默认服务所使用的位于 /lib/systemd/system/docker.service 文件中的参数进行覆盖。</li></ul><pre><code># 定义新的存储位置$ sudo vi /etc/systemd/system/docker.service.d/docker.conf[Service]ExecStart=/usr/bin/dockerd --graph=&quot;/data/docker&quot; --storage-driver=devicemapper# 重启$ sudo systemctl start docker</code></pre><ul><li>/data/docker 就是新的存储位置，而 devicemapper 是当前 Docker 所使用的存储驱动。如果你的存储驱动有所不同，请输入之前第一步查看并记下的值。现在，你可以重新加载服务守护程序，并启动 Docker 服务了，这将改变新的镜像和容器的存储位置。为了确认一切顺利，运行 docker info 命令检查 Docker 的根目录。</li></ul><blockquote><p>因为docker pull 太慢所以待到图书馆关门，保安叔叔来赶人</p></blockquote><h4 id="Docker容器-1"><a href="#Docker容器-1" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>容器是 Docker 又一核心概念。简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。</p><p>本节将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><p><strong>新建并启动容器</strong></p><p>所需要的命令主要为 <code>docker run</code>。其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><pre class="line-numbers language-c++"><code class="language-c++">docker run [-i -t -d -p -P -c] [--name]:在容器内运行一个应用程序 -t :在新容器内指定一个伪终端或终端 -i:允许你对容器内的标准输入进行交互 -d：以进程方式运行容器，让容器在后台运行 -p：设置端口 -P：将容器内部使用的网络端口映射到我们使用的主机，就是让我们访问我们使用的主机就等同于访问到容器内部 -c：command,后面接命令 --name container name：指定容器名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从registry下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>启动已终止的容器</strong></p><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><p><strong>停止容器</strong></p><p>docker stop可以停止运行的容器。理解：容器在docker host中实际上是一个进程，docker stop命令本质上是向该进程发送一个SIGTERM信号。如果想要快速停止容器，可使用docker kill命令，其作用是向容器进程发送SIGKILL信号。</p><p><strong>重启容器</strong></p><p>对于已经处于停止状态的容器，可以通过docker start重新启动。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker start bdf593fda8bebdf593fda8be<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>docker start会保留容器的第一次启动时的所有参数。docker restart可以重启容器，其作用就是依次执行docker stop和docker start。容器可能因某种错误而停止运行。对于服务类容器，通常希望它能够自动重启。启动容器时设置–restart就可以达到效果。–restart=always意味着无论容器因何种原因退出（包括正常退出），都立即重启；</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -it ubuntu:15.10 /bin/echo --restart=always -d "Hello world"--restart=always -d Hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>后台运行容器</strong></p><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。下面举两个例子来说明一下。</p><p><strong>如果不使用 <code>-d</code> 参数运行容器。</strong></p><pre><code>$ docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;hello worldhello worldhello worldhello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p><strong>如果使用了 <code>-d</code> 参数运行容器。</strong></p><pre><code>$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关，只要命令不结束，容器也就不会退出。上述命令中，while语句不会让bash退出，因此该容器就不会退出。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container lsCONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#39;while tr  2 minutes ago  Up 1 minute        agitated_wright</code></pre><p>使用-d启动容器后，会回到host终端；此时如果想要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进入容器</strong></p><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台，启动完容器之后会停在host端；某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><p><code>attach</code> 命令</p><p>下面示例如何使用 <code>docker attach</code> 命令。</p><pre><code>$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中exit回到host端，会导致容器的停止。</p><p><code>exec</code> 命令</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bashlsbinbootdev...$ docker exec -it 69d1 bashroot@69d137adef7a:/#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果从这个 stdin 中 exit回到host端，但不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p><strong>attach和exec的区别</strong></p><p>attach和exec的区别： （1）attach直接进入容器启动命令的终端，不会启动新的进程； （2）exec则是在容器中打开新的终端，并且可以启动新的进程； （3）如果想直接在终端中查看命令的输出，用attach，其他情况使用exec；</p><p><strong>暂停容器</strong></p><p>有时我们只是希望让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者docker host需要使用CPU，可以执行:docker pause CONTAINER [CONTAINER…]</p><p><strong>删除容器</strong></p><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code>$ docker container rm trusting_newtontrusting_newton</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><strong>清理所有处于终止状态的容器</strong></p><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre><code>$ docker container prune</code></pre><p>####批量删除所有已经退出的容器</p><pre><code>$ docker rm -v $(docker ps -aq -f status=exited)</code></pre><p><strong>导出容器</strong></p><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e > ubuntu.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样将导出容器快照到本地文件。</p><p><strong>导入容器</strong></p><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>cmd试一下用type替代，不行，直接导入，成功</p></blockquote><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker import http://example.com/exampleimage.tgz example/imagerepo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h3 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h3><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS (UNIX File System) ，可以提供很多有用的特性：</p><blockquote><p>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><p><strong>创建数据卷</strong></p><pre><code>$ docker volume create datawhale</code></pre><p>查看所有的数据卷</p><pre><code>$ docker volume ls</code></pre><p>在主机里使用以下命令可以查看指定数据卷的信息</p><pre><code>$ docker volume inspect datawhale</code></pre><p><strong>启动一个挂载数据卷的容器</strong></p><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将数据卷挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个数据卷到容器的 <code>/usr/share/nginx/html</code> 目录。</p><pre><code>$ docker run -d -P \    --name web \    --mount source=datawhale,target=/usr/share/nginx/html \    nginx:alpine</code></pre><blockquote><p>–-mount参数说明：<br>source ：数据卷<br>target ：是容器内文件系统挂载点</p></blockquote><blockquote><p>注意，可以不需要提前创建好数据卷，直接在运行容器的时候mount 这时如果不存在指定的数据卷，docker会自动创建，自动生成。</p></blockquote><p><strong>查看数据卷的具体信息</strong></p><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><pre><code>$ docker inspect web</code></pre><p><strong>删除数据卷</strong></p><pre><code>$ docker volume rm datawhale  #datawhale为卷名</code></pre><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>$ docker volume prune</code></pre><h4 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h4><p><strong>挂载一个主机目录作为数据卷</strong></p><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -d -P \    --name web \    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \    nginx:alpine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><blockquote><p>注意： 如果挂载的目录不存在，创建容器时，docker 不会自动创建，此时会报错</p></blockquote><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -d -P \    --name web \    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \    nginx:alpine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>源路径不存在，source是本地路径，然后前面启动了一个叫web的容器了，不能再启动</p></blockquote><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><pre class="line-numbers language-cmd"><code class="language-cmd">/usr/share/nginx/html # touch new.txttouch: new.txt: Read-only file system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>查看数据卷的具体信息</strong></p><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><pre><code>$ docker inspect web</code></pre><p><strong>挂载一个本地主机文件作为数据卷</strong></p><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run --rm -it \   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \   ubuntu:18.04 \   bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><h4 id="Docker-基础网络介绍"><a href="#Docker-基础网络介绍" class="headerlink" title="Docker 基础网络介绍"></a>Docker 基础网络介绍</h4><h5 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a><strong>外部访问容器</strong></h5><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过<code>-P</code>或<code>-p</code>参数来指定端口映射。</p><p>当使用<code>-P</code>标记时，<code>Docker</code>会随机映射一个端口到内部容器开放的网络端口。 使用<code>docker container ls</code>可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><p>同样的，可以通过<code>docker logs</code>命令来查看访问记录。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker logs [container name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cmd"><code class="language-cmd">D:\mynginx>docker logs 64a2/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d//docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh/docker-entrypoint.sh: Configuration complete; ready for start up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210417091738256.png" alt="成功"></p><p><code>-p</code>则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>.</p><p><strong>映射所有接口地址</strong></p><p>使用<code>hostPort:containerPort</code>格式本地的 80 端口映射到容器的 80 端口，可以执行</p><pre><code>$ docker run -d -p 80:80 nginx:alpine</code></pre><p>此时默认会绑定本地所有接口上的所有地址。</p><p><strong>映射到指定地址的指定端口</strong></p><p>可以使用<code>ip:hostPort:containerPort</code>格式指定映射使用一个特定地址，比如<code>localhost</code>地址127.0.0.1</p><pre><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code></pre><p><strong>映射到指定地址的任意端口</strong></p><p>使用<code>ip::containerPort</code>绑定<code>localhost</code>的任意端口到容器的80端口，本地主机会自动分配一个端口。</p><pre><code>$ docker run -d -p 127.0.0.1::80 nginx:alpine</code></pre><p>还可以使用<code>udp</code>标记来指定<code>udp</code>端口</p><pre><code>$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</code></pre><p><strong>查看映射端口配置</strong></p><p>使用<code>docker port</code>来查看当前映射的端口配置，也可以查看到绑定的地址</p><pre><code>$ docker port fa 800.0.0.0:32768</code></pre><p><strong>注意：</strong> 容器有自己的内部网络和 ip 地址（使用<code>docker inspect</code>查看，<code>Docker</code>还可以有一个可变的网络配置。） <code>-p</code>标记可以多次使用来绑定多个端口</p><p>例如</p><pre><code>$ docker run -d \    -p 80:80 \    -p 443:443 \    nginx:alpine</code></pre><h5 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a><strong>容器互联</strong></h5><p><strong>新建网络</strong></p><p>下面先创建一个新的 <code>Docker</code>网络。</p><pre><code>$ docker network create -d bridge my-net</code></pre><p><code>-d</code>参数指定<code>Docker</code>网络类型，有<code>bridge overlay</code>,其中<code>overlay</code>网络类型用于<code>Swarm mode</code>，在本小节中你可以忽略它。</p><p><strong>连接容器</strong></p><p>运行一个容器并连接到新建的<code>my-net</code>网络</p><pre><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code></pre><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code>网络</p><pre><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh</code></pre><blockquote><p>-rm是退出后删除了容器，所以我要开两个终端</p></blockquote><p>再打开一个新的终端查看容器信息</p><pre><code>$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESb47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox28720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</code></pre><blockquote><p>能互相ping通证明，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p></blockquote><p><code>Docker Compose</code> 如果你有多个容器之间需要互相连接，推荐使用<code>Docker</code>Compose。</p><h5 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h5><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是<code>Docker</code>利用<strong>虚拟文件</strong>来挂载容器的 3个相关配置文件。</p><p><strong>在容器中</strong>使用 <code>mount</code>命令可以看到挂载信息：</p><pre><code>$ mount/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 .../dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...tmpfs on /etc/resolv.conf type tmpfs ...</code></pre><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有<code>Docker</code>容器的 DNS 配置通过 <code>/etc/resolv.conf</code>文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><pre><code>{  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]}</code></pre><p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和8.8.8.8。使用以下命令来证明其已经生效。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>cat是Linux连接文件并打印到标准输出设备上的命令，win上可以好像用type命令</p></blockquote><p>如果用户想要<strong>手动指定容器的配置</strong>，可以在使用<code>docker run</code>命令启动容器时加入如下参数： <code>-h HOSTNAME</code>或者<code>--hostname=HOSTNAME</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname 和 /etc/hosts</code>。但它在容器外部看不到，既不会在<code>docker container ls</code>中显示，也不会在其他的容器的<code>/etc/hosts</code>看到。</p><p><code>--dns=IP_ADDRESS</code>添加 DNS 服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code>中的主机名。</p><p><code>--dns-search=DOMAIN</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS 不仅搜索 <code>host</code>，还会搜索<code>host.example.com</code>。</p><blockquote><p>关于DNS还有一些不明白</p></blockquote><p><strong>注意：</strong>如果在容器启动时没有指定最后两个参数，<code>Docker</code>会默认用主机上的<code>/etc/resolv.conf</code>来配置容器。</p><h4 id="Docker的网络模式"><a href="#Docker的网络模式" class="headerlink" title="Docker的网络模式"></a>Docker的网络模式</h4><p>可以通过<code>docker network ls</code>查看网络</p><p>常见网络的含义：</p><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Bridge</td><td>为每一个容器分配、设置 IP 等，并将容器连接到一个 <code>docker0</code> 虚拟网桥，默认为该模式。</td></tr><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</td></tr><tr><td>None</td><td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。</td></tr><tr><td>Container</td><td>新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</td></tr></tbody></table><blockquote><p>上学期机组课上虚拟机间通网老师让我们看过各种桥接模式，当时没看懂，之后要好好看看计算机网络了，现在先把看不懂的名词记下来</p></blockquote><p>Bridge 模式</p><p>虚拟网桥是什么？网卡？</p><p>二层网络？子网分配ip？虚拟网卡两端放在容器和主机？</p><p>守护进程？</p><p>对于每个容器的 IP 地址和 Gateway 信息，可以通过 <code>docker inspect 容器名称|ID</code> 进行查看</p><p>可以通过 <code>docker network inspect bridge</code> 查看所有 <code>bridge</code> 网络模式下的容器，在 <code>Containers</code> 节点中可以看到容器名称</p><p>关于 <code>bridge</code> 网络模式的使用，只需要在创建容器时通过参数 <code>--net bridge</code> 或者 <code>--network bridge</code> 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。</p><p><code>iptables</code>做了<code>DNAT</code>规则，实现端口转发功能？</p><pre class="line-numbers language-cmd"><code class="language-cmd">以使用iptables -t nat -vnL查看。演示：$ docker run -tid --net=bridge --name docker_bri1 \            ubuntu-base:v3            docker run -tid --net=bridge --name docker_bri2 \            ubuntu-base:v3 $ brctl show$ docker exec -ti docker_bri1 /bin/bash$ ifconfig –a$ route –n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>还有一些细节不明白，命令完全不明白在干嘛,暂时用不上所以先放放</p></blockquote><hr><p>Host 模式</p><p>通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定</p><p>可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；</p><blockquote><p>是不是说我把container扔到服务器上去就可以直接用服务器ip的意思？</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/host.png" alt="看不明白"></p><p>不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个<code>Network Namespace</code></p><p>None 模式</p><p>通过参数 <code>--net none</code> 或者 <code>--network none</code> 指定；</p><p>只有 lo 接口 local 的简写，代表 127.0.0.1</p><p>localhost 本地环回接口？loopback 网络设备？</p><p>需要自己为 <code>Docker</code> 容器添加网卡、配置 IP 等</p><p><strong>“少即是多”</strong></p><hr><p>Container 模式</p><p>在创建容器时通过参数 <code>--net container:已运行的容器名称|ID</code> 或者 <code>--network container:已运行的容器名称|ID</code> 指定；</p><p>共享一个网络栈？</p><p>这样两个容器之间可以使用 localhost 高效快速通信。</p><p><strong>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等</strong>。</p><h4 id="Docker高级网络配置"><a href="#Docker高级网络配置" class="headerlink" title="Docker高级网络配置"></a>Docker高级网络配置</h4><p><strong>快速配置指南</strong></p><p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p><ul><li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li><li><code>--bip=CIDR</code>定制 <code>docker0</code> 的掩码</li><li><code>-H SOCKET...</code> 或 <code>--host=SOCKET... Docker</code> 服务端接收命令的通道</li><li><code>--icc=true|false</code> 是否支持容器之间进行通信</li><li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li><li><code>--iptables=true|false</code> 是否允许 Docker 添加 <code>iptables</code> 规则</li><li><code>--mtu=BYTES</code> 容器网络中的 <code>MTU</code></li></ul><p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p><ul><li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li><li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li></ul><p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p><ul><li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li><li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li><li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li><li><code>-p SPEC</code> 或 –publish=SPEC` 映射容器端口到宿主主机</li><li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li></ul><p><strong>容器访问控制</strong></p><p><code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。机组课上用过。</p><p>容器要想<strong>访问外部网络</strong>，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p><pre><code>$sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1</code></pre><p>如果为 0，说明没有开启转发，则需要手动打开。</p><pre><code>$sysctl -w net.ipv4.ip_forward=1</code></pre><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p><p><strong>容器之间相互访问</strong>，需要两方面的支持。</p><ul><li>容器的<strong>网络拓扑</strong>是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li><li>本地系统的防火墙软件 <code>-- iptables</code> 是否允许通过。</li></ul><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条<strong>转发策略</strong>到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p><p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p><p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来<strong>访问容器的开放端口</strong>。</p><p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p><p>启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p><p><strong>端口映射实现</strong></p><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p><p>查看主机的 NAT 规则。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo iptables -t nat -nL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态<strong>伪装</strong>为从系统网卡发出</p><p><strong>端口映射实现</strong></p><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><blockquote><p>开放端口</p></blockquote><p>其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p><ul><li>永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</li></ul><pre><code>{  &quot;ip&quot;: &quot;0.0.0.0&quot;}</code></pre><p><strong>配置docker0网桥</strong></p><p>它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p><p>MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p><ul><li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</li><li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li></ul><p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo brctl show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注</strong>：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p><p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p><p><strong>自定义网桥</strong></p><p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p><p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p><pre><code>$ sudo systemctl stop docker$ sudo ip link set dev docker0 down$ sudo brctl delbr docker0</code></pre><blockquote><p>都没法在Windows上实现一遍了</p></blockquote><p>然后创建一个网桥 <code>bridge0</code>。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo brctl addbr bridge0$ sudo ip addr add 192.168.5.1/24 dev bridge0$ sudo ip link set dev bridge0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看确认网桥创建并启动。</p><p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p><pre><code>{  &quot;bridge&quot;: &quot;bridge0&quot;,}</code></pre><p>启动 Docker 服务。</p><p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p><p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p><hr><p><strong>工具和示例</strong></p><p>pipework，shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p><p>playground，一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p><p><strong>编辑网络配置文件</strong></p><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p><p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p><p>实例：<strong>创建一个点到点连接</strong></p><p>首先启动 2 个容器：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker run -i -t --rm --net=none base /bin/bashroot@1f1f4c1f931a:/#$ docker run -i -t --rm --net=none base /bin/bashroot@12e343489d2f:/#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在两个终端启动吗？</p></blockquote><p>找到进程号，然后创建网络命名空间的<strong>跟踪文件</strong>。</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ docker inspect -f '{{.State.Pid}}' 1f1f4c1f931a2989$ docker inspect -f '{{.State.Pid}}' 12e343489d2f3004$ sudo mkdir -p /var/run/netns$ sudo ln -s /proc/2989/ns/net /var/run/netns/2989$ sudo ln -s /proc/3004/ns/net /var/run/netns/3004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>绿色的是端口号？ln用于硬连接 ln -s软连接？什么是创建接口？</p></blockquote><p>创建一对 <code>peer</code> 接口，然后配置路由</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ sudo ip link add A type veth peer name B$ sudo ip link set A netns 2989$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A$ sudo ip netns exec 2989 ip link set A up$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A$ sudo ip link set B netns 3004$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B$ sudo ip netns exec 3004 ip link set B up$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p><p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p><p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p><blockquote><p>后面完全是因为基本功没到位看不懂了</p></blockquote><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>先手资料</p><hr><p><a href="https://vuepress.mirror.docker-practice.com/compose/install/" target="_blank" rel="noopener">docker compose安装与卸载</a></p><p><strong><a href="https://github.com/docker/awesome-compose" target="_blank" rel="noopener">awesome-compose</a></strong>这个项目也非常推荐。</p><blockquote><p>推荐大家多看看一些项目的docker-compose.yml文件是怎么写的，慢慢模仿着去写很多就越来越熟练清晰了。</p></blockquote><p><strong>什么是</strong>docker compose</p><p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p><p><strong>如何使用</strong>docker compose</p><p>在<code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个<strong>应用的容器</strong>，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个<strong>完整业务单元</strong>，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><strong>web应用</strong></p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><strong>启动服务</strong></p><pre><code>docker-compose up</code></pre><p>命令后会自动接一个默认值<code>-f docker-compose.yml</code>，也就是默认是使用docker-compose.yml文件的。我们也可以给文件起名为<code>docke-test.yml</code>，这样在使用时指定文件名，但是为了符合规范，还是统一为<code>docker-compose.yml</code>。</p><pre><code>docker-compose up -f docer-test.yml</code></pre><p>-d参数让启动时的输出不会打印到终端</p><p><strong>查看服务状态</strong></p><pre><code>docker-compose ps</code></pre><p>要是想要查看所有service的状态可以使用-a参数</p><p><strong>停止或删除服务</strong></p><pre><code>docker-compose stopdocker-compose down</code></pre><p>其中stop是直接停止services，而down则会停止并删除创建的service，volume和network。</p><p><strong>进入服务</strong></p><pre><code>docker-compose exec mysql bash</code></pre><p><strong>查看服务输出日志</strong></p><pre><code>docker-compose logs</code></pre><hr><p>Compose<strong>模板文件</strong></p><p><em><a href="https://vuepress.mirror.docker-practice.com/compose/compose_file/#cap-add-cap-drop" target="_blank" rel="noopener">Compose模板文件</a></em></p><p>文件格式为 YAML 格式。</p><pre class="line-numbers language-yml"><code class="language-yml">version: "3"services:  webapp:    image: examples/web    ports:      - "80:80"    volumes:      - "/data"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p><strong>build</strong></p><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><p><code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><p>使用 <code>cache_from</code> 指定构建镜像的缓存。</p><p><strong>depends_on</strong></p><p>解决容器的依赖、启动先后的问题。</p><p><strong>environment</strong></p><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔 (opens new window)</a>含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><pre><code>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</code></pre><p><strong>expose</strong></p><p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数</p><p><strong>ports</strong></p><p>暴露端口信息。使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><p><strong>secrets</strong>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><p><strong>image</strong>指定为镜像名称或镜像 ID。</p><p><strong>labels</strong>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><p><strong>network_mode</strong>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><p><strong>networks</strong>配置容器连接的网络。</p><p><strong>volumes</strong></p><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。该指令中路径支持相对路径。</p><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><hr><p>Compose<strong>命令</strong></p><p><code>docker-compose</code> 命令的基本的使用格式是</p><pre><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre><ul><li><code>f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><table><thead><tr><th>命令</th><th align="center">作用</th></tr></thead><tbody><tr><td>build</td><td align="center">格式为 <code>docker-compose build [options] [SERVICE...]</code>。构建（重新构建）项目中的服务容器。</td></tr><tr><td>config</td><td align="center">验证 Compose 文件格式是否正确</td></tr><tr><td>down</td><td align="center">此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</td></tr><tr><td>exec</td><td align="center">进入指定的容器。</td></tr><tr><td>help</td><td align="center">帮助</td></tr><tr><td>image</td><td align="center">列出 Compose 文件中包含的镜像</td></tr><tr><td>kill</td><td align="center">格式为 <code>docker-compose kill [options] [SERVICE...]</code>。通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。支持通过 <code>-s</code> 参数来指定发送的信号</td></tr><tr><td>logs</td><td align="center">查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。该命令在调试问题的时候十分有用。</td></tr><tr><td>pause</td><td align="center">暂停一个服务容器。</td></tr><tr><td>port</td><td align="center">打印某个容器端口所映射的公共端口。</td></tr><tr><td>ps</td><td align="center">列出项目中目前的所有容器。</td></tr><tr><td>pull</td><td align="center">拉取服务依赖的镜像。–ignore-pull-failures忽略拉取镜像过程中的错误。</td></tr><tr><td>push</td><td align="center">推送服务</td></tr><tr><td>restart</td><td align="center">重启项目中的服务。</td></tr><tr><td>rm</td><td align="center">删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。<code>-f, --force</code> 强制直接删除 -v删除容器所挂载的数据卷</td></tr><tr><td>start</td><td align="center">启动</td></tr><tr><td>stop</td><td align="center">停止已经处于运行状态的容器，但不删除它</td></tr><tr><td>top</td><td align="center">查看各个服务容器内运行的进程</td></tr><tr><td>unpause</td><td align="center">恢复处于暂停状态中的服务</td></tr><tr><td>up</td><td align="center">尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。<code>-d</code>，将会在后台启动并运行所有的容器</td></tr></tbody></table><p>up选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><hr><p><strong>扩缩容</strong></p><pre><code>docker-compose up --scale web=3 -d</code></pre><blockquote><p>理想情况下这三个web会同时对外提供服务，以减轻访问单个容器的压力。但是我们在上面也看到了因为大家都是绑定的5000端口，这样端口就冲突了，导致新创建的两个web服务都是Exit的状态，对于这个问题我们可以通过HAProxy来解决。</p></blockquote><p>HAProxy？等我学完网络再来看能不能PR好了</p><h3 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a>综合实践</h3><h4 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h4><p>看github上的教程没搞懂这次打卡具体要做什么，如果自己写dockfile估计时间不够了，所以参照阮一峰的docker实战尝试在服务器上做点东西出来好了。</p><p>在服务器上装docker，见参考资料</p><p>首先还要更新一下yum，遇到点小问题，csdn解决。</p><p><a href="https://blog.csdn.net/haohaoxuexiyai/article/details/111027692" target="_blank" rel="noopener">yum更新失败：rpmdb: BDB0113 Thread/process 2673/140126198814528 failed: BDB1507 Thread died…</a></p><p>服务器一边还在进行一些其他任务，所以在本地同时开工。</p><p>由于时间关系这次就不自建WordPress容器了，直接采取最简单的方法，使用官方提供的容器。</p><p>首先，新建并启动 MySQL 容器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container run \  -d \  --rm \  --name wordpressdb \  --env MYSQL_ROOT_PASSWORD<span class="token operator">=</span>123456 \  --env MYSQL_DATABASE<span class="token operator">=</span>wordpress \  mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container run \  -d \  --rm \  --name wordpress \  --env WORDPRESS_DB_PASSWORD<span class="token operator">=</span>123456 \  --link wordpressdb:mysql \  wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p><p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container inspect wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。</p><p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p><p>然而我打不开<code>172.17.0.3</code>，不知道是不是打开方式不对。</p><p>到了上一步，官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p><blockquote><ul><li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li><li>WordPress 安装在容器里面，本地无法修改文件。</li></ul></blockquote><p>解决这两个问题很容易，只要新建容器的时候，加两个命令行参数就可以了。</p><p>先把刚才启动的 WordPress 容器终止（容器文件会自动删除）。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>然后，使用下面的命令新建并启动 WordPress 容器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash"> $ docker container run \  -d \  -p 127.0.0.2:8080:80 \  --rm \  --name wordpress \  --env WORDPRESS_DB_PASSWORD<span class="token operator">=</span>123456 \  --link wordpressdb:mysql \  --volume <span class="token string">"<span class="token variable">$PWD</span>/wordpress"</span>:/var/www/html \  wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>上面的命令跟前面相比，命令行参数只多出了两个。</p><blockquote><ul><li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li><li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li></ul></blockquote><p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p><p>最后，终止这两个容器（容器文件会自动删除）。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop wordpress wordpressdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="第一次实际实用docker"><a href="#第一次实际实用docker" class="headerlink" title="第一次实际实用docker"></a><strong>第一次实际实用docker</strong></h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/1836012?qq-pf-to=pcqq.group" target="_blank" rel="noopener">教你用AI Studio+wechaty+阿里云白嫖一个智能微信机器人</a></p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰的docker教程</a></p><p><a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener">Docker 从入门到实践</a></p><p><a href="https://github.com/datawhalechina/team-learning-program/tree/master/Docker" target="_blank" rel="noopener">github组队学习</a></p><p><a href="https://blog.csdn.net/zzq060143/article/details/91050272?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">Windows上docker使用教程</a></p><p><a href="https://www.cnblogs.com/linjj/p/5606911.html" target="_blank" rel="noopener">Windows创建自己的镜像</a></p><p>关于安装问题</p><p><a href="https://blog.csdn.net/LFxiaosu/article/details/112214780" target="_blank" rel="noopener">docker的安装及卸载不干净造成的问题</a></p><p><a href="https://blog.csdn.net/lazy_ting/article/details/106375737" target="_blank" rel="noopener">乌班图配网</a></p><p>关于服务器装docker</p><p><a href="https://cloud.tencent.com/document/product/213/46000#.E5.AE.89.E8.A3.85-docker" target="_blank" rel="noopener">我用的腾讯云centos7</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语学习</title>
      <link href="/2021/04/11/ying-yu-xue-xi/"/>
      <url>/2021/04/11/ying-yu-xue-xi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/v2-70663faaf7ff2ad7f5c034b58c1cd9e5_b.jpg" alt="小天爷学英语"></p><h3 id="2021英语学习计划1-0"><a href="#2021英语学习计划1-0" class="headerlink" title="2021英语学习计划1.0"></a>2021英语学习计划1.0</h3><blockquote><p>ᵀʰᵉʳᵉ ⁱˢ ᵐᵒʳᵉ ᵗᵒ ᶜᵒᵐᵉ</p><p>于未来有更多期许。</p></blockquote><p><strong>六级备考(距离考试只有80天不到)</strong></p><p>十周计划前期每天一篇翻译，一套阅读，一三五早上一套听力，每周五一次套题，周日早整理复习，二四六早写作。</p><p><strong>目前进度</strong></p><p>4.1前六级词汇已过，刷完</p><p><strong>第一周（4.4）</strong></p><p>翻译*6</p><p>阅读*5</p><p>听力*3</p><p>一套历年真题（缺）偷懒了，后面要补上。</p><p>单词：雅思2768</p><p><strong>第二周（4.11）</strong></p><p>翻译*4</p><p>阅读*6</p><p>听力*1</p><p>杂七杂八的事情太多，这周又没做真题，不过估计能在第四周前把各个题型刷完，目前已经差不多刷完听力和阅读了，后面有时间可以刷真题。</p><p>这周复习雅思单词</p><p><strong>第三周（4.18）</strong></p><p>翻译*4</p><p>阅读？做完了好像，可以开始做六级真题了。</p><p>一套英语真题，好像错了五个</p><p>又是没刷真题套卷的一周，还剩七周，应该能刷完吧？</p><p>单词：雅思3112，下周不背单词了，努力刷题，有空还是要看一看大英赛的题目的。</p><blockquote><p>这周没做多少练习，倒是读了一些英语原文，所以没有总结。</p></blockquote><p><strong>第四周4.25</strong></p><p>完成大英赛初赛，写作翻译能力果然还是很需要提升，特别是英文写作，最近基本上没怎么写过英文作文，之后要多练习使用英语，多尝试输出，而不仅仅是阅读输入。</p><p>翻译*3</p><p>两套CET-6真题，除作文翻译。听力错四五个，阅读第一篇cloze好久没做过了，很吃力，根本选不出来。时间上也比较紧张，之前以为没有cloze了。好在阅读都不觉得有太大问题。</p><p>2019.6第一套和第二套</p><p>剩下精力要攻克听力和写作翻译了。</p><p>还剩四周口语，也得准备准备。</p><p>单词还是3112，这周复习，大英赛断了一天。</p><p><strong>第五周4.30</strong></p><p><strong>使用书目</strong></p><p>语法：重点推荐剑桥校友张满胜的《英语语法新思维》</p><p>初级教程-走近语法结果买错成张道真《实用英语语法（最新版）》</p><p>《华研外语六级真题》</p><p><strong>参考资料</strong></p><p><a href="https://www.zhihu.com/search?type=content&q=大学英语自学书" target="_blank" rel="noopener">大学英语自学书 - 搜索结果 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 外语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow学习笔记</title>
      <link href="/2021/04/01/tensorflow/"/>
      <url>/2021/04/01/tensorflow/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>TensorFlow 是一个开源的、基于 Python 的机器学习框架，它由 Google 开发，并在图形分类、音频处理、推荐系统和自然语言处理等场景下有着丰富的应用，是目前最热门的机器学习框架。</p><p>除了 Python，TensorFlow 也提供了 C/C++、Java、Go、R 等其它编程语言的接口。</p></blockquote><p>个人配置：电脑上已经安装好了anaconda，python版本3.7.6</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>国内直接下载TensorFlow速度慢，直接换清华源，清华园也挂了，再换豆瓣源，配置到pycharm，Spyder先不配置了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://c.biancheng.net/tensorflow/" target="_blank" rel="noopener">TensorFlow教程：TensorFlow快速入门教程（非常详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/110980436?utm_source=wechat_session" target="_blank" rel="noopener">tensorflow安装全解(全解萌新向/CPU/下载快/自选新旧版本/GPU安装简述/报错解决)</a></p><p><a href="https://blog.csdn.net/qq_43211132/article/details/94426458?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328767.234.16172629286554925&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">win10中anaconda安装tensorflow时报错Traceback (most recent call last): File “E:\Anaconda3\lib\site-packag</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3月复盘</title>
      <link href="/2021/03/28/2021-3/"/>
      <url>/2021/03/28/2021-3/</url>
      
        <content type="html"><![CDATA[<h1 id="三月复盘（4-3）"><a href="#三月复盘（4-3）" class="headerlink" title="三月复盘（4.3）"></a>三月复盘（4.3）</h1><h2 id="本月关键词：看开"><a href="#本月关键词：看开" class="headerlink" title="本月关键词：看开"></a>本月关键词：看开</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“凡事应该简单到不能再简单为止。”</strong></p><p><strong>——奥克海姆剃刀</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>考试</strong></p><p>大二冬季期末，虽然有想过要好好利用考试周复习各科专业课，但还是浪费了不少时间，看了70多个小时的b站，还看人家送外卖</p><p><strong>学习</strong></p><p>复习考试科目</p><p>提前预习信息论，《信息论基础》20h</p><p>六级英语计划重启</p><p><a href="https://zhuanlan.zhihu.com/p/359945906" target="_blank" rel="noopener">小天爷学英语</a></p><p><strong>比赛</strong></p><p>计算机应用能力大赛最后截止是在考试周结束前一天，导致最后概率论的复习计划被打乱，生活一遍又一遍地提醒我，不确定性无法完全避免。</p><p>得知美赛论文发错版本，那天心情很不好，但也已经是过去了。</p><p>或许我对比赛拿奖本来就不该有多少期待，喜欢的事情就拿十二分努力去做，结果什么的都让老天去考虑吧。</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>这次考试以后重新找回自己的状态，最后一周12km，更改一年的计划为500km。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p>阅读</p><p>《蔡康永学说话》作者有一句话说的很好，一本书总是作者有话想对读者说，并且抱着极大的热情才能写出来的，所以哪怕书里的这些看起来很浅显得道理也值得读者花上一点时间。看这些书的时候，我们更多可能是在反思自己，回忆自己的过去并且总结经验，从而对未来做好一定准备。</p><p>《搏击俱乐部》在图书馆复习，下午在书架上看到这本书然后就拿下来看了两个小时，看书和看电影的感觉还是不太一样的，不得不佩服导演的才华。</p><p>《傲慢与偏见》</p><p>《赢》</p><p>《禅与摩托车维修艺术》</p><p>写作</p><p><a href="https://henryavery.cn/2021/03/25/da-er-dong-ji-xue-qi-zong-jie/">SHU智科大二冬季学期总结</a></p><p>观影</p><p>《守护解放西》1和2刚开学就疯狂看完了，然后停不下来又看了《巡查2018》和《现场2019》，看热闹真的是刻在人类基因里的。看纪录片并不能减少我对b站的使用时间。</p><p>《罪恶王冠》一部看了浪费时间浪费感情的老动漫。</p><p>《无人区》一部没什么意思的片子，每周周末放松打发时间</p><p>《建国大业》看看我们的历史，瞬间恢复斗志</p><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>这个月最大的投资是买了个吹风机。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>考完试溜出学校到外滩骑自行车放松心情，从外滩到豫园再到南京东路和大学同学一起去吃晚饭。校招去凑热闹认识了一些优秀的学长。</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>一周168h，每天8h那就是睡56小时，然后每天2h花在路上，可用的时间只有100个小时不到。每天平均上课6h，一周30h在上课。还剩60h，拿出一半用来完成课后作业，就只有30h可以自己把握，这30h要想好怎么使用。</p><p>比如可以用在学英语上，翻译和单词1h，阅读和听力轮流1h。还有15小时，可以拿5个小时来运动，还剩十个小时花在自己想学的东西上面，可以阅读，可以学数学，也可以是某样技术。</p><p>希望下个月的30*24=720小时里，我能有120小时要用在课后学习，另外有120h在上课，60小时学英语，30小时在运动，40小时在学自己想学的东西，比如一门计算机网络的课和一门操作系统课。或者一门深度学习的课。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/362B696CD4CF2B4D05B120B8FA081C08.jpg" alt="其实没有睡足8小时"></p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>英语学习计划</p><p>算法学习计划</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于考试。备考就像黑屋子里洗衣服，你不知道洗干净没有，只能一遍一遍去洗。等到上了考场的那一刻，灯光亮了。你发现只要你认真洗过，那件衣服光亮如新，而你以后每次穿上那件衣服都会想起那段岁月。</p><p>第二件事，关于数学。伽利略说，惟有数学才能揭示科学的真实面貌，因为数学似乎是上帝的语言。我希望能掌握全面的知识，让我能够熟练掌握我将来用得到的一切知识。对于微积分，线性代数，概率论及统计学中最重要的内容不管是否喜欢都要熟练掌握，并且花大量时间去训练，起码不应该少于花在英语上的时间。</p><p>第三件事，关于英语。如果想要提升英语的一个阶段，也需要时间和决心，而且学英语如同逆水行舟，不进则退。<strong>习惯化是非常重要的，把一次正确的实践变成习惯，把理论内在化，把这个东西变成你身体的一个部分，当你去使用它的时候你甚至可以不用思考。这也是文化社会学家Bourdieu所谓的文化惯习（Habitus）</strong></p><p><a href="https://www.zhihu.com/question/22808635/answer/258783880" target="_blank" rel="noopener">怎样才能从英语很糟糕的人变成英语很厉害的人？</a></p><p>第四件事，关于算法。想想自己这个月都没认真敲过代码，就好像一个作家不提笔，一个钢琴家不摸琴一样。专业是自己喜欢的专业，写代码也是一件很艺术的事情，我也很想去写，但是为什么会这样呢？是时候开始着手潜下心来学习算法了，打算花一年时间学习不难的《算法导论》，把这修炼成一项自己的吃饭本领。</p><p>第五件事，关于学习。永远要有两周学完一门课的勇气。把每天的第一个小时，用来完成最困难的任务，并在这段时间内消除所有干扰，只专注于一项任务，这就是动力小时。—— 卡尔·纽波特《深度工作》ps：在图书馆坐一天会比在寝室做一天舒服，只有睡觉才需要回寝室的床上，因为趴在桌上睡对眼睛不好。</p><p>第六件事，关于心态。对于已经过去的事情，没法改变的事实和历史就不用再纠结，继续做手头上的事情，未来的计划没有大的改变可以继续按部就班执行。比赛，重在参与，感兴趣就去勇敢报名，结果让老天爷去决定，但是不打无准备之战。</p><p>第七件事，关于未来。读研，出国还是留在上海亦或者一路北上。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU智科大二冬季学期总结</title>
      <link href="/2021/03/25/da-er-dong-ji-xue-qi-zong-jie/"/>
      <url>/2021/03/25/da-er-dong-ji-xue-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="课程总览"><a href="#课程总览" class="headerlink" title="课程总览"></a>课程总览</h3><p>这个学期一共十周，寒假前八周，五周寒假之后再上两周课，然后是两周的考试周。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210325094224653.png" alt="一开始选了35分"></p><p>我选课的习惯是在第一轮和第二轮选课把35学分选满，因为基本上不会被踢课，不选白不选，所以就想等第三轮的时候再把不想去的课推掉。这个习惯好像是有点拖延症，一方面其实是犹豫不决，另一方面也确实是为了给自己留出余地。</p><p>但是，这次第三轮选课我给忘了，导致我直接课表上直接多了三门英语课（原本只用上一门）课表直接被塞满成有三天都是白天晚上连轴转，四门英语课我实在是吃不消而且也没必要，如果真的硬上估计这学期挂科的概率会直线上升，所以就只好去找学院教务处的老师退课。</p><p>第一周还不能退课，没办法，怕到时候万一退不了课所以第一次课这四门英语课我都去上了，正好更多地了解了一下每门课老师的要求，因为最后还是要留一门的（最后是因为商务英语入门时间比较合适就留了这门）。然后这一周我室友白天基本上就没在寝室里看到过我。</p><p>为了退课，我跑了好几次教务处找教务处的老师说要退课，那个坐办公室的老师一开始满脸不情愿，不耐烦而且推三阻四，还会用退课情况太多机房老师不一定允许退课，她还说我这个情况不符合退课条件（只有时间冲突和有先修课没上或者是其他一些什么特殊情况才能退）虽然说实话我好像确实不符合这些情况，但我还是不想就这么过一个学期，绞尽脑汁想办法怎么才能说服她给我开个退课单。经过我一番的<strong>动之以情晓之以理</strong>之后，教务处老师<strong>无动于衷</strong>。</p><p>眼看我就要失败，打算再进行一轮进攻过后如果失败就接受现实的时候，教务处办公室里又走进来一个兄弟说要退课，他说他也是选了两门英语课结果忘了退，我看着他也在教务处老师面前<strong>无可奈何的样子</strong>像极了我刚来的时候。（此时教务处老师已经坐在电脑前极度不耐烦并喝起了茶）</p><p>他的理由几乎和我一样，不同的是他最多只用每周多上两小时的课，而且如果这个学期上午下个学期就不用再多选一门英语课了，虽然我如果要是一学期上四门英语课之后也一样不用再选英语课，而且还多出4学分可以充当任选学分，但这学期人非不得发疯了。</p><p>这个时候我灵机一动，既然我说服不了教务处老师，那就<strong>逆向思维</strong>，不如帮着教务处老师劝那个来退课的兄弟放弃，告诉他如果这个学期多上一门课也没关系，相当于下学期不用上而已，也没多大关系。好在这兄弟也是真实诚，就这样在我的劝说下高高兴兴地回去了。</p><p>教务处老师眼看着来退课的学生就这么轻松的走了也是<strong>露出了欣慰的笑容</strong>，我眼看有机会，立即再次发动我的七寸不烂之舌，我说老师你看，刚刚那个同学他是只是多选了一门英语课，而我是真的不小心多选了三门课，这个学期实在是没有这么多时间和精力去上这么多课了，如果不能退课的话那非不得挂科，您高抬贵手放我一马。</p><p>此时她好像才第一次被动摇，我就知道有戏了。说巧也是真巧，前那个来退课的兄弟前脚刚走后脚又办公室又来了一个退伍回来的同学签退课单（有正当理由），教务处老师可能是看我实在可怜，又或者是因为嫌我太碍眼，看在我帮她”送走”了一个麻烦的份上（不好意思了前面来退课的兄弟）就同意顺手帮我和那位退伍同学一起把退课单签了，让我和他一起上楼盖章，我是真没想到她的态度还能反转的那么快，所以立马也是千恩万谢，感恩戴德，不过临走她还是吓我说到机房最后能不能退课还得看机房老师的意思。</p><p>只是既然我都已经签好退课单了，退课这个大问题基本上也就解决了，果然，到机房后一看负责登录选课网站操作退课的除了机房老师以外还有我们学院的学长，等排队到我了我就直接到学长那边，直接和他说了我要退的那三门英语课，退课单上的理由问都没问就完成了退课。</p><p>不得不说，<strong>退完课之后我的心情极好，就好像这个学期的生活又重新充满了光明。</strong></p><h3 id="课程学习心得"><a href="#课程学习心得" class="headerlink" title="课程学习心得"></a>课程学习心得</h3><p><strong>数据结构</strong></p><p>还是选的zjq老师，推荐一本《大话数据结构》，很有意思，开始上课前花几个小时可以看完，大概知道这门课学什么。</p><p>虽然觉得数据结构1也没太大难度，但是做题好像是另外一回事，写代码也只是时间问题。</p><p>刷题还是建议买本王道的考研书，提早做作业，我后悔买的晚了，边上课边做效果最好。</p><p>寒假返校后一个月基本不怎么敲代码，会有点手生。</p><p>组队没找到认识的组员会有一定的麻烦，果然建议找认识的人是没有错的，可惜我还是太年轻不信邪，不信邪就很容易会撞邪。</p><p><strong>计算机组成原理与体系结构</strong></p><p>这门课有的实验做起来真的很麻烦，我边做边记录最后写成了一份<strong>实验攻略</strong>，最后复习的笔记也上传到了另一篇博客上。</p><p><a href="https://henryavery.cn/2020/11/28/shu-ji-zu/">SHU智科机组</a></p><p>虽然这门课计科学两个学期智科只学一个学期，但我觉得也没什么大不了的，问了问计科的同学，他们机组好像也没多讲什么内容，我们课时短内容好像反而还更多。强烈建议自己买本王道考研的书做题，提前预习，一边上课一边做题无压力，考前突击要靠背，背完大概会觉得自己考研问题都不大了，但是考试范围还是会出乎意料，因为老师会搞偷袭。</p><p>swf老师是好老师，讲的很多东西都很有道理，能从他的机组课上学到不少思想。比如二八定理就很有用，打个比方，一般考试有80%是简单的题目或者说是重复的问题，只有20%是难题。所以如果想要拿高分，与其花九成的精力攻克20%的难题，不如用这个时间确保能拿下另外80%的基础题。再比如很多计算机体系里的思想仔细思索都会觉得很有意思。</p><p>另外，他上课还经常会讲他当辅导员的时候去查寝的例子，印象中他起码讲了三遍以上。</p><p><strong>概率论</strong></p><p>hhp，感觉比机组简单，但是要多刷题，寒假回来要小测验我忘了，被打了个措手不及。</p><p>概率论和实际生活有很多联系，在机器学习中也是非常有用的工具，在美赛建模里会用到数理统计，是一门值得花时间好好学的科目。</p><p>推荐买《考研数学复习全书》和《张宇数学1000题》，别和我一样傻傻的把数学一买成了数学二就行。</p><p><strong>离散数学</strong></p><p>wp，老师很好也讲的很慢，跟上就能听懂。而且离散1不难。考试选择题多选，坑，要克服<strong>人的思维惯性</strong>，有一些概念得自己梳理，这让我看清自己的学习方式和复习习惯在<strong>梳理</strong>和<strong>区分</strong>这里还有不足，希望日后能够完善。</p><p>离散数学顾名思义讲的就是“离散”的数学知识。</p><p><strong>商务英语入门</strong></p><p>hl，很有特色的老师，会开玩笑，而且上她的课还是比较放松的，可以带零食</p><p>这门课要求很少，没有作业，有一次额外的案例分析，一次可选的任务（起码她是这么说的）</p><p>关于如何卖出一瓶高端水，当时我是想做的，很认真的开了一篇博客打算开写，但是时间比较急没来得及写完，我是觉得如果为了敷衍而去完成任务那还不如不交，其实这种思维就有问题，可我总是后知后觉，然后直到现在都还没填这个坑。<a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于如何卖出一瓶高端水</a></p><p>课上讲了很多商务案例以及职场关系的内容，有不少课堂讨论，还有很多有趣的东西，考试也不算太难（相对于新闻听力和口译来说）</p><p><strong>演讲艺术</strong>（强推）</p><p>wx，经历很丰富思想也很丰富的老师，北大法学院转学播音主持，做过主持人、配音，课讲得也很好，这门课能学到很多东西，我觉得个人收获很大。</p><p>期末作业是寒假里录一次限定主题的三分半演讲视频，要求正装，半身，最后一次课要把演讲内容写下来交给教务处留档。我是第一次认真看自己说话的视频，一个人从上午录到下午录了快一百遍，主要是很多时候一开始没准备好，两三秒那种不能剪辑只好重新来过。</p><p>建议认真对待，不然运气不好的话可能会在课上被”公开处刑“，脸皮厚点也无所谓。</p><p>另外如果课程期间在校内或者校外参加演讲比赛拿奖告诉老师他会直接给4.0。</p><p>关于演讲有本《TED演讲的力量》推荐。</p><p><strong>毛概</strong></p><p>一学期可以选完两门毛概，考试时间不冲突，而且反正都是开卷。考研要考，我一开始还想好好学一下，实在是学不进多少。</p><p>红课要选就选xjp</p><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><p>知乎上看到一段话觉得形容的特别合适。</p><blockquote><p><strong>备考就像黑屋子里洗衣服，你不知道洗干净没有，只能一遍一遍去洗。等到上了考场的那一刻，灯光亮了。你发现只要你认真洗过，那件衣服光亮如新，而你以后每次穿上那件衣服都会想起那段岁月。</strong></p></blockquote><p>特别是这次复习机组，其实光说大学的某次考试的话，是可以不用再像高中那样去想那么多的，一次考试考完了就考完了。考试的题目是老师出的，对这门课的考察其实一定科学合理吗？考试的分数在某种程度上或许可以说明你对这门课的学习态度是否认真，它处在一个置信度不明的置信区间内，仅此而已。</p><p>而考试周的意义则更像是给了我们一段时间，可以好好整理复习我们一个学期学过的内容，最后的考试成绩不是我们的收获，在这短短两周不到的时间内自己复习过的，整理出来的知识和经验才是我们真正能收获到的。考试中某个题目的答案或许这辈子都不会再用到，无论是做对还是做错，都只不过是在一定程度上反映出你在这次考试之前的准备是否充分。</p><p>我相信等将来真正要用到曾经学过的知识时，那些复习过程中真正学到的东西都会是有用的，而考试时某个做错或者做对的题目早就会被大脑遗忘了。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月复盘</title>
      <link href="/2021/03/05/2021-2/"/>
      <url>/2021/03/05/2021-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2月复盘（3-5）"><a href="#2月复盘（3-5）" class="headerlink" title="2月复盘（3.5）"></a>2月复盘（3.5）</h1><h2 id="本月关键词：寒假"><a href="#本月关键词：寒假" class="headerlink" title="本月关键词：寒假"></a>本月关键词：寒假</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“哪有什么很忙，只是你觉得当下选择做某件事，而非另一件而已。说白了，一切都是你自己的选择。“</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><a href="https://henryavery.cn/2021/01/22/2021-han-jia-ji-hua/">寒假计划</a></p><p><a href="https://henryavery.cn/2020/09/11/mei-sai-qi-hang/">美赛四天</a></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113407044" target="_blank" rel="noopener">吴恩达机器学习</a></p><p><a href="https://henryavery.cn/2021/01/22/flutter/">Flutter</a></p><p>英语：六级单词2000，四级成绩567，马上就要报名六级了，考完期末备战600+</p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>就出门打了一次球，散了一次步，自己在家只做俯卧撑，下定决心要在毕业前改变自己的形象，回学校后重新开始健身。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><h5 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a><strong>阅读</strong></h5><p>《第五项修炼》速读，打发时间</p><p>《自私的基因》有空单独写书评</p><p>看了几天的网络小说</p><h5 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h5><p>《蛮荒世界》一部由六个小故事组成的电影，揭露人性，下饭片</p><p>《宿醉》神作，适合下饭</p><p>《神探》很久以前有印象的一部片子，只记得一个片段，当时看不懂</p><p>《拆弹专家2》下饭</p><p>《算死草》在b站上找到一部星爷主演的片子，居然没看过</p><p><strong>写作</strong>（有待完成）</p><p><a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于如何卖出一瓶水</a></p><p>社交圈和社交软件推荐算法的小研究</p><h3 id="4-人际交往副本"><a href="#4-人际交往副本" class="headerlink" title="4 人际交往副本"></a>4 人际交往副本</h3><p>寒假里和高中的一些朋友出去聚餐，然后除了几个比赛开会以外好像和外界的交流就比较少了，过年走亲戚不算交流，基本上说不上话，两三天是正常，连续走亲戚一周纯属浪费是啊金。然后主要可能还是因为忙比赛，所以也没精力组织其他活动。读书会今年也不了了之。</p><p>明年可以把新年祝福留到初一的时候再发，元旦不如过年有空，正好可以整理一下人机关系。</p><p>发现自己原来偶尔也会思考关于合群的问题。</p><p>关于社交圈和社交软件推荐算法的小研究还在继续，希望可以写有意思的东西出来。</p><h3 id="5-生活习惯副本"><a href="#5-生活习惯副本" class="headerlink" title="5 生活习惯副本"></a>5 生活习惯副本</h3><p>刚回家一周就急性肠胃炎，瘫了整整一周，吃了一些药，好在美赛之前好的差不多了。作息太重要了，回家最重要的就是能克服这些阻碍，假期质量受到严重影响。</p><p>生病几天日记断了，什么也不想干。</p><p><strong>时间</strong></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/20212.jpg" alt="2月时间统计"></p><p>这个假期过的很放纵，慢慢习惯用块时间，但是每周的计划就全废了，记录得倒是很清楚，甚至可以看出自己在拜年走亲戚上花的时间可能不像自己想的那么多，有很多时间其实是可以转换到有意义的事情上的。</p><p>距离完全记录还差了一些，下个月的目标是记录80%，也就是576h。可以看到自己的复习时间，上课的时间。</p><p>考虑入手一个GoPro或者其他记录摄像头，美团小哥那种就不错，可以试着记录一下自己的一天。</p><h3 id="6-其他计划副本"><a href="#6-其他计划副本" class="headerlink" title="6 其他计划副本"></a>6 其他计划副本</h3><p><a href="https://henryavery.cn/2021/02/10/2021-nian-ji-hua/">2021年度计划</a></p><p><a href="https://henryavery.cn/2021/02/10/2020-nian-zhong-zong-jie/">2020年终总结</a></p><p>未完成</p><p><a href="https://henryavery.cn/2021/01/22/processing/">Processing</a></p><p><a href="https://henryavery.cn/2021/01/02/docker/">Docker</a></p><p><a href="https://henryavery.cn/2021/01/22/java/">Java学习笔记</a></p><p><a href="https://henryavery.cn/2021/01/01/ren-ji-gong-sheng/">人机共生</a></p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于日记。可能是刚开始使用电子日记，不太习惯写很多，没有那种纸笔写起来的顺畅，可以回忆的东西也少了很多。</p><p>第二件事，关于学习。我又发现一个适合自己的学习方法，那就是把学习计划压缩在一个比较密集的时间里，比如有空就花三天看完机器学习课，但这需要极度集中的精神，除了长假以外真的很难还有这样的时间完全投入到一件事情上面。</p><p>第三件事，关于演讲。“但凡有面对两个或以上的人说话，就是在演讲。”第一次记录自己演讲的样子，一遍又一遍地看，发现自己身上存在的问题。只有了解自己，才能改变自己。一共录了九十多遍，中午连饭都没吃，一直录到下午结束，不得回家收拾行李，很认真的去做一件自己以前好像从来没认真做过的事情。</p><p>第四件事，关于阅读。看了太多的网络小说，明明自己有那么多书可以看，结果都只看了一本《自私的基因》。这个寒假的阅读量很少，阅读计划里的另外五本书其中两本刚买到手，另外三本打算去图书馆借。</p><p>第五件事，关于计划。这个月过的很没有章法的原因还是自己么有按照计划去执行。可能要从根源上去找原因，究竟是什么让自己不能面对现实。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视时app</title>
      <link href="/2021/02/16/shi-shi-app/"/>
      <url>/2021/02/16/shi-shi-app/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>一款用于记录命运的APP。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>从github仓库拉取到本地，Android要求路径不能有中文</p><h2 id="暂存资料"><a href="#暂存资料" class="headerlink" title="暂存资料"></a>暂存资料</h2><p><a href="http://hukai.me/android-training-course-in-chinese/input/gestures/multi.html" target="_blank" rel="noopener">处理多点触控手势</a></p><p><a href="http://hukai.me/android-training-course-in-chinese/" target="_blank" rel="noopener">Android官方培训课程中文版(v0.9.7)</a></p><p>mvvm</p><p>sqlite</p><p>viewmode</p>]]></content>
      
      
      <categories>
          
          <category> 开发项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021的百日阅读计划1.0</title>
      <link href="/2021/02/10/2-4-yue-yue-du-ji-hua/"/>
      <url>/2021/02/10/2-4-yue-yue-du-ji-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="《CS：APP》"><a href="#《CS：APP》" class="headerlink" title="《CS：APP》"></a>《CS：APP》</h3><p>看了一下网络编程</p><h3 id="《傲慢与偏见》"><a href="#《傲慢与偏见》" class="headerlink" title="《傲慢与偏见》"></a>《傲慢与偏见》</h3><p>主人公是谁？达西？宾利？简？</p><h3 id="《维特根斯坦传》"><a href="#《维特根斯坦传》" class="headerlink" title="《维特根斯坦传》"></a>《维特根斯坦传》</h3><h3 id="《图解HTTP》"><a href="#《图解HTTP》" class="headerlink" title="《图解HTTP》"></a>《图解HTTP》</h3><p>第二章</p><h3 id="《算法导论》"><a href="#《算法导论》" class="headerlink" title="《算法导论》"></a>《算法导论》</h3><h3 id="《自私的基因》"><a href="#《自私的基因》" class="headerlink" title="《自私的基因》"></a>《自私的基因》</h3><p>2月已一刷，对ESS理论有了进一步的理解</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年度计划</title>
      <link href="/2021/02/10/2021-nian-ji-hua/"/>
      <url>/2021/02/10/2021-nian-ji-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="2021年度计划"><a href="#2021年度计划" class="headerlink" title="2021年度计划"></a>2021年度计划</h1><p><strong>关键词：自由</strong></p><blockquote><p><strong>”凡事应该尽可能使其简单到不能再简单为止。“</strong></p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/v2-3edd43e2e69739a0c4be482bfa263602_720w.jpg" alt></p><h2 id="大二夏季学期计划"><a href="#大二夏季学期计划" class="headerlink" title="大二夏季学期计划"></a><strong>大二夏季学期计划</strong></h2><p>ASC超算竞赛</p><p>Flutter开发app</p><p>NLP神经网络</p><p>Deep Learning吴恩达深度学习</p><p>ACwing算法</p><p>CSAPP专业书籍阅读</p><p>王道计网、OS</p><p>小程序比赛</p><p>创新项目</p><p>2021阅读清单2.0</p><p><strong>待办</strong></p><p>nlp跑代码</p><p>Python教程修订</p><p><strong>心有余而力不足</strong></p><p>Datawhale开源之Web开发</p><p>Datawhale开源之《统计学习方法》编写组</p><p>Linux</p><h3 id="日程"><a href="#日程" class="headerlink" title="日程"></a><strong>日程</strong></h3><table><thead><tr><th>日期</th><th>任务1（早上+上午）</th><th>任务2（周末+晚上）</th><th>阅读计划（其他时间）</th><th>完成度</th></tr></thead><tbody><tr><td>第一周6.21-6.27</td><td>暑期大作业：游戏开发</td><td>吴恩达深度学习</td><td>《游戏改变世界》</td><td></td></tr><tr><td>第二周6.28-7.4</td><td>ACwing</td><td>Web开发</td><td>《labuladong算法小抄》</td><td></td></tr><tr><td>第三周7.5-7.11</td><td>ACwing</td><td></td><td></td><td></td></tr><tr><td>第四周7.12-7.18</td><td>ACwing</td><td>游戏项目收官</td><td></td><td></td></tr><tr><td>第五周7.19-7.25</td><td>7.16<strong>开始军训</strong></td><td></td><td>《穷查理宝典》</td><td></td></tr><tr><td>第六周7.26-8.1</td><td></td><td></td><td>《CS：APP》</td><td></td></tr><tr><td><strong>7.29</strong></td><td><strong>暑假开始</strong></td><td></td><td></td><td></td></tr><tr><td>第七周8.2-8.8</td><td>flutter</td><td>王道计网和OS</td><td>课本</td><td></td></tr><tr><td>第八周8.9-8.15</td><td>flutter</td><td></td><td>《CS：APP》</td><td></td></tr><tr><td>第九周8.16-8.22</td><td>flutter</td><td></td><td></td><td></td></tr><tr><td>第十周8.23-8.29</td><td>flutter</td><td></td><td></td><td></td></tr><tr><td>第十一周8.30-9.5</td><td>ASC</td><td></td><td></td><td></td></tr><tr><td><strong>9.6</strong></td><td><strong>大三开学</strong></td><td></td><td></td><td></td></tr></tbody></table><h3 id="个人计划"><a href="#个人计划" class="headerlink" title="个人计划"></a><strong>个人计划</strong></h3><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a><strong>运动</strong></h4><p>500km，<strong>健身计划</strong></p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a><strong>阅读</strong></h4><p><a href="https://henryavery.cn/2021/02/10/2-4-yue-yue-du-ji-hua/">2021的百日阅读计划1.0</a></p><h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a><strong>写作</strong></h4><p>五篇认真的书评或者读书笔记</p><h4 id="专业学习"><a href="#专业学习" class="headerlink" title="专业学习"></a><strong>专业学习</strong></h4><p><strong>CS</strong></p><p>《算法导论》</p><p>操作系统</p><p>计算机网络</p><p>Flutter</p><p>Java</p><p>Linux</p><p><del>Docker</del></p><p>MySQL</p><p>Go</p><p>NLP</p><p>吴恩达《深度学习》</p><p><strong>数学</strong></p><p>吴军博士在《数学之美》中这样描述：</p><blockquote><p>牛顿曾经说过，“真理在形式上从来都是简单的，而不是复杂和含混不清的”，数学之美也体现在这里。如果你能拿数学工具来解决问题，那么不管你的方法多复杂，这里面的基本思想都应格是简单的。</p></blockquote><p>查理芒格也说过：</p><blockquote><p>最好且最实用的智慧是最基本的学术智慧，但有一个相当重要的前提：必须从多元学科的角度来思考。在生活中应时常运用大学一年级基础学科中所有易学好懂的概念，如果达到自如运用的境界，就能提出解决问题的多种方法。</p></blockquote><p>实变函数与泛函分析</p><p>复习线性代数</p><h4 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a><strong>课外学习</strong></h4><p>《微观经济学原理》</p><p>《宏观经济学原理》</p><h4 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a><strong>英语学习</strong></h4><p><a href="https://zhuanlan.zhihu.com/p/359945906" target="_blank" rel="noopener">小天爷学英语</a></p><h4 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a><strong>兴趣</strong></h4><p>视频剪辑</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a><strong>资源</strong></h3><p><strong>bilibili大学</strong></p><p><a href="https://www.bilibili.com/video/BV1kE411E7HX?from=search&seid=1448930925957729165" target="_blank" rel="noopener">b站信息论</a></p><p><strong>关于考研</strong></p><p><a href="https://www.hackslog.com/blog/Life/about-PG-entrance-exam.html#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">关于考研灰熊的博客</a></p><p>清北复交</p><p><strong>信息管理</strong></p><p>了解GSOC相关信息</p><h2 id="大二春季学期计划"><a href="#大二春季学期计划" class="headerlink" title="大二春季学期计划"></a><strong>大二春季学期计划</strong></h2><p><strong>比赛or考试</strong></p><p>大英赛</p><p>英语六级600+</p><h3 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h3><h5 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a><strong>专业课</strong></h5><hr><p><strong>数据结构2</strong></p><p>46开</p><p><strong>离散数学2</strong></p><p>28开</p><p><strong>矩阵代数与应用</strong></p><p>37开，开卷考试（？）</p><p><strong>信息论</strong></p><p>37开，闭卷考试</p><h5 id="专业选修"><a href="#专业选修" class="headerlink" title="专业选修"></a><strong>专业选修</strong></h5><hr><p>大数据：从理论到实践</p><p>第五周reading paper（10p），第九周pre，考试周term paper（20p）</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210402203942530.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210402204108831.png" alt="image-20210402204108831"></p><h5 id="通选课"><a href="#通选课" class="headerlink" title="通选课"></a><strong>通选课</strong></h5><hr><p>人工智能与认知科学</p><p>《禅与摩托车维修艺术》读书笔记</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203134.jpg" alt></p><p>投资与理财</p><p>《穷查理宝典》读书笔记</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203032.jpg" alt></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h5><hr><p>人工智能进展</p><p>个人报告＋小组研讨</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203122.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210402203131.jpg" alt></p><p>欧洲文化入门</p><p>考试和上课无关，书前两章，背题库</p><p>乒乓球</p><p>左推侧身右攻，30km，五次课外，第二周开始</p><p>思政实践</p><p>略</p><h3 id="其他计划"><a href="#其他计划" class="headerlink" title="其他计划"></a>其他计划</h3><p>创新项目</p>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年终总结</title>
      <link href="/2021/02/10/2020-nian-zhong-zong-jie/"/>
      <url>/2021/02/10/2020-nian-zhong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年终总结（2-15）"><a href="#2020年终总结（2-15）" class="headerlink" title="2020年终总结（2.15）"></a>2020年终总结（2.15）</h1><p><strong>关键词：原点</strong></p><h2 id="一、结语"><a href="#一、结语" class="headerlink" title="一、结语"></a>一、结语</h2><blockquote><p><strong>“如果一个人和同伴的步调不一致，也许因为他听到的是不同的鼓点。让他跟着他听到的音乐前行吧，不管节奏是迟缓还是激越。”</strong></p><p>——<strong>梭罗</strong></p></blockquote><h2 id="二、年度计划及目标"><a href="#二、年度计划及目标" class="headerlink" title="二、年度计划及目标"></a>二、年度计划及目标</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><p>专业学习：选择专业，智能科学与技术，进入大二，开始正式学习专业课程，找到适合自己的学习方法，课前预习，课上刷题自学，总的来说还是自己还是很喜欢这个专业。能在大学学习自己喜欢的专业真的很美好。</p><p>课外学习：YC创业课20h，边练英语听力边学完。乐理课没上，但是在校内上了一门外国经典音乐，算是半只脚入门了古典，很喜欢莫扎特。地理知识还是没能补上，应该和科幻概论配套写作一起，主要是却写作素材，但是由于写作中断了所以这门课也不了了之。</p><p>科幻概论上了几次就没看了，也不是没时间，也不是不感兴趣，本来打算休闲的时候看一看，结果课外时间都浪费在了其他地方。</p><p>英语学习：练习口语以及思考学习英语的目的，制订了大学四年出国的英语学习计划，但是因为种种原因，只能先搁置，另辟蹊径，着眼于当下，半年之中仍未找到完整且可行的英语学习计划。所幸大一一年结束后仍在不同方面有巨大收获。百词斩上把六级托福考研单词也过了一遍，就是背完就忘了，真的不如墨墨背单词，单词主要还是要有复习和口头记忆。《新概念3》背一背也还不错，用得好的话是不错的英语资料，可惜后半年就没有再碰过了。</p><p>后半年重新开始使用app背单词，考过了一次四级，大二在学校里每天中午还经常做点阅读练习，可惜早上没有再坚持去食堂早读，冬天太冷了，返校四个月一眨眼就过了，这让我明白了一个道理，假如你么有一个良好的学习习惯，那就只能眼睁睁地虚度光阴。</p><h4 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h4><p>史蒂芬·柯维博士的《高效能人士的七个习惯》就是今年对我影响最大的书，没有之一。当然今年还有很多其他新读的书籍可能也一样重要，比如《原则》和《穷查理宝典》，可是最终都落在了这本书上，如果用一本书来代表我上半年来读的大部分书，那一定是《高效能人士的七个习惯》，因为我从一月份读到这本书，到了六月份仍在读这本书，并且依照此书开始制订出了我的人生系统1.0并且改进到了2.0。</p><h5 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h5><p>《一路向前》关于星巴克，卖咖啡的霍华德·舒尔茨，书中叙述了2007~2010年舒尔茨回归期间，在<em>星巴克</em>内外的一系列令人叹为观止的变革以及<em>星巴克</em>如何一如既往地坚守价值观以重新实现赢利和可持续发展的故事。</p><p>《考拉小巫的英语学习日记》学英语的，鸡汤味有点重，但确实有用，高中第一次读到这本书的还是同桌带到学校来的，让我和他一样对英语学习有了一种自信和执念。</p><p>《创意实现》创新创意的，帮助我写了大一的新研论文，属于用完即弃。</p><p><strong>《高效能人士的七个习惯》这半年最具有代表性的书</strong></p><p>《写给大家看的设计书》关于设计，生活中处处都有设计，我喜欢创作，但对于设计并不上心，直到有一天我真的用得上这些简单又实用的设计理念，需要别人告诉我什么样的设计才是好设计的时候，我才幡然醒悟自己居然忘记了这些简单的设计原则。</p><p>《原则》关于原则，每个人其实都有他们的原则，有一些成功的人会写下自己的原则，还有一些人会帮那些成功的人总结原则，但是古往今来，总有一些普世的原则需要遵守，结合《高效能人士的七个习惯》看完了前半部分，大概能够理解书中意而不用去记住书中具体细节，所以我一直觉得后半部分现在不需要花时间去读，如果哪天真的需要了，它一定再会出现在我的手边。</p><p>精读：</p><p>《滚雪球》关于股神巴菲特，我觉得这个世界上成功的人也分几种，一种是像巴菲特、比尔盖茨他们这样的，而另一种则是像富兰克林、曾国藩这样的。写了一篇书评，拿人物传记练习写书评，其实要写好难度也很大。我读传记有个小习惯，喜欢人物代入，揣摩人物心理变化，并且会关注书中出现的那些对于人的描写和形容词，一般褒义的形容词以后就可以记下来以后拿去夸别人，学习如何对他人给出评价并且称赞也很有意思。</p><p>《如何阅读一本书》关于阅读，每个人阅读之前应该阅读的第一本书，可能每一个喜欢阅读的人都会读过这本书，有时候共同语言就是这么来的，其实过完一年很容易就忘了书中的那些具体方法，但是大致的轮廓心中还是有的。</p><p>而且我发现如果要训练自己的阅读能力，换一种语言也是不错的尝试，比如阅读英文原版书，然后再按照《如何阅读一本书》的方法去进行阅读，可以感受到使用中文阅读时完全不同的阅读体会，而且我从今年开始对照译本阅读英文原版的时候，也会发现自己学习英语的乐趣增加了不少，所以决定在之后的阅读计划，除了由于我的英语能力还不足以进行原文阅读的原因外，不会再只读翻译的书籍了，读原版书一边也是在学英语，所以阅读速度慢一点也无所谓，但是要有方法地进行阅读。</p><p>重读：</p><p>《富兰克林自传》关于美国国父，通才，我的精神导师之一。一遍又一遍地重读这本不厚的自传，恨不得早点读过，但同时又会想假如真的在很小的年纪就阅读到这本传记，缺少了自己如今的思考，很可能不是一件好事，这点让我很矛盾。</p><p>《财务自由之路》关于赚钱，书的封面是7年赚到1000万，假如一个人18岁总的资产是10万，包括各种资源算进去，那么只要他的资产每年翻一番，7年就是128倍，等他25岁资产就能到一千万。</p><h5 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h5><p>略读：</p><p>《写给大家看的设计书》关于设计，设计的四个基本原则，从这本书学习一些简单的设计理念，还有“知其名”的意义。不管是一个概念还是一个人，只有你知道他的名字，你才能记住他。</p><p>《创业维艰》关于创业，大致翻了翻，主要是看本·霍洛维茨的创业故事，哪些具体的建议现在不打算看，等以后配上Stanford的创业课一起看，里面有一章“一对一沟通交流”，之前有问题找人沟通的时候确实有用到，就是一个提问指南，要用的时候才有用，用过了就记住了，用不上的话很快就忘了。就是这样的。</p><p>《鼠疫》因为这次肺炎流感才又找出来看的，很久没看这种文学书了，自己写作之后读文学能感觉到作者更多的东西，后面还听了文学院教授关于《鼠疫》的线上讲座，受益不少，虽然中午听睡着了。</p><p>《剑来》说好了和网络小说绝交，想了想这本书可能和其他网络小说还是有些不同的地方。主要是作者把传统哲学理念融入进了小说，我以前从没想过能把心学写进小说里，所以喜欢这种叙述方式，还有书中人物的知行合一和一些简单却深入人心的道理。但网络小说真的挺荼毒人的，都2021了还在更，虽然陈振华一个月也就写那么点，不像其他网络作家，每个月花两三个小时就能看完。但是每天早上起来追着看也真没啥意思，不如等他写完再看好了，从年初追到年尾不值得。</p><p>精读：</p><p>《海盗、囚徒与麻风病人：关于正义的十二堂课》，关于正义，读的第一本和法律有关的书，作者是一位宾夕法尼亚的刑法学教授，讨论在各种极端情况下生存与正义的平衡，除了法律和道德，我还从中了解了很多中国以外的历史，以及维根特斯坦的哲学理念，虽然还不是很懂，有点类似心学的知行合一。ps：喜欢Henry Avery这个英文名，所以就拿来自己用了。</p><p>《我跑步的时候谈什么》关于跑步，一本不是自传的自传，讲了一个跑步小说家对跑步和写作的一些看法，村上春树说出了写作和跑步的共同点。我也一样喜欢写作和跑步，所以从他那里学到不少。可惜今年后半年跑步运动少的可怜，比前半年还要少。</p><p>《沉默的大多数》关于写作，最喜欢的中国作家还是王小波，仿写波哥的杂文，喜欢这种幽默又带点讽刺的文风。</p><p>《鞋狗》关于Nike，奈特卖鞋发家的故事。对于这个人人熟知的品牌有了新的全面认识，从此Nike在我心里不再仅仅是一双鞋那么简单了。</p><p>重读：《如何阅读一本书》</p><h5 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h5><p>略读：《剑来》《我有一座恐怖屋》</p><p>想阅读这种无脑小说，就跟打游戏差不多，会导致各个方面的衰退，听有声书也有可能向小说发展，所以不能三心二意，该做什么就做什么，给自己点放松当奖励没问题，只是不要再边做其他事边学习了，这个原则和某条人生宪法一样，需要花大力气去克服。在学校每天都靠着耳机催眠入睡，十几二十分钟的也不是不行，只是自己很烦这种不算好的小习惯，索性下定决心慢慢戒掉。</p><p>精读：《中华帝国的衰落》书评</p><p>少了一篇书评，原因是没看完，睡前阅读的好习惯，读累了就睡，早上起不来就提醒一下早十分钟睡，睡不着就看书，起不来就早睡。</p><p>重读：《富兰克林自传》《三体》关于科幻，从小就很喜欢科幻小说，长大了也想写科幻小说，听说科学家的想象力不输科幻小说家，我觉得是真的，所以也想当一个能写科幻小说的科学家。</p><h5 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h5><p>略读：《诡秘之主》完结了，没啥看的。</p><p>精读：《邓小平时代》关于时代，对当代中国影响巨大的伟人，有一副脑图聚沙成塔就差这一点了。</p><p>重读：《浪潮之巅》《智能时代》选择专业，行业分析，吴军老师是影响我青年时期最大的作家之一，高中买了很多他的书，大学又买了他在得到APP上的课程，是一笔不小的投资，但是我觉得真的很值得。</p><h5 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h5><p>略读：《中国哲学简史》关于中国哲学，从某种意义上来说，中国哲学替代了宗教的作用。平时我们在写作和交流中也会聊到哲学，而我作为一个理工科的学生，在这一块的通识教育上还是又些欠缺的，要自己补上，这一点也是向吴军老师学到的。</p><p>精读：《今日简史》关于历史，世界历史以及应对今日危机。微信读书APP上看完的第一本电子书，用起来做笔记也很方便，只是不如第一次读《人类简史》那么震撼了，可能是边际效应递减了吧。</p><p>重读：《剑来》小说</p><h5 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h5><p>略读：《守夜者3》无聊，想起高考考数学前几天晚上好像还在看秦明写的《守夜者2》，这些中国的推理小说我真的不喜欢。</p><p>《白夜行》一年都只看这一本东野圭吾的书，日本人对于人心复杂社会黑暗的深刻描写，自己之前评价得好像还挺中二的，但我也不是很认真地评论，说实话，这本书打分高还是又理由的，只是我说不出一二三来了，读过也就读过了。</p><p>《洛克菲勒自传》又是传记，窥探上帝秘密的男人，还有他写给儿子的二十八封信。</p><h5 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h5><p>《Python从入门到实践》关于编程，对于专业相关的书在我没有达到一定的水平前不作任何评价，仅做简单的阅读记录和收获。</p><p>《钢铁枪炮与病菌》关于世界，世界为什么会是这个样子？探讨“终极”——地理决定论，一洲文运与武运。第一遍粗浅的阅读，还想尝试一下英文原版，没有多读几遍还是不要乱来，单词量太大了。</p><p>《创新者》专业素养，计算机技术发展史，创新者是一群什么样的人呢？</p><p>《围城》关于比喻之美，听说中国人不能不读，不然和别人沟通都会有困难，放假有空才可以多读点经典的文学书。</p><h5 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h5><p>略读：沃尔特·艾萨克森写的《富兰克林传》，进一步了解富兰克林本人。思考他传与自传，客观与主观。美国精神领袖之一，我比较想通过这本书了解他不曾在自传中提到的后半生。通过艾萨克森写的传记更加全面地了解他的一生，又或者是说，从别人的角度来看他的一生。</p><p>《剑来》小说，用典极多，前二十章人物及人心刻画及其传神，或情节略有网络小说特色，然仍有可取之处。</p><p>《中国哲学简史》关于儒释道，或许有人说冯友兰先生写的这本书全是抄的，但天下文章一“大”抄，怎么抄也是一门“大”学问。这本书最后一页有一句话让我印象深刻“<strong>人必须先说很多话，然后保持静默。</strong>”这本书带我初步认识了道家，了解道家思想，对比儒家思想，思考人类的未来，计算机的未来。</p><p>《旅行与读书》闲暇时翻阅，寥寥数语触动人心，旅行与读书，于人生的意义，于一个书呆子的意义。</p><p>《穷查理宝典》关于那个没有哪一天不读书的聪明人，查理·芒格的智慧。虽是相见恨晚，仍不愿快速读完。</p><p>《徐霞客游记》《夜航船》都是因为《剑来》所以才有兴趣动力去略读一二，不然就算接触到了也不会去找来看。</p><h5 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h5><p>略读：</p><p>《激荡三十年（上下）》关于商业，吴晓波作为财经作家的经历也很励志，书是借的反正看不坏，看多看少都是赚，刚回到学校没什么压力看书也很随意。</p><p>《上海早晨》关于上海大学的前世今生，还是社团发的书，不得不说很用心。</p><p>《通信之道》（专业需求）信号处理课带上不怕课听不懂，当初差点因为这本书想选通信专业。</p><p>精读：《人性的弱点》</p><p>重读：《数学之美》关于专业，可能正是因为在高中时读吴军老师这本书读的一知半解，所以我才有了今天这样的专业选择。</p><h5 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h5><p>《奇特的一生》讲述了一个将自己一生时间用来做计划的人。前苏联的柳比歇夫从26岁起便树立起自己在科学领域要完成的目标，并且此后一生都在为此计划。这一计划就是56年，直到他82岁去世，没有一天间歇。</p><p>柳比歇夫的自律和他的时间统计法可能不由得会让人想起曾国藩，他们也许从骨子里是同一种人，或者说他们身上都有着某种共性，又或许这就是人性的一部分，在我们每个人身上都存在着。我们会对他们奇特或伟大的一生产生共鸣，是因为我们也想过好自己的一生……</p><p>想起来自从回学校之后就没怎么用过番茄TODO统计时间，觉得没有必要记录每分钟，只要做好该做的事情就好了，但其实都只是自己找的借口。结果是不会骗人的，自己的计划有没有完成自己知道。所以这四十几天过的很快，就好像是时间推着我走，而我却抓不住时间。</p><p>《毛泽东传》罗斯，不评。</p><p>每周都说看书的时间来看论文，结果就是啥也没看啊。</p><h5 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h5><p>由于一个月没认真读书（课本倒是看得不算慢），所以半夜做梦都会惊醒。好好反思。</p><h5 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h5><p>同上，没怎么认真看书，看得比较随便，没有笔记也没有方法和计划，跟大一状态完全相反。</p><h4 id="写作计划"><a href="#写作计划" class="headerlink" title="写作计划"></a>写作计划</h4><p>搁置</p><h4 id="健身计划"><a href="#健身计划" class="headerlink" title="健身计划"></a>健身计划</h4><p>上半年还算正常，下半年运动量少的可怜，虽然真要花时间认真健身还是很难，但我还是想要在大学本科毕业的时候让自己焕然一新，彻头彻尾地改变一下。400km大半都是上半年跑的，冬天明显发现跑起来体力有些不如春天了。健身房还是可以每周去的。</p><h4 id="公益计划"><a href="#公益计划" class="headerlink" title="公益计划"></a>公益计划</h4><p>寒假和暑假完成了几次读书会，虽然因为疫情的原因没有达到预期，但是这部分计划可以算是额外加分项目，而且志愿者也参与了一次，对于志愿活动我也有自己的思考。</p><h4 id="投资计划"><a href="#投资计划" class="headerlink" title="投资计划"></a>投资计划</h4><p>说是投资计划，其实还是重在理性消费以及对于学习的投资，本来计划的学习内容像一些经济学和投资理论的书都没时间去看，其实想想不浪费时间是可以看完一遍的。把时间投资在有意义的地方，这就是我的投资计划。</p><h4 id="生活计划"><a href="#生活计划" class="headerlink" title="生活计划"></a>生活计划</h4><p>早睡早起不知道多少天，还是要早上五点起来比较适合我的习惯，到了计算机学院发现大家很多都是夜猫子类型，我不想改变自己的作息。</p><p>每次在家都会感冒一次，真的一病傻仨月。</p><p>一些小习惯还需要改掉。</p><h3 id="目标完成度"><a href="#目标完成度" class="headerlink" title="目标完成度"></a>目标完成度</h3><p>学业计划90%,绩点还差一些，需要提高目标。</p><p>阅读计划经调整变为专业书籍和英语原版书导向，总的来说可以达到70%的满意度，可以根据实际情况再调整。</p><p>写作计划20%，基本上完全搁置，不过有了自己的博客，对于写作的本身理解仍需要加深，早起写作和练英语可以尝试交替进行。</p><p>运动计划30%，同上，还是需要把运动当成爱好和习惯，可以不用太关注太高的目标和要求，但是要坚持，直到运动成为吃饭和喝水一样正常的习惯。</p><p>课外学习50%，还是少了点意思，制定计划的时候没考虑结合专业，由于专业特殊，课外可以学一点有用的专业技能。</p><p>人际关系50%，更改了一开始制定的计划，留待以后完成。</p><p>投资计划，不太好衡量，才发现这个okr一开始设计的时候就没考虑周全。</p><p>工作计划，同上。</p><h3 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h3><p>前半年时间记录用的番茄TODO，发现不太适合在校使用，索性换成块时间，在家记录起来也很方便，另外自己也在准备开发复盘和时间信息记录的APP工具了，等自己学会开发之后就打造一款自己专属的时间管理工具。</p><p>一年花了365h在b站上还是很恐怖，使用b站还是因为居家学习开始的，不知不觉成了重度使用者，每天大概有一个小时花在了屏幕上看一些没意义的视频，这让我自己都很难接受。在上面看电影也看的有点多，电影对于我来说基本上也只是打发时间的东西。</p><h2 id="三、每月复盘"><a href="#三、每月复盘" class="headerlink" title="三、每月复盘"></a>三、每月复盘</h2><p>一月：原则</p><p>二月：自律</p><p>三月：分心</p><p>四月：愚人</p><p>五月：断片</p><p>六月：考试</p><p>七月：蜕变</p><p>八月：散人</p><p>九月：CS</p><p>十月：时停</p><p>十一：刷番</p><p>十二：惜时</p><h2 id="四、角色扮演消化"><a href="#四、角色扮演消化" class="headerlink" title="四、角色扮演消化"></a>四、角色扮演消化</h2><p>大二学生：</p><p>专业：</p><h2 id="五、总结反思"><a href="#五、总结反思" class="headerlink" title="五、总结反思"></a>五、总结反思</h2><p>2020对我来说是关键的一年，但我收获的不是更多的喜悦，而是很多很多“正确的失败”。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021一月复盘</title>
      <link href="/2021/01/30/2021-1/"/>
      <url>/2021/01/30/2021-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一月复盘（1-30）"><a href="#一月复盘（1-30）" class="headerlink" title="一月复盘（1.30）"></a>一月复盘（1.30）</h1><h2 id="本月关键词：原点"><a href="#本月关键词：原点" class="headerlink" title="本月关键词：原点"></a>本月关键词：原点</h2><h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><blockquote><p><strong>“物来顺应，未来不迎，当事不杂，过往不恋。”</strong></p><p><strong>——曾国藩</strong></p></blockquote><h2 id="本月副本完成情况"><a href="#本月副本完成情况" class="headerlink" title="本月副本完成情况"></a>本月副本完成情况</h2><h3 id="1-学习工作副本"><a href="#1-学习工作副本" class="headerlink" title="1 学习工作副本"></a>1 学习工作副本</h3><p><strong>上课</strong></p><p>数据结构：这次小组作业真是太让人不放心了，好像多学点算法啊!!</p><p>机组：王道的书真好用，上课听不懂多刷题就完事了，有空刷刷csapp就当课外书看</p><p>概率论：刷题真有意思</p><p>离散数学：希望多学一点</p><p>英语：每周练一次听力，最后一周回来了忘了少了一次，后面补上。本来按计划是每天做一篇翻译题，到了一月底都还没开始做过。但是发现在阅读英语原版书的对照中文书阅读也可以训练翻译，觉得很多地方真的翻译的特别巧妙，在这之中体会到学习语言并使用的乐趣。养成了每天背英语单词的习惯，重新开始使用墨墨背单词app，从一百个加到两百再到三百，现在每天大概用四十分钟去复习两百个单词并且学一百个新词，<strong>一个月坚持下来能感受到效果</strong>，在看TED，做阅读或者听英语的时候经常碰到新学的六级单词，这种“眼熟”的感觉非常好，要继续努力学英语，争取大二过完六级前再准备一下雅思，以考促学。</p><p>六级阅读题，做了一周，被打断暂停了，下个月重启刷题，每天学两个小时英语。下个月英语单词应该也到了复习阶段了，可以多做点阅读使用起来。单词规划了3700个，平均每天100个寒假结束应该能到6k才对。那样返校之后正好就可以开始雅思的单词副本了。</p><p><strong>学习</strong></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113446714" target="_blank" rel="noopener">SHU机组实验</a></p><p><a href="https://blog.csdn.net/Henry_Avery/article/details/113407044" target="_blank" rel="noopener">吴恩达机器学习</a></p><h3 id="2-运动健康副本"><a href="#2-运动健康副本" class="headerlink" title="2 运动健康副本"></a>2 运动健康副本</h3><p>30km，2021年运动副本预热，放假前后没有怎么运动，寒假里过年要加强锻炼了。1km居然跑了三分五十秒，比起去年还要慢了，没能用上全力，大冬天的嗓子还是不太舒服，小命要紧。</p><h3 id="3-阅读写作副本"><a href="#3-阅读写作副本" class="headerlink" title="3 阅读写作副本"></a>3 阅读写作副本</h3><p><strong>阅读</strong></p><p>《穷查理宝典》现学现用。</p><p>《TED演讲》一边上吴笑老师的演讲课一边看书加深记忆，我一直觉得光上课不算学习，必须自己动手写一写，起码也得有本书在手上划一划才算是自己的学习。</p><p>《自私的基因》，一本不可多得的好书，目前还没读完，希望可以慢点读，同时找来了英文原版书也是很好的阅读材料，从今年开始正式开始阅读英文的原版书开始，渐渐喜欢上了这种原汁原味的阅读。</p><p>《游戏改变世界》，完整的去读这种畅销书已经没有意思了，读一点英文正好可以训练关键信息提取，感觉有意思的地方也可以读久一点，就当做英语阅读。 </p><p>或许我也该调整自己的阅读计划了：一个月挑选两本书比较合适，而且必须有一本是和专业有关的。</p><p><strong>写作</strong></p><p>开了巨多篇博客的坑，等着2021去填，比如2021新年计划</p><p><a href="https://henryavery.cn/2021/01/15/guan-yu-yi-ping-shui/">关于一瓶水</a></p><p><a href="https://henryavery.cn/2021/01/01/ren-ji-gong-sheng/">《人机共生》</a></p><p>每个周日的晚上都是想着第二天早点起床好写博客，结果就都是起不来，要么就是起来了做其他事情去了。</p><p><strong>观影</strong></p><p>看了一下自己这个月居然花了43个小时在娱乐上，其中一半是在b站看电影，之所以在b站是因为不小心冲了个流量送的大会员，然后另一半时间可能也都是在b站上看动漫了。统计一下看的电影，下个月要收敛一点，有更重要的事情要做。</p><p>《我和我的祖国》《动物世界》《魔鬼代言人》2021元旦第一天，放松一下充充电可以理解，完全就是静不下心复盘总结，总来想找件事来分散一下精力和精神，打发一下时间。最起码别伊始就像无头苍蝇一样乱撞，等自己慢慢缓过来。</p><p>《黑客帝国2》《黑客帝国3》很老的片子了，把计算机系统变成科幻电影脑洞真的大，计算机专业看这部电影真的时不时会心一笑。</p><p>《达拉斯买家俱乐部》也是很好的一部片子，重温了一遍《我不是药神》（发现自己第一次看的时候太感动了最后结尾没看明白，错过了不少细节）看到有人评论说这部电影，发现两部电影主题其实都是类似的，关于人性主题的电影往往都很复杂，但是拍出来也更容易打动人心。</p><p>《入侵华尔街》下饭片，没有英文字幕，不太好练英语，以后不看没字幕的片子。</p><p>《我不是传奇》《僵尸世界大战》无脑片，而且还不下饭，这种末世片我是真的不想再看了，但是每次过一段时间无聊了又会想找这种电影来打发时间，其实还不如看书有意思。</p><p>《传染病》回家高铁路上看的，看电影果然是打发时间的好方式，两个小时在车上读书是很累的，看电影就很轻松了，而且由于和现实有重叠部分，看这部片子也不会无聊。</p><p>《姜子牙》下饭，点了个外卖看了一中午，其实我觉得再好的电影也都是用来打发时间的，就跟有时候刷b站一样，本来就是抱着打发时间的目的去的，所以也要有所把控。</p><blockquote><p>好家伙，这四十个小时都够我看完三四本书了，要是把时间利用起来看一遍《CSAPP》该有多好</p></blockquote><h3 id="4-理财投资副本"><a href="#4-理财投资副本" class="headerlink" title="4 理财投资副本"></a>4 理财投资副本</h3><p>还真是不如拿着钱买一台新电脑，买点新软件也行，比如MarginNote3。</p><p>认识一个喜欢炒币的朋友，从他那里了解了一些关于比特币和区块链的知识，也是第一次在现实中看到有人炒比特币。</p><h3 id="5-人际交往副本"><a href="#5-人际交往副本" class="headerlink" title="5 人际交往副本"></a>5 人际交往副本</h3><p>新年还是花点心思群发一下祝福好了，想闲聊一下的正好也可以聊聊最近发生的事情，不要忘了积极主动的原则。也正好可以趁着新的开始梳理一下以前的人际关系，加的好友越来越多，反而更加需要上心，就当是另一种历练了。</p><p>研究关于社交网络的推荐算法，从量变引起质变，但我对线上社交的看法仍旧没有改变，除了扩大我们的社交圈以外没有更多的实际意义，人类的基因只允许我们和148个人有交集，因此对越是交往密切的人越应该保持慎重的态度。</p><p>这个月有很多比赛都在准备当中，因此花了不少时间在和同学讨论，放假以后更是一到周末晚上就得准备开线上会议。我不喜欢等到晚上再来讨论或者开会，因为白天时间其实更加充裕一些，晚上总是会有自己的事情要做，而且让大家为了会议去熬夜得不偿失</p><h3 id="6-生活习惯副本"><a href="#6-生活习惯副本" class="headerlink" title="6 生活习惯副本"></a>6 生活习惯副本</h3><p>早睡早起，偶尔出现打卡不起的情况，特别是回家以后，每天睡眠时长长达8个多小时，放松一周就差不多了，接下来的一年都要按照十点半早睡，五点早起的作息来完成早睡早起的flag。</p><p>每天起床做俯卧撑，微习惯。</p><p>每天看一个TED，时长无所谓，短一点五六分钟，长一点十七八分钟都可以，重要的是每天接触一些没有接触过的信息，我认为TED演讲是一个很好的思想传播平台。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/QQ%E5%9B%BE%E7%89%8720210130215234.jpg" alt="每天睡足8小时"></p><h3 id="7-其他计划副本"><a href="#7-其他计划副本" class="headerlink" title="7 其他计划副本"></a>7 其他计划副本</h3><p>2021年的新年计划1.0</p><p>对后面的大学学习做出了计划，分别对考研和保研做出了大致的规划和相应的了解。考虑再多加一条出国的路子备用，作为一个男人一定要小心，永远不能大意，给自己留后路就是要留一手准备。</p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>第一件事，关于“日记”。时间信息管理，简称“日记”。新年新气象，开始使用新的工具——块时间app——记录自己的时间，整理信息，日记也开始尝试用电子日记，甚至开始考虑自己开发软件帮助自己管理时间和信息，寒假里正好和同学开发移动应用，学习一下如何使用flutter，前端和数据库，希望能学以致用，知行合一。</p><p>奥卡姆剃刀：如无必要，勿增实体。</p><p>KISS：keep it simple and stupid</p><p>第二件事，关于阅读。原汁原味的英语阅读打开的一扇新的门，换一种语言反而能从基础开始训练自己的阅读能力。做一下100天的阅读计划，挑选六本书，不一定要每本都看完，提前计划，临时调整。我对于今年的阅读计划有一个简单的期望，就是多读一点专业书，其他的杂书如果要读那就读英语，但是不可以完全替代掉做英语阅读题，起码的刷题训练还是要的，希望自己可以喜欢上英语阅读。</p><p>第三件事，关于计划。对于2021有一个简单的启动计划，掏出一页纸总结去年的大目标，再根据大学四年的计划看看有哪些出入需要调整，写下2021年的几个大的目标，这就是我的新年仪式。等过年几天有空抽时间再整理一下，做成一年的计划。寒假也一样有寒假的计划，由于寒假时间太短，能够做的其实也不多，考试复习计划是其中重要的一部分。大学后面两年的学习计划也已经大致规划好了，接下来可以全力朝着一个方向努力，慢慢完成计划中的每一个环节。</p><p>第四件事，关于作息。睡了250个小时，好家伙，真就每天睡到8小时。施瓦辛格说过，如果你说你每天要睡8h，那就请睡“快”一点吧。其实我完全可以每天睡六小时就够了，回到家之后每天睡到超过早上五点半起床反而更困难，第一天回来睡到五点自然醒状态就很不错。我理想中的时间规划就是这样的，每天24h，工作或者说上课学习花去10h（其实每天平均两三堂课最多不过6h），路上花去两小时，那么如果睡六个小时的话，每天就能够有六个小时自己安排：2小时运动，2小时学英语（包括阅读和口语），1小时阅读，1小时写作。</p><p>第五件事，关于成长。我想说的成长是指专业学习上的成长，在大学里总有一种错觉，就是自己会怀疑自己是不是学的东西太少，学的还不够深，不够多，转而觉得时间不够用。其实这是一个很没有意义的事情，还不如去想想要怎么才能更好地利用时间。这一年里自己的成长好像也不是很大，有一部分原因可能是在家里蹲太久了，我一直觉得人只要呆在学校里就会受到教育，然而疫情导致我家里蹲的半年过的很没有章法，就好像成长的高速公路上突然堵得车水马龙了一样，这大概是我一辈子都不会忘记的经历。因为它带给了我惨痛的教训。</p><p>第六件事，关于思考。思考是训练大脑中的模型和框架，将参数调优。但是思考只是思考，没有输入有就没有输出，模型再优秀也是要拿来解决问题的。只有知行合一，才是真正的思考。</p><p>第七件事，关于人生。人生宪法是一个很神奇的东西，它会在某一个瞬间提醒我什么事情该做什么事情不改做，往往就是一个难以抉择的瞬间，它给我带来了启示和方向。一个人一辈子会读很多书，遇见很多人，很多事，但是每次遇到新的选择时都会需要进行新的抉择，而不是照搬过去的经验。就好像机器学习中的线上学习模型一样，会不断根据最近的输入去调整数学模型，然后去给出当前问题的答案。有时候我真的很需要人生宪法，它就像是老师，不经意地给我带来只言片语，却能帮助我找到自己的前进的方向。</p><h2 id="下月目标与计划"><a href="#下月目标与计划" class="headerlink" title="下月目标与计划"></a>下月目标与计划</h2><p><a href="https://henryavery.cn/2021/01/22/2021/">寒假计划</a></p><p>100天阅读计划</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达的机器学习课程笔记</title>
      <link href="/2021/01/25/ml/"/>
      <url>/2021/01/25/ml/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习"><a href="#吴恩达机器学习" class="headerlink" title="吴恩达机器学习"></a>吴恩达机器学习</h1><blockquote><p><strong>几乎每一个和我讨论过的人都同意，人生的最糟糕时期是在11岁到14岁。——《黑客与画家》</strong></p></blockquote><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>课程</p><p><a href="https://www.bilibili.com/video/BV164411b7dx?p=1" target="_blank" rel="noopener">b站[中英字幕]吴恩达机器学习系列课程</a></p><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习</a></p><p><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera深度学习</a></p><blockquote><p>主成分数据选择那里有一节课没有字幕，建议移步Coursera</p></blockquote><p>黄海广笔记</p><p><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener"><strong>Coursera深度学习教程中文笔记</strong></a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>斯坦福大学2014（吴恩达）机器学习教程中文笔记</strong></a></p><h1 id="第0天"><a href="#第0天" class="headerlink" title="第0天"></a>第0天</h1><p>搜集信息，注册Coursera，申请奖学金，安排学习计划。（2h）</p><h2 id="引言-Introduction"><a href="#引言-Introduction" class="headerlink" title="引言(Introduction)"></a>引言(Introduction)</h2><h3 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1.1 欢迎"></a>1.1 欢迎</h3><p>参考视频: 1 - 1 - Welcome (7 min).mkv</p><p>第一个视频主要讲了什么是机器学习，机器学习能做些什么事情。</p><h3 id="1-2-机器学习是什么？"><a href="#1-2-机器学习是什么？" class="headerlink" title="1.2 机器学习是什么？"></a>1.2 机器学习是什么？</h3><p>第一个机器学习的定义来自于<strong>Arthur Samuel</strong>。他定义机器学习为，在进行特定编程的情况下，给予计算机学习能力的领域。<strong>Samuel</strong>的定义可以回溯到50年代，他编写了一个西洋棋程序。</p><p>另一个年代近一点的定义，由<strong>Tom Mitchell</strong>提出，来自卡内基梅隆大学，<strong>Tom</strong>定义的机器学习是，一个好的学习问题定义如下，他说，一个程序被认为能从经验<strong>E</strong>中学习，解决任务<strong>T</strong>，达到性能度量值<strong>P</strong>，当且仅当，有了经验<strong>E</strong>后，经过<strong>P</strong>评判，程序在处理T时的性能有所提升。我认为经验<strong>E</strong> 就是程序上万次的自我练习的经验而任务<strong>T</strong> 就是下棋。性能度量值<strong>P</strong>呢，就是它在与一些新的对手比赛时，赢得比赛的概率。</p><p>目前存在几种不同类型的学习算法。主要的两种类型被我们称之为<strong>监督学习和无监督学习</strong>。此外你将听到诸如，强化学习和推荐系统等各种术语。这些都是机器学习算法的一员，以后我们都将介绍到，但学习算法最常用两个类型就是监督学习、无监督学习。我会在接下来的两个视频中给出它们的定义。本课中，我们将花费最多的精力来讨论这两种学习算法。而另一个会花费大量时间的任务是了解应用学习算法的实用建议。</p><h3 id="1-3-监督学习"><a href="#1-3-监督学习" class="headerlink" title="1.3 监督学习"></a>1.3 监督学习</h3><p>监督学习指的就是我们给学习算法一个数据集。这个数据集由“正确答案”组成。</p><p>回归这个词的意思是，我们在试着推测出这一系列连续值属性。</p><p>分类指的是，我们试着推测出离散的输出值：0或1良性或恶性，而事实上在分类问题中，输出可能不止两个值。</p><h3 id="1-4-无监督学习"><a href="#1-4-无监督学习" class="headerlink" title="1.4 无监督学习"></a>1.4 无监督学习</h3><p>所以这个就是无监督学习，因为我们没有提前告知算法一些信息，比如，这是第一类的人，那些是第二类的人，还有第三类，等等。我们只是说，是的，这是有一堆数据。我不知道数据里面有什么。我不知道谁是什么类型。我甚至不知道人们有哪些不同的类型，这些类型又是什么。但你能自动地找到数据中的结构吗？就是说你要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。</p><p>鸡尾酒宴问题</p><h1 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h1><h2 id="单变量线性回归-Linear-Regression-with-One-Variable"><a href="#单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="单变量线性回归(Linear Regression with One Variable)"></a>单变量线性回归(Linear Regression with One Variable)</h2><h3 id="2-1-模型表示"><a href="#2-1-模型表示" class="headerlink" title="2.1 模型表示"></a>2.1 模型表示</h3><h3 id="2-2-代价函数"><a href="#2-2-代价函数" class="headerlink" title="2.2 代价函数"></a>2.2 代价函数</h3><p>接下来我们会引入一些术语我们现在要做的便是为我们的模型选择合适的<strong>参数</strong>（<strong>parameters</strong>）</p><p>我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是<strong>建模误差</strong>（<strong>modeling error</strong>）。</p><p>我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。</p><p>代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。</p><h3 id="2-3-代价函数的直观理解I"><a href="#2-3-代价函数的直观理解I" class="headerlink" title="2.3 代价函数的直观理解I"></a>2.3 代价函数的直观理解I</h3><h3 id="2-4-代价函数的直观理解II"><a href="#2-4-代价函数的直观理解II" class="headerlink" title="2.4 代价函数的直观理解II"></a>2.4 代价函数的直观理解II</h3><h3 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h3><p>梯度下降是一个用来求函数最小值的算法</p><p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到找到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。</p><p>批量梯度下降（<strong>batch gradient descent</strong>）算法的公式为：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7da5a5f635b1eb552618556f1b4aac1a.png" alt="7da5a5f635b1eb552618556f1b4aac1a"></p><p>其中是学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/ef4227864e3cabb9a3938386f857e938.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/13176da01bb25128c91aca5476c9d464.png" alt></p><p>在梯度下降算法中，这是正确实现<strong>同时更新</strong>的方法。我不打算解释为什么你需要同时更新，同时更新是梯度下降中的一种常用方法。我们之后会讲到，同步更新是更自然的实现方法。当人们谈到梯度下降时，他们的意思就是同步更新。</p><h3 id="2-6-梯度下降的直观理解"><a href="#2-6-梯度下降的直观理解" class="headerlink" title="2.6 梯度下降的直观理解"></a>2.6 梯度下降的直观理解</h3><p>学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p><p>如果太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</p><p>如果太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果太大，它会导致无法收敛，甚至发散。</p><h3 id="2-7-梯度下降（gradient-descent）的线性回归"><a href="#2-7-梯度下降（gradient-descent）的线性回归" class="headerlink" title="2.7 梯度下降（gradient descent）的线性回归"></a>2.7 梯度下降（gradient descent）的线性回归</h3><p>实际上，在机器学习中，通常不太会给算法起名字，但这个名字”<strong>批量梯度下降</strong>”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有m个训练样本求和。</p><h2 id="线性代数回顾-Linear-Algebra-Review"><a href="#线性代数回顾-Linear-Algebra-Review" class="headerlink" title="线性代数回顾(Linear Algebra Review)"></a>线性代数回顾(Linear Algebra Review)</h2><p><strong>matlab</strong>中矩阵转置：直接打一撇，<code>x=y&#39;</code>。</p><h2 id="多变量线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多变量线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多变量线性回归(Linear Regression with Multiple Variables)"></a>多变量线性回归(Linear Regression with Multiple Variables)</h2><h3 id="4-1-多维特征"><a href="#4-1-多维特征" class="headerlink" title="4.1 多维特征"></a>4.1 多维特征</h3><h3 id="4-2-多变量梯度下降"><a href="#4-2-多变量梯度下降" class="headerlink" title="4.2 多变量梯度下降"></a>4.2 多变量梯度下降</h3><p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和</p><p>我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。 </p><p><strong>Python</strong> 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">computeCost</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">:</span>    inner <span class="token operator">=</span> np<span class="token punctuation">.</span>power<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">*</span> theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>inner<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-梯度下降法实践1-特征缩放"><a href="#4-3-梯度下降法实践1-特征缩放" class="headerlink" title="4.3 梯度下降法实践1-特征缩放"></a>4.3 梯度下降法实践1-特征缩放</h3><p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。</p><h3 id="4-4-梯度下降法实践2-学习率"><a href="#4-4-梯度下降法实践2-学习率" class="headerlink" title="4.4 梯度下降法实践2-学习率"></a>4.4 梯度下降法实践2-学习率</h3><p>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。</p><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率a过小，则达到收敛所需的迭代次数会非常高；如果学习率a过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p><h3 id="4-5-特征和多项式回归"><a href="#4-5-特征和多项式回归" class="headerlink" title="4.5 特征和多项式回归"></a>4.5 特征和多项式回归</h3><p>注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。</p><h3 id="4-6-正规方程Normal-Equation"><a href="#4-6-正规方程Normal-Equation" class="headerlink" title="4.6 正规方程Normal Equation"></a>4.6 正规方程Normal Equation</h3><h2 id="Octave教程-Octave-Tutorial"><a href="#Octave教程-Octave-Tutorial" class="headerlink" title="Octave教程(Octave Tutorial)"></a>Octave教程(Octave Tutorial)</h2><p>现在大家都用python了，octave不想再浪费时间去搞了，反正作业可以用matlab一样可以做。5.6向量化看一下，当你使用向量化地实现线性回归，通常运行速度就会比你以前用你的<strong>for循环</strong>快的多，也就是自己写代码更新。</p><h1 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h1><h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h2><h3 id="6-1-分类问题"><a href="#6-1-分类问题" class="headerlink" title="6.1 分类问题"></a>6.1 分类问题</h3><p>我们将学习一种叫做逻辑回归 (<strong>Logistic Regression</strong>) 的算法，这是目前最流行使用最广泛的一种学习算法。</p><p>我们从二元的分类问题开始讨论。</p><p>我们将因变量(<strong>dependent variable</strong>)可能属于的两个类分别称为负向类（<strong>negative class</strong>）和正向类（<strong>positive class</strong>），则因变量，其中 0 表示负向类，1 表示正向类。</p><p>顺便说一下，<strong>逻辑回归算法是分类算法</strong>，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上是一种分类算法</p><h3 id="6-2-假说表示"><a href="#6-2-假说表示" class="headerlink" title="6.2 假说表示"></a>6.2 假说表示</h3><p>逻辑回归模型的假设</p><h3 id="6-3-判定边界"><a href="#6-3-判定边界" class="headerlink" title="6.3 判定边界"></a>6.3 判定边界</h3><p>现在讲下决策边界(<strong>decision boundary</strong>)的概念。这个概念能更好地帮助我们理解逻辑回归的假设函数在计算什么。</p><p>我们可以用非常复杂的模型来适应非常复杂形状的判定边界。</p><h3 id="6-4-代价函数"><a href="#6-4-代价函数" class="headerlink" title="6.4 代价函数"></a>6.4 代价函数</h3><p>定义用来拟合参数的优化目标或者叫代价函数，这便是监督学习问题中的逻辑回归模型的拟合问题。</p><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将h()带入到这样定义了的代价函数中时，我们得到的代价函数将是一个非凸函数（<strong>non-convexfunction</strong>）。</p><p>这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p><p>我们重新定义逻辑回归的代价函数为</p><p>在得到这样一个代价函数以后，我们便可以用梯度下降算法来求得能使代价函数最小的参数了。算法为：</p><p>在这个视频中，我们定义了单训练样本的代价函数，凸性分析的内容是超出这门课的范围的，但是可以证明我们所选的代价值函数会给我们一个凸优化问题。代价函数会是一个凸函数，并且没有局部最优值。</p><p>注：虽然得到的梯度下降算法表面上看上去与线性回归的梯度下降算法一样，但是这里的${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$与线性回归中不同，所以实际上是不一样的。另外，在运行梯度下降算法之前，进行特征缩放依旧是非常必要的。</p><p>一些梯度下降算法之外的选择： 除了梯度下降算法以外，还有一些常被用来令代价函数最小的算法，这些算法更加复杂和优越，而且通常不需要人工选择学习率，通常比梯度下降算法要更加快速。这些算法有：<strong>共轭梯度</strong>（<strong>Conjugate Gradient</strong>），<strong>局部优化法</strong>(<strong>Broyden fletcher goldfarb shann,BFGS</strong>)和<strong>有限内存局部优化法</strong>(<strong>LBFGS</strong>) ，<strong>fminunc</strong>是 <strong>matlab</strong>和<strong>octave</strong> 中都带的一个最小值优化函数，使用时我们需要提供代价函数和每个参数的求导，下面是 <strong>octave</strong> 中使用 <strong>fminunc</strong> 函数的代码示例</p><h3 id="6-5-简化的成本函数和梯度下降"><a href="#6-5-简化的成本函数和梯度下降" class="headerlink" title="6.5 简化的成本函数和梯度下降"></a>6.5 简化的成本函数和梯度下降</h3><p>找出一种稍微简单一点的方法来写代价函数，来替换我们现在用的方法。同时我们还要弄清楚如何运用梯度下降法，来拟合出逻辑回归的参数。。因此，听了这节课，你就应该知道如何实现一个完整的逻辑回归算法。</p><p>最小化代价函数的方法，是使用<strong>梯度下降法</strong>(<strong>gradient descent</strong>)。这是我们的代价函数：</p><p>如果我们要最小化这个关于$\theta$的函数值，这就是我们通常用的梯度下降法的模板。</p><p>因此，即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p><p>在先前的视频中，当我们在谈论线性回归的梯度下降法时，我们谈到了如何监控梯度下降法以确保其收敛，我通常也把同样的方法用在逻辑回归中，来监测梯度下降，以确保它正常收敛。</p><p>最后还有一点，我们之前在谈线性回归时讲到的特征缩放，我们看到了特征缩放是如何提高梯度下降的收敛速度的，这个特征缩放的方法，也适用于逻辑回归。如果你的特征范围差距很大的话，那么应用特征缩放的方法，同样也可以让逻辑回归中，梯度下降收敛更快。</p><p>就是这样，现在你知道如何实现逻辑回归，这是一种非常强大，甚至可能世界上使用最广泛的一种分类算法。</p><h3 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h3><p>使通过梯度下降，进行逻辑回归的速度大大提高，而这也将使算法更加适合解决大型的机器学习问题</p><p>这三种算法有许多优点：</p><h3 id="6-7-多类别分类：一对多"><a href="#6-7-多类别分类：一对多" class="headerlink" title="6.7 多类别分类：一对多"></a>6.7 多类别分类：一对多</h3><p>如何使用逻辑回归 (<strong>logistic regression</strong>)来解决多类别分类问题，具体来说，我想通过一个叫做”一对多” (<strong>one-vs-all</strong>) 的分类算法。</p><p>我们先从用三角形代表的类别1开始，实际上我们可以创建一个，新的”伪”训练集，类型2和类型3定为负类，类型1设定为正类，我们创建一个新的训练集，如下图所示的那样，我们要拟合出一个合适的分类器。</p><p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。</p><h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化(Regularization)"></a>正则化(Regularization)</h2><h3 id="7-1-过拟合的问题-over-fitting"><a href="#7-1-过拟合的问题-over-fitting" class="headerlink" title="7.1 过拟合的问题(over-fitting)"></a>7.1 过拟合的问题(<strong>over-fitting</strong>)</h3><p>如果我们发现了过拟合问题，应该如何处理？</p><ol><li>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li><li>正则化。 保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）。</li></ol><h3 id="7-2-代价函数"><a href="#7-2-代价函数" class="headerlink" title="7.2 代价函数"></a>7.2 代价函数</h3><p>正则化参数（<strong>Regularization Parameter</strong>）。 </p><h3 id="7-3-正则化线性回归"><a href="#7-3-正则化线性回归" class="headerlink" title="7.3 正则化线性回归"></a>7.3 正则化线性回归</h3><p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程。</p><p>我们同样也可以利用正规方程来求解正则化线性回归模型</p><h3 id="7-4-正则化的逻辑回归模型"><a href="#7-4-正则化的逻辑回归模型" class="headerlink" title="7.4 正则化的逻辑回归模型"></a>7.4 正则化的逻辑回归模型</h3><p>针对逻辑回归问题，我们在之前的课程已经学习过两种优化算法：我们首先学习了使用梯度下降法来优化代价函数$J\left( \theta \right)$，接下来学习了更高级的优化算法，这些高级优化算法需要你自己设计代价函数$J\left( \theta \right)$。</p><p>自己计算导数同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数：</p><h2 id="神经网络：表述-Neural-Networks-Representation"><a href="#神经网络：表述-Neural-Networks-Representation" class="headerlink" title="神经网络：表述(Neural Networks: Representation)"></a>神经网络：表述(Neural Networks: Representation)</h2><h3 id="8-1-非线性假设"><a href="#8-1-非线性假设" class="headerlink" title="8.1 非线性假设"></a>8.1 非线性假设</h3><p>我们之前学的，无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p><p>普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要神经网络。</p><h3 id="8-2-神经元和大脑"><a href="#8-2-神经元和大脑" class="headerlink" title="8.2 神经元和大脑"></a>8.2 神经元和大脑</h3><p>神经网络是一种很古老的算法，它最初产生的目的是制造能模拟大脑的机器。</p><h3 id="8-3-模型表示1"><a href="#8-3-模型表示1" class="headerlink" title="8.3 模型表示1"></a>8.3 模型表示1</h3><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？每一个神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>）。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被称为权重（<strong>weight</strong>）。</p><p>神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。下图为一个3层的神经网络，第一层成为输入层（<strong>Input Layer</strong>），最后一层称为输出层（<strong>Output Layer</strong>），中间一层成为隐藏层（<strong>Hidden Layers</strong>）。我们为每一层都增加一个偏差单位（<strong>bias unit</strong>）：</p><p>（我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )）</p><h3 id="8-4-模型表示2"><a href="#8-4-模型表示2" class="headerlink" title="8.4 模型表示2"></a>8.4 模型表示2</h3><p>( <strong>FORWARD PROPAGATION</strong> ) 相对于使用循环来编码，利用向量化的方法会使得计算更为简便。</p><h3 id="8-5-特征和直观理解1"><a href="#8-5-特征和直观理解1" class="headerlink" title="8.5 特征和直观理解1"></a>8.5 特征和直观理解1</h3><p><strong>OR</strong>与<strong>AND</strong>整体一样，区别只在于的取值不同。</p><h3 id="8-6-样本和直观理解II"><a href="#8-6-样本和直观理解II" class="headerlink" title="8.6 样本和直观理解II"></a>8.6 样本和直观理解II</h3><p>二元逻辑运算符（<strong>BINARY LOGICAL OPERATORS</strong>）当输入特征为布尔值（0或1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。</p><h3 id="8-7-多类分类"><a href="#8-7-多类分类" class="headerlink" title="8.7 多类分类"></a>8.7 多类分类</h3><h2 id="神经网络的学习-Neural-Networks-Learning"><a href="#神经网络的学习-Neural-Networks-Learning" class="headerlink" title="神经网络的学习(Neural Networks: Learning)"></a>神经网络的学习(Neural Networks: Learning)</h2><h3 id="9-1-代价函数"><a href="#9-1-代价函数" class="headerlink" title="9.1 代价函数"></a>9.1 代价函数</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/8f7c28297fc9ed297f42942018441850.jpg" alt></p><h3 id="9-2-反向传播算法"><a href="#9-2-反向传播算法" class="headerlink" title="9.2 反向传播算法"></a>9.2 反向传播算法</h3><h3 id="9-3-反向传播算法的直观理解"><a href="#9-3-反向传播算法的直观理解" class="headerlink" title="9.3 反向传播算法的直观理解"></a>9.3 反向传播算法的直观理解</h3><h3 id="9-4-实现注意：展开参数"><a href="#9-4-实现注意：展开参数" class="headerlink" title="9.4 实现注意：展开参数"></a>9.4 实现注意：展开参数</h3><h3 id="9-5-梯度检验"><a href="#9-5-梯度检验" class="headerlink" title="9.5 梯度检验"></a>9.5 梯度检验</h3><p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。</p><p>为了避免这样的问题，我们采取一种叫做梯度的数值检验（<strong>Numerical Gradient Checking</strong>）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。</p><h3 id="9-6-随机初始化"><a href="#9-6-随机初始化" class="headerlink" title="9.6 随机初始化"></a>9.6 随机初始化</h3><p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为0，这将意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非0的数，结果也是一样的。</p><p>我们通常初始参数为正负ε之间的随机值</p><h3 id="9-7-综合起来"><a href="#9-7-综合起来" class="headerlink" title="9.7 综合起来"></a>9.7 综合起来</h3><p>我们真正要决定的是隐藏层的层数和每个中间层的单元数。</p><p>训练神经网络：</p><ol><li><p>参数的随机初始化</p></li><li><p>利用正向传播方法计算所有的h</p></li><li><p>编写计算代价函数 J的代码</p></li><li><p>利用反向传播方法计算所有偏导数</p></li><li><p>利用数值检验方法检验这些偏导数</p></li><li><p>使用优化算法来最小化代价函数</p></li></ol><h3 id="9-8-自主驾驶"><a href="#9-8-自主驾驶" class="headerlink" title="9.8 自主驾驶"></a>9.8 自主驾驶</h3><p>这就是基于神经网络的自动驾驶技术。当然，我们还有很多更加先进的试验来实现自动驾驶技术。在美国，欧洲等一些国家和地区，他们提供了一些比这个方法更加稳定的驾驶控制技术。但我认为，使用这样一个简单的基于反向传播的神经网络，训练出如此强大的自动驾驶汽车，的确是一次令人惊讶的成就。</p><h2 id="应用机器学习的建议-Advice-for-Applying-Machine-Learning"><a href="#应用机器学习的建议-Advice-for-Applying-Machine-Learning" class="headerlink" title="应用机器学习的建议(Advice for Applying Machine Learning)"></a>应用机器学习的建议(Advice for Applying Machine Learning)</h2><h3 id="10-1-决定下一步做什么"><a href="#10-1-决定下一步做什么" class="headerlink" title="10.1 决定下一步做什么"></a>10.1 决定下一步做什么</h3><p>当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？</p><ol><li><p>获得更多的训练样本——通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。</p></li><li><p>尝试减少特征的数量</p></li><li><p>尝试获得更多的特征</p></li><li><p>尝试增加多项式特征</p></li><li><p>尝试减少正则化程度</p></li><li><p>尝试增加正则化程度</p></li></ol><p>我们不应该随机选择上面的某种方法来改进我们的算法，而是运用一些机器学习诊断法来帮助我们知道上面哪些方法对我们的算法是有效的。</p><h3 id="10-2-评估一个假设"><a href="#10-2-评估一个假设" class="headerlink" title="10.2 评估一个假设"></a>10.2 评估一个假设</h3><p>为了检验算法是否过拟合，我们将数据分成训练集和测试集，通常用70%的数据作为训练集，用剩下30%的数据作为测试集。很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行“洗牌”，然后再分成训练集和测试集。</p><p>测试集评估在通过训练集让我们的模型学习得出其参数后，对测试集运用该模型，我们有两种方式计算误差：</p><ol><li>对于线性回归模型，我们利用测试集数据计算代价函数J</li><li>对于逻辑回归模型，我们除了可以利用测试数据集来计算代价函数外：</li></ol><p>误分类的比率，对于每一个测试集样本，计算：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/751e868bebf4c0bf139db173d25e8ec4.png" alt></p><p>然后对计算结果求平均。</p><h3 id="10-3-模型选择和交叉验证集"><a href="#10-3-模型选择和交叉验证集" class="headerlink" title="10.3 模型选择和交叉验证集"></a>10.3 模型选择和交叉验证集</h3><p>适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用交叉验证集来帮助选择模型。</p><p>即：使用60%的数据作为训练集，使用 20%的数据作为交叉验证集，使用20%的数据作为测试集</p><p>模型选择的方法为：</p><ol><li><p>使用训练集训练出10个模型</p></li><li><p>用10个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</p></li><li><p>选取代价函数值最小的模型</p></li><li><p>用步骤3中选出的模型对测试集计算得出推广误差（代价函数的值）</p></li></ol><h3 id="10-4-诊断偏差和方差"><a href="#10-4-诊断偏差和方差" class="headerlink" title="10.4 诊断偏差和方差"></a>10.4 诊断偏差和方差</h3><p>训练集误差和交叉验证集误差近似时：偏差/欠拟合</p><p>交叉验证集误差远大于训练集误差时：方差/过拟合</p><h3 id="10-5-正则化和偏差-方差"><a href="#10-5-正则化和偏差-方差" class="headerlink" title="10.5 正则化和偏差/方差"></a>10.5 正则化和偏差/方差</h3><p>选择$\lambda$的方法为：</p><ol><li>使用训练集训练出12个不同程度正则化的模型</li><li>用12个模型分别对交叉验证集计算的出交叉验证误差</li><li>选择得出交叉验证误差<strong>最小</strong>的模型</li><li>运用步骤3中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与λ的值绘制在一张图表上：</li></ol><p>• 当 $\lambda$ 较小时，训练集误差较小（过拟合）而交叉验证集误差较大</p><p>• 随着 $\lambda$ 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</p><h3 id="10-6-学习曲线"><a href="#10-6-学习曲线" class="headerlink" title="10.6 学习曲线"></a>10.6 学习曲线</h3><p>学习曲线就是一种很好的工具，我经常使用学习曲线来判断某一个学习算法是否处于偏差、方差问题。学习曲线是学习算法的一个很好的<strong>合理检验</strong>（<strong>sanity check</strong>）。学习曲线是将训练集误差和交叉验证集误差作为训练集样本数量的函数绘制的图表。</p><p>如何利用学习曲线识别高偏差/欠拟合：作为例子，我们尝试用一条直线来适应下面的数据，可以看出，无论训练集有多么大误差都不会有太大改观：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/4a5099b9f4b6aac5785cb0ad05289335.jpg" alt></p><p>也就是说在高偏差/欠拟合的情况下，增加数据到训练集不一定能有帮助。</p><p>如何利用学习曲线识别高方差/过拟合：假设我们使用一个非常高次的多项式模型，并且正则化非常小，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2977243994d8d28d5ff300680988ec34.jpg" alt></p><p>也就是说在高方差/过拟合的情况下，增加更多数据到训练集可能可以提高算法效果。</p><h3 id="10-7-决定下一步做什么"><a href="#10-7-决定下一步做什么" class="headerlink" title="10.7 决定下一步做什么"></a>10.7 决定下一步做什么</h3><p>哪些方法可能有助于改进学习算法的效果，而哪些可能是徒劳的呢？</p><p>回顾 1.1 中提出的六种可选的下一步，让我们来看一看我们在什么情况下应该怎样选择：</p><ol><li><p>获得更多的训练样本——解决高方差</p></li><li><p>尝试减少特征的数量——解决高方差</p></li><li><p>尝试获得更多的特征——解决高偏差</p></li><li><p>尝试增加多项式特征——解决高偏差</p></li><li><p>尝试减少正则化程度λ——解决高偏差</p></li><li><p>尝试增加正则化程度λ——解决高方差</p></li></ol><p>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。</p><p>对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络，<br>然后选择交叉验证集代价最小的神经网络。</p><h1 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h1><h2 id="机器学习系统的设计-Machine-Learning-System-Design"><a href="#机器学习系统的设计-Machine-Learning-System-Design" class="headerlink" title="机器学习系统的设计(Machine Learning System Design)"></a>机器学习系统的设计(Machine Learning System Design)</h2><h3 id="11-1-首先要做什么"><a href="#11-1-首先要做什么" class="headerlink" title="11.1 首先要做什么"></a>11.1 首先要做什么</h3><p>以一个垃圾邮件分类器算法为例进行讨论。</p><p>为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量$x$。我们可以选择一个由100个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否有在邮件中出现，来获得我们的特征向量（出现为1，不出现为0），尺寸为100×1。</p><p>为了构建这个分类器算法，我们可以做很多事，例如：</p><ol><li><p>收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件的样本</p></li><li><p>基于邮件的路由信息开发一系列复杂的特征</p></li><li><p>基于邮件的正文信息开发一系列复杂的特征，包括考虑截词的处理</p></li><li><p>为探测刻意的拼写错误（把<strong>watch</strong> 写成<strong>w4tch</strong>）开发复杂的算法</p></li></ol><h3 id="11-2-误差分析"><a href="#11-2-误差分析" class="headerlink" title="11.2 误差分析"></a>11.2 误差分析</h3><p>误差分析（<strong>Error Analysis</strong>）的概念。这会帮助你更系统地做出决定。如果你准备研究机器学习的东西，或者构造机器学习应用程序，最好的实践方法不是建立一个非常复杂的系统，拥有多么复杂的变量；而是构建一个简单的算法，这样你可以很快地实现它。</p><p>构建一个学习算法的推荐方法为：</p><p>1.从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法</p><p>2.绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</p><p>3.进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的样本，看看这些样本是否有某种系统化的趋势</p><h3 id="11-3-类偏斜的误差度量"><a href="#11-3-类偏斜的误差度量" class="headerlink" title="11.3 类偏斜的误差度量"></a>11.3 类偏斜的误差度量</h3><p>类偏斜情况表现为我们的训练集中有非常多的同一种类的样本，只有很少或没有其他类的样本。</p><p><strong>查准率</strong>（<strong>Precision</strong>）和<strong>查全率</strong>（<strong>Recall</strong>） 我们将算法预测的结果分成四种情况：</p><p>1.<strong>正确肯定</strong>（<strong>True Positive,TP</strong>）：预测为真，实际为真</p><p>2.<strong>正确否定</strong>（<strong>True Negative,TN</strong>）：预测为假，实际为假</p><p>3.<strong>错误肯定</strong>（<strong>False Positive,FP</strong>）：预测为真，实际为假</p><p>4.<strong>错误否定</strong>（<strong>False Negative,FN</strong>）：预测为假，实际为真</p><p>则：查准率=<strong>TP/(TP+FP)</strong>。例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。</p><p>查全率=<strong>TP/(TP+FN)</strong>。例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p><p>这样，对于我们刚才那个总是预测病人肿瘤为良性的算法，其查全率是0。</p><table><thead><tr><th></th><th></th><th><strong>预测值</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td><strong>Positive</strong></td><td><strong>Negtive</strong></td></tr><tr><td><strong>实际值</strong></td><td><strong>Positive</strong></td><td><strong>TP</strong></td><td><strong>FN</strong></td></tr><tr><td></td><td><strong>Negtive</strong></td><td><strong>FP</strong></td><td><strong>TN</strong></td></tr></tbody></table><h3 id="11-4-查准率和查全率之间的权衡"><a href="#11-4-查准率和查全率之间的权衡" class="headerlink" title="11.4 查准率和查全率之间的权衡"></a>11.4 查准率和查全率之间的权衡</h3><p>我们希望有一个帮助我们选择这个阀值的方法。一种方法是计算<strong>F1 值</strong>（<strong>F1 Score</strong>），其计算公式为：</p><p>我们选择使得<strong>F1</strong>值最高的阀值。</p><h3 id="11-5-机器学习的数据"><a href="#11-5-机器学习的数据" class="headerlink" title="11.5 机器学习的数据"></a>11.5 机器学习的数据</h3><p>在一定的条件下，得到大量的数据并在某种类型的学习算法中进行训练，可以是一种有效的方法来获得一个具有良好性能的学习算法。</p><h2 id="支持向量机-Support-Vector-Machines"><a href="#支持向量机-Support-Vector-Machines" class="headerlink" title="支持向量机(Support Vector Machines)"></a>支持向量机(Support Vector Machines)</h2><h3 id="12-1-优化目标"><a href="#12-1-优化目标" class="headerlink" title="12.1 优化目标"></a>12.1 优化目标</h3><p>与逻辑回归和神经网络相比，支持向量机，或者简称<strong>SVM</strong>，在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p><h3 id="12-2-大边界的直观理解"><a href="#12-2-大边界的直观理解" class="headerlink" title="12.2 大边界的直观理解"></a>12.2 大边界的直观理解</h3><p>这就相当于在支持向量机中嵌入了一个额外的安全因子，或者说安全的间距因子。</p><p>支持向量机将会选择这个黑色的决策边界，相较于之前我用粉色或者绿色画的决策界。这条黑色的看起来好得多，黑线看起来是更稳健的决策界。在分离正样本和负样本上它显得的更好。数学上来讲，这是什么意思呢？这条黑线有更大的距离，这个距离叫做间距(<strong>margin</strong>)。</p><p>这个距离叫做支持向量机的间距，而这是支持向量机具有<strong>鲁棒性</strong>的原因，因为它努力用一个最大间距来分离样本。因此支持向量机有时被称为<strong>大间距分类器</strong></p><p>关于大间距分类器，我想讲最后一点：我们将这个大间距分类器中的正则化因子常数$C$设置的非常大，我记得我将其设置为了100000，因此对这样的一个数据集，也许我们将选择这样的决策界，从而最大间距地分离开正样本和负样本。那么在让代价函数最小化的过程中，我们希望找出在$y=1$和$y=0$两种情况下都使得代价函数中左边的这一项尽量为零的参数。如果我们找到了这样的参数，则我们的最小化问题便转变成：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f4b6dee99cfb4352b3cac5287002e8de.png" alt></p><p>事实上，支持向量机现在要比这个大间距分类器所体现得更成熟，尤其是当你使用大间距分类器的时候，你的学习算法会受异常点(outlier) 的影响。比如我们加入一个额外的正样本。</p><p>C 较大时，相当于 lambda​ 较小，可能会导致过拟合，高方差。</p><p>C​ 较小时，相当于lambda较大，可能会导致低拟合，高偏差。</p><h3 id="12-3-大边界分类背后的数学（选修）"><a href="#12-3-大边界分类背后的数学（选修）" class="headerlink" title="12.3 大边界分类背后的数学（选修）"></a>12.3 大边界分类背后的数学（选修）</h3><p>因此支持向量机做的全部事情，就是<strong>极小化参数向量</strong>范数的平方，或者说长度的平方。</p><h3 id="12-4-核函数1"><a href="#12-4-核函数1" class="headerlink" title="12.4 核函数1"></a>12.4 核函数1</h3><p>给定一个训练样本$x$，我们利用$x$的各个特征与我们预先选定的<strong>地标</strong>(<strong>landmarks</strong>)的近似程度来选取新的特征。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/2516821097bda5dfaf0b94e55de851e0.png" alt></p><h3 id="12-5-核函数2"><a href="#12-5-核函数2" class="headerlink" title="12.5 核函数2"></a>12.5 核函数2</h3><p>如何选择地标？</p><h3 id="12-6-使用支持向量机"><a href="#12-6-使用支持向量机" class="headerlink" title="12.6 使用支持向量机"></a>12.6 使用支持向量机</h3><p>在高斯核函数之外我们还有其他一些选择，如：</p><p>多项式核函数（<strong>Polynomial Kerne</strong>l）</p><p>字符串核函数（<strong>String kernel</strong>）</p><p>卡方核函数（ <strong>chi-square kernel</strong>）</p><p>直方图交集核函数（<strong>histogram intersection kernel</strong>）</p><p>等等…</p><p>这些核函数的目标也都是根据训练集和地标之间的距离来构建新特征，这些核函数需要满足Mercer’s定理，才能被支持向量机的优化软件正确处理。</p><p><strong>多类分类问题</strong></p><p>尽管你不去写你自己的<strong>SVM</strong>的优化软件，但是你也需要做几件事：</p><p>1、是提出参数的选择。我们在之前的视频中讨论过误差/方差在这方面的性质。</p><p>2、你也需要选择内核参数或你想要使用的相似函数，其中一个选择是：我们选择不需要任何内核参数，没有内核参数的理念，也叫线性核函数。因此，如果有人说他使用了线性核的<strong>SVM</strong>（支持向量机），这就意味这他使用了不带有核函数的<strong>SVM</strong>（支持向量机）。</p><p>从逻辑回归模型，我们得到了支持向量机模型，在两者之间，我们应该如何选择呢？</p><p><strong>下面是一些普遍使用的准则：</strong></p><h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类(Clustering)"></a>聚类(Clustering)</h2><h3 id="13-1-无监督学习：简介"><a href="#13-1-无监督学习：简介" class="headerlink" title="13.1 无监督学习：简介"></a>13.1 无监督学习：简介</h3><p>在一个典型的监督学习中，我们有一个有标签的训练集，我们的目标是找到能够区分正样本和负样本的决策边界，在这里的监督学习中，我们有一系列标签，我们需要据此拟合一个假设函数。与此不同的是，在非监督学习中，我们的数据没有附带任何标签</p><h3 id="13-2-K-均值算法"><a href="#13-2-K-均值算法" class="headerlink" title="13.2 K-均值算法"></a>13.2 K-均值算法</h3><p><strong>K-均值</strong>是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。</p><p><strong>K-均值</strong>是一个迭代算法，假设我们想要将数据聚类成n个组，其方法为:</p><h3 id="13-3-优化目标"><a href="#13-3-优化目标" class="headerlink" title="13.3 优化目标"></a>13.3 优化目标</h3><p>K-均值最小化问题，是要最小化所有的数据点与其所关联的聚类中心点之间的距离之和，因此<br>K-均值的代价函数（又称<strong>畸变函数</strong> <strong>Distortion function</strong>）为：</p><h3 id="13-4-随机初始化"><a href="#13-4-随机初始化" class="headerlink" title="13.4 随机初始化"></a>13.4 随机初始化</h3><p>在运行K-均值算法的之前，我们首先要随机初始化所有的聚类中心点，下面介绍怎样做：</p><h3 id="13-5-选择聚类数"><a href="#13-5-选择聚类数" class="headerlink" title="13.5 选择聚类数"></a>13.5 选择聚类数</h3><p>没有所谓最好的选择聚类数的方法，通常是需要根据不同的问题，人工进行选择的。选择的时候思考我们运用<strong>K-均值</strong>算法聚类的动机是什么，然后选择能最好服务于该目的标聚类数。</p><h2 id="降维-Dimensionality-Reduction"><a href="#降维-Dimensionality-Reduction" class="headerlink" title="降维(Dimensionality Reduction)"></a>降维(Dimensionality Reduction)</h2><h3 id="14-1-动机一：数据压缩"><a href="#14-1-动机一：数据压缩" class="headerlink" title="14.1 动机一：数据压缩"></a>14.1 动机一：数据压缩</h3><p>第二种类型的无监督学习问题，称为降维。有几个不同的的原因使你可能想要做降维。一是数据压缩，后面我们会看了一些视频后，数据压缩不仅允许我们压缩数据，因而使用较少的计算机内存或磁盘空间，但它也让我们加快我们的学习算法。</p><h3 id="14-2-动机二：数据可视化"><a href="#14-2-动机二：数据可视化" class="headerlink" title="14.2 动机二：数据可视化"></a>14.2 动机二：数据可视化</h3><p>在许多及其学习问题中，如果我们能将数据可视化，我们便能寻找到一个更好的解决方案，降维可以帮助我们。</p><p>这样做的问题在于，降维的算法只负责减少维数，新产生的特征的意义就必须由我们自己去发现了。</p><h3 id="14-3-主成分分析问题"><a href="#14-3-主成分分析问题" class="headerlink" title="14.3 主成分分析问题"></a>14.3 主成分分析问题</h3><p>主成分分析(<strong>PCA</strong>)是最常见的降维算法。</p><p>在<strong>PCA</strong>中，我们要做的是找到一个方向向量（<strong>Vector direction</strong>），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。</p><p>面给出主成分分析问题的描述：</p><p>主成分分析与线性回归是两种不同的算法。主成分分析最小化的是投射误差（<strong>Projected Error</strong>），而线性回归尝试的是最小化预测误差。线性回归的目的是预测结果，而主成分分析不作任何预测。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/7e1389918ab9358d1432d20ed20f8142.png" alt="7e1389918ab9358d1432d20ed20f8142"></p><p>左边的是线性回归的误差（垂直于横轴投影），右边则是主要成分分析的误差（垂直于红线投影）。</p><p><strong>PCA</strong>将n个特征降维到k个，可以用来进行数据压缩，如果100维的向量最后可以用10维来表示，那么压缩率为90%。同样图像处理领域的<strong>KL变换</strong>使用<strong>PCA</strong>做图像压缩。但<strong>PCA</strong> 要保证降维后，还要保证数据的特性损失最小。</p><p><strong>PCA</strong>技术的一大好处是对数据进行降维的处理。我们可以对新求出的“主元”向量的重要性进行排序，根据需要取前面最重要的部分，将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息。</p><p><strong>PCA</strong>技术的一个很大的优点是，它是完全无参数限制的。在<strong>PCA</strong>的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。</p><p>但是，这一点同时也可以看作是缺点。如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。</p><h3 id="14-4-主成分分析算法"><a href="#14-4-主成分分析算法" class="headerlink" title="14.4 主成分分析算法"></a>14.4 主成分分析算法</h3><p>第一步是均值归一化。</p><p>第二步是计算<strong>协方差矩阵</strong>（<strong>covariance matrix</strong>)</p><p>第三步是计算协方差矩阵的<strong>特征向量</strong>（<strong>eigenvectors</strong>）:</p><h3 id="14-5-选择主成分的数量"><a href="#14-5-选择主成分的数量" class="headerlink" title="14.5 选择主成分的数量"></a>14.5 选择主成分的数量</h3><p>主要成分分析是减少投射的平均均方误差：</p><blockquote><p>方差越大，表明这个特征里数据分布的离散程度就越大，特征所包含的信息量就越大；反之，如果特征里数据的方差小，分布集中，则表明其包含的信息量就小。那么，我们自然选择保留信息量大的那个特征了。</p></blockquote><h3 id="14-6-重建的压缩表示"><a href="#14-6-重建的压缩表示" class="headerlink" title="14.6 重建的压缩表示"></a>14.6 重建的压缩表示</h3><h3 id="14-7-主成分分析法的应用建议"><a href="#14-7-主成分分析法的应用建议" class="headerlink" title="14.7 主成分分析法的应用建议"></a>14.7 主成分分析法的应用建议</h3><pre><code>  1. 第一步是运用主要成分分析将数据压缩至1000个特征  2. 然后对**训练集**运行学习算法  3. 在预测时，采用之前学习而来的U将输入的特征x转换成特征向量z，然后再进行预测</code></pre><p>错误的主要成分分析情况：一个常见错误使用主要成分分析的情况是，将其用于减少过拟合（减少了特征的数量）。这样做非常不好，不如尝试正则化处理。原因在于主要成分分析只是近似地丢弃掉一些特征，它并不考虑任何与结果变量有关的信息，因此可能会丢失非常重要的特征。然而当我们进行正则化处理时，会考虑到结果变量，不会丢掉重要的数据。</p><p>另一个常见的错误是，默认地将主要成分分析作为学习过程中的一部分，这虽然很多时候有效果，最好还是从所有原始特征开始，只在有必要的时候（算法运行太慢或者占用太多内存）才考虑采用主要成分分析。</p><h2 id="异常检测-Anomaly-Detection"><a href="#异常检测-Anomaly-Detection" class="headerlink" title="异常检测(Anomaly Detection)"></a>异常检测(Anomaly Detection)</h2><h3 id="15-1-问题的动机"><a href="#15-1-问题的动机" class="headerlink" title="15.1 问题的动机"></a>15.1 问题的动机</h3><p>异常检测(<strong>Anomaly detection</strong>)问题。这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于：它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。</p><p>异常检测主要用来识别欺骗。例如在线采集而来的有关用户的数据，一个特征向量中可能会包含如：用户多久登录一次，访问过的页面，在论坛发布的帖子数量，甚至是打字速度等。尝试根据这些特征构建一个模型，可以用这个模型来识别那些不符合该模式的用户。</p><h3 id="15-2-高斯分布"><a href="#15-2-高斯分布" class="headerlink" title="15.2 高斯分布"></a>15.2 高斯分布</h3><p>回顾高斯分布的基本知识。</p><h3 id="15-3-算法"><a href="#15-3-算法" class="headerlink" title="15.3 算法"></a>15.3 算法</h3><p>异常检测算法：</p><h3 id="15-4-开发和评价一个异常检测系统"><a href="#15-4-开发和评价一个异常检测系统" class="headerlink" title="15.4 开发和评价一个异常检测系统"></a>15.4 开发和评价一个异常检测系统</h3><p>具体的评价方法如下：</p><h3 id="15-5-异常检测与监督学习对比"><a href="#15-5-异常检测与监督学习对比" class="headerlink" title="15.5 异常检测与监督学习对比"></a>15.5 异常检测与监督学习对比</h3><table><thead><tr><th>异常检测</th><th>监督学习</th></tr></thead><tbody><tr><td>非常少量的正向类（异常数据 ）, 大量的负向类（）</td><td>同时有大量的正向类和负向类</td></tr><tr><td>许多不同种类的异常，非常难。根据非常 少量的正向类数据来训练算法。</td><td>有足够多的正向类实例，足够用于训练 算法，未来遇到的正向类实例可能与训练集中的非常近似。</td></tr><tr><td>未来遇到的异常可能与已掌握的异常、非常的不同。</td><td></td></tr><tr><td>例如： 欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况</td><td>例如：邮件过滤器 天气预报 肿瘤分类</td></tr></tbody></table><h3 id="15-6-选择特征"><a href="#15-6-选择特征" class="headerlink" title="15.6 选择特征"></a>15.6 选择特征</h3><p>对于异常检测算法，我们使用的特征是至关重要的，下面谈谈如何选择特征：</p><p>异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布</p><p>误差分析：</p><p>我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小），例如，在检测数据中心的计算机状况的例子中，我们可以用<strong>CPU</strong>负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。</p><h3 id="15-7-多元高斯分布（选修）"><a href="#15-7-多元高斯分布（选修）" class="headerlink" title="15.7 多元高斯分布（选修）"></a>15.7 多元高斯分布（选修）</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/598db991a7c930c9021cec5f6ab9beb9.png" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/29df906704d254f18e92a63173dd51e7.jpg" alt></p><p>上图是5个不同的模型，从左往右依次分析：</p><ol><li><p>是一个一般的高斯分布模型</p></li><li><p>通过协方差矩阵，令特征1拥有较小的偏差，同时保持特征2的偏差</p></li><li><p>通过协方差矩阵，令特征2拥有较大的偏差，同时保持特征1的偏差</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的正相关性</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的负相关性</p></li></ol><p>多元高斯分布模型与原高斯分布模型的关系：</p><p>可以证明的是，原本的高斯分布模型是多元高斯分布模型的一个子集，即像上图中的第1、2、3，3个例子所示，如果协方差矩阵只在对角线的单位上有非零的值时，即为原本的高斯分布模型了。</p><p>原高斯分布模型和多元高斯分布模型的比较：</p><table><thead><tr><th>原高斯分布模型</th><th>多元高斯分布模型</th></tr></thead><tbody><tr><td>不能捕捉特征之间的相关性 但可以通过将特征进行组合的方法来解决</td><td>自动捕捉特征之间的相关性</td></tr><tr><td>计算代价低，能适应大规模的特征</td><td>计算代价较高 训练集较小时也同样适用</td></tr><tr><td></td><td>必须要有 m&gt;n​，不然的话协方差矩阵不可逆的，通常需要 m&gt;10n​另外特征冗余也会导致协方差矩阵不可逆</td></tr></tbody></table><p>原高斯分布模型被广泛使用着，如果特征之间在某种程度上存在相互关联的情况，我们可以通过构造新新特征的方法来捕捉这些相关性。</p><p>如果训练集不是太大，并且没有太多的特征，我们可以使用多元高斯分布模型。</p><h3 id="15-8-使用多元高斯分布进行异常检测（可选）"><a href="#15-8-使用多元高斯分布进行异常检测（可选）" class="headerlink" title="15.8 使用多元高斯分布进行异常检测（可选）"></a>15.8 使用多元高斯分布进行异常检测（可选）</h3><p>原始模型和多元高斯分布比较如图：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f4585239738f2b5149608879fa166889.png" alt></p><h2 id="推荐系统-Recommender-Systems"><a href="#推荐系统-Recommender-Systems" class="headerlink" title="推荐系统(Recommender Systems)"></a>推荐系统(Recommender Systems)</h2><h3 id="16-1-问题形式化"><a href="#16-1-问题形式化" class="headerlink" title="16.1 问题形式化"></a>16.1 问题形式化</h3><blockquote><p>机器学习中的大思想</p></blockquote><p>我们从一个例子开始定义推荐系统的问题。</p><p>假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。</p><h3 id="16-2-基于内容的推荐系统"><a href="#16-2-基于内容的推荐系统" class="headerlink" title="16.2 基于内容的推荐系统"></a>16.2 基于内容的推荐系统</h3><h3 id="16-3-协同过滤"><a href="#16-3-协同过滤" class="headerlink" title="16.3 协同过滤"></a>16.3 协同过滤</h3><h3 id="16-4-协同过滤算法"><a href="#16-4-协同过滤算法" class="headerlink" title="16.4 协同过滤算法"></a>16.4 协同过滤算法</h3><h3 id="16-5-向量化：低秩矩阵分解"><a href="#16-5-向量化：低秩矩阵分解" class="headerlink" title="16.5 向量化：低秩矩阵分解"></a>16.5 向量化：低秩矩阵分解</h3><p>实现一种选择的方法，写出协同过滤算法的预测情况。</p><p>通过这个方法，希望你能知道，如何进行一个向量化的计算来对所有的用户和所有的电影进行评分计算。同时希望你也能掌握，通过学习特征参数，来找到相关电影和产品的方法。</p><h3 id="16-6-推行工作上的细节：均值归一化"><a href="#16-6-推行工作上的细节：均值归一化" class="headerlink" title="16.6 推行工作上的细节：均值归一化"></a>16.6 推行工作上的细节：均值归一化</h3><p>如果我们新增一个用户 <strong>Eve</strong>，并且 <strong>Eve</strong> 没有为任何电影评分，那么我们以什么为依据为<strong>Eve</strong>推荐电影呢？</p><p>我们首先需要对结果矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值：</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9ec5cb55e14bd1462183e104f8e02b80.png" alt></p><p>然后我们利用这个新的Y矩阵来训练算法。<br>如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，对于<strong>Eve</strong>，我们的新模型会认为她给每部电影的评分都是该电影的平均分。</p><h2 id="大规模机器学习-Large-Scale-Machine-Learning"><a href="#大规模机器学习-Large-Scale-Machine-Learning" class="headerlink" title="大规模机器学习(Large Scale Machine Learning)"></a>大规模机器学习(Large Scale Machine Learning)</h2><h3 id="17-1-大型数据集的学习"><a href="#17-1-大型数据集的学习" class="headerlink" title="17.1 大型数据集的学习"></a>17.1 大型数据集的学习</h3><p>如果我们有一个低方差的模型，增加数据集的规模可以帮助你获得更好的结果。我们应该怎样应对一个有100万条记录的训练集？</p><p>首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用1000个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。</p><h3 id="17-2-随机梯度下降法"><a href="#17-2-随机梯度下降法" class="headerlink" title="17.2 随机梯度下降法"></a>17.2 随机梯度下降法</h3><p>如果我们一定需要一个大规模的训练集，我们可以尝试使用随机梯度下降法来代替批量梯度下降法。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9710a69ba509a9dcbca351fccc6e7aae.jpg" alt></p><h3 id="17-3-小批量梯度下降"><a href="#17-3-小批量梯度下降" class="headerlink" title="17.3 小批量梯度下降"></a>17.3 小批量梯度下降</h3><p>小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数b次训练实例，便更新一次参数</p><h3 id="17-4-随机梯度下降收敛"><a href="#17-4-随机梯度下降收敛" class="headerlink" title="17.4 随机梯度下降收敛"></a>17.4 随机梯度下降收敛</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/76fb1df50bdf951f4b880fa66489e367.png" alt></p><h3 id="17-5-在线学习"><a href="#17-5-在线学习" class="headerlink" title="17.5 在线学习"></a>17.5 在线学习</h3><p>在这个视频中，讨论一种新的大规模的机器学习机制，叫做在线学习机制。在线学习机制让我们可以模型化问题。</p><p>今天，许多大型网站或者许多大型网络公司，使用不同版本的在线学习机制算法，从大批的涌入又离开网站的用户身上进行学习。特别要提及的是，如果你有一个由连续的用户流引发的连续的数据流，进入你的网站，你能做的是使用一个在线学习机制，从数据流中学习用户的偏好，然后使用这些信息来优化一些关于网站的决策。</p><p>一个算法来从中学习的时候来模型化问题在线学习算法指的是对数据流而非离线的静态数据集的学习。许多在线网站都有持续不断的用户流，对于每一个用户，网站希望能在不将数据存储到数据库中便顺利地进行算法学习。</p><p>在线学习的算法与随机梯度下降算法有些类似，我们对单一的实例进行学习，而非对一个提前定义的训练集进行循环。</p><p>一旦对一个数据的学习完成了，我们便可以丢弃该数据，不需要再存储它了。这种方式的好处在于，我们的算法可以很好的适应用户的倾向性，算法可以针对用户的当前行为不断地更新模型以适应该用户。</p><p><strong>每次交互事件并不只产生一个数据集</strong>，例如，我们一次给用户提供3个物流选项，用户选择2项，我们实际上可以获得3个新的训练实例，因而我们的算法可以一次从3个实例中学习并更新模型。</p><p>在线学习的一个优点就是，如果你有一个变化的用户群，又或者你在尝试预测的事情，在缓慢变化，就像你的用户的品味在缓慢变化，这个在线学习算法，可以慢慢地调试你所学习到的假设，将其调节更新到<strong>最新的用户行为</strong>。</p><h3 id="17-6-映射化简和数据并行"><a href="#17-6-映射化简和数据并行" class="headerlink" title="17.6 映射化简和数据并行"></a>17.6 映射化简和数据并行</h3><p>映射化简和数据并行对于大规模机器学习问题而言是非常重要的概念。</p><p>如果我们能够将我们的数据集分配给不多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计所的结果汇总在求和。这样的方法叫做映射简化。</p><p>具体而言，如果任何学习算法能够表达为，对训练集的函数的求和，那么便能将这个任务分配给多台计算机（或者同一台计算机的不同<strong>CPU</strong> 核心），以达到加速处理的目的。</p><h2 id="应用实例：图片文字识别-Application-Example-Photo-OCR"><a href="#应用实例：图片文字识别-Application-Example-Photo-OCR" class="headerlink" title="应用实例：图片文字识别(Application Example: Photo OCR)"></a>应用实例：图片文字识别(Application Example: Photo OCR)</h2><h3 id="18-1-问题描述和流程图Problem-Description-and-Pipeline"><a href="#18-1-问题描述和流程图Problem-Description-and-Pipeline" class="headerlink" title="18.1 问题描述和流程图Problem Description and Pipeline"></a>18.1 问题描述和流程图Problem Description and Pipeline</h3><p>图像文字识别应用所作的事是，从一张给定的图片中识别文字。这比从一份扫描文档中识别文字要复杂的多。</p><p>为了完成这样的工作，需要采取如下步骤：</p><ol><li><p>文字侦测（<strong>Text detection</strong>）——将图片上的文字与其他环境对象分离开来</p></li><li><p>字符切分（<strong>Character segmentation</strong>）——将文字分割成一个个单一的字符</p></li><li><p>字符分类（<strong>Character classification</strong>）——确定每一个字符是什么<br>可以用任务流程图来表达这个问题，每一项任务可以由一个单独的小队来负责解决：</p></li></ol><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/610fffb413d8d577882d6345c166a9fb.png" alt></p><h3 id="18-2-滑动窗口"><a href="#18-2-滑动窗口" class="headerlink" title="18.2 滑动窗口"></a>18.2 滑动窗口</h3><p>滑动窗口是一项用来从图像中抽取对象的技术。假使我们需要在一张图片中识别行人，首先要做的是用许多固定尺寸的图片来训练一个能够准确识别行人的模型。然后我们用之前训练识别行人的模型时所采用的图片尺寸在我们要进行行人识别的图片上进行剪裁，然后将剪裁得到的切片交给模型，让模型判断是否为行人，然后在图片上滑动剪裁区域重新进行剪裁，将新剪裁的切片也交给模型进行判断，如此循环直至将图片全部检测完。</p><p>滑动窗口技术也被用于文字识别，首先训练模型能够区分字符与非字符，然后，运用滑动窗口技术识别字符，一旦完成了字符的识别，我们将识别得出的区域进行一些扩展，然后将重叠的区域进行合并。接着我们以宽高比作为过滤条件，过滤掉高度比宽度更大的区域（认为单词的长度通常比高度要大）。</p><p>模型训练完后，我们仍然是使用滑动窗口技术来进行字符识别。</p><p>以上便是字符切分阶段。</p><p>最后一个阶段是字符分类阶段，利用神经网络、支持向量机或者逻辑回归算法训练一个分类器即可。</p><h3 id="18-3-获取大量数据和人工数据"><a href="#18-3-获取大量数据和人工数据" class="headerlink" title="18.3 获取大量数据和人工数据"></a>18.3 获取大量数据和人工数据</h3><p>如果我们的模型是低方差的，那么获得更多的数据用于训练模型，是能够有更好的效果的。问题在于，我们怎样获得数据，数据不总是可以直接获得的，我们有可能需要人工地创造一些数据。</p><p>有关获得更多数据的几种方法：</p><pre><code>1. 人工数据合成2. 手动收集、标记数据3. 众包</code></pre><h3 id="18-4-上限分析：哪部分管道的接下去做"><a href="#18-4-上限分析：哪部分管道的接下去做" class="headerlink" title="18.4 上限分析：哪部分管道的接下去做"></a>18.4 上限分析：哪部分管道的接下去做</h3><p>在机器学习的应用中，我们通常需要通过几个步骤才能进行最终的预测，我们如何能够知道哪一部分最值得我们花时间和精力去改善呢？这个问题可以通过上限分析来回答。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/f1ecee10884098f98032648da08f8937.jpg" alt></p><h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结(Conclusion)"></a>总结(Conclusion)</h2><p>作为这门课的结束时间，那么我们学到了些什么呢？在这门课中，我们花了大量的时间介绍了诸如<strong>线性回归、逻辑回归、神经网络、支持向量机</strong>等等一些<strong>监督学习算法</strong>，这类算法具有带标签的数据和样本.</p><p>然后我们也花了很多时间介绍<strong>无监督学习</strong>。例如 <strong>K-均值聚类</strong>、<strong>用于降维的主成分分析</strong>，以及当你只有一系列无标签数据时的<strong>异常检测算法</strong>。</p><p>当然，有时带标签的数据，也可以用于异常检测算法的评估。此外，我们也花时间讨论了一些特别的应用或者特别的话题，比如说<strong>推荐系统</strong>。以及<strong>大规模机器学习系统</strong>，包括<strong>并行系统和映射化简方法，</strong>还有其他一些特别的应用。比如，用于计算机视觉技术的<strong>滑动窗口分类</strong>算法。</p><p>最后，我们还提到了很多关于<strong>构建机器学习系统的实用建议</strong>。这包括了怎样理解某个机器学习算法是否正常工作的原因，所以我们谈到了<strong>偏差和方差</strong>的问题，也谈到了解决<strong>方差问题的正则化</strong>，同时我们也讨论了怎样决定接下来<strong>怎么做</strong>的问题，也就是说当你在开发一个机器学习系统时，什么工作才是接下来应该优先考虑的问题。因此我们讨论了学习算法的<strong>评价法</strong>。介绍了评价矩阵，比如：<strong>查准率、召回率以及F1分数，还有评价学习算法比较实用的训练集、交叉验证集和测试集</strong>。我们也介绍了<strong>学习算法</strong>的调试，以及如何确保学习算法的正常运行，于是我们介绍了一些诊断法，比如<strong>学习曲线</strong>，同时也讨论了<strong>误差分析、上限分析</strong>等等内容。</p><p>所有这些工具都能有效地指引你决定接下来应该怎样做，让你把宝贵的时间用在刀刃上。现在你已经掌握了很多机器学习的工具，包括监督学习算法和无监督学习算法等等。</p><p>但除了这些以外，我更希望你现在不仅仅只是认识这些工具，更重要的是掌握怎样有效地利用这些工具来建立强大的机器学习系统。所以，以上就是这门课的全部内容。如果你跟着我们的课程一路走来，到现在，你应该已经感觉到自己已经成为机器学习方面的专家了吧？</p><p>我们都知道，机器学习是一门对科技、工业产生深远影响的重要学科，而现在，你已经完全具备了应用这些机器学习工具来创造伟大成就的能力。我希望你们中的很多人都能在相应的领域，应用所学的机器学习工具，构建出完美的机器学习系统，开发出无与伦比的产品和应用。并且我也希望你们通过应用机器学习，不仅仅改变自己的生活，有朝一日，还要让更多的人生活得更加美好！</p><p>我也想告诉大家，教这门课对我来讲是一种享受。所以，谢谢大家！</p><p>最后，在结束之前，我还想再多说一点：那就是，也许不久以前我也是一个学生，即使是现在，我也尽可能挤出时间听一些课，学一些新的东西。所以，我深知要坚持学完这门课是很需要花一些时间的，我知道，也许你是一个很忙的人，生活中有很多很多事情要处理。正因如此，你依然挤出时间来观看这些课程视频。我知道，很多视频的时间都长达数小时，你依然花了好多时间来做这些复习题。你们中好多人，还愿意花时间来研究那些编程练习，那些又长又复杂的编程练习。我对你们表示衷心的感谢！我知道你们很多人在这门课中都非常努力，很多人都在这门课上花了很多时间，很多人都为这门课贡献了自己的很多精力。所以，我衷心地希望你们能从这门课中有所收获！</p><p>最后我想说！再次感谢你们选修这门课程！</p><p><strong>Andew Ng</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>申请Coursera奖学金拿证书</p><blockquote><p>I am a Master student at Shang Hai  University which located in China，I’m so sorry I’m so poor to afford the cost in China All my income is just enough to cover my living expense, so I don’t have extra money to register the class. Furthermore, I want to save money for my family Since my parents have been working so hard to support me.For nowadays ，machine learning is so hot not only in China but also in the world I request Coursera for financial aid, and I promise I will finish the course in time. I think Coursera is a very good platform for people to learn something they need, and sincerely hoping to learn something. This program provided by Coursera is a great opportunity for a poor student like me to pursue the course, and I hope I can get the chance. Thank you for your consideration. I hope you can agree with my application. I look forward to your reply.Thank you so much</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Processing</title>
      <link href="/2021/01/22/processing/"/>
      <url>/2021/01/22/processing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter七天入门</title>
      <link href="/2021/01/22/flutter/"/>
      <url>/2021/01/22/flutter/</url>
      
        <content type="html"><![CDATA[<h2 id="七天学习Flutter"><a href="#七天学习Flutter" class="headerlink" title="七天学习Flutter"></a>七天学习Flutter</h2><h3 id="入门资料"><a href="#入门资料" class="headerlink" title="入门资料"></a>入门资料</h3><p><a href="https://blog.csdn.net/qq_41976613/article/details/91432304" target="_blank" rel="noopener">android studio的安装，史上最详细(超多图)！！</a></p><p><a href="http://hukai.me/android-training-course-in-chinese/basics/index.html" target="_blank" rel="noopener">Android入门基础：从这里开始</a></p><p><a href="https://www.cnblogs.com/ztpark/p/7698640.html" target="_blank" rel="noopener">Android Studio 运行 React Native 开发手机App 起步和踩坑</a></p><p><a href="http://laomengit.com/guide/introduction/mobile_system.html" target="_blank" rel="noopener">Flutter实战</a></p><p><a href="https://www.wolai.com/gfDRYkDNaCU1eg9anNvZay" target="_blank" rel="noopener">Flutter资源整理</a></p><p><a href="https://flutter.cn/docs/development/ui/widgets-intro" target="_blank" rel="noopener">Widgets 介绍</a></p><p><a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/declarative" target="_blank" rel="noopener">状态管理中的声明式编程思维</a></p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p><a href="https://blog.csdn.net/yechaoa/article/details/89150852" target="_blank" rel="noopener">Flutter环境配置</a></p><p><a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=windows" target="_blank" rel="noopener">Flutter SDK releases</a></p><p><a href="https://www.mockplus.cn/?home=1" target="_blank" rel="noopener">慕客</a></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ul><li><p>运行flutter doctor 命令报错</p><p>解决的时候注意使用管理员权限运行bat文件</p></li><li><p>Android studio 升级到4.1之后出现 flutter dart 插件找不到问题</p></li></ul><p>  其实也可以不管，项目可以正常运行。</p><p><a href="https://blog.csdn.net/wwp9527/article/details/113120829?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">Android studio4.1之后Flutter更新</a></p><p><a href="https://blog.csdn.net/tw2496907023/article/details/111243230" target="_blank" rel="noopener">【flutter环境问题】Downloading Dart SDK Flutter engine时卡着不动</a></p><p><strong>注意</strong>：现在Flutter只能用<strong>JDK8</strong>！！！ 否则会报错说：Exception in thread “main” java.lang.NoclassDefFoundError</p><p>配置镜像源</p><p>FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a> PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210216201127115.png" alt="image-20210216201127115"></p><h2 id="学习过程记录"><a href="#学习过程记录" class="headerlink" title="学习过程记录"></a>学习过程记录</h2><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>花了四个多小时安装环境配置</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9AF67F88167620FD8454AA888AE2E4A4.jpg" alt></p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p><a href="http://laomengit.com/guide/introduction/%E5%88%9B%E5%BB%BAFlutter%E9%A1%B9%E7%9B%AE%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D.html" target="_blank" rel="noopener">创建Flutter项目及默认代码介绍</a></p><p>Flutter 的构建模式选择</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/5C3B096E6AE10D8EFD1771E5EE2D73C8.jpg" alt="第一款练手app"></p><h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/UI_.png" alt="UI_"></p><p>什么是声明式UI?</p><h3 id="暂时放弃"><a href="#暂时放弃" class="headerlink" title="暂时放弃"></a>暂时放弃</h3><p><a href="https://juejin.cn/post/6930508768983646216" target="_blank" rel="noopener">Flutter 路由与导航</a></p><p><a href="https://juejin.cn/post/6844904178863587336" target="_blank" rel="noopener">使用 Flutter 绘制图表（一）柱状图</a></p><p><a href="https://juejin.cn/post/6844903996923052040" target="_blank" rel="noopener">flutter - sqlite数据库小白入门，看不懂打死我</a></p><p><a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/intro" target="_blank" rel="noopener">https://flutter.cn/docs/development/data-and-backend/state-mgmt/intro</a></p><p><a href="https://flutter.cn/docs/cookbook/persistence/sqlite#example" target="_blank" rel="noopener">https://flutter.cn/docs/cookbook/persistence/sqlite#example</a></p><p><a href="https://blog.csdn.net/u010940300/article/details/43909509?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">.android占C盘空间解决方案</a></p><h2 id="重启6-17"><a href="#重启6-17" class="headerlink" title="重启6.17"></a>重启6.17</h2><p>应以实用为导向目标，因为终点是做出产品。</p><p>之前感觉教程看起来不太容易理解，还需要找更多资料，这次希望先找Android开发看一下，花点时间了解开发app的一些细节。</p><h3 id="目标6-18"><a href="#目标6-18" class="headerlink" title="目标6.18"></a>目标6.18</h3><p>认认真真写下项目策划。（6.18）</p><p>关于时间管理以及如何掌握自己的时间，很多的思考都是来源于彼得·德鲁克，《The Effective Executive》。第二章开头就告诉了我们，“关于管理者任务的讨论，一般都从如何做计划说起……可惜的是管理者的工作计划，很少真正发生作用。计划通常只是纸上谈兵，或只是良好的意愿而已，很少能够真正实现。”</p><p>就比如我很早以前就想自己写一个app，但是一直没有明确的计划，所以也被卡在同一个地方很久，直到现在也没有太大的进展。</p><p>根据德鲁克的观察，有效的管理者不会一开始就着手工作，他们往往会从时间入手。就像很多人一样，那些富有创造力并且成功打造出产品的人也有着不同程度的拖延症，比如达芬奇。</p><p>所以，他们并不以计划为起点，<strong>认清楚自己的时间用在什么地方才是起点</strong>。</p><p>然后他们<strong>管理自己的时间</strong>，减少非生产性工作所占用的时间。就好像《穿普拉达的女王》中BOSS老板把所有小事情，包括挂衣服背宴会人员名单等都扔给下属的小助理去做，自己则更多专注于时尚和各种活动。</p><p>最后，再将“<strong>可自由运用的时间</strong>”，由零星而集中成大块连续的时段。</p><p>因此可以总结出Executive Effective的基础：</p><ul><li>记录时间</li><li>管理时间</li><li>统一安排时间</li></ul><p>记录时间是最简单也最重要的，这符合奥卡姆剃刀法则。如果完全靠记忆，我们恐怕都说不清自己昨天或者前天的时间是怎么打发的，一个月或者一年就更难了，随着时间拉长，记录的时间信息可能就会越来越多，要持续不间断地记录下每一天的时间信息对我们来说也是非常困难的，事实上，任何一件小事坚持的时间只要变的足够长，难度都会超过起初的想象。</p><p>而为了后续更好地管理和安排时间，如何记录时间信息就是基础，在这个数据为王的时代，有了足够的数据支撑，就能根据数据做出有效的决策。</p><p>如此看来，记录时间有两个难点：</p><p><strong>一是知</strong>，即对记录<strong>时间信息的理解和思考</strong>，为了对市面上存在的几款时间管理工具做比较，我曾向朋友们了解过他们的使用体验以及对时间管理的看法。当然我自己也使用过很长时间的番茄TODO和块时间这两款APP，有很多想法大家都是不谋而合的。</p><p><strong>二是行</strong>，即<strong>记录方法和实践</strong>，如何方便地记录时间，必须尽量减少记录者的麻烦。又比如应该以什么样的形式记录信息？是提前写下计划任务的时间再临时修改、等完成某一工作后记录、还是必须在处理某一工作<strong>“当时“</strong>立即加一记录，而不能时候凭记忆补充呢？</p><p>所谓管理时间，可以先简单对应到数据结构课中的AOV网络，就是对所有任务进行拓扑排序。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021寒假计划</title>
      <link href="/2021/01/22/2021-han-jia-ji-hua/"/>
      <url>/2021/01/22/2021-han-jia-ji-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="2021寒假计划1-0"><a href="#2021寒假计划1-0" class="headerlink" title="2021寒假计划1.0"></a>2021寒假计划1.0</h1><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210124214306736.png" alt></p><blockquote><p><strong>“哪有什么很忙，只是你觉得当下选择做某件事，而非另一件而已。说白了，一切都是你自己的选择。“</strong></p></blockquote><p>从1.25开始放寒假到2.28刚好是整整五周时间（35天840个小时）</p><p>虽然目前不好说3.1能不能正常返校开学，但是这个寒假还是很短暂的，要利用好时间。</p><h2 id="课内学习"><a href="#课内学习" class="headerlink" title="课内学习"></a>课内学习</h2><h3 id="寒假作业"><a href="#寒假作业" class="headerlink" title="寒假作业"></a>寒假作业</h3><p>数据结构</p><ul><li><input checked disabled type="checkbox"> 实验四</li><li><input disabled type="checkbox"> 小组作业四</li></ul><p>组成原理</p><ul><li><input checked disabled type="checkbox"> linkpac实验</li><li><input disabled type="checkbox"> 第五章到第八章课本作业题</li></ul><p>概率论</p><ul><li><input checked disabled type="checkbox"> 假设检验作业题</li></ul><p>离散数学</p><ul><li><input checked disabled type="checkbox"> 第四章课后练习</li></ul><h2 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h2><h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>美赛（2.4-2.8）</p><p>计赛（2月底收尾）</p><p>创赛（5月底）</p><h3 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h3><ul><li><input disabled type="checkbox"> 计算机网络</li><li><input disabled type="checkbox"> 操作系统</li><li><input disabled type="checkbox"> 数据结构</li><li><input disabled type="checkbox"> 离散数学</li><li><input disabled type="checkbox"> 复变函数</li></ul><h3 id="温习"><a href="#温习" class="headerlink" title="温习"></a>温习</h3><ul><li><input disabled type="checkbox"> 线性代数</li><li><input disabled type="checkbox"> 微积分</li></ul><h3 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h3><p><strong>完成部分</strong></p><h4 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h4><p>7天</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《西瓜书》</p><h4 id="英语CET-6"><a href="#英语CET-6" class="headerlink" title="英语CET-6"></a>英语CET-6</h4><p>单词已背完</p><p>没刷题</p><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>3天</p><hr><p><strong>未完成部分</strong></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>3天</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>3天</p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>1天</p><h4 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h4><h4 id="NLP自然语言处理"><a href="#NLP自然语言处理" class="headerlink" title="NLP自然语言处理"></a>NLP自然语言处理</h4><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>1天</p><h4 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h4><p>1天</p><h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><p>四门专业课考试+毛概</p><p>体育乒乓球</p><h2 id="时间安排表"><a href="#时间安排表" class="headerlink" title="时间安排表"></a>时间安排表</h2><table><thead><tr><th>时间阶段</th><th>具体任务安排</th></tr></thead><tbody><tr><td>第一阶段1.25-2.9(前两周)</td><td>1.25-2.1知识准备（2.4-2.8）正式比赛</td></tr><tr><td>第二阶段2.10-2.14</td><td>拜年修整</td></tr><tr><td>第三阶段2.15-2.21</td><td>Flutter</td></tr><tr><td>第四阶段2.22-2.28</td><td>考试复习</td></tr><tr><td>未知阶段3.1-？</td><td></td></tr></tbody></table><h2 id="资料整理归档"><a href="#资料整理归档" class="headerlink" title="资料整理归档"></a>资料整理归档</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><strong>asoc</strong></p><p><strong>gsoc</strong></p>]]></content>
      
      
      <categories>
          
          <category> 假期计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2021/01/22/java/"/>
      <url>/2021/01/22/java/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Java学习之路"><a href="#我的Java学习之路" class="headerlink" title="我的Java学习之路"></a>我的Java学习之路</h1><blockquote><p>工欲善其事必先利其器。</p></blockquote><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>Jdk:可以理解为就是java本身，你写的java程序必须要Jdk才能执行。</p><p>Eclipse：是写Java代码的地方，它集成了调试、运行、管理等功能于一体。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210123093843490.png" alt="Hello World"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何卖出一瓶水</title>
      <link href="/2021/01/15/guan-yu-yi-ping-shui/"/>
      <url>/2021/01/15/guan-yu-yi-ping-shui/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/v2-569c7994e7598714d44790fbacbf065a_b.jpg" alt="看看这些水"></p><p>作为一个卖水的二道贩子，我们也要学会自己使用思维框架了。</p><p>现在我要提出五个观念，并且使用它们来解决这个在推销中极难的问题——如何卖出一瓶水。</p><p>这个问题实际上是这样的：假设你作为HFDP公司商务部门的一员，你要如何重新策划并在上海引入Kristal这种高端水（玻璃瓶装，国外售价3$/L）</p><p>接下来，我会利用查理芒格有用的普遍观念来尝试解决这个问题。</p><blockquote><p><strong>The first helpful notion is that it is usually best to simplify problems by deciding big “no-brainer” questions first.</strong></p><p><strong>The second helpful notion mimics Galileo’s conclusion that scientific realiry is often revealed only by math as if math was the language of God. Galileo’s attitude also works well in messy, practical life.</strong></p><p><strong>The third helpful norion is that it is not enough to think problems through forward.</strong> You must also think in reverse, much like the rustic who wanted ro know where he was going to die so that he’d never go there. </p><p><strong>The fourth helpful noion is that the best and most pracrical wisdom is elementary academic wisdom.</strong> But there is one extremely important qualification: You must think in a multidisciplinary manner. </p><p><strong>The fifth helpful noion is that really big effects, lollapalooza effects, will often come only from large combinations of factors.</strong></p></blockquote><hr><p><a href="https://zhuanlan.zhihu.com/p/36708872" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 商务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人机共生》</title>
      <link href="/2021/01/01/ren-ji-gong-sheng/"/>
      <url>/2021/01/01/ren-ji-gong-sheng/</url>
      
        <content type="html"><![CDATA[<p><strong>Man-Computer Symbiosis</strong></p><p><strong>J. C. R. Licklider</strong><br>IRE Transactions on Human Factors in Electronics,<br>volume HFE-1, pages 4-11, March 1960</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote><p>Man-computer symbiosis is an expected development in cooperative interaction between men and electronic computers. It will involve very close coupling between the human and the electronic members of the partnership. The main aims are 1) to let computers facilitate formulative thinking as they now facilitate the solution of formulated problems, and 2) to enable men and computers to cooperate in making decisions and controlling complex situations without inflexible dependence on predetermined programs. In the anticipated symbiotic partnership, men will set the goals, formulate the hypotheses, determine the criteria, and perform the evaluations. Computing machines will do the routinizable work that must be done to prepare the way for insights and decisions in technical and scientific thinking. Preliminary analyses indicate that the symbiotic partnership will perform intellectual operations much more effectively than man alone can perform them. Prerequisites for the achievement of the effective, cooperative association include developments in computer time sharing, in memory components, in memory organization, in programming languages, and in input and output equipment.</p></blockquote><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><h2 id="1-1-Symbiosis"><a href="#1-1-Symbiosis" class="headerlink" title="1.1 Symbiosis"></a>1.1 Symbiosis</h2><p>The fig tree is pollinated only by the insect <em>Blastophaga grossorun</em>. The larva of the insect lives in the ovary of the fig tree, and there it gets its food. The tree and the insect are thus heavily interdependent: the tree cannot reproduce wit bout the insect; the insect cannot eat wit bout the tree; together, they constitute not only a viable but a productive and thriving partnership. This cooperative “living together in intimate association, or even close union, of two dissimilar organisms” is called symbiosis [27].</p><p>“Man-computer symbiosis is a subclass of man-machine systems. There are many man-machine systems. At present, however, there are no man-computer symbioses. The purposes of this paper are to present the concept and, hopefully, to foster the development of man-computer symbiosis by analyzing some problems of interaction between men and computing machines, calling attention to applicable principles of man-machine engineering, and pointing out a few questions to which research answers are needed. The hope is that, in not too many years, human brains and computing machines will be coupled together very tightly, and that the resulting partnership will think as no human brain has ever thought and process data in a way not approached by the information-handling machines we know today.</p><h2 id="1-2-Between-“Mechanically-Extended-Man”-and-“Artificial-Intelligence”"><a href="#1-2-Between-“Mechanically-Extended-Man”-and-“Artificial-Intelligence”" class="headerlink" title="1.2 Between “Mechanically Extended Man” and “Artificial Intelligence”"></a>1.2 Between “Mechanically Extended Man” and “Artificial Intelligence”</h2><p>As a concept, man-computer symbiosis is different in an important way from what North [21] has called “mechanically extended man.” In the man-machine systems of the past, the human operator supplied the initiative, the direction, the integration, and the criterion. The mechanical parts of the systems were mere extensions, first of the human arm, then of the human eye. These systems certainly did not consist of “dissimilar organisms living together…” There was only one kind of organism-man-and the rest was there only to help him.</p><p>In one sense of course, any man-made system is intended to help man, to help a man or men outside the system. If we focus upon the human operator within the system, however, we see that, in some areas of technology, a fantastic change has taken place during the last few years. “Mechanical extension” has given way to replacement of men, to automation, and the men who remain are there more to help than to be helped. In some instances, particularly in large computer-centered information and control systems, the human operators are responsible mainly for functions that it proved infeasible to automate. Such systems (“humanly extended machines,” North might call them) are not symbiotic systems. They are “semi-automatic” systems, systems that started out to be fully automatic but fell short of the goal.</p><p>Man-computer symbiosis is probably not the ultimate paradigm for complex technological systems. It seems entirely possible that, in due course, electronic or chemical “machines” will outdo the human brain in most of the functions we now consider exclusively within its province. Even now, Gelernter’s IBM-704 program for proving theorems in plane geometry proceeds at about the same pace as Brooklyn high school students, and makes similar errors.[12] There are, in fact, several theorem-proving, problem-solving, chess-playing, and pattern-recognizing programs (too many for complete reference [1, 2, 5, 8, 11, 13, 17, 18, 19, 22, 23, 25]) capable of rivaling human intellectual performance in restricted areas; and Newell, Simon, and Shaw’s [20] “general problem solver” may remove some of the restrictions. In short, it seems worthwhile to avoid argument with (other) enthusiasts for artificial intelligence by conceding dominance in the distant future of cerebration to machines alone. There will nevertheless be a fairly long interim during which the main intellectual advances will be made by men and computers working together in intimate association. A multidisciplinary study group, examining future research and development problems of the Air Force, estimated that it would be 1980 before developments in artificial intelligence make it possible for machines alone to do much thinking or problem solving of military significance. That would leave, say, five years to develop man-computer symbiosis and 15 years to use it. The 15 may be 10 or 500, but those years should be intellectually the most creative and exciting in the history of mankind.</p><h1 id="2-Aims-of-Man-Computer-Symbiosis"><a href="#2-Aims-of-Man-Computer-Symbiosis" class="headerlink" title="2 Aims of Man-Computer Symbiosis"></a>2 Aims of Man-Computer Symbiosis</h1><p>Present-day computers are designed primarily to solve preformulated problems or to process data according to predetermined procedures. The course of the computation may be conditional upon results obtained during the computation, but all the alternatives must be foreseen in advance. (If an unforeseen alternative arises, the whole process comes to a halt and awaits the necessary extension of the program.) The requirement for preformulation or predetermination is sometimes no great disadvantage. It is often said that programming for a computing machine forces one to think clearly, that it disciplines the thought process. If the user can think his problem through in advance, symbiotic association with a computing machine is not necessary.</p><p>However, many problems that can be thought through in advance are very difficult to think through in advance. They would be easier to solve, and they could be solved faster, through an intuitively guided trial-and-error procedure in which the computer cooperated, turning up flaws in the reasoning or revealing unexpected turns in the solution. Other problems simply cannot be formulated without computing-machine aid. Poincare anticipated the frustration of an important group of would-be computer users when he said, “The question is not, ‘What is the answer?’ The question is, ‘What is the question?’” One of the main aims of man-computer symbiosis is to bring the computing machine effectively into the formulative parts of technical problems.</p><p>The other main aim is closely related. It is to bring computing machines effectively into processes of thinking that must go on in “real time,” time that moves too fast to permit using computers in conventional ways. Imagine trying, for example, to direct a battle with the aid of a computer on such a schedule as this. You formulate your problem today. Tomorrow you spend with a programmer. Next week the computer devotes 5 minutes to assembling your program and 47 seconds to calculating the answer to your problem. You get a sheet of paper 20 feet long, full of numbers that, instead of providing a final solution, only suggest a tactic that should be explored by simulation. Obviously, the battle would be over before the second step in its planning was begun. To think in interaction with a computer in the same way that you think with a colleague whose competence supplements your own will require much tighter coupling between man and machine than is suggested by the example and than is possible today.</p><h1 id="3-Need-for-Computer-Participation-in-Formulative-and-Real-Time-Thinking"><a href="#3-Need-for-Computer-Participation-in-Formulative-and-Real-Time-Thinking" class="headerlink" title="3 Need for Computer Participation in Formulative and Real-Time Thinking"></a>3 Need for Computer Participation in Formulative and Real-Time Thinking</h1><p>The preceding paragraphs tacitly made the assumption that, if they could be introduced effectively into the thought process, the functions that can be performed by data-processing machines would improve or facilitate thinking and problem solving in an important way. That assumption may require justification.</p><h2 id="3-1-A-Preliminary-and-Informal-Time-and-Motion-Analysis-of-Technical-Thinking"><a href="#3-1-A-Preliminary-and-Informal-Time-and-Motion-Analysis-of-Technical-Thinking" class="headerlink" title="3.1 A Preliminary and Informal Time-and-Motion Analysis of Technical Thinking"></a>3.1 A Preliminary and Informal Time-and-Motion Analysis of Technical Thinking</h2><p>Despite the fact that there is a voluminous literature on thinking and problem solving, including intensive case-history studies of the process of invention, I could find nothing comparable to a time-and-motion-study analysis of the mental work of a person engaged in a scientific or technical enterprise. In the spring and summer of 1957, therefore, I tried to keep track of what one moderately technical person actually did during the hours he regarded as devoted to work. Although I was aware of the inadequacy of the sampling, I served as my own subject.</p><p>It soon became apparent that the main thing I did was to keep records, and the project would have become an infinite regress if the keeping of records had been carried through in the detail envisaged in the initial plan. It was not. Nevertheless, I obtained a picture of my activities that gave me pause. Perhaps my spectrum is not typical–I hope it is not, but I fear it is.</p><p>About 85 per cent of my “thinking” time was spent getting into a position to think, to make a decision, to learn something I needed to know. Much more time went into finding or obtaining information than into digesting it. Hours went into the plotting of graphs, and other hours into instructing an assistant how to plot. When the graphs were finished, the relations were obvious at once, but the plotting had to be done in order to make them so. At one point, it was necessary to compare six experimental determinations of a function relating speech-intelligibility to speech-to-noise ratio. No two experimenters had used the same definition or measure of speech-to-noise ratio. Several hours of calculating were required to get the data into comparable form. When they were in comparable form, it took only a few seconds to determine what I needed to know.</p><p>Throughout the period I examined, in short, my “thinking” time was devoted mainly to activities that were essentially clerical or mechanical: searching, calculating, plotting, transforming, determining the logical or dynamic consequences of a set of assumptions or hypotheses, preparing the way for a decision or an insight. Moreover, my choices of what to attempt and what not to attempt were determined to an embarrassingly great extent by considerations of clerical feasibility, not intellectual capability.</p><p>The main suggestion conveyed by the findings just described is that the operations that fill most of the time allegedly devoted to technical thinking are operations that can be performed more effectively by machines than by men. Severe problems are posed by the fact that these operations have to be performed upon diverse variables and in unforeseen and continually changing sequences. If those problems can be solved in such a way as to create a symbiotic relation between a man and a fast information-retrieval and data-processing machine, however, it seems evident that the cooperative interaction would greatly improve the thinking process.</p><p>It may be appropriate to acknowledge, at this point, that we are using the term “computer” to cover a wide class of calculating, data-processing, and information-storage-and-retrieval machines. The capabilities of machines in this class are increasing almost daily. It is therefore hazardous to make general statements about capabilities of the class. Perhaps it is equally hazardous to make general statements about the capabilities of men. Nevertheless, certain genotypic differences in capability between men and computers do stand out, and they have a bearing on the nature of possible man-computer symbiosis and the potential value of achieving it.</p><p>As has been said in various ways, men are noisy, narrow-band devices, but their nervous systems have very many parallel and simultaneously active channels. Relative to men, computing machines are very fast and very accurate, but they are constrained to perform only one or a few elementary operations at a time. Men are flexible, capable of “programming themselves contingently” on the basis of newly received information. Computing machines are single-minded, constrained by their “ pre-programming.” Men naturally speak redundant languages organized around unitary objects and coherent actions and employing 20 to 60 elementary symbols. Computers “naturally” speak nonredundant languages, usually with only two elementary symbols and no inherent appreciation either of unitary objects or of coherent actions.</p><p>To be rigorously correct, those characterizations would have to include many qualifiers. Nevertheless, the picture of dissimilarity (and therefore p0tential supplementation) that they present is essentially valid. Computing machines can do readily, well, and rapidly many things that are difficult or impossible for man, and men can do readily and well, though not rapidly, many things that are difficult or impossible for computers. That suggests that a symbiotic cooperation, if successful in integrating the positive characteristics of men and computers, would be of great value. The differences in speed and in language, of course, pose difficulties that must be overcome.</p><h1 id="4-Separable-Functions-of-Men-and-Computers-in-the-Anticipated-Symbiotic-Association"><a href="#4-Separable-Functions-of-Men-and-Computers-in-the-Anticipated-Symbiotic-Association" class="headerlink" title="4 Separable Functions of Men and Computers in the Anticipated Symbiotic Association"></a>4 Separable Functions of Men and Computers in the Anticipated Symbiotic Association</h1><p>It seems likely that the contributions of human operators and equipment will blend together so completely in many operations that it will be difficult to separate them neatly in analysis. That would be the case it; in gathering data on which to base a decision, for example, both the man and the computer came up with relevant precedents from experience and if the computer then suggested a course of action that agreed with the man’s intuitive judgment. (In theorem-proving programs, computers find precedents in experience, and in the SAGE System, they suggest courses of action. The foregoing is not a far-fetched example. ) In other operations, however, the contributions of men and equipment will be to some extent separable.</p><p>Men will set the goals and supply the motivations, of course, at least in the early years. They will formulate hypotheses. They will ask questions. They will think of mechanisms, procedures, and models. They will remember that such-and-such a person did some possibly relevant work on a topic of interest back in 1947, or at any rate shortly after World War II, and they will have an idea in what journals it might have been published. In general, they will make approximate and fallible, but leading, contributions, and they will define criteria and serve as evaluators, judging the contributions of the equipment and guiding the general line of thought.</p><p>In addition, men will handle the very-low-probability situations when such situations do actually arise. (In current man-machine systems, that is one of the human operator’s most important functions. The sum of the probabilities of very-low-probability alternatives is often much too large to neglect. ) Men will fill in the gaps, either in the problem solution or in the computer program, when the computer has no mode or routine that is applicable in a particular circumstance.</p><p>The information-processing equipment, for its part, will convert hypotheses into testable models and then test the models against data (which the human operator may designate roughly and identify as relevant when the computer presents them for his approval). The equipment will answer questions. It will simulate the mechanisms and models, carry out the procedures, and display the results to the operator. It will transform data, plot graphs (“cutting the cake” in whatever way the human operator specifies, or in several alternative ways if the human operator is not sure what he wants). The equipment will interpolate, extrapolate, and transform. It will convert static equations or logical statements into dynamic models so the human operator can examine their behavior. In general, it will carry out the routinizable, clerical operations that fill the intervals between decisions.</p><p>In addition, the computer will serve as a statistical-inference, decision-theory, or game-theory machine to make elementary evaluations of suggested courses of action whenever there is enough basis to support a formal statistical analysis. Finally, it will do as much diagnosis, pattern-matching, and relevance-recognizing as it profitably can, but it will accept a clearly secondary status in those areas.</p><h1 id="5-Prerequisites-for-Realization-of-Man-Computer-Symbiosis"><a href="#5-Prerequisites-for-Realization-of-Man-Computer-Symbiosis" class="headerlink" title="5 Prerequisites for Realization of Man-Computer Symbiosis"></a>5 Prerequisites for Realization of Man-Computer Symbiosis</h1><p>The data-processing equipment tacitly postulated in the preceding section is not available. The computer programs have not been written. There are in fact several hurdles that stand between the nonsymbiotic present and the anticipated symbiotic future. Let us examine some of them to see more clearly what is needed and what the chances are of achieving it.</p><h2 id="5-1-Speed-Mismatch-Between-Men-and-Computers"><a href="#5-1-Speed-Mismatch-Between-Men-and-Computers" class="headerlink" title="5.1 Speed Mismatch Between Men and Computers"></a>5.1 Speed Mismatch Between Men and Computers</h2><p>Any present-day large-scale computer is too fast and too costly for real-time cooperative thinking with one man. Clearly, for the sake of efficiency and economy, the computer must divide its time among many users. Timesharing systems are currently under active development. There are even arrangements to keep users from “clobbering” anything but their own personal programs.</p><p>It seems reasonable to envision, for a time 10 or 15 years hence, a “thinking center” that will incorporate the functions of present-day libraries together with anticipated advances in information storage and retrieval and the symbiotic functions suggested earlier in this paper. The picture readily enlarges itself into a network of such centers, connected to one another by wide-band communication lines and to individual users by leased-wire services. In such a system, the speed of the computers would be balanced, and the cost of the gigantic memories and the sophisticated programs would be divided by the number of users.</p><h2 id="5-2-Memory-Hardware-Requirements"><a href="#5-2-Memory-Hardware-Requirements" class="headerlink" title="5.2 Memory Hardware Requirements"></a>5.2 Memory Hardware Requirements</h2><p>When we start to think of storing any appreciable fraction of a technical literature in computer memory, we run into billions of bits and, unless things change markedly, billions of dollars.</p><p>The first thing to face is that we shall not store all the technical and scientific papers in computer memory. We may store the parts that can be summarized most succinctly-the quantitative parts and the reference citations-but not the whole. Books are among the most beautifully engineered, and human-engineered, components in existence, and they will continue to be functionally important within the context of man-computer symbiosis. (Hopefully, the computer will expedite the finding, delivering, and returning of books.)</p><p>The second point is that a very important section of memory will be permanent: part indelible <em>memory</em> and part <em>published memory</em>. The computer will be able to write once into indelible memory, and then read back indefinitely, but the computer will not be able to erase indelible memory. (It may also over-write, turning all the 0’s into l’s, as though marking over what was written earlier.) Published memory will be “read-only” memory. It will be introduced into the computer already structured. The computer will be able to refer to it repeatedly, but not to change it. These types of memory will become more and more important as computers grow larger. They can be made more compact than core, thin-film, or even tape memory, and they will be much less expensive. The main engineering problems will concern selection circuitry.</p><p>In so far as other aspects of memory requirement are concerned, we may count upon the continuing development of ordinary scientific and business computing machines There is some prospect that memory elements will become as fast as processing (logic) elements. That development would have a revolutionary effect upon the design of computers.</p><h2 id="5-3-Memory-Organization-Requirements"><a href="#5-3-Memory-Organization-Requirements" class="headerlink" title="5.3 Memory Organization Requirements"></a>5.3 Memory Organization Requirements</h2><p>Implicit in the idea of man-computer symbiosis are the requirements that information be retrievable both by name and by pattern and that it be accessible through procedure much faster than serial search. At least half of the problem of memory organization appears to reside in the storage procedure. Most of the remainder seems to be wrapped up in the problem of pattern recognition within the storage mechanism or medium. Detailed discussion of these problems is beyond the present scope. However, a brief outline of one promising idea, “trie memory,” may serve to indicate the general nature of anticipated developments.</p><p>Trie memory is so called by its originator, Fredkin [10], because it is designed to facilitate retrieval of information and because the branching storage structure, when developed, resembles a tree. Most common memory systems store functions of arguments at locations designated by the arguments. (In one sense, they do not store the arguments at all. In another and more realistic sense, they store all the possible arguments in the framework structure of the memory.) The trie memory system, on the other hand, stores both the functions and the arguments. The argument is introduced into the memory first, one character at a time, starting at a standard initial register. Each argument register has one cell for each character of the ensemble (e.g., two for information encoded in binary form) and each character cell has within it storage space for the address of the next register. The argument is stored by writing a series of addresses, each one of which tells where to find the next. At the end of the argument is a special “end-of-argument” marker. Then follow directions to the function, which is stored in one or another of several ways, either further trie structure or “list structure” often being most effective.</p><p>The trie memory scheme is inefficient for small memories, but it becomes increasingly efficient in using available storage space as memory size increases. The attractive features of the scheme are these: 1) The retrieval process is extremely simple. Given the argument, enter the standard initial register with the first character, and pick up the address of the second. Then go to the second register, and pick up the address of the third, etc. 2) If two arguments have initial characters in common, they use the same storage space for those characters. 3) The lengths of the arguments need not be the same, and need not be specified in advance. 4) No room in storage is reserved for or used by any argument until it is actually stored. The trie structure is created as the items are introduced into the memory. 5) A function can be used as an argument for another function, and that function as an argument for the next. Thus, for example, by entering with the argument, “matrix multiplication,” one might retrieve the entire program for performing a matrix multiplication on the computer. 6) By examining the storage at a given level, one can determine what thus-far similar items have been stored. For example, if there is no citation for Egan, J. P., it is but a step or two backward to pick up the trail of Egan, James … .</p><p>The properties just described do not include all the desired ones, but they bring computer storage into resonance with human operators and their predilection to designate things by naming or pointing.</p><h2 id="5-4-The-Language-Problem"><a href="#5-4-The-Language-Problem" class="headerlink" title="5.4 The Language Problem"></a>5.4 The Language Problem</h2><p>The basic dissimilarity between human languages and computer languages may be the most serious obstacle to true symbiosis. It is reassuring, however, to note what great strides have already been made, through interpretive programs and particularly through assembly or compiling programs such as FORTRAN, to adapt computers to human language forms. The “Information Processing Language” of Shaw, Newell, Simon, and Ellis [24] represents another line of rapprochement. And, in ALGOL and related systems, men are proving their flexibility by adopting standard formulas of representation and expression that are readily translatable into machine language.</p><p>For the purposes of real-time cooperation between men and computers, it will be necessary, however, to make use of an additional and rather different principle of communication and control. The idea may be highlighted by comparing instructions ordinarily addressed to intelligent human beings with instructions ordinarily used with computers. The latter specify precisely the individual steps to take and the sequence in which to take them. The former present or imply something about incentive or motivation, and they supply a criterion by which the human executor of the instructions will know when he has accomplished his task. In short: instructions directed to computers specify courses; instructions-directed to human beings specify goals.</p><p>Men appear to think more naturally and easily in terms of goals than in terms of courses. True, they usually know something about directions in which to travel or lines along which to work, but few start out with precisely formulated itineraries. Who, for example, would depart from Boston for Los Angeles with a detailed specification of the route? Instead, to paraphrase Wiener, men bound for Los Angeles try continually to decrease the amount by which they are not yet in the smog.</p><p>Computer instruction through specification of goals is being approached along two paths. The first involves problem-solving, hill-climbing, self-organizing programs. The second involves real-time concatenation of preprogrammed segments and closed subroutines which the human operator can designate and call into action simply by name.</p><p>Along the first of these paths, there has been promising exploratory work. It is clear that, working within the loose constraints of predetermined strategies, computers will in due course be able to devise and simplify their own procedures for achieving stated goals. Thus far, the achievements have not been substantively important; they have constituted only “demonstration in principle.” Nevertheless, the implications are far-reaching.</p><p>Although the second path is simpler and apparently capable of earlier realization, it has been relatively neglected. Fredkin’s trie memory provides a promising paradigm. We may in due course see a serious effort to develop computer programs that can be connected together like the words and phrases of speech to do whatever computation or control is required at the moment. The consideration that holds back such an effort, apparently, is that the effort would produce nothing that would be of great value in the context of existing computers. It would be unrewarding to develop the language before there are any computing machines capable of responding meaningfully to it.</p><h2 id="5-5-Input-and-Output-Equipment"><a href="#5-5-Input-and-Output-Equipment" class="headerlink" title="5.5 Input and Output Equipment"></a>5.5 Input and Output Equipment</h2><p>The department of data processing that seems least advanced, in so far as the requirements of man-computer symbiosis are concerned, is the one that deals with input and output equipment or, as it is seen from the human operator’s point of view, displays and controls. Immediately after saying that, it is essential to make qualifying comments, because the engineering of equipment for high-speed introduction and extraction of information has been excellent, and because some very sophisticated display and control techniques have been developed in such research laboratories as the Lincoln Laboratory. By and large, in generally available computers, however, there is almost no provision for any more effective, immediate man-machine communication than can be achieved with an electric typewriter.</p><p>Displays seem to be in a somewhat better state than controls. Many computers plot graphs on oscilloscope screens, and a few take advantage of the remarkable capabilities, graphical and symbolic, of the charactron display tube. Nowhere, to my knowledge, however, is there anything approaching the flexibility and convenience of the pencil and doodle pad or the chalk and blackboard used by men in technical discussion.</p><p>1) <em>Desk-Surface Display and Control:</em> Certainly, for effective man-computer interaction, it will be necessary for the man and the computer to draw graphs and pictures and to write notes and equations to each other on the same display surface. The man should be able to present a function to the computer, in a rough but rapid fashion, by drawing a graph. The computer should read the man’s writing, perhaps on the condition that it be in clear block capitals, and it should immediately post, at the location of each hand-drawn symbol, the corresponding character as interpreted and put into precise type-face. With such an input-output device, the operator would quickly learn to write or print in a manner legible to the machine. He could compose instructions and subroutines, set them into proper format, and check them over before introducing them finally into the computer’s main memory. He could even define new symbols, as Gilmore and Savell [14] have done at the Lincoln Laboratory, and present them directly to the computer. He could sketch out the format of a table roughly and let the computer shape it up with precision. He could correct the computer’s data, instruct the machine via flow diagrams, and in general interact with it very much as he would with another engineer, except that the “other engineer” would be a precise draftsman, a lightning calculator, a mnemonic wizard, and many other valuable partners all in one.</p><p>2) <em>Computer-Posted Wall Display:</em> In some technological systems, several men share responsibility for controlling vehicles whose behaviors interact. Some information must be presented simultaneously to all the men, preferably on a common grid, to coordinate their actions. Other information is of relevance only to one or two operators. There would be only a confusion of uninterpretable clutter if all the information were presented on one display to all of them. The information must be posted by a computer, since manual plotting is too slow to keep it up to date.</p><p>The problem just outlined is even now a critical one, and it seems certain to become more and more critical as time goes by. Several designers are convinced that displays with the desired characteristics can be constructed with the aid of flashing lights and time-sharing viewing screens based on the light-valve principle.</p><p>The large display should be supplemented, according to most of those who have thought about the problem, by individual display-control units. The latter would permit the operators to modify the wall display without leaving their locations. For some purposes, it would be desirable for the operators to be able to communicate with the computer through the supplementary displays and perhaps even through the wall display. At least one scheme for providing such communication seems feasible.</p><p>The large wall display and its associated system are relevant, of course, to symbiotic cooperation between a computer and a team of men. Laboratory experiments have indicated repeatedly that informal, parallel arrangements of operators, coordinating their activities through reference to a large situation display, have important advantages over the arrangement, more widely used, that locates the operators at individual consoles and attempts to correlate their actions through the agency of a computer. This is one of several operator-team problems in need of careful study.</p><p>3) <em>Automatic Speech Production and Recognition:</em> How desirable and how feasible is speech communication between human operators and computing machines? That compound question is asked whenever sophisticated data-processing systems are discussed. Engineers who work and live with computers take a conservative attitude toward the desirability. Engineers who have had experience in the field of automatic speech recognition take a conservative attitude toward the feasibility. Yet there is continuing interest in the idea of talking with computing machines. In large part, the interest stems from realization that one can hardly take a military commander or a corporation president away from his work to teach him to type. If computing machines are ever to be used directly by top-level decision makers, it may be worthwhile to provide communication via the most natural means, even at considerable cost.</p><p>Preliminary analysis of his problems and time scales suggests that a corporation president would be interested in a symbiotic association with a computer only as an avocation. Business situations usually move slowly enough that there is time for briefings and conferences. It seems reasonable, therefore, for computer specialists to be the ones who interact directly with computers in business offices.</p><p>The military commander, on the other hand, faces a greater probability of having to make critical decisions in short intervals of time. It is easy to overdramatize the notion of the ten-minute war, but it would be dangerous to count on having more than ten minutes in which to make a critical decision. As military system ground environments and control centers grow in capability and complexity, therefore, a real requirement for automatic speech production and recognition in computers seems likely to develop. Certainly, if the equipment were already developed, reliable, and available, it would be used.</p><p>In so far as feasibility is concerned, speech production poses less severe problems of a technical nature than does automatic recognition of speech sounds. A commercial electronic digital voltmeter now reads aloud its indications, digit by digit. For eight or ten years, at the Bell Telephone Laboratories, the Royal Institute of Technology (Stockholm), the Signals Research and Development Establishment (Christchurch), the Haskins Laboratory, and the Massachusetts Institute of Technology, Dunn [6], Fant [7], Lawrence [15], Cooper [3], Stevens [26], and their co-workers, have demonstrated successive generations of intelligible automatic talkers. Recent work at the Haskins Laboratory has led to the development of a digital code, suitable for use by computing machines, that makes an automatic voice utter intelligible connected discourse [16].</p><p>The feasibility of automatic speech recognition depends heavily upon the size of the vocabulary of words to be recognized and upon the diversity of talkers and accents with which it must work. Ninety-eight per cent correct recognition of naturally spoken decimal digits was demonstrated several years ago at the Bell Telephone Laboratories and at the Lincoln Laboratory [4], [9]. To go a step up the scale of vocabulary size, we may say that an automatic recognizer of clearly spoken alpha-numerical characters can almost surely be developed now on the basis of existing knowledge. Since untrained operators can read at least as rapidly as trained ones can type, such a device would be a convenient tool in almost any computer installation.</p><p>For real-time interaction on a truly symbiotic level, however, a vocabulary of about 2000 words, e.g., 1000 words of something like basic English and 1000 technical terms, would probably be required. That constitutes a challenging problem. In the consensus of acousticians and linguists, construction of a recognizer of 2000 words cannot be accomplished now. However, there are several organizations that would happily undertake to develop an automatic recognize for such a vocabulary on a five-year basis. They would stipulate that the speech be clear speech, dictation style, without unusual accent.</p><p>Although detailed discussion of techniques of automatic speech recognition is beyond the present scope, it is fitting to note that computing machines are playing a dominant role in the development of automatic speech recognizers. They have contributed the impetus that accounts for the present optimism, or rather for the optimism presently found in some quarters. Two or three years ago, it appeared that automatic recognition of sizeable vocabularies would not be achieved for ten or fifteen years; that it would have to await much further, gradual accumulation of knowledge of acoustic, phonetic, linguistic, and psychological processes in speech communication. Now, however, many see a prospect of accelerating the acquisition of that knowledge with the aid of computer processing of speech signals, and not a few workers have the feeling that sophisticated computer programs will be able to perform well as speech-pattern recognizes even without the aid of much substantive knowledge of speech signals and processes. Putting those two considerations together brings the estimate of the time required to achieve practically significant speech recognition down to perhaps five years, the five years just mentioned.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] A. Bernstein and M. deV. Roberts, “Computer versus chess-player,” <em>Scientific American</em>, vol. 198, pp. 96-98; June, 1958.</p><p>[2] W. W. Bledsoe and I. Browning, “Pattern Recognition and Reading by Machine,” presented at the Eastern Joint Computer Conf, Boston, Mass., December, 1959.</p><p>[3] F. S. Cooper, et al., “Some experiments on the perception of synthetic speech sounds,” <em>J. Acoust Soc. Amer.</em>, vol.24, pp.597-606; November, 1952.</p><p>[4] K. H. Davis, R. Biddulph, and S. Balashek, “Automatic recognition of spoken digits,” in W. Jackson, <em>Communication Theory</em>, Butterworths Scientific Publications, London, Eng., pp. 433-441; 1953.</p><p>[5] G. P. Dinneen, “Programming pattern recognition,” <em>Proc. WJCC</em>, pp. 94-100; March, 1955.</p><p>[6] H. K. Dunn, “The calculation of vowel resonances, and an electrical vocal tract,” <em>J. Acoust Soc. Amer.</em>, vol. 22, pp.740-753; November, 1950.</p><p>[7] G. Fant, “On the Acoustics of Speech,” paper presented at the Third Internatl. Congress on Acoustics, Stuttgart, Ger.; September, 1959.</p><p>[8] B. G. Farley and W. A. Clark, “Simulation of self-organizing systems by digital computers.” <em>IRE Trans. on Information Theory</em>, vol. IT-4, pp.76-84; September, 1954</p><p>[9] J. W. Forgie and C. D. Forgie, “Results obtained from a vowel recognition computer program,” <em>J. Acoust Soc. Amer.</em>, vol. 31, pp. 1480-1489; November, 1959</p><p>[10] E. Fredkin, “Trie memory,” <em>Communications of the ACM</em>, Sept. 1960, pp. 490-499</p><p>[11] R. M. Friedberg, “A learning machine: Part I,” <em>IBM J. Res. &amp; Dev.</em>, vol.2, pp.2-13; January, 1958.</p><p>[12] H. Gelernter, “Realization of a Geometry Theorem Proving Machine.” Unesco, NS, ICIP, 1.6.6, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[13] P. C. Gilmore, “A Program for the Production of Proofs for Theorems Derivable Within the First Order Predicate Calculus from Axioms,” Unesco, NS, ICIP, 1.6.14, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[14] J. T. Gilmore and R. E. Savell, “The Lincoln Writer,” Lincoln Laboratory, M. I. T., Lexington, Mass., Rept. 51-8; October, 1959.</p><p>[15] W. Lawrence, et al., “Methods and Purposes of Speech Synthesis,” Signals Res. and Dev. Estab., Ministry of Supply, Christchurch, Hants, England, Rept. 56/1457; March, 1956.</p><p>[16] A. M. Liberman, F. Ingemann, L. Lisker, P. Delattre, and F. S. Cooper, “Minimal rules for synthesizing speech,” <em>J. Acoust Soc. Amer.</em>, vol. 31, pp. 1490-1499; November, 1959.</p><p>[17] A. Newell, “The chess machine: an example of dealing with a complex task by adaptation,” <em>Proc. WJCC</em>, pp. 101-108; March, 1955.</p><p>[18] A. Newell and J. C. Shaw, “Programming the logic theory machine.” <em>Proc. WJCC</em>, pp. 230-240; March, 1957.</p><p>[19] A. Newell, J. C. Shaw, and H. A. Simon, “Chess-playing programs and the problem of complexity,” <em>IBM J. Res &amp; Dev.</em>, vol.2, pp. 320-33.5; October, 1958.</p><p>[20] A. Newell, H. A. Simon, and J. C. Shaw, “Report on a general problem-solving program,” Unesco, NS, ICIP, 1.6.8, Internatl. Conf. on Information Processing, Paris, France; June, 1959.</p><p>[21] J. D. North, “The rational behavior of mechanically extended man”, Boulton Paul Aircraft Ltd., Wolverhampton, Eng.; September, 1954.</p><p>[22] 0. G. Selfridge, “Pandemonium, a paradigm for learning,” <em>Proc. Symp. Mechanisation of Thought Processes</em>, Natl. Physical Lab., Teddington, Eng.; November, 1958.</p><p>[23] C. E. Shannon, “Programming a computer for playing chess,” <em>Phil. Mag.</em>, vol.41, pp.256-75; March, 1950.</p><p>[24] J. C. Shaw, A. Newell, H. A. Simon, and T. O. Ellis, “A command structure for complex information processing,” <em>Proc. WJCC</em>, pp. 119-128; May, 1958.</p><p>[25] H. Sherman, “A Quasi-Topological Method for Recognition of Line Patterns,” Unesco, NS, ICIP, H.L.5, Internatl. Conf. on Information Processing, Paris, France; June, 1959</p><p>[26] K. N. Stevens, S. Kasowski, and C. G. Fant, “Electric analog of the vocal tract,” <em>J. Acoust. Soc. Amer.</em>, vol. 25, pp. 734-742; July, 1953.</p><p>[27] <em>Webster’s New International Dictionary</em>, 2nd e., G. and C. Merriam Co., Springfield, Mass., p. 2555; 1958.</p><hr><h1 id="中文翻译参考"><a href="#中文翻译参考" class="headerlink" title="中文翻译参考"></a>中文翻译参考</h1><p>摘要</p><p>人机共生是人类和电子计算机之间合作互动的一个预期发展。这将涉及人类和电子设备之间非常密切的耦合。主要目的是1）让计算机促进公式化思维，因为它们现在促进了公式化问题的解决；2）让人类和计算机能够合作做出决策和控制复杂的情况，而不依赖于预先确定的程序。在预期的共生伙伴关系中，人类将设定目标，制定假设，确定标准，并进行评估。计算机将会做一些常规的工作，为人类在技术和科学思考方面的见解和决策做好准备。初步分析表明，共生伙伴关系将比单独的人能更有效地进行智力活动。实现有效合作关系的先决条件包括计算机分时、内存组件、内存组织、编程语言以及输入和输出设备的发展。</p><p>1介绍</p><p>1.1共生</p><p>只有无花果小黄蜂（Blastophaga grossorun）才能帮助无花果树完成授粉。这种昆虫的幼体生活在无花果树的子房中，它们也能在无花果树的子房中找到食物。如此一来，无花果树和无花果小黄蜂便对彼此有着严重的依赖：没有无花果小黄蜂，无花果树就不能结出果实；没有无花果树，无花果小黄蜂也不能获得食物。两者的结合不仅能使彼此生存下去，更能创造一种高产且生机勃勃的合作关系。“两个不同的生物体以亲密合作的方式生活在一起，甚至结成紧密的联盟”，这种合作模式就叫共生。</p><p>人机共生是人机系统的一个子类。有许多人机系统。然而，目前还没有人机共生体。本文的目的是提出这一概念，并希望通过分析人机交互的一些问题，提请人们注意人机工程的适用原则，并指出一些需要研究回答的问题，从而促进人机共生的发展。我们希望，在不太长的时间内，人脑和计算机将紧密结合在一起，由此产生的伙伴关系将会认为，没有人脑能够以我们今天所知的信息处理机器所未有的方式思考和处理数据。</p><p>1.2在“机器增强的人类”和“人工智能”之间</p><p>作为一个概念，人机共生在一个重要的方面与North所称的“机器增强的人类”是不同的。在过去的人机系统中，操作者掌握主动权，提供方向，进行整合，制定标准。系统中机械的部分，首先是人类的胳膊，然后是眼睛的延伸。这些系统当然不是由“生活在一起的不同生物”组成的。只有一种有机体——人，其余的只是为了帮助这个人。</p><p>在某种意义上，任何人造系统都是为了帮助人类，帮助系统外的一个或多个人。然而，如果我们关注系统内的操作人员，我们会发现，在某些技术领域，过去几年发生了巨大的变化。“机器增强”已经取代了人类，转向了自动化，留下来的人更多的是为了帮助，而不是得到帮助。在某些情况下，特别是在以计算机为中心的大型信息和控制系统中，人工操作员主要负责自动化不可行的功能。这种系统（North可能称之为“人类增强的机器”）不是共生系统。它们是“半自动”系统，系统最初是全自动的，但没有达到目标。</p><p>人机共生可能不是复杂技术系统的最终范例。在适当的时候，电子或化学“机器”似乎完全有可能在我们现在专门考虑的大部分功能上超过人脑。即使是现在，Gelernter的IBM - 704平面几何定理证明程序的进度也和布鲁克林高中学生差不多，并且犯了类似的错误。事实上，有几个理论证明、解决问题、下棋和模式识别程序，它们能够在受限制的领域中与人类的智力表现相媲美；而Newell、Simon和Shaw的“一般问题解决器”可能会消除一些限制。简而言之，避免与(其他)人工智能爱好者争论似乎是值得的，因为他们认为在遥远的未来只有机器的统治地位。然而，在此期间，主要的智力进步将会由密切合作的人和计算机来完成，这将会是一个相当长的过渡期。一个多学科的研究小组，研究了空军未来的研究和发展问题，估计在1980年之前，人工智能的发展使机器能够独自思考或解决具有军事意义问题。这将会导致，比如说，5年的时间来发展人机共生，15年的时间来使用它。15年可能是10年或500年，但那些年应该是人类历史上最具创造力和最激动人心的时期。</p><p>2人机共生的目标</p><p>当今的计算机主要是为了解决预先设定的问题或者按照预定的程序处理数据。计算过程可能取决于计算过程中获得的结果，但是所有的替代方案都必须提前预见。（如果出现不可预见的替代方案，整个过程就会停止，等待程序的必要扩展。）预先制定或预先确定的要求有时并没有什么大的缺点。预先制定或预先确定的要求有时并没有什么大的缺点。人们常说，计算机的编程迫使人们要清楚地思考，它会规范思维过程。如果用户能够提前思考他的问题，那么与计算机的共生关系就没有必要了。</p><p>然而，很多问题……很难提前想透彻，回想一下前文对新兴系统的描述。如果能通过与计算机合作，由直觉引导进行试错，暴露出推理过程中的错误，或是揭示解决方案中某些意想不到的转折，就能更快、更好地解决问题。没有计算机辅助，其他问题根本无法解决。庞加莱预见到了一批重要的潜在计算机用户的沮丧，他说，“问题不是，答案是什么？，问题是，问题是什么”。人机共生的主要目的之一是将计算机有效地纳入技术问题的公式化部分。</p><p>另一个主要目标是密切相关的。这是为了有效地将计算机带入必须“实时”进行的思考过程，时间过快，不允许以传统方式使用计算机。想象一下，例如，试图在这样的时间表上借助计算机指挥一场战斗。你今天提出了你的问题。明天你和程序员一起度过。你会得到一张20英尺长的纸，上面写满了数字，这些数字并没有提供最终的解决方案，只是提出了一种应该通过模拟来探索的策略。显然，这场战斗将在其计划的第二步开始之前结束。与电脑互动的思维方式与你与一位同事互动的思维方式是一样的，他的能力补充了你自己的能力，这将要求人与机器之间的耦合比这个例子所建议的和现状可能的要紧密得多。</p><p>3计算机参与公式化和实时思维的需要</p><p>前面的段落默认了这样的假设：如果可以有效地引入到思想过程中，数据处理机器所能执行的功能将会以一种重要的方式改进或促进思考和解决问题。这种假设可能需要正当理由。</p><p>3.1技术思维的初步和非正式工效分析</p><p>尽管有大量关于思考和解决问题的文献，包括对发明过程的大量历史案例研究，但我找不到比对从事科技企业的人的脑力劳动进行工效研究分析更好的东西。因此，在1957年的春天和夏天，我试着记录一个中等技术人员在他认为专注于工作的时间里所做的事情。尽管我意识到取样的不足，但我还是做了自己的研究对象。很明显，我所做的主要事情是保持记录，如果按照最初计划中设想的细节保存记录，这个项目将会变成一个无限倒退。不是。尽管如此，我还是获得了一张让我停下来的活动照片。也许我的范围不典型——我希望不是，但我担心是。</p><p>我85 %的“思考”时间都花在了思考、决策、学习一些我需要知道的事情上。寻找或获取信息的时间比消化信息的时间多得多。几个小时用于绘制图表，其他几个小时用于指导助手如何绘制图表。当图表完成后，两种关系立刻变得明显，但必须进行绘图以使其成为现实。在某一点上，有必要对语音清晰度和语音噪声比相关函数的六个实验测定值进行比较。没有两个实验者使用相同的语音噪声比定义或测量。需要几个小时的计算才能把数据变成可比的形式。当它们处于可比较的形式时，我只花了几秒钟就确定了我需要知道的东西。</p><p>简而言之，在整个研究期间，我的“思考”时间主要用于本质上是文书或机械的活动：搜索、计算、绘图、转换、确定一组假设或假设的逻辑或动态后果，为决策或洞察铺平道路。此外，我对尝试什么和不尝试什么的选择在很大程度上是出于对文书可行性的考虑，而不是智力能力的考虑，这令人尴尬。</p><p>刚刚描述的研究结果传达的主要建议是，在大多数时间里，被称为技术思维的操作都是机器可以比人类更有效地执行的操作。这些操作必须在不同的变量上以不可预见的和不断变化的顺序进行，这一事实带来了严重的问题。然而，如果这些问题能够以在人和快速信息检索和数据处理机器之间建立共生关系的方式得到解决，那么合作互动显然会大大改善思维过程。</p><p>在这一点上，也许应该承认，我们正在使用术语“计算机”来涵盖各种计算、数据处理以及信息存储和检索机器。这类机器的能力几乎每天都在增加。因此，对该类的功能进行一般性陈述是危险的。也许就人的能力发表一般性声明也同样危险。尽管如此，人类和计算机之间在能力上的某些基因型差异确实很突出，并且它们对可能的人机共生的性质和实现这种共生的潜在价值有着影响。</p><p>正如已经以各种方式所说的那样，人类是嘈杂的窄带设备，但是他们的神经系统有很多平行的同时活跃的通道。相对于人类来说，计算机速度非常快而且非常精确，但是它们一次只能执行一个或几个基本操作。人类很灵活，能够根据新收到的信息“不断地自我规划”。计算机是一根筋的，受其“预编程”的约束。人类自然会说冗余性的语言，这些语言围绕着单一的物体和连贯的动作组织起来，使用20到60个基本符号。计算机“自然”会说非冗余语言，通常只有两个基本符号，对单一物体或连贯动作都没有固有的鉴赏能力。</p><p>要严格正确，这些特征必须包括许多限定符。尽管如此，它们所呈现的不同（因此也是潜在的补充）本质上是正确的。计算机可以很容易、很好、很快地做许多对人类来说困难或不可能的事情，而人类可以很容易、很好地做许多对计算机来说困难或不可能的事情，尽管不是很快。这表明，共生合作，如果成功地融合了人和计算机的积极特征，将具有巨大的价值。当然，速度和语言的差异带来了必须克服的困难。</p><p>4预期共生关系中人和计算机的可分离功能</p><p>似乎人类操作员和设备的贡献在许多操作中会如此完全地融合在一起，以至于在分析中很难将它们整齐地分开。情况就是这样；例如，在收集决策依据的数据时，人和计算机都从经验中找到了相关的先例，如果计算机随后提出了一个符合人直觉判断的行动方案。（在定理证明程序中，计算机在经验中找到了先例，在SAGE系统中，它们提出了行动方案。上述内容并不是一个牵强附会的例子。）然而，在其他行动中，人员和设备的贡献在某种程度上是可分离的。</p><p>当然，至少在早期，人类会设定目标并提供动机。他们将提出假设。他们会问问题。他们会想到机制、程序和模型。他们会记得，这样的人早在1947年，或者至少在二战后不久，就对一个感兴趣的主题做了一些可能相关的工作，他们会知道该主题可能在哪些期刊上发表。总的来说，他们会做出近似的、错误的、但领先的贡献，他们会定义标准并充当评估者，判断设备的贡献并指导总体思路。</p><p>此外，当这种情况确实出现时，人类会处理极低概率的情况。（在当前的人机系统中，这是操作员最重要的功能之一。极低概率替代方案的概率之和往往太大，不容忽视。）当计算机没有适用于特定环境的模式或程序时，人们会填补问题解决方案或计算机程序中的空白。</p><p>信息处理设备本身将把假设转换成可测试的模型，然后根据数据对模型进行测试（操作员可以粗略地指定这些数据，并在计算机将它们提交给他审批时确定它们是相关的）。这些设备将回答问题。它将模拟机制和模型，执行程序，并向操作员显示结果。它将转换数据，绘制图表（以人类操作员指定的任何方式“切蛋糕”，或者如果人类操作员不确定他想要什么，那就呈现几种替代方式）。设备将会插入、推断和转换。它将静态方程或逻辑语句转换成动态模型，以便操作员可以检查他们的行为。一般来说，它将执行可例行公事的文书工作，以填补决策之间的间隔。</p><p>此外，只要有足够的基础支持正式的统计分析，计算机将充当统计推断、决策理论或博弈论机器，对建议的行动方案进行初步评估。最后，它将尽可能多地进行诊断、模式匹配和相关性识别，但在这些领域，它将接受一个明显的次要地位。</p><p>5实现人机共生的前提条件</p><p>在前一节中默认的数据处理设备是不可用的。计算机程序尚未编写。事实上，在非共生的当下和预期的共生未来之间存在着一些障碍。让我们研究一下其中的一些障碍，以便更清楚地了解需要什么以及实现这一目标的可能性。</p><p>5.1人与计算机之间的速度不匹配</p><p>现在的大型计算机对于与一个人进行实时合作思考来说，速度太快，成本太高。显然，为了效率和经济，计算机必须在许多用户之间分配时间。分时系统目前正在积极开发中。甚至有一些安排来防止用户“破坏”除了他们自己的个人程序之外的任何东西。</p><p>在10年或15年后的一段时间里，设想一个“思维中心”似乎是合理的，它将结合当今图书馆的功能，以及信息存储和检索的预期进展和本文前面建议的共生功能。这种设想很容易放大成这样的中心网络，通过宽带通信线路相互连接，并通过租用线路服务连接到各个用户。在这样的系统中，计算机的速度将会平衡，巨大的存储器和复杂程序的成本将会除以用户的数量。</p><p>5.2存储器硬件要求</p><p>当我们开始考虑将任何已知的技术文献存储在计算机存储器中时，我们会遇到数十亿比特数据，除非事情发生显着变化，否则将花费数十亿美元。</p><p>首先要面对的是，我们不会将所有的技术和科学论文都存储在计算机存储器中。我们可能会储存概括得最简洁的部分——数量部分和参考文献——但不是全部。书籍是现存最精美、最人性化的组件之一，在人机共生的背景下，它们将继续发挥重要的功能。（希望计算机能加快图书的查找、交付和归还。）</p><p>第二点是，存储器的一个非常重要的部分将是永久的:部分是不可擦除的内存和部分是发布的内存。计算机将能够一次写入不可擦除的内存，然后无限期地读取，但是计算机将无法擦除不可擦除的内存。（它也可能会重写，将所有的0变成1，就像在之前写的东西上做标记一样。）发布的内存将是“只读”内存。它将被引入到已经构建好的计算机中。计算机将能够重复引用它，但不能改变它。随着计算机越来越大，这些类型的内存将变得越来越重要。它们可以做的比核心、薄膜、甚至磁带存储器更紧凑，而且价格也要便宜得多。主要的工程问题将涉及选择电路。</p><p>就内存需求的其他方面而言，我们可以指望普通的科学和商业计算机的持续发展。存储元件有可能变得与处理（逻辑）元件一样快。这一发展将对计算机的设计产生革命性的影响。</p><p>5.3存储组织要求</p><p>人机共生理念中隐含着这样的要求，即信息可以按名称和模式检索，并且可以通过比串行搜索快得多的程序访问。至少有一半的内存组织问题似乎存在于存储过程中。其余大部分似乎都包含在存储机制或介质中的模式识别问题中。对这些问题的详细讨论超出了目前的范围。然而，简要概述一个有希望的想法，即“trie存储”，可能有助于说明预期发展的一般性质。</p><p>Trie存储是由其创始人Fredkin所称的，是因为它被设计成便于检索信息，并且因为分支存储结构在开发的时候类似于一棵树。大多数常见的内存系统在参数指定的位置存储参数的函数。（从某种意义上说，它们根本不存储这些参数。在另一个更现实的意义上，它们将所有可能的参数存储在内存的框架结构中。）另一方面，trie存储系统存储函数和参数。从标准的初始寄存器开始，参数首先被引入内存，一次一个字符。每个参数寄存器都有一个单元格，每个字符都有一个单元格（例如，两个用于二进制形式的信息），每个字符单元都有一个存储空间，用于下一个寄存器的地址。这个参数是通过写一系列地址来存储的，每一个地址都告诉我们在哪里找到下一个地址。在引数的最后，是一个特殊的“结束参数”标记。然后遵循函数的指示，该函数以多种方式中的一种或另一种方式存储，进一步的trie结构或“列表结构”通常是最有效的。</p><p>Trie存储方案对于小内存来说是低效的，但是随着内存大小的增加，它在使用可用存储空间方面变得越来越高效。该方案吸引人的特点是：1）检索过程极其简单。给定参数后，输入第一个字符的标准初始寄存器，并提取第二个字符的地址。然后转到第二个寄存器，获取第三个寄存器的地址，等等。2）如果两个参数具有相同的初始字符，则它们对这些字符使用相同的存储空间。3）参数的长度不必相同，也不必事先指定。4）在实际存储之前，任何参数都不会保留或使用存储空间。trie结构是在项目被引入内存时创建的。5）一个函数可以用作另一个函数的参数，该函数可以用作下一个函数的参数。因此，例如，通过用参数“矩阵乘法”输入，人们可以检索在计算机上执行矩阵乘法的整个程序。6）通过检查给定级别的存储，可以确定迄今为止存储了哪些相似的项目。例如，如果没有引用Egan, J. P.，那么只需要一两步就能找到Egan James的踪迹…….</p><p>刚刚描述的属性并不包括所有想要的属性，但是它们使计算机存储与人类操作者产生共鸣，并且他们倾向于通过命名或指向来指定事物。</p><p>5.4语言问题</p><p>人类语言和计算机语言之间的基本差异可能是真正共生的最严重障碍。然而，令人欣慰的是，通过解释程序，特别是通过汇编或编译程序，如FORTRAN，已经取得了巨大进步，使计算机适应人类语言形式。Shaw，Newell，Simon和Ellis的“信息处理语言（Information Processing Language）”代表了另一种和解方式。而且，在ALGOL和相关系统中，人们通过采用可以轻易翻译成机器语言的表示和表达的标准公式来证明其灵活性。</p><p>然而，为了实现人与计算机之间的实时合作，有必要利用另外一种相当不同的通信和控制原理。可以通过比较通常针对智能人的指令和通常用于计算机的指令来突出这个想法。后者精确地指定了要采取的各个步骤以及采取这些步骤的顺序。前者提出或暗示了一些关于激励或动机的东西，它们提供了一个标准，在这个标准中，指令的执行者将知道完成任务的时间。简而言之：针对计算机的指令指定路线；针对人类的指令指定了目标。</p><p>人类似乎在目标方面比在路线方面更自然，更容易地思考。的确，他们通常知道一些关于旅行或工作路线的信息，但很少有人能从精确制定的行程开始。例如，谁会带着详细的路线说明从波士顿出发去洛杉矶？相反，用Wiener的话来说，前往洛杉矶的人试图不断减少他们还没有被烟雾笼罩的程度。</p><p>通过两种途径来实现计算机指令。第一个涉及解决问题、爬山算法、自组织项目。第二种是预编程段和闭合子程序的实时串联，操作员可以简单地通过名字来指定和调用这些子程序。</p><p>沿着第一条道路，已经有了有希望的探索性工作。很明显，在预定策略的宽松约束下工作，计算机将能够在适当的时候设计和简化自己的程序来实现既定的目标。迄今为止，这些成就并不重要；他们只是“原则上的示范”。然而，其影响深远。</p><p>尽管第二条道路更简单，显然能够更早实现，但它相对被忽视了。Fredkin的trie存储提供了一个有前途的范例。我们可能会在适当的时候看到一个认真努力来开发的计算机程序，这些程序可以像语言的单词和短语一样连接在一起，这样就可以进行任何计算或控制。显然，阻碍这种努力的考虑因素是，这种努力不会产生任何在现有计算机环境中具有重大价值的东西。在没有任何计算机能够对语言做出有意义的反应之前，开发语言是不可取的。</p><p>5.5输入输出设备</p><p>就人机共生的要求而言，似乎最不先进的数据处理部门是处理输入和输出设备的部门，或者从操作员的角度来看，是处理显示和控制的部门。在说了这句话之后，有必要做出符合条件的评论，因为用于高速引入和提取信息的设备工程一直很出色，而且一些非常复杂的显示和控制技术已经在林肯实验室等研究实验室中得到发展。然而，总的来说，在一般可用的计算机中，几乎没有比电动打字机更有效、更即时的人机通信。</p><p>显示器似乎比控制的状态好一些。许多计算机在示波器屏幕上绘制图形，少数计算机利用了字符显示管卓越的图形和符号功能。然而，据我所知，在技术讨论中，没有任何东西能接近铅笔和涂鸦板的灵活性和方便性，或者是人们使用的粉笔和黑板。</p><p>1）桌面显示和控制：当然，为了有效的人机交互，在相同的显示面上，人和电脑需要绘制图形和图画，并在相同的显示面上写注释和方程。这个人应该能够通过绘制图表，以粗糙但快速的方式向计算机展示一个功能。计算机应该阅读这个人的文字，也许是在清楚的大写字母的条件下，并且应该立即在每个手绘符号的位置张贴相应的字符，并将其翻译成精确的字体。有了这种输入输出设备，操作员将很快学会以机器可读的方式书写或打印。他可以编写指令和子程序，将它们设置成适当的格式，并在最终将它们引入计算机的主存储器之前检查它们。他甚至可以像Gilmore和Savell在林肯实验室所做的那样定义新的符号，并将它们直接呈现给计算机。他可以粗略地勾画出一张表格的格式，然后让电脑精确地塑造它。他可以修正计算机的数据，通过流程图指导机器，并且就像通常与其他工程师一样进行交互，除了“其他工程师”将是精确的绘图员，快速的计算器，助记符向导，以及许多其他有价值的合作伙伴。</p><p>2）计算机发布的墙面显示：在一些技术系统中，几个人共同负责控制行为相互影响的车辆。一些信息必须同时呈现给所有人，最好是在一个公共网格上，以协调他们的行动。其他信息仅与一两个操作者相关。如果所有信息都在一个显示器上呈现给所有人，那将只会产生无法解释的混乱。这些信息必须由计算机发布，因为手工绘图太慢，无法保持最新。</p><p>刚才概述的问题现在甚至是一个关键问题，随着时间的推移，它似乎肯定会变得越来越关键。一些设计者相信，基于光阀原理，可以借助脉冲光源和分时观看屏幕来构建具有所需特性的显示器。</p><p>大多数思考过这个问题的人认为，大型显示器应该由单独的显示器控制单元来补充。后者将允许操作者修改墙面显示而不离开他们的位置。出于某些目的，希望操作者能够通过辅助显示器甚至墙面显示与计算机通信。至少有一种提供这种通信的方案似乎是可行的。</p><p>当然，大型墙面显示及其相关系统与计算机和一组人之间的共生合作相关。实验室实验一再表明，操作员非正式的平行安排，通过参考大型位置显示器来协调他们的活动，比更广泛使用的安排具有重要优势，它将操作员定位在各个控制台上，并试图通过计算机代理来关联他们的行动。这是需要仔细研究的几个操作团队问题之一。</p><p>3）自动语音生成和识别：人类操作员和计算机之间的语音通信有多理想和可行？每当讨论复杂的数据处理系统时，都会问这个复杂的问题。与计算机一起工作和生活的工程师对这种愿望持保守态度。在自动语音识别领域有经验的工程师对可行性持保守态度。然而，人们仍然对与计算机对话的想法感兴趣。在很大程度上，这种兴趣源于人们认识到，很难把一名军事指挥官或公司总裁离开他们的工作，教他们打字。如果计算机能够被高层决策者直接使用，那么通过最自然的方式提供通信可能是值得的，即使花费相当大的成本。</p><p>对公司总裁的问题和时间尺度的初步分析表明，他只对作为爱好的计算机的共生关系感兴趣。业务情况通常进展缓慢，以至于有时间进行简报和会议。因此，对于计算机专家而言，与商务办公室中的计算机直接交互似乎是合理的。</p><p>另一方面，军事指挥官在短时间内做出关键决策的可能性更大。人们很容易夸大10分钟战争的概念，但是指望有十分钟以上的时间来做出关键决定是危险的。因此，随着军事系统地面环境和控制中心的能力和复杂性的增长，计算机自动语音生成和识别的真正需求似乎有可能得到发展。当然，如果设备已经被开发、可靠的和可用的，它就会被使用。</p><p>就可行性而言，与自动识别语音相比，语音产生带来的技术性问题不那么严重。一台商用电子数字电压表现在一个数字一个数字地大声读出它的指示。八年或十年，贝尔电话实验室，皇家理工学院（斯德哥尔摩），Signals Research and Development Establishment（Christchurch），耶鲁大学汉斯金实验室和麻省理工学院，Dunn，Fant，Lawrence，Cooper，Stevens和他们的同事，已经展示了一代又一代的可理解的自动发生器。汉斯金实验室的研究已经开发出了一种适合计算机使用的数字代码，这种代码使得自动语音完全可以理解相关的话语。</p><p>自动语音识别的可行性在很大程度上取决于要识别的单词的词汇量以及说话者和口音的多样性。几年前，在贝尔电话实验室和林肯实验室，人们已经证明了百分之九十八的正确识别自然的十进制数字。为了进一步扩大词汇量，我们可以说，现在几乎可以肯定地在现有知识的基础上开发出一种清晰发音的字母数字字符的自动识别器。由于未经训练的操作员读取的速度与训练有素的操作员键入的速度至少一样快，因此这种设备几乎可以在任何计算机安装中使用。</p><p>然而，为了在真正共生的水平上进行实时交互，可能需要大约2000个单词的词汇，例如1000个基本英语单词和1000个专业术语。这是一个具有挑战性的问题。在声学专家和语言学家的共识中，现在还不能完成建立2000个单词的识别器。然而，有几个组织乐意承诺在五年内为这样的词汇开发一个自动识别系统。他们会规定演讲要清晰，听写的风格，没有不寻常的口音。</p><p>尽管对自动语音识别技术的详细讨论超出了目前的范围，但值得注意的是，计算机在自动语音识别器的发展中起着主导作用。他们为当前的乐观情绪提供了动力，或者说是一些人目前的乐观情绪。两三年前，似乎在10年或15年内不会自动识别大量词汇；它将不得不等待语音交流中声学、语音、语言和心理过程的知识的逐渐积累。然而，现在，许多人看到了借助计算机处理语音信号来加速获取这种知识的前景，不少工作者认为，即使没有语音信号和过程的大量实质性知识的帮助，复杂的计算机程序也能像语音模式识别一样表现出色。将这两个考虑因素结合起来，可以将实现实际意义上的语音识别所需的时间估计降低到五年，即刚才提到的五年。</p><hr><h1 id="个人解读"><a href="#个人解读" class="headerlink" title="个人解读"></a>个人解读</h1>]]></content>
      
      
      <categories>
          
          <category> -未来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU机组</title>
      <link href="/2020/11/28/shu-ji-zu/"/>
      <url>/2020/11/28/shu-ji-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理与结构体系"><a href="#计算机组成原理与结构体系" class="headerlink" title="计算机组成原理与结构体系"></a>计算机组成原理与结构体系</h1><h2 id="理论学习"><a href="#理论学习" class="headerlink" title="理论学习"></a>理论学习</h2><p><a href="https://www.bilibili.com/video/BV1BE411D7ii" target="_blank" rel="noopener">b站王道机组课程</a></p><h2 id="实验一二三（实验箱）"><a href="#实验一二三（实验箱）" class="headerlink" title="实验一二三（实验箱）"></a>实验一二三（实验箱）</h2><h2 id="实验四（虚拟机）"><a href="#实验四（虚拟机）" class="headerlink" title="实验四（虚拟机）"></a>实验四（虚拟机）</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>看一遍老师给的教程。（虽然它是一份老掉牙的教程，但是你首先得知道自己要干什么，然后才好跟上大家吐槽的脚步。建议先全部看一遍，而且最后的问题汇总其实更应该放到教程开头才对）</p></li><li><p>最好提前了解一点Linux操作系统的相关知识，不是很清楚也没关系，按照步骤把实验做一遍下来大概也就差不多了。</p></li><li><p>这里是一些可能需要提前在自己电脑上安装好的东西，可能会用到的链接和教程都放在这里了，需要的请自取。</p></li></ul><p><a href="https://blog.csdn.net/hao5119266/article/details/89198275" target="_blank" rel="noopener">VM虚拟机下载及安装教程</a></p><p><a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">Vmware官方</a></p><p><a href="https://vault.centos.org/6.5/isos/x86_64/" target="_blank" rel="noopener">centos6.5下载</a><strong>（版本一致很重要！版本一致很重要！版本一致很重要！）</strong></p><hr><p>重要的事说三遍，这里说的一致是和老师给的教程里使用的版本一致，因为有的同学安装的是centos7或8甚至是Ubuntu（不同版本操作命令可能不同，安装过程也可能不会完全相同），如果你不想花费大量时间在打开CSDN上的话，建议还是装这个CentOS-6.5-x86_64-<strong>LiveCD</strong>。而且这个下载起来也快，只有600多M。之后再按照教程走就会轻松很多，直到你碰上你的第一个问题，最起码你可以不那么困难地迈出第一步。</p><hr><p>下面是几篇避坑的博客，<strong>偷懒最好的办法是一遍就把事情做好</strong>，所以为了省时间还是值得一看的，当然你也可以等遇到问题再来查</p><p><a href="https://zhuanlan.zhihu.com/p/68111471" target="_blank" rel="noopener">精通 VIM ，此文就够了</a>（linux的编辑器，和你以前使用过的编辑器可能完全不一样，做好心理准备）</p><p><a href="https://yuhui.blog.csdn.net/article/details/52325716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai" target="_blank" rel="noopener">虚拟机：三台虚拟机互通且连网</a>（要是早点看到这篇我就不用花那么多时间找其他博客了，感谢原博主帮我找到了我的问题）</p><p><a href="https://blog.csdn.net/mijichui2153/article/details/80918285" target="_blank" rel="noopener">CentOS7虚拟机克隆，且成功互ping</a>（仅供参考）</p><p>最后还是不得不吐槽一下老师给的参考教程版本实在是太老了，虽然我在这个很痛苦的过程中也学到了不少东西，但也带来了很多不必要的困扰，就拿centos6.5这个版本举例，现在都0202年了，官网上有的是centos7和8，那找起6.5来就是一个重复做功的过程，而教程后的链接也是失效的，简直是浪费感情。</p><p>剩下的其实就只要按照老师给的教程来就行了，直到虚拟机之间互通这里，我碰到最麻烦的问题也还是版本的问题，吐槽最多的地方也还是教程太老以及不够仔细。</p><hr><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>下面是我在实验过程中遇到过的一些问题，仅供参考。</p><p>首先还是回到老师给的教程上里面，如果你看的足够仔细就会发现有个地方很奇怪，那就是在修改复制的（或者说克隆）虚拟机ip这里，原来教程这里写的是</p><pre><code>修改ip：vim /etc/sysconfig/network-scripts/ifconfig-eth0将IPADDR=后的ip改为192.168.224.201</code></pre><p>但是在创建第一台虚拟机配置centos网络时是这样的</p><pre><code>配置centos网络：vim /etc/sysconfig/network-scripts/ifcfg-eth0修改（或者说是输入）DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticBROADCAST=192.168.224.225 IPADDR=192.168.224.130 NETMASK=255.255.255.0NETWORK=192.168.224.0 GATEWAY=192.168.224.2 </code></pre><p>同样是改IPADDR，为什么两个文件名不一样呢？（ifconfig-eth0和ifcfg-eth0）</p><p>这里要么是版本的问题，要么就是一个笔误，造成的后果可能就是你三台虚拟机都能ping master而不能实现真正的互通（会显示Unreachable）。</p><p>因为如果你细心的话就会发现当你在复制的虚拟机上打开ifconfig-eth0时，其实是新建了一个名为ifconfig-eth0的文件，而不是打开了复制过来的ifcfg-eth0文件。（可以自己验证一下）这里只需要注意一下即可。</p><p>我遇到的最坑的问题还是下面这个</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/798663-20160711161510686-1749110137.png" alt="直接复制文件导致两台虚拟机Mac相同，即物理地址和备份的虚拟机重复"></p><p>我是按照教程在windows中文件中直接将一个虚拟机进行复制了两份（克隆好像就没有问题），然后用vm打开， 选择我已经复制，结果虚拟机开机的时候出现了上面的日志消息提示，导致了我无法ping 通。解决方法如下（改不了的话先关闭一下虚拟机）： </p><p><a href="https://www.cnblogs.com/nucdy/p/5660701.html" target="_blank" rel="noopener">如何更改Mac地址</a></p><hr><p><strong>ssh无密码验证原理：</strong></p><p>节点A要实现无密码公钥认证连接到节点B上时，节点A是客户端，节点B是服务端，需要在客户端A上生成一个密钥对，包括一个公钥和一个私钥，而后将公钥复制到服务端B上。当客户端A通过ssh连接服务端B时，服务端B就会生成一个随机数并用客户端A的公钥对随机数进行加密，并发送给客户端A。客户端A收到加密数之后再用私钥进行解密，并将解密数回传给B，B确认解密数无误之后就允许A进行连接了。这就是一个公钥认证过程，其间不需要用户手工输入密码。重要过程是将客户端A公钥复制到B上。</p><p><img src="https://m.qpic.cn/psc?/V50yGAmm4Y7rG60gKAT73IXxN50OzhRf/bqQfVz5yrrGYSXMvKr.cqfBUrrv5isfzJMoRkFHPwqDEOOykWN3ExbxXLwX3CIPppXZvOULP*UwfGuI0whImzuhWCI3ZKLgliZeH.HHaIik!/b&bo=gAcPBAAAAAADB64!&rf=viewer_4" alt="第一步就出错了"></p><p>教程里第一步启用shh服务找不到文件，可能是版本不一样所以命令不一样了，不过很神奇的是我在第一台虚拟机上能够使用这条命令，但是复制的那两台上无法成功运行。所以我直接参考了<a href="https://www.cnblogs.com/opsprobe/p/9147934.html" target="_blank" rel="noopener">CentOS6.5下安装、配置SSH</a>（最后是使用putty需要自行安装），只要确认shh正常启用就行。以下是我成功运行的一些命令</p><blockquote><p>1.登录CentOS 6.5系统，使用root用户登录，如果为非root用户则执行 su 或 su - 或 su root 或 su - root 输入root密码切换为root用户。</p><p>2.查看SSH是否安装（检查是否装了SSH包）。<br>输入命令：rpm -qa | grep ssh 或者（rpm -qa | grep openssh）</p><p>3.查看SSH服务是否正在运行。<br>输入命令：/etc/init.d/sshd status 或者（service sshd status）</p><p>4.若CentOS 6.5系统中SSH服务处于非运行状态则使用（service sshd start）命令开启SSH服务；停止SSH服务命令（service sshd stop）；重启SSH服务命令（service sshd restart）。为了演示效果，我这里先停止SSH服务，然后启动SSH服务，再接着重启SSH服务。[service sshd stop] -&gt; [/etc/init.d/sshd status] -&gt; [service sshd start]-&gt; [service sshd restart] -&gt; [/etc/init.d/sshd status] </p><p>[重启后可输入：netstat -antp | grep sshd 查看是否启动22端口]</p><p>5.检查sshd是否在本运行级别下设置为开机启动<br>输入命令：chkconfig –list sshd<br>CentOS 6.5系统中SSH服在本运行级别下已经设置为开机启动,如果没设置启动就使用如下命令[chkconfig –level 2345 sshd on]设置下即可。（每个级别需要分别开启）</p></blockquote><p>【常见的远程SSH登录工具有：securecrt、xshell、putty等..】</p><p><a href="https://blog.csdn.net/wojiuguowei/article/details/79308090" target="_blank" rel="noopener">使用Xshell远程访问虚拟机</a></p><p>先来看看按照老师给的教程能不能幸运地完成实验吧。</p><p>![很不幸，不能](<a href="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc" target="_blank" rel="noopener">https://gitee.com/henry-avery/my_pic_bed/raw/master/psc</a> (1).png)</p><p>最后一条重启命令一看就知道应该是又把service写错成servive了。</p><p>![正常重启](<a href="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc" target="_blank" rel="noopener">https://gitee.com/henry-avery/my_pic_bed/raw/master/psc</a> (2).png)</p><p>之后就是一路采坑，最后也不知道自己怎么搞定的，看了很多博客但好像最后都没怎么用上。</p><p>而且这里具体问题还需要具体解决，可以在这篇博客的评论区把遇到的问题发出来，让大家帮忙看看。</p><p><strong>scp连接远程传输报错The authenticity of host …… can‘t be established.</strong></p><p><a href="https://blog.csdn.net/qq_35022803/article/details/108937779" target="_blank" rel="noopener">解决linux配置ssh免密登录遇到的异常：-bash: cd: /root/.ssh: Not a directory</a></p><p>No such file：可能要先进入子目录（cd .ssh），然后在使用scp命令，否则找不到你要传输的文件</p><hr><p><strong>使用ssh实现windows主机与linxu虚拟机文件互传</strong></p><p>这一步网上教程很多，但是可能还是不能完全符合我们的需求。</p><p>首先在主机上安装SSH Secure Shell，这个软件的下载地址是：<a href="http://ccm.net/download/download-1423-ssh-secure-shell-windows，如果打不开，请自行百度解决。" target="_blank" rel="noopener">http://ccm.net/download/download-1423-ssh-secure-shell-windows，如果打不开，请自行百度解决。</a></p><p>在实现互传文件之前先要令主机和虚拟机ping通，所以在这里先直接测试能不能ping通，别急着关防火墙和调整网络设置，如果之前的操作正确的话是可以直接跳过前两步的。</p><blockquote><p>在cmd中输入ipconfig查看本机ip，在terminal中输入ifconfig查看虚拟机ip</p></blockquote><p><a href="https://blog.csdn.net/jiechuhoudeshang/article/details/94407815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai" target="_blank" rel="noopener">虚拟机和主机相互ping不通方法总结</a></p><p>为了使用虚拟机而关闭防火墙这种因小失大的做法是不大可取的，其实设置防火墙很简单，以win7为例，打开控制面板 &gt; 系统和安全 &gt; windows防火墙 &gt;高级设置 &gt;入站规则 &gt; 文件和打印机共享(回显请求 - ICMPv4-In) （专用，公用） &gt; 右键启用 即可</p><p><strong>注意事项</strong>：直接打开SSH Secure File Transfer输入Hostname和Username然后输入密码。</p><p><strong>注意用户名这里不是master和slave1或2，而是你登录虚拟机时的用户名，</strong>比如我三台虚拟机用户名都是centos，否则用户名和密码不匹配会一直让你输入密码。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/psc.png" alt="小波男神镇贴"></p><hr><p><strong>RSH互通</strong></p><p>摆脱教程之后说不定还更简单了，而且碰巧找到了一篇可能是前两届某位学长写的博客，补充了没有的rsh部分，有兴趣可以看看，反正我是不想再多看了一眼了。</p><p><a href="https://blog.csdn.net/kingdomkitty/article/details/79897572" target="_blank" rel="noopener">centos6.5 配置ssh与rsh</a></p><hr><p><a href="https://www.cnblogs.com/baimh/p/11139668.html" target="_blank" rel="noopener"><strong>连接外网</strong></a></p><p><strong>下面摘抄了关于网络配置模式的介绍，可以详细了解下，可以对配置更加清晰；</strong></p><blockquote><p>桥接 通过使用物理机网卡 具有单独ip<br>NAT 把物理机为路由器进行上网</p><p>下面是详细的解说：</p><p>VMWare提供了三种工作模式，它们是bridged(bridged模式)、NAT(网络地址转换模式)和host-only(主机模式)。要想在网络管理和维护中合理应用它们，了解一下这三种工作模式。</p><p><strong>1.bridged(桥接模式)</strong></p><p>在bridged模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。在bridged模式下，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信。如果想利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择bridged模式。<br>这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡 绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。<br>使用这种方式很简单，前提是可以得到1个以上的地址。</p><p><strong>2.NAT(网络地址转换模式)</strong></p><p>使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。<br>这种方式也可以实现Host OS与Guest OS的双向访问。但网络内其他机器不能访问Guest OS，Guest OS可通过Host OS用NAT协议访问网络内其他机器。NAT方式的IP地址配置方法是由VMware的虚拟DHCP服务器中分配一个IP ，在这个IP地址中已经设置好路由，就是指向192.168.138.1的。</p><p>如果想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。这种方式下host内部出现了一个虚拟的网卡vmnet8（默认情况下），如果有过 做nat服务器的经验，这里的vmnet8就相当于连接到内网的网卡，而虚拟机本身则相当于运 行在内网上的机器，虚拟机内的网卡（eth0）则独立于vmnet8。发现在这种方式下，vmware自带的dhcp会默认地加载到vmnet8界面上，这样虚拟机就可以使用dhcp服务。更为重要的是，vmware自带了nat服务，提供了从vmnet8到外网的地址转换，所以这种情况是一个实实在在的nat服务器在运行，只不过是供虚拟机用的。</p></blockquote><hr><h2 id="AI科普：NVIDIA自动避障小车Jetbot-amp-口罩识别"><a href="#AI科普：NVIDIA自动避障小车Jetbot-amp-口罩识别" class="headerlink" title="AI科普：NVIDIA自动避障小车Jetbot &amp;口罩识别"></a>AI科普：NVIDIA自动避障小车Jetbot &amp;口罩识别</h2><p>讲师：侯宇涛，英伟达公司GPU/CUDA应用市场总监。何琨，英伟达开发者社区高级培训师。</p><blockquote><p>上机实验口罩识别就只是使用一下他们写的代码，挺无聊的。</p></blockquote><hr><h2 id="实验五OpenMP"><a href="#实验五OpenMP" class="headerlink" title="实验五OpenMP"></a>实验五OpenMP</h2><p><a href="https://zhuanlan.zhihu.com/p/61857547" target="_blank" rel="noopener">OpenMP入门实例与分析</a></p><p><strong>实验目的</strong></p><p>1) 在Linux平台上编译和运行OpenMP程序；</p><p>2) 在Windows平台上编译和运行OpenMP程序。</p><p>3) 掌握OpenMP并行编程基础。</p><p><strong>实验环境</strong></p><p>1) 硬件环境：计算机一台；</p><p>2) 软件环境：Linux、Win2003、GCC、MPICH、VS2008或其他版本Visual Studio；</p><p><strong>实验内容</strong></p><p>Linux下OpenMP程序的编译和运行。OpenMP是一个共享存储并行系统上的应用编程接口，支持C/C++和FORTRAN等语言，编译和运行简单的”Hello World”程序。在Linux下编辑hellomp.c源程序，或在Windows下编辑并通过附件中的FTP工具（端口号：1021）上传，用”gcc -fopenmp -O2 -o hellomp.out hellomp.c”命令编译，用”./hellomp.out”命令运行程序。</p><p>注：在虚拟机中当使用vi编辑文件时，不是以ESC键退出插入模式，可以使用“Ctrl+c”进入命令模式，然后输入wq进行存盘退出。</p><p>Linux下OpenMP环境，需要安装gcc(<strong>此处注意避坑</strong>，6.5版本太老需换源，可参考以下链接提供方法)</p><pre><code>yum intall gcc    (在redhat, centOS 下使用，用root安装，必须保证网络畅通)</code></pre><p><a href="https://blog.csdn.net/weixin_44160584/article/details/110872926?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-2.nonecase" target="_blank" rel="noopener">centos 6.5 yum安装报YumRepo Error: All mirror URLs are not using ftp, http[s] or file</a></p><p><a href="https://bbs.csdn.net/topics/392269634" target="_blank" rel="noopener">Linux中安装gcc出现All mirror URLs are not using ftp,http[s] or file</a></p><blockquote><p>修改镜像配置：vim /etc/yum.repos.d/CentOS-Base.repo</p><p>将配置文件中的#mirrorlist注释掉，取消注销baseurl的行，将$releasever改成你的centos的版本号,可用cat /etc/redhat-release查看</p></blockquote><p>如果能够正常安装好编译器就没有什么问题了，写好代码放在不同地方跑而已。</p><p>测试代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <omp.h>#include <stdio.h>int main(){int nthreads,tid;omp_set_num_threads(8);#pragma omp parallel private(nthreads,tid){tid=omp_get_thread_num();printf("Hello World from OMP thread %d\n",tid);if(tid==0){nthreads=omp_get_num_threads();printf("Number of threads is %d\n",nthreads);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先从本地传到虚拟机上去，编译然后运行正常就OK了。</p><p><strong>实验报告</strong></p><p><strong>实验目的</strong></p><p>1) 在Linux平台上编译和运行OpenMP程序；</p><p>2) 在Windows平台上编译和运行OpenMP程序。</p><p>3) 掌握OpenMP并行编程基础。</p><p><strong>实验环境</strong></p><p>1) 硬件环境：计算机一台；</p><p>2) 软件环境：Linux（centOS6.5）、Win10、GCC、G++、VS2019</p><p><strong>问题描述</strong></p><p>对于一个大向量（所有元素全部大于 0）， 把它的前半部分全部平方，后半部分全部开方取整。</p><p>将所得的新向量中的奇数个数输出。</p><pre class="line-numbers language-c++"><code class="language-c++">vector<int> v_i{}//初始给定大小的大向量（从1e100~1e10000）vector<int> v_ans{};//新生成的向量，大小与向量v_i相同clock_t s, f;//记录时间double duration;//计算时间长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实验过程</strong></p><p>数据量变动，大于cache</p><p>L1缓存256KB，L2缓存1.0MB，L3缓存6.0MB</p><p>纸质打印</p><p><strong>实验结果</strong></p><pre class="line-numbers language-c++"><code class="language-c++">s :0.372000- size of v_ans:        2522907p :1.378000- size of v_ans:        2522907<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码附录</strong></p><pre class="line-numbers language-c++"><code class="language-c++">/*核心代码示例*/    s = clock();//计时开始#pragma omp parallel for reduction(+:cnt_ans) default(shared)  num_threads(10)//openmp并行计算，开启十个线程    for (int i = 0; i < len; i++)    {        auto& e = v_i[i];        int t = 0;        if (i < len / 2)        {            t = pow(e, 2);        }        else        {            t = (int)sqrt(e);        }        if (t % 2 == 1)        {            cnt_ans += 1;//计数器，计算新向量奇数个数        }    }    f = clock();//计时结束    duration = (double)(f - s) / CLOCKS_PER_SEC;//计算计时时间    printf("s :%f\n", duration);//输出并行计算计时时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/yt_42370304/article/details/83904121" target="_blank" rel="noopener">linux 上查询cache 大小的方法</a></p><p><a href="https://blog.csdn.net/azri81226/article/details/101691139?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">并行程序耗时过大问题</a></p><h2 id="实验六HPL安装和测试"><a href="#实验六HPL安装和测试" class="headerlink" title="实验六HPL安装和测试"></a>实验六HPL安装和测试</h2><h3 id="Linpack背景及内容"><a href="#Linpack背景及内容" class="headerlink" title="Linpack背景及内容"></a><strong>Linpack背景及内容</strong></h3><p><a href="https://blog.csdn.net/hanzhenbushihu/article/details/88416724" target="_blank" rel="noopener">HPL与HPCG测试 (一)</a></p><p><a href="https://blog.csdn.net/sishuiliunian0710/article/details/20493101/" target="_blank" rel="noopener"></a></p><p><a href="https://wenku.baidu.com/view/ce44c4a5b8f67c1cfad6b8f8.html" target="_blank" rel="noopener"></a></p><p>（1）背景介绍</p><p>LINPACK全名Linear Equations Package，是近年来较为常用的一种计算机系统性能测试的线性方程程序包，内容包括求解稠密矩阵运算，带状的线性方程，求解最小平方问题以及其它各种矩阵运算。它最早由来自Tennessee 大学的超级计算专家Jack Dongarra提出。程序用FORTRAN编写，在此基础上还有C，JAVA等版本。Linpack使用线性代数方程组，利用选主元高斯消去法在分布式内存计算机上按双精度(64 bits)算法，测量求解稠密线性方程组所需的时间。Linpack的结果按每秒浮点运算次数（flops）表示。第一个Linpack测试报告出现在1979年的Linpack用户手册上，最初LINPACK包并不是要制订一个测试计算机性能的统一标准，而是提供了一些很常用的计算方法的实现程序，但是由于这一程序包被广泛使用，就为通过Linpack 例程来比较不同计算机的性能提供了可能，从而发展出一套完整的Linpack 测试标准。</p><p>（2）测试标准的内容</p><p>LINPACK标准可以解决的问题有：</p><p> 1) 各种矩阵分解(Matrix factorization)，如LU分解，Cholesky分解， Schur，Gauss分解，SVD分解，QR分解，generalized Schur分解等</p><p>2) 矢量运算（Vector operation），如Copy，Add，scalar multiple，Interchange</p><p>3) 存储模式（Storage Modes），如full，banded，symmetric </p><p>Linpack原始版本的问题规模为100×100的矩阵，目前的Linpack测试分成三个层次的问题规模和优化选择： </p><p>—- 100×100的矩阵</p><p>在该测试中，不允许对Linpack测试程序进行任何修改，哪怕是注释行。 所有的优化工作只能在编译器里完成。</p><hr><p>—- 1000×1000的矩阵</p><p>该测试也叫“面向峰值性能的测试”，在该测试中，要求有所放宽，允许对算法和软件进行修改或替换，并尽量利用系统的硬件特点，以达到尽可能高的性能。但是所有的优化都必须保持和标准算法如高斯消去法相同的相对精度，而且必须使用Linpack的主程序进行调用。测试者可修改或替换其中的过程调用例程DGEFA 和DGESL 。其中DGEFA 是Linpack 软件包中标准的高斯消去LU 分解过程，而DGESL 是根据分解后得到的结果回代求解过程。</p><hr><p>—- 针对大规模并行计算系统的测试，即Highly Parallel Computing。</p><p>在这一测试中，问题规模限制被取消，针对现代的并行计算机，要求最宽松，即用户可对任意大小的问题规模，使用任意个数的CPU ，使用各种优化方法（必须基于高斯消去法）来执行该测试程序，寻求最佳的测试结果。</p><p>目前，用Linpack基准测试出的最高性能指标已经成为衡量机器性能的标准之一，这个数字可以作为对系统峰值性能的一个修正。</p><h3 id="HPL基准测试"><a href="#HPL基准测试" class="headerlink" title="HPL基准测试"></a><strong>HPL基准测试</strong></h3><p>（1）概述</p><p>HPL，即High Performance Linpack，目前已经成为国际标准的Linpack基准测试程序，其1.0版于2000年9月发布，是第一个标准的公开版本并行Linpack测试软件包，一般用于全世界TOP500超级计算机上的并行超级计算机排名。HPL测试标准的用户自由度要大很多，使用者可以选择矩阵的规模，分块大小，分解方法等等一系列的各种参数，都是按需要更改的。 </p><p>HPL软件包需要在配备了MPI环境下的系统中才能运行，还需要底层有线性代数子程序包BLAS的支持（或者有另一种向量信号图像处理库VSIPL也可）。</p><p>HPL软件包不仅提供了完整的Linpack测试程序，还进行了全面细致的计时工作，最后可以得到求解的精确性和计算所花费的总时间。该软件在系统上所能达到的最佳性能值适合很多因素有关的。</p><p>（2）主算法</p><p>该软件包是用来求一个N维的线性方程组A x = b的解，首先通过选局部列主元的方法对Nⅹ(N+1)的[A b]系数矩阵进行LU分解成如下形式：</p><p>[A b]=[[L,U] y]</p><p>由于下三角矩阵L因子所作的变换在分解的过程中也逐步应用到b上，所以最后方程组的解x就可以由转化为求解上三角矩阵U作为系数矩阵的线性方程组 U x = y从而得到。</p><p>为了保证良好的负载平衡和算法的可扩展性，数据是以循环块的方式分布到一个P x Q的由所有进程组成的2维网格中。N x (N+1)的系数矩阵首先在逻辑上被分成一个个Nb x Nb大小的数据块，然后循环的分配到P x Q进程网格上去处理。这个分配的工作在矩阵的行、列两个方向同时进行。</p><p>在前面所提到的N，Nb，P，Q都是可以根据集群的具体配置和用户需要而随时修改的，也是HPL测试中十分关键和重要的几个参数。详细内容请看后面。</p><h3 id="HPL的安装及使用"><a href="#HPL的安装及使用" class="headerlink" title="HPL的安装及使用"></a><strong>HPL的安装及使用</strong></h3><p>主要软件包：</p><p>hpl-2.1.tar.gz</p><p>GotoBLAS2-1.13.tar.gz</p><p>openmpi-1.6.5.tar.gz</p><p><strong>HPL的安装过程</strong></p><p>（1）安装gotoblas</p><p>注：出于提高性能的因数，选择GOTO BLAS，作为HPL调用的底层线性代数子程序包</p><p>目前最新版本为GotoBLAS2</p><p>下载GotoBLAS2-1.13.tar.gz</p><p>（网址<a href="https://www.tacc.utexas.edu/tacc-projects/gotoblas2）" target="_blank" rel="noopener">https://www.tacc.utexas.edu/tacc-projects/gotoblas2）</a></p><blockquote><p>这个网址not found，直接在学习通下载</p></blockquote><p>执行步骤：</p><blockquote><p>需要在虚拟机上进行，先把文件传到虚拟机上</p></blockquote><p>在usr/local/mathlib/goto下解压：（随便什么位置应该都可以，我全部放在桌面了）</p><p>$ tar -zxvf GotoBLAS2-1.13.tar.gz</p><p>$ cd GotoBLAS2</p><p>$ make  （TARGET=NEHALEM）</p><p>注：可直接输入#make既可 也可自己选择参数 类似</p><p> $ make CC=gcc  BINARY=64 TARGET=NEHALEM </p><p>（新的intel都要有后面这个参数）</p><p>依次是编译器 库的位数和cpu的类型（architecture），具体可选择的参数可从GotoBLAS2的目录下02QuickInstall.txt的查找</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228101841554.png" alt></p><p>（3）安装openmpi</p><p> <strong>安装tar压缩的安装包</strong></p><p>tar -zxvf <em>**</em>.tar.gz</p><p>tar -jxvf <em>**</em>.tar.bz(或bz2)<br> 1、用CD命令进入解压缩后的目录<br> 2、输入编译文件命令：./configure（有的压缩包已经编译过，这一步可以省去）<br> 3、然后是命令：make<br> 4、再是安装文件命令：make install<br> 5、安装完毕<br>————————————————<br><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228103352342.png" alt="make好久之后"></p><p>（4）安装HPL</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110042073.png" alt="又是文件名的问题，自己打开文件夹确认"></p><p>（5）编译</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110150035.png" alt="貌似成功编译了"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110340435.png" alt="任务说明，mpicc写错了"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110248444.png" alt="快速成功"></p><p>运行</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228110838391.png" alt="没配置好结点，把结点名设置一下试试"></p><p>改好结点还是遇到错误</p><p><a href="https://www.cnblogs.com/codingmengmeng/p/7456539.html" target="_blank" rel="noopener">Linux中error while loading shared libraries错误解决办法</a></p><p>原因：默认情况下，编译器只会使用/lib和/usr/lib这两个目录下的库文件，通常通过源码包进行安装时，如果不指定–prefix，会将库安装在/usr/local/lib目录下；当运行程序需要链接动态库时，提示找不到相关的.so库，会报错。也就是说，/usr/local/lib目录不在系统默认的库搜索目录中，需要将目录加进去。</p><p>也可能是由于我安装位置的问题，<strong>安装共享库后要注意共享库路径设置问题</strong>，解决方法如下，第二部排错后成功</p><p><a href="https://www.cnblogs.com/lcw/p/3341257.html" target="_blank" rel="noopener">【linux排错】”error while loading shared libraries: xxx.so.x” 错误的原因和解决办法</a></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/image-20210228112440345.png" alt="大概用了一个多小时搞定"></p><p>然后就是慢慢调参写报告了。</p><p>使用gcc编译器的情况下测试，当进程数为4时，测试结果如下表：</p><table><thead><tr><th>N</th><th>NB</th><th>P</th><th>Q</th><th>Time</th><th>Gflops</th></tr></thead><tbody><tr><td>1960</td><td>60</td><td>2</td><td>2</td><td>0.83</td><td>6.079</td></tr><tr><td>1960</td><td>80</td><td>2</td><td>2</td><td>0.84</td><td>6.015</td></tr><tr><td>2048</td><td>60</td><td>2</td><td>2</td><td>0.91</td><td>6.319</td></tr><tr><td>2048</td><td>80</td><td>2</td><td>2</td><td>0.93</td><td>6.165</td></tr><tr><td>1960</td><td>60</td><td>4</td><td>1</td><td>1.28</td><td>3.940</td></tr><tr><td>1960</td><td>80</td><td>4</td><td>1</td><td>1.27</td><td>3.949</td></tr><tr><td>2048</td><td>60</td><td>4</td><td>1</td><td>1.40</td><td>4.105</td></tr><tr><td>2048</td><td>80</td><td>4</td><td>1</td><td>1.37</td><td>4.176</td></tr></tbody></table><h2 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h2><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/726DBF8B-6D7B-4E92-B5BE-3CF9D9C2D016_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/850EB3AB-490C-4527-8278-97C28814B684_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/78801AE2-0135-4690-A858-ABC9023D409C_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/CD541527-A203-405B-BA33-0E1E51415147_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/928ECBFF-572D-4303-8AA2-7055F4891DB7_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/27F3CB21-B6EF-4B6E-9684-A9D9B5BC4F93_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/A854536F-CEAE-428F-AB35-E8976946BB6E_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/300FE9C1-3433-4E74-BF52-6688ECD31D53_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/CBC1B61E-8738-4A8F-B9DB-BE1B4EFA2496_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/9F926425-6690-4D1B-97F7-6B55D99A4F75_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/FD440926-C674-4713-8926-3E2432F475E9_org.jpg" alt></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/A37504FC-C3DF-4B77-A28A-34CAD13DA3D8_org.jpg" alt="历年卷"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/FB9B20B3-B585-434E-A6CA-6D7B2DDB1ACB_org.jpg" alt="填空"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/0E9C81FA-A748-488A-B18D-272C01B460FA_org.jpg" alt></p><p><strong>参考资料</strong></p><p><a href="https://wenku.baidu.com/view/ce44c4a5b8f67c1cfad6b8f8.html#" target="_blank" rel="noopener">实验报告</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHU数据结构</title>
      <link href="/2020/11/28/shu-shu-ju-jie-gou/"/>
      <url>/2020/11/28/shu-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>如果有人不相信数学是简单的,那是因为他们没有意识到人生有多复杂。<br>——冯•诺依曼</p></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="编程问题"><a href="#编程问题" class="headerlink" title="编程问题"></a>编程问题</h4><h5 id="函数指针Visit"><a href="#函数指针Visit" class="headerlink" title="函数指针Visit"></a>函数指针Visit</h5><p><strong>函数指针</strong> 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，<strong>函数指针就是指向代码段中函数入口地址的指针。</strong></p><p>函数指针的声明方法为：</p><p>返回值类型 ( * 指针变量名) ([形参列表]);</p><p>注1：“返回值类型”说明函数的返回类型，“(指针变量名 )”中的括号不能省，括号改变了运算符的优先级。若省略整体则成为一个函数说明，说明了一个返回的数据类型是指针的函数，后面的“形参列表”表示指针变量指向的函数所带的参数列表。例如：</p><p>int func(int x); /<em> 声明一个函数 </em>/</p><p>int (<em>f) (int x); /</em> 声明一个函数指针 */</p><p>f=func; /<em> 将func函数的首地址赋给指针f </em>/</p><p>或者使用下面的方法将函数地址赋给函数指针：</p><p>f = &func;</p><p>赋值时函数func不带括号，也不带参数，由于func代表函数的首地址，因此经过赋值以后，指针f就指向函数func(x)的代码的首地址。</p><p>注2：函数括号中的形参可有可无，视情况而定。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/viafcccy/article/details/102765886" target="_blank" rel="noopener">(*visit)(TElemType e )函数指针理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外国经典音乐</title>
      <link href="/2020/11/17/wai-guo-jing-dian-yin-le/"/>
      <url>/2020/11/17/wai-guo-jing-dian-yin-le/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐的巴洛克——巴洛克艺术的整体风格"><a href="#音乐的巴洛克——巴洛克艺术的整体风格" class="headerlink" title="音乐的巴洛克——巴洛克艺术的整体风格"></a>音乐的巴洛克——巴洛克艺术的整体风格</h2><h3 id="第一讲-音乐与建筑、音乐与绘画、音乐与宗教"><a href="#第一讲-音乐与建筑、音乐与绘画、音乐与宗教" class="headerlink" title="第一讲 音乐与建筑、音乐与绘画、音乐与宗教"></a><strong>第一讲 音乐与建筑、音乐与绘画、音乐与宗教</strong></h3><p><strong>巴洛克艺术的整体风格</strong> “巴洛克（Baroque） 一词源自葡萄牙文，意为不规则的珍珠。</p><p>18世纪“巴洛克”一词首先用于建筑，被18世纪的文艺理论家用来贬称17世纪以来的意大利建筑、雕刻、绘画等艺术。后来巴罗克一词成为一个时代艺术风格的代名词。</p><p>在艺术史上，巴洛克风格是指17、18世纪一种华丽的建筑风格，表现为精密的雕刻、弯曲的线条和夸张的装饰，这种风格明显和文艺复兴时期的平衡风格形成对比。</p><p><strong>巴洛克建筑、雕塑与绘画</strong></p><p>巴洛克时期的艺术表现的是充满动感的形态和刻意夸张的结构</p><p>德国哲学家谢林把建筑称为“凝固的音乐”，因而音乐也被称为“流动的建筑”。建筑与音乐作为艺术的两个载体，相互关联，相互渗透。建筑和音乐的外在形式可以有很多种，但其中的审美规律和审美意蕴有着异曲同工之意味。</p><p>巴洛克建筑（Baroque Architecture）与巴洛克音乐（ Baroque Music）都冠以“巴洛克”这个定语。一个是空间艺术，一个是时间艺术。这二者互相渗透呈现了巴洛克时代的人文景观。</p><p><strong>音乐中的巴洛克</strong></p><p>   巴洛克时期的艺术特征是高贵庄严，气势雄伟，富有动力，激情和张力。同时期的音乐大体上也具有这些特征。巴洛克音乐时期由于普遍使用数字低音记谱法，因此又称“数字低音时代”。</p><p>   巴洛克时期一般是指1600年到1750年，共150年的历史阶段。其重要的标志是1600年歌剧的诞生，到1750年巴赫逝世为止。</p><p><strong>巴洛克时期代表音乐家</strong></p><p>  像同时代的姊妹艺术一样，巴洛克时期的音乐也充满着激情与色彩，在追求广博与深远的同时，也喜好精致与华丽。在这一个半世纪的音乐历史中，出现大批作曲家，主要代表有：蒙特威尔第、维瓦尔第、吕利、珀塞尔、亨德尔和J.S.巴赫等。他们的创作领域和艺术个性虽然各不相同，但都包含了巴洛克音乐的某些基本特征。</p><p>  音乐在西方文明进程中与宗教文化关系紧密，甚至可以说它就是宗教文化的一部分。圣咏、经文歌、赞美诗、弥散曲等都是宗教音乐文化的主要形式。西方音乐就是在这个基础上发展起来的。</p><p>​    18世纪启蒙时期以后，音乐开始向世俗化发展，艺术的自主性、社会性以及创造性进入蓬勃发展的时期。但宗教音乐仍然占据着一定的地位。从巴洛克时期、古典时期到浪漫时期，众多的音乐大师们给我们留下了极其丰富的宗教音乐的遗产。</p><p><strong>圣咏——宗教音乐重要源头</strong></p><p>   宗教音乐是欧洲艺术音乐的源头。在18世纪以前，欧洲音乐主要以教会音乐为主，而教会音乐则以圣咏为主。圣咏是指单声调，没有固定节拍的宗教歌曲，分东方圣咏和西方圣咏，前者例如亚美尼亚圣咏，拜占庭圣咏等，后者例如安布罗西圣咏，格里高利圣咏等。公元6世纪，教皇格雷高利一世对宗教音乐——圣咏进行了统一。</p><p><strong>管风琴——宗教音乐的象征</strong></p><p>   管风琴在西方音乐中是历史最悠久的键盘乐器。它的体积庞大，构造复杂，通常是固定置放在大教堂或音乐厅里，大型的管风琴可拥有多层键盘和上千根乐管。因此，管风琴的音域宽广，音量洪大、音色多样，气势宏伟，能模仿管弦乐器效果，能演奏丰富的和声，有“乐器之王”之称。</p><p> 管风琴具有雄伟磅礴的气势，肃穆庄严的气氛，其丰富的和声效果绝不逊色于一支管弦乐队，是最能激发人类产生敬畏之情的乐器，也是最具宗教色彩的乐器。</p><p>经典作品赏析：</p><p><strong>管风琴曲《D小调托卡塔与赋格》</strong></p><p>这首作品是德国作曲家、管风琴家 约翰•塞巴斯蒂安•巴赫（Johann Sebastian Bach ，1685-1750）的代表作之一，具有华丽的技巧、风格和雄伟的戏剧情节。是巴赫在1704-1707年间专为阿恩斯塔德教堂的新管风琴所创作的。</p><p>托卡塔（Toccata）是巴洛克时期常用的键盘音乐乐体裁，以炫示即兴创作和表演为主要目的。</p><p>赋格是拉丁文Fuga的音译，意思是“飞翔”、“遁走”。是复调音乐中最复杂而又严谨的曲式体裁，其结构通常包括呈示部、展开部、再现部三部分，基本特点是运用模仿对位法，使一个简短而富有特性的主题在乐曲的各个声部轮流出现，互相模仿，造成力量的不断积聚增长，当乐曲内在的能量完全释放，乐曲便告结束。因此了解主题的性格特点往往是把握整个乐曲的关键。</p><p><strong>清唱剧《弥赛亚》</strong></p><p><strong>英籍德国作曲家</strong>亨德尔（Georg Friedrich Handel，1685-1759）的代表作。亨德尔出生在德国中部的哈雷镇。成年后的亨德尔离开汉堡游历欧洲。最后他选择了英国，并在伦敦定居下来，在这个城市生活了近50年。成为英国音乐界的领军人物，对英国的音乐发生深远的响。</p><p><strong>清唱剧(Oratorio)</strong>是一种从十七世纪发展起来的音乐形式，常以宗教或半宗教故事作为主题，没有复杂的舞台情节而注重音乐的表现。亨德尔的清唱剧由于剧情取材于英国人耳熟能详的圣经故事，且采用英语演唱，因此广受英国人喜爱。1742年，他仅用24天就完成了清唱剧《弥赛亚》的创作。同年这部作品在爱尔兰首府都柏林低调上演，获得了巨大的成功。亨德尔在英国的声誉得到极大的提升，成为英国的音乐生活的核心人物。</p><p> 《弥撒亚》分三部分：第一部分为 [预言与完成] 描写耶稣诞生的预言和他的诞生。第二部分为 [受难与得胜] 描写耶稣四处传播福音和受难。第三部分为 [复活与光荣] 写耶稣显圣复活。全曲包括有序曲、咏叹调、独唱、重唱、合唱、间奏等57首分曲。</p><p>​    这部作品每年圣诞节都在世界各地上演，以庆祝耶稣基督的降生并歌颂他的救世精神。其中“哈里路亚”合唱以其崇高雄浑的旋律，谐和丰满的和声，鲜明活跃的节奏，充分表现出基督教徒对救世主衷心的感恩，以及欢愉喜悦的心情。</p><p>《弥赛亚》中的第44分曲 “哈里路亚”合唱</p><p><strong>巴洛克艺术的共通性</strong></p><p> 巴洛克时期艺术的重要特点之一就是艺术一体化的高度融合和繁荣，无论是建筑、雕塑、绘画、音乐都相互影响，相互融合，所有宏伟建筑都囊括了这些艺术组合。在表现形式上，巴洛克艺术在观念和造型上是大胆的、装饰性的、且气势宏伟、动感强烈、充满活力。</p><h3 id="第二讲-数字与音乐的游戏——巴洛克复调艺术之美"><a href="#第二讲-数字与音乐的游戏——巴洛克复调艺术之美" class="headerlink" title="第二讲 数字与音乐的游戏——巴洛克复调艺术之美"></a>第二讲 数字与音乐的游戏——巴洛克复调艺术之美</h3><p>杜费与经文歌《近日玫瑰开放》</p><p>巴洛克时期的键盘乐器：拨弦古钢琴、击弦古钢琴、近代钢琴（1710）、现代钢琴（1850）</p><p>巴赫与《十二平均律钢琴曲集》——钢琴乐的“旧约全书”</p><p>《C大调前奏曲与赋格》</p><p>约翰·帕赫贝尔与卡农，帕赫贝尔的卡农的全名是《Canon and Gigue in D major for 3 violins and Basso Continuo》（为三把小提琴和通奏低音创作的D大调卡农和吉格舞曲）。</p><p>《G弦上的咏叹调》</p><p>出自巴赫《D大调第3管弦乐组曲》第二乐章“咏叹调”。1871年由德国小提琴家威廉密将其改编成小提琴独奏曲，他将原曲由D大调改为C大调，让乐曲的主旋律完全在小提琴最低的一根弦——G弦上演奏，此曲因而得名“G弦上的咏叹调”：</p><p><strong>复调</strong></p><p>一种“多声部音乐”。作品中含有两条以上（含）独立旋律，通过技术性处理，和谐地结合在一起，这样的音乐就叫做<em>复调</em>音乐。</p><h3 id="第三讲-神性时代的世俗快乐"><a href="#第三讲-神性时代的世俗快乐" class="headerlink" title="第三讲 神性时代的世俗快乐"></a>第三讲 神性时代的世俗快乐</h3><p>世俗歌曲起源：意大利牧歌</p><p><strong>意大利牧歌 蒙特威尔第《残酷的阿马里利》</strong></p><p>文艺复兴时期最后一位伟大的牧歌作曲家，巴洛克早期歌剧奠基人</p><p><strong>法国尚松 雅内坎《百鸟之歌》</strong></p><p><strong>第一部歌剧</strong></p><p>1597利努契尼剧本，佩里作曲《达芙妮》（残片）</p><p>1600利努契尼剧本，佩里和卡契尼作曲《尤里迪西》（Euridice）</p><p><strong>第一座歌剧院</strong>（1637，威尼斯，圣卡西亚诺）</p><p><strong>蒙特威尔第 歌剧《奥菲欧》序曲</strong>(歌剧史上第一部真正意义上的歌剧，1607)</p><p><strong>巴洛克时期主要四大类乐器</strong></p><p>键盘乐器、弦乐器、管乐器、打击乐器</p><p><strong>巴洛克时期的乐曲题体裁</strong></p><p>巴洛克时期奏鸣曲（sonata）巴洛克时期协奏曲（concerto）</p><p>托卡塔（toccata）赋格曲（fugue）前奏曲（prelude）组曲（Dance Suite）</p><p><strong>安东尼奥·维瓦尔第</strong>“红发神父”（1678-1741）</p><p>“快慢快”三乐章结构规范，对巴洛克协奏曲贡献巨大，为古典协奏曲形式打下基础</p><p>维瓦尔第 小提琴协奏曲《四季》（指挥：卡拉扬，小提琴：安妮·索菲·穆特）</p><p>第一乐章：快板</p><p>第二乐章：广板</p><p>第三乐章：快板“田园舞曲”</p><p><strong>亨德尔 管弦乐组曲《水上音乐》</strong></p><h2 id="形式美的时代"><a href="#形式美的时代" class="headerlink" title="形式美的时代"></a>形式美的时代</h2><h3 id="第一讲-十八世纪西方宫廷音乐文化"><a href="#第一讲-十八世纪西方宫廷音乐文化" class="headerlink" title="第一讲 十八世纪西方宫廷音乐文化"></a><strong>第一讲 十八世纪西方宫廷音乐文化</strong></h3><p><strong>约瑟夫·海顿 ——维也纳古典乐派奠基人</strong>（1732-1809）“交响曲之父”</p><p>古典主义（法语：Le Classicisme 英语：Western classical），形成并繁盛于17世纪的法国，从古希腊罗马文化里面吸取艺术形式和题材，主张拥护中央集权，尊崇王权，歌颂君主；崇尚理性，克制个人情欲，有严格的艺术规范和标准。</p><p>注重形式优雅与和谐的美。</p><p>古典乐派（18世纪中叶-19世纪30年代）</p><p><strong>第45交响曲“告别”末乐章</strong></p><p>引发思考：古典主义时期音乐家社会身份、音乐家与雇主的关系</p><p><strong>交响曲</strong></p><p>第一乐章：快板，奏鸣式</p><p>第二乐章：广板行板或广板，奏鸣式或主题与变奏形式</p><p>第三乐章：带三声中部的小步舞曲</p><p>第四乐章：快板或比第一章更快的急板</p><p>乐队编制以弦乐四声部为基础，双管制的管弦乐体制在海顿手里成型</p><p><strong>海顿 第94交响曲“惊愕”第二乐章片段</strong></p><p>引发思考：古典主义时期音乐的功能：娱乐社交</p><p><strong>海顿 弦乐四重奏 NO.76-3 “皇帝”第二乐章</strong></p><h3 id="第二讲-纯音乐之美在形式中自由飞扬"><a href="#第二讲-纯音乐之美在形式中自由飞扬" class="headerlink" title="第二讲 纯音乐之美在形式中自由飞扬"></a><strong>第二讲 纯音乐之美在形式中自由飞扬</strong></h3><p><strong>沃尔夫冈阿马德乌斯莫扎特</strong>（Wolfgang Amadeus Mozart，1756-1791）</p><p>萨尔茨堡与维也纳</p><p><strong>莫扎特 D小调第20钢琴协奏曲</strong></p><p>第一乐章：快板</p><p>第二乐章：慢板，浪漫曲</p><p>第三乐章：快板，回旋曲</p><p><strong>莫扎特 A大调第五小提琴协奏曲</strong></p><p><strong>莫扎特 第40交响曲</strong></p><p>第一乐章：很快的快板 G小调 2/4 奏鸣曲式</p><p>第二乐章：行板 降E大调 6/8 奏鸣曲式</p><p>第三乐章：小快板 G小调 3/4 小步舞曲</p><p>第四乐章：很快的快板 G小调 2/2 奏鸣曲式</p><p><strong>小夜曲或嬉游曲</strong></p><p>主要是指供娱乐的，室内重奏乐队演奏的多乐章组曲，主题朴素民歌风，情绪轻松活泼</p><p><strong>莫扎特 G大调弦乐小夜曲</strong></p><p>第一乐章：快板，奏鸣曲式</p><p>第二乐章：行板，浪漫曲</p><p>第三乐章：小快板，小步舞曲</p><p>第四乐章：快板，回旋曲</p><h3 id="第三讲-音乐戏剧的天才禀赋"><a href="#第三讲-音乐戏剧的天才禀赋" class="headerlink" title="第三讲 音乐戏剧的天才禀赋"></a>第三讲 音乐戏剧的天才禀赋</h3><p><strong>莫扎特的歌剧</strong></p><p>意大利喜歌剧：《费加罗的婚礼》《唐璜》《女人心》</p><p>德国歌唱剧：《魔笛》《后宫诱逃》</p><p>正歌剧：《伊多美纽斯》《狄多的仁慈》</p><p><strong>莫扎特 歌剧《费加罗的婚礼》男中音选段 费加罗“你不要再去做情郎”</strong></p><p><strong>莫扎特</strong> <strong>歌剧《费加罗的婚礼》女高音二重唱“微风轻拂的时光”</strong></p><h2 id="奏响时代最强音"><a href="#奏响时代最强音" class="headerlink" title="奏响时代最强音"></a>奏响时代最强音</h2><h3 id="第一讲-音符迸发出的思想火花"><a href="#第一讲-音符迸发出的思想火花" class="headerlink" title="第一讲 音符迸发出的思想火花"></a>第一讲 音符迸发出的思想火花</h3><p><strong>路德维希·范·贝多芬</strong>(1770-1872)——集古典音乐之大成，开浪漫主义之先河</p><p>波恩时期与维也纳早中晚期，谐虐曲取代小步舞曲，主要作品歌剧《费德里奥》艺术歌曲《远方的爱人》宗教性合唱《庄严弥撒》</p><p><strong><em>贝多芬的交响曲</em></strong></p><p><strong>贝多芬 第三交响曲 “英雄” 第一乐章片断</strong></p><p>贝多芬 第五交响曲 “命运”第一乐章</p><p>贝多芬 第六交响曲“田园”第一乐章</p><p>贝多芬 第九交响曲 “合唱交响曲” 第四乐章片断</p><h3 id="第二讲-用音乐的力和美颂扬全人类最高理想"><a href="#第二讲-用音乐的力和美颂扬全人类最高理想" class="headerlink" title="第二讲 用音乐的力和美颂扬全人类最高理想"></a>第二讲 用音乐的力和美颂扬全人类最高理想</h3><p><strong><em>贝多芬的钢琴奏鸣曲</em></strong></p><p><strong>贝多芬 C小调第八钢琴奏鸣曲 “悲怆” 第一乐章</strong></p><p>贝多芬 第十四钢琴奏鸣曲 “月光”</p><p>贝多芬 D小调第十七钢琴奏鸣曲 “暴风雨”</p><p>贝多芬 第五钢琴协奏曲 “皇帝”第三乐章</p><p><strong>贝多芬弦乐四重奏 Op.59 ‘Rasumovsky’ No.2-4</strong></p><h2 id="音乐史上的“狂飙时代”"><a href="#音乐史上的“狂飙时代”" class="headerlink" title="音乐史上的“狂飙时代”"></a>音乐史上的“狂飙时代”</h2><p><strong>狂飙突进运动</strong>（<a href="https://baike.baidu.com/item/德语/240836" target="_blank" rel="noopener">德语</a>：Sturm und Drang）是指1760年代晚期到1780年代早期德国<a href="https://baike.baidu.com/item/新兴资产阶级/1831940" target="_blank" rel="noopener">新兴资产阶级</a>城市青年所发动的一次文学解放运动，也是德国启蒙运动的第一次高潮。这个时期，是文艺形式从<a href="https://baike.baidu.com/item/古典主义/202936" target="_blank" rel="noopener">古典主义</a>向<a href="https://baike.baidu.com/item/浪漫主义/214808" target="_blank" rel="noopener">浪漫主义</a>过渡时的阶段，也可以说是幼稚时期的浪漫主义。其名称来源于剧作家<a href="https://baike.baidu.com/item/克林格/13868929" target="_blank" rel="noopener">克林格</a>的戏剧“狂飙突进”，但其中心代表人物是<a href="https://baike.baidu.com/item/歌德/63083" target="_blank" rel="noopener">歌德</a>和<a href="https://baike.baidu.com/item/席勒/3020501" target="_blank" rel="noopener">席勒</a>，歌德的《<a href="https://baike.baidu.com/item/少年维特的烦恼" target="_blank" rel="noopener">少年维特的烦恼</a>》是其典型代表作品，表达的是人类内心感情的冲突和奋进精神。这次运动是由一批市民阶级出身的青年德国作家发起的，他们受到<a href="https://baike.baidu.com/item/启蒙时代/29262" target="_blank" rel="noopener">启蒙时代</a>影响，推崇天才，创造性的力量，并把其作为其<a href="https://baike.baidu.com/item/美学" target="_blank" rel="noopener">美学</a>观点的核心。狂飙突进时期的作家受到当时<a href="https://baike.baidu.com/item/启蒙运动/119997" target="_blank" rel="noopener">启蒙运动</a>的影响，特别是受到了<a href="https://baike.baidu.com/item/卢梭/193632" target="_blank" rel="noopener">卢梭</a>哲学思想的影响，他们歌颂“天才”，主张“自由”、“个性解放”，提出了“返回自然”的口号。但另一方面这些年轻作家反对启蒙运动时期的社会关系，驳斥了过分强调<a href="https://baike.baidu.com/item/理性/576586" target="_blank" rel="noopener">理性</a>的观点。这个运动持续了将近二十多年，从1765年到1795年，然后被成熟的<a href="https://baike.baidu.com/item/浪漫主义运动/10620044" target="_blank" rel="noopener">浪漫主义运动</a>所取代。</p><h3 id="第一讲-音乐中的幻想与狂想"><a href="#第一讲-音乐中的幻想与狂想" class="headerlink" title="第一讲 音乐中的幻想与狂想"></a>第一讲 音乐中的幻想与狂想</h3><p><strong>柏辽兹《幻想交响曲》第四乐章（柏林爱乐乐团 杨松斯指挥）</strong></p><p>恋人主题“固定乐思”</p><p><strong>李斯特</strong>（Franz Liszt，1811-1886）</p><p>匈牙利钢琴家、作曲家、指挥家，浪漫主义音乐代表人物，被誉为“钢琴之王”。</p><p>帕格尼尼的《第二小提琴协奏曲》与李斯特的音乐会练习曲《钟》</p><p><strong>李斯特 交响诗《前奏曲》</strong></p><p>引子：疑问动机，主部：年轻人对爱情的憧憬，展开部：暴风雨的来临，插部：田园曲，再现部，副部：爱情主题变为威严的进行曲，主部：年轻人在爱情中经历了考验重新恢复青春</p><p><strong>李斯特《匈牙利狂想曲》第二首</strong>“猫和老鼠”</p><p><strong>交响诗</strong></p><hr><h3 id="第二讲-音乐中抒情与激情"><a href="#第二讲-音乐中抒情与激情" class="headerlink" title="第二讲 音乐中抒情与激情"></a>第二讲 音乐中抒情与激情</h3><p><strong>门德尔松 《仲夏夜之梦》序曲</strong></p><p><em><em>舒伯特 艺术歌曲《小夜曲》 </em></em></p><p>舒伯特 艺术歌曲《魔王》</p><p><strong>舒曼 《a小调钢琴协奏曲》</strong></p><p>舒曼 钢琴作品《童年情景》之《梦幻曲》</p><h3 id="第三讲-浪漫狂潮中的孤独与坚守"><a href="#第三讲-浪漫狂潮中的孤独与坚守" class="headerlink" title="第三讲 浪漫狂潮中的孤独与坚守"></a>第三讲 浪漫狂潮中的孤独与坚守</h3><p><strong>肖邦</strong>（Fryderyk Chopin，1810-1849）</p><p><strong>肖邦 “革命”练习曲</strong></p><p>肖邦 降E大调夜曲 Op.9 No.2</p><p>肖邦 “黑键”练习曲 Op.10 No.5</p><p><strong>约翰内斯·勃拉姆斯</strong>——“最后的古典主义音乐家”</p><p>勃拉姆斯 第一交响曲 第一乐章——“贝多芬第十交响曲”</p><p>勃拉姆斯 艺术歌曲《摇篮曲》</p><p>勃拉姆斯 第五匈牙利舞曲 管弦乐版</p><p>勃拉姆斯 第一匈牙利舞曲 双钢琴</p><h3 id="第四讲-歌剧艺术的辉煌与绽放（一）"><a href="#第四讲-歌剧艺术的辉煌与绽放（一）" class="headerlink" title="第四讲 歌剧艺术的辉煌与绽放（一）"></a>第四讲 歌剧艺术的辉煌与绽放（一）</h3><p><strong>歌剧</strong></p><p>歌剧（英文：opera，意大利语：opera）是一门西方舞台艺术，简单而言就是主要或完全以歌唱和音乐来交代和表达剧情的戏剧（是唱出来而不是说出来的戏剧）。歌剧在17世纪，即1600年前后，出现在意大利<a href="https://baike.baidu.com/item/佛罗伦萨/32608" target="_blank" rel="noopener">佛罗伦萨</a>，源自<a href="https://baike.baidu.com/item/古希腊戏剧/1978649" target="_blank" rel="noopener">古希腊戏剧</a>的剧场音乐。歌剧的演出和戏剧的所需一样，都要凭借剧场的典型元素，如背景、<a href="https://baike.baidu.com/item/戏服/880548" target="_blank" rel="noopener">戏服</a>以及表演等。</p><p><strong>浪漫主义时期歌剧的繁荣</strong></p><p>歌剧序曲、间奏曲、咏叹调、重唱合唱</p><p><strong><em>19世纪意大利歌剧</em></strong></p><p><strong>乔阿基诺·安东尼奥·罗西尼</strong>（17952-1868）</p><p><strong>罗西尼 歌剧《塞维利亚理发师》 费加罗咏叹调“快给忙人让路”</strong></p><p>罗西尼 歌剧《威廉退尔》序曲 （片段）</p><p><strong>朱塞佩·威尔第</strong>（1813-1901）</p><p>威尔第 歌剧《纳布科》 合唱“飞吧，思想，展开金色的翅膀”</p><p>威尔第 歌剧《茶花女》选段“饮酒歌”</p><p>威尔第 歌剧《阿依达》  “凯旋”片段</p><p><strong>真实主义</strong></p><hr><p><strong>贾科莫·普契尼</strong>（1858-1924）</p><p>早期歌剧《曼侬·列斯科》中期《艺术家的生涯》《托斯卡》《蝴蝶夫人》晚期《西部女郎》《外套》（真实主义）《姜尼·斯基基》（仅有喜歌剧）<strong>《图兰朵》</strong></p><p>普契尼 歌剧《蝴蝶夫人》巧巧桑咏叹调“晴朗的一天”</p><p><strong>普契尼 歌剧《图兰朵》王子咏叹调“今夜无人入眠”</strong></p><h3 id="第五讲-歌剧艺术的辉煌与绽放（二）"><a href="#第五讲-歌剧艺术的辉煌与绽放（二）" class="headerlink" title="第五讲 歌剧艺术的辉煌与绽放（二）"></a>第五讲 歌剧艺术的辉煌与绽放（二）</h3><p><strong><em>喜歌剧</em></strong></p><hr><p><strong><em>法国抒情歌剧</em></strong></p><hr><p>托马、古诺、乔治·比才、圣桑、马斯涅</p><p>奥芬·巴赫 歌剧《地狱中的奥菲欧》序曲片段</p><p><strong>古诺 歌剧《浮士德》士兵合唱</strong></p><p><strong>《卡门》</strong>——“主导动机”</p><p>比才 歌剧《卡门》序曲</p><p><strong>比才 歌剧《卡门》 卡门的咏叹调“哈巴涅拉”</strong></p><p>比才 歌剧《卡门》 “斗牛士之歌”</p><p><strong>19世纪德国歌剧</strong></p><p><strong>瓦格纳</strong>（Richard Wagner，1813-1883）</p><p>瓦格纳 歌剧《尼伯龙根的指环》之《女武神》“女武神的骑行”</p><p><strong>瓦格纳 歌剧《罗恩格林》选段“婚礼进行曲”</strong></p><hr><h2 id="音乐中的民族旋风"><a href="#音乐中的民族旋风" class="headerlink" title="音乐中的民族旋风"></a>音乐中的民族旋风</h2><h3 id="第一讲-乐声中的森林、河流、晨曦、阳光"><a href="#第一讲-乐声中的森林、河流、晨曦、阳光" class="headerlink" title="第一讲 乐声中的森林、河流、晨曦、阳光"></a>第一讲 乐声中的森林、河流、晨曦、阳光</h3><p><strong>十九世纪民族乐派</strong></p><p>俄罗斯——格林卡，五人团</p><p>捷克——斯美塔纳，德沃夏克</p><p>挪威——格里格</p><p>芬兰——西贝柳斯</p><p>格里格《培尔·金特组曲》第一组曲 之 “晨曲”</p><p>格里格《培尔·金特组曲》第一组曲 之 “阿尼特拉舞曲”</p><p><strong>格里格《培尔·金特组曲》第二组曲 之 “索尔维格之歌”（第五首）</strong>    </p><p>西贝柳斯 交响诗《芬兰颂》</p><h3 id="第二讲-异国他乡的母国情怀"><a href="#第二讲-异国他乡的母国情怀" class="headerlink" title="第二讲 异国他乡的母国情怀"></a>第二讲 异国他乡的母国情怀</h3><p><strong>捷克作曲家德沃夏克</strong></p><p>《幽魂曲》,《水仙花》女高音咏叹调“月亮颂”</p><p><strong>德沃夏克 第九交响曲 “自新大陆”</strong>（版本：卡尔· 伯姆 指挥 维也纳爱乐乐团演奏）</p><p>斯美塔那 歌剧《被出卖的新嫁娘》序曲</p><p>斯美塔那 交响诗套曲《我的祖国》第二乐章《伏尔塔瓦河》</p><h2 id="欧亚风情画"><a href="#欧亚风情画" class="headerlink" title="欧亚风情画"></a>欧亚风情画</h2><h3 id="第一讲-业余出身的“专业”作曲家"><a href="#第一讲-业余出身的“专业”作曲家" class="headerlink" title="第一讲 业余出身的“专业”作曲家"></a>第一讲 业余出身的“专业”作曲家</h3><p><strong><em>五人团</em></strong></p><hr><p><strong>穆索尔斯基钢琴组曲 《图画展览会》（管弦乐版）”基辅大门”</strong></p><p>格林卡 歌剧《鲁斯兰与柳德米拉》序曲</p><p>里姆斯基-科萨科夫 交响组曲《舍赫拉查德》（又名《天方夜谭》）</p><p><strong><em>交响音画</em></strong></p><hr><p><strong>鲍罗丁 交响音画《在中亚细亚草原上》</strong></p><h3 id="第二讲-“悲情大师”的世纪绝唱"><a href="#第二讲-“悲情大师”的世纪绝唱" class="headerlink" title="第二讲 “悲情大师”的世纪绝唱"></a>第二讲 “悲情大师”的世纪绝唱</h3><p><strong>彼得·伊里奇·柴可夫斯基</strong>（1840-1893）——古典浪漫结合</p><p>《第四交响曲》《第五交响曲》《第六交响曲》圆舞曲替代谐虐曲</p><p>柴科夫斯基 第六交响曲“悲怆”第一乐章</p><p>柴科夫斯基 第一钢琴协奏曲 第一乐章</p><h3 id="第三讲-俄罗斯的舞剧音乐王国"><a href="#第三讲-俄罗斯的舞剧音乐王国" class="headerlink" title="第三讲 俄罗斯的舞剧音乐王国"></a>第三讲 俄罗斯的舞剧音乐王国</h3><p>柴科夫斯基的《天鹅湖》《胡桃夹子》《睡美人》</p><p><strong>柴可夫斯基 舞剧《天鹅湖》“主题”</strong></p><p>柴可夫斯基 舞剧《天鹅湖》“白天鹅和王子双人舞”</p><p>柴可夫斯基 舞剧《天鹅湖》“四小天鹅舞”</p><p>柴可夫斯基 舞剧《天鹅湖》“黑天鹅32圈转”</p><p>柴可夫斯基 舞剧《天鹅湖》“西班牙舞”“拿波里舞”</p><p>柴可夫斯基 舞剧《胡桃夹子》配乐 “糖梅仙子之舞”</p><p>柴可夫斯基 舞剧《胡桃夹子》配乐“花之圆舞曲” Waltz of the Flowers</p><p>柴可夫斯基 舞剧《睡美人》“婚礼大双人舞“ （双人舞-王子-公主-双人舞）</p><h2 id="从“印象”到“音响”（略）"><a href="#从“印象”到“音响”（略）" class="headerlink" title="从“印象”到“音响”（略）"></a>从“印象”到“音响”（略）</h2><h3 id="音响中五光十色的“印象”"><a href="#音响中五光十色的“印象”" class="headerlink" title="音响中五光十色的“印象”"></a>音响中五光十色的“印象”</h3><p><strong><em>印象主义</em></strong></p><p><strong>德彪西</strong>（1862-1918）</p><p>德彪西 管弦乐前奏曲《牧神午后》</p><p>德彪西 钢琴前奏曲《亚麻色头发的少女》</p><p>德彪西 钢琴曲《月光》‘</p><p>拉威尔 管弦乐曲《波莱罗舞曲》</p><hr><h2 id="课程回顾与总结"><a href="#课程回顾与总结" class="headerlink" title="课程回顾与总结"></a>课程回顾与总结</h2><h3 id="音乐家和音乐主题"><a href="#音乐家和音乐主题" class="headerlink" title="音乐家和音乐主题"></a>音乐家和音乐主题</h3><p>（1）古代音乐</p><p>西方最早的弦乐器是里拉琴，又称诗琴。</p><p>（2）中纪音乐</p><p>（3）文艺复兴时期的音乐</p><p>这一时期的乐派有尼德兰乐派（勃艮第乐派和法一佛兰德乐派）、罗马乐派、威尼斯乐派。</p><p>（4）巴洛克时期的音乐</p><p>①欧洲历史上的第一部歌剧是由里努契尼写脚本、佩里作曲的《达芙妮》，但是乐谱已失传。现存的第一部歌剧是《优丽狄茜》，由里努契尼写脚本、佩里和卡契尼作曲。</p><p>②清唱剧又叫圣剧、神剧，17世纪诞生于意大利，是一种宗教性的大型声乐体裁。创作清唱剧的最重要的作曲家是卡里西米和亨德尔。</p><p>③巴赫，德国作曲家，代表作品有《平均律钢琴曲集》《赋格的艺术》《b小调弥撒曲》《马太受难乐》等。</p><p>（5）古典主义时期的音乐</p><p>①维也纳古典时期的代表作曲家是海顿、莫扎特和贝多芬，称他们为“维也纳三杰”。</p><p>②海顿是古典维也纳乐派的奠基者，被誉为“交响曲之父”“弦乐四重奏之父”。代表作有12首“伦敦”交响曲，清唱剧《创世纪》和《四季》等。</p><p>③莫扎特是西方音乐史上最富有智慧的音乐家，被誉为“音乐神童”，代表作品有歌剧《后宫诱逃》《费加罗的婚礼》《唐璜》《魔笛》，钢琴奏鸣曲《G大调弦乐小夜曲》等。</p><p>④贝多芬被誉为“乐圣”，他在后期虽然两耳失聪，但仍然坚持音乐创作，代表作品有钢琴奏鸣曲《悲怆》《月光》《暴风雨》《黎明》《热情》，交响曲《第三交响曲“英雄”》《第五交响曲“命运”》《第六交响曲“田园”》《第九交响曲“合唱”》，歌剧《费德里奥》等。</p><p>（6）浪漫主义时期的音乐</p><p>①韦伯，德国浪漫主义歌剧奠基人。</p><p>②舒伯特，德奥艺术歌曲之王，代表作品有艺术歌曲《野玫瑰》《魔王》《鳟鱼》，声乐套曲《美丽的磨坊姑娘》《冬之旅》，钢琴小品《音乐的瞬间》等。</p><p>③门德尔松，德国作曲家，首创钢琴体裁“无词歌”。</p><p>④舒曼，德国作曲家、钢琴家、音乐评论家，代表作品有钢琴套曲《狂欢节》《童年情景》，声乐套曲《桃金娘》《诗人之恋》等。</p><p>⑤肖邦，波兰钢琴家、作曲家，被誉为“钢琴诗人”，是较早将东欧民间音乐融入西方音乐艺术的大师。</p><p>⑥李斯特，匈牙利钢琴家、作曲家、指挥家，被誉为“钢琴之王”。</p><p>⑦古诺，法国作曲家，代表作品有《浮土德》《罗密欧与朱丽叶》等。</p><p>⑧比才，法国作曲家，代表作品有歌剧《卡门》等。</p><p>⑨柴可夫斯基，俄国作曲家，代表作品有歌剧《叶甫盖尼·奥涅金》《黑桃皇后》，舞剧《天鹅湖》《睡美人》《胡桃夹子》，《第六“悲怆”交响曲》《1812序曲》等</p><p>（7）民族主义音乐</p><p>①俄国民族乐派的奠基人是格林卡和达尔戈梅斯基。格林卡是俄国民族歌剧的创始人，被称为“俄罗斯民族音乐之父”。</p><p>②帕修斯是芬兰民族乐派的创始人，“芬兰歌剧之父”，代表作品是第一部芬兰歌剧《卡尔王之猎》。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h3 id="形式与体裁"><a href="#形式与体裁" class="headerlink" title="形式与体裁"></a>形式与体裁</h3><p>1．曲调：具有歌唱性的器乐曲，常用于18世纪的组曲中。</p><p>2．阿勒曼德：17世纪盛行于法国和英国的舞曲体裁，四拍子，节奏平稳，速度较慢，常用于组曲。同样的名称在19世纪指流行于瑞士乡村的三拍子轻快舞曲，它是华尔兹的前身。</p><p>3．赞美歌：英国基督教教会仪式所用音乐，有独唱、合唱形式，歌词大多取自圣经，用英语演唱，一般用管风琴伴奏。</p><p>4．咏叹调：独唱曲，是歌剧、清唱剧等大型声乐作品中的重要段落，也可以是独立的作品。具有高超的演唱技巧和幅度较大的情感抒发。</p><p>5．叙事歌：</p><p>（1）13、14世纪的法国世俗歌曲；</p><p>（2）19世纪盛行于德国的具有叙事性的歌曲，内容常与民间故事、传奇有关；</p><p>（3）19世纪抒情浪漫的器乐曲，如肖邦和勃拉姆斯的钢琴作品。</p><p>6．芭蕾舞剧：由舞蹈演员身着剧装在音乐伴奏下表演的戏剧。起源于文艺复兴时期的意大利，后传入法国获得极大发展。最初的法国芭蕾舞剧音乐不仅有器乐，还有歌唱和朗诵，因此可看作是歌剧的前身（当时的歌剧中也有芭蕾舞，此传统一直延续到19世纪末，并影响到意大利歌剧）。19世纪中叶以后出现大量优秀的芭蕾舞剧音乐，如柴可夫斯基的《天鹅湖》、斯特拉文斯基的《火鸟》等。</p><p>7．船歌：来源于威尼斯船夫歌曲的器乐曲（钢琴曲为多，也有管弦乐曲），6/8或12/8拍，速度和缓，通常是在荡漾的节奏韵律之上有一条歌唱性的悠扬曲调。</p><p>8．摇篮曲：安静温和的声乐或器乐小曲，节奏有如摇篮缓缓摆动。</p><p>9．布鲁斯：又译蓝调。美国爵士乐的一种风格，源于黑人灵歌。通常为十二小节，节奏平稳，速度较慢，其名称来源于别具特色的常降低半音的大调第三和第七级音。</p><p>10．波莱罗：西班牙舞曲，三拍子，稳定的中速，用响板敲击具有特性的节奏。拉威尔的管弦乐《波莱罗舞曲》是最著名的作品，肖邦也写有这种风格的钢琴曲。</p><p>11．布列：</p><p>（1）盛行于17和18世纪的法国舞曲，速度较快，通常为2/2拍。</p><p>（2）现流行于法国中部奥弗涅山区的三拍子舞曲。</p><p>12．康康：19世纪末盛行于法国的舞曲，快速，2/4拍，热烈而粗俗。最著名的是奥芬巴赫所作轻歌剧《地狱中的奥菲欧》中的康康舞曲。</p><p>13．卡农：“规律”，一种二声部或更多声部的复调音乐形式，当一个声部的旋律出现之后，另外的声部紧跟模仿。它可以是一首独立乐曲的形式，也可在大型作品中出现局部性的卡农写法。</p><p>14．康塔塔：又译大合唱。盛行于17世纪和18世纪上半叶的多乐章声乐作品，包括独唱的宣叙调、咏叹调，重唱，合唱，由管弦乐队伴奏，与清唱剧相类似，但规模较小。有宗教的也有世俗内容的。巴赫留存于世的二百余部康塔塔是经典之作。</p><p>15．随想曲：</p><p>（1）16世纪末至17世纪较为自由的赋格性质器乐曲，多为古钢琴作品；</p><p>（2）技巧性练习曲，如帕格尼尼的《24首小提琴随想曲》；</p><p>（3）19世纪用于形式较为自由的乐曲，常借用著名曲调为主题，如柴可夫斯基的管弦乐曲《意大利随想曲》。</p><p>16．夏空：又译恰空。盛行于17世纪的风格庄重的三拍子舞曲，也是一种复调音乐形式，即在固定的主题或一连串固定的和声进行之上作多次变奏。</p><p>17．室内乐：指适合在室内而不是大厅由少数人演奏的器乐曲，早期曾包括声乐。主要体裁是数种重奏，最常见的是古典时期的弦乐四重奏、钢琴五重奏等。现在虽常在音乐厅演奏这类作品，但依然保持原有的细腻亲切的特性。</p><p>18．众赞歌：基督新教（路德教派）的赞美诗曲调，最早出版于1524年。宗教改革者马丁-路德将其作为改革手段之一（他本人还曾创作过一些）。其特点为：采用本国语演唱，曲调大多选自朴素通俗的民歌和古老的圣歌。起初为单声部，后来出现了主旋律在最高声部的四部合唱式以及复调形式。17、18世纪众赞歌成为重要的音乐创作源泉，如巴赫的管风琴众赞歌前奏曲、众赞歌变奏曲以及大量宗教康塔塔中都以众赞歌旋律为素材。</p><p>19．众赞歌前奏曲：以众赞歌为素材的管风琴曲通称，盛行于17、18世纪。在路德教派的教堂仪式中，会众唱赞美歌之前要先由管风琴将其旋律演奏一遍。演奏者可将旋律作自由变奏，这种做法逐渐形成了众赞歌前奏曲体裁。</p><p>20．协奏曲：也称作独奏协奏曲，是一件独奏乐器和管弦乐队的协奏。形成于18世纪，通常为快－慢－快三个乐章。在莫扎特奠定的古典协奏曲模式中，第一乐章有两个呈示部，即乐队先呈示主题，然后由主奏乐器在乐队伴奏下带有变化地再次呈示主题；第一乐章（有时也在末乐章）将近结束处有华彩乐段，即主奏乐器单独演奏的炫技性段落。19世纪逐渐不再遵循这种模式。</p><p>21．大协奏曲：盛行于17世纪和18世纪初的多乐章作品，是由几件乐器组成的独奏小组和管弦乐队的协奏。主奏组大多由小提琴、长笛、双簧管、大提琴、古钢琴组成，通常为2-5件乐器，它们细腻纤巧的音响与宏亮的乐队合奏形成鲜明对比。</p><p>22．库朗：盛行于17和18世纪初的活泼的三拍子舞曲，常用于组曲。</p><p>23．恰尔达什：又译查尔达什。匈牙利舞曲，由缓慢而忧郁的lassan段和快速热烈的friss段构成。李斯特的《第二匈牙利狂想曲》即典型的恰尔达什舞曲。</p><p>24．嬉游曲：盛行于18世纪末的轻松怡情的多乐章室内乐或小乐队作品。在莫扎特的嬉游曲中，也有些比较深刻严肃。</p><p>25．二重协奏曲：两件独奏乐器与乐队的协奏曲。如勃拉姆斯《小提琴与大提琴二重协奏曲》。</p><p>26．二重奏：供两人演奏（演唱）的形式，二个声部不分主次，可有伴奏或无伴奏。器乐二重奏（除钢琴二重奏外）还专门称做duo。</p><p>27．练习曲：专为练习乐器演奏技巧而作的乐曲。19世纪肖邦、李斯特、德彪西等人加强了这种体裁的艺术性，使之成为音乐会上的正式曲目。这类作品称为音乐会练习曲。</p><p>28．凡丹戈：活泼的西班牙舞曲，快速、三拍子，用响板和吉他伴奏。</p><p>29．幻想曲：器乐曲，总体特点是形式上自由不拘，带有幻想的性质。</p><p>（1）文艺复兴时期指不采用舞曲形式或变奏手法而采用复调技巧自由写作的器乐曲。</p><p>（2）巴洛克时期即兴性的键盘或琉特琴乐曲，如巴赫的《半音阶幻想曲》。</p><p>（3）古典主义时期在写法上比奏鸣曲更为自由的大型作品。</p><p>（4）浪漫时期带有幻想色彩的乐曲。</p><p>（5）根据现成主题（民歌、他人音乐素材）所写的乐曲，如李斯特《根据贝利尼歌剧&lt;梦游女&gt;主题而作的幻想曲》等。</p><p>30．法朗多尔：古老的法国舞曲，目前仍流行于普罗旺斯一带。6/8拍，也有2/4拍，如比才管弦乐组曲《阿莱城姑娘》中的《法朗多尔舞曲》。</p><p>31．弗拉门科：盛行于西班牙南部安达卢西亚的歌舞体裁，用吉他伴奏，常常带有悲伤意味。在西班牙吉他作品中弗拉门科是一种典型风格。</p><p>32．赋格：在一个主题上构成的多声部（至少二声部）复调作品。单声部的主题在原调上出现之后，另外的声部依次进行模仿。主题在全曲多次出现，中间有数个间插段，它们大多采用主题片断作素材，在不同调性上进行丰富多样的变化，也可引进新材料。最后一次主题在原调上完整出现，便告结束。赋格可用于一部独立的作品，也可用于一部大作品的局部，称作赋格段。</p><p>33．加伏特：盛行于17世纪的法国舞曲，传入宫廷后，成为当时各种作品中不可或缺的形式，如歌剧、组曲中常有加伏特舞曲。快速，4/4拍。</p><p>34．格里高利圣咏：又译素歌。罗马教会所保存并沿用至今的最古老的宗教歌曲集，以教皇格里高利一世命名。单声部旋律，节奏自由，以拉丁文歌词的抑扬顿挫为依据。</p><p>分为两大类：</p><p>（1）用于教堂举行弥撒的成套圣咏，内容集中于耶稣最后的晚餐与受难；</p><p>（2）用于修道院每天不同时辰祈祷的日课圣咏。</p><p>35．哈巴涅拉：又译阿伐奈拉。起源于古巴哈瓦那的舞曲，较慢的二拍子，第一拍为切分音。19世纪传入西班牙</p><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>音乐常识经典!<br>这些都是平时老师上课提到的一些比较常识的东西，有很多都是经典。</p><ol><li>三大安魂曲是指哪三首呢<br>三大安魂曲是指莫札特的《Ｄ小调安魂曲》、威尔第的《安魂曲》和佛瑞的《安魂曲 》。</li><li>三大神剧是指哪三首呢<br> 三大神剧是指韩德尔的《弥赛亚》、海顿的《创世纪》和门德尔松的《伊利亚 》</li><li>中国乐器有哪几类呢<br> 中国乐器依八音分类法分为金、石、丝、竹、匏、土、革、木八种</li><li>中国传统音乐如何分类呢<br> 中国传统音乐分为民间歌曲，民间歌舞，民间曲艺，民间戏曲，民间器乐！</li><li>西方乐器如何分类呢<br>西方乐器总括分为擦弦、木管、铜管及敲击四大类</li><li>五大纲琴协奏曲是指哪几首呢<br>贝多芬的《第五号降Ｅ大调钢琴协奏曲“皇帝”》、柴可夫斯基的《第一号降Ｂ大调钢琴协奏曲》、拉赫曼尼诺夫的《第二号Ｃ小调钢琴协奏曲》、舒曼的《Ａ小调钢琴协奏曲》和李斯特的《降Ｅ大调钢琴协奏曲合称为“五大纲琴协奏曲”》其实还有拉赫曼尼诺夫的《第三钢琴协奏曲》这是公认的世界最难钢琴曲。</li><li>六大交响曲是指哪几首呢<br> 六大交响曲包含了贝多芬的《第六田园交响曲》、《第五命运交响曲》、舒伯特的《第八未完成交响曲》、德沃夏克的《新世界交响曲》、柴可夫斯基的《悲怆交响曲》和柏辽兹的《幻想交响曲》</li><li>四大小提琴协奏曲是哪几首呢<br>贝多芬的《Ｄ大调小提琴协奏曲》、门德尔松的《Ｅ小调小提琴协奏曲》、柴可夫斯基的《Ｄ大调小提琴协奏曲》和布拉姆斯的《Ｄ大调小提琴协奏曲》并称为四大小提琴协奏曲 ，老师提的问题，很遗憾当时没有答上。</li><li>音乐史上的3B（4B）是指哪些人呢<br>布拉姆斯（Brahms, Johannes）、巴赫（Bach, Johann Sebastian）与贝多芬（Beethoven, Ludwig van）三人并称为音乐史上的3B，若是4B就要另加巴尔托克（Bartok, Bela）</li><li>音乐的新旧约是指什么呢<br>在音乐史上，通常我们会把巴赫的，《钢琴十二平均律曲集》比喻为旧约圣经，且把贝多芬的《三十二首钢琴奏鸣曲》比喻为新约圣经 ，这是去年考试没有答上的问题！</li><li>约翰·斯特劳斯家族的音乐家.小约翰·斯特劳斯(圆舞曲之王），老约翰·斯特劳斯（圆舞曲之父），其最出名的作品《拉德斯基进行曲》是每年维也纳新年音乐会的押尾曲目.爱德华·斯特劳斯。</li><li>谁是歌曲之王呢<br>  奥地利的舒伯特（Schubert, Franz (Peter)）因为留有超过六百首的歌曲而被称为歌曲之王 。代表曲目有《野玫瑰》，《魔王》 等，套曲有《冬之旅》，《美丽的磨坊女》。</li><li>谁是“交响曲之父”<br>  “交响曲之父”指的是海顿（Haydn, Franz Joseph）。由于当时的人们总把音乐会当作打瞌睡的场所，海顿创作了在漫长的宁静之后突然钟鼓齐鸣的“惊愕”交响曲 ，还是四重奏之父。</li><li>谁是“协奏曲之父”呢？<br>  “协奏曲之父”就是因一头红发而被称为“红发教士”的韦瓦尔第代表曲目《四季》</li><li>谁是“音乐之父”呢？<br>  “音乐之父”就是出身于音乐世家的巴赫。</li><li>谁是“音乐神童”呢？<br>  “音乐神童”就是从小就到处旅行演奏并创作的莫札特</li><li>谁是“神剧之父”呢？<br> “神剧之父”指的是神剧“弥赛亚”的作者亨德尔《弥赛亚》–《哈里路亚》。</li><li>谁是音乐史上的“乐圣”呢？<br>  “乐圣”是指丧失听力的贝多芬。</li><li>谁是“钢琴诗人”呢？<br>  波兰作曲家萧邦，被视为钢琴音乐最伟大的作曲家，通常被誉为“钢琴诗人”</li><li>十二平均律是由谁首创？</li></ol><p>中国十二平均律是由明代朱载堉首创，西洋十二平均律是由德国巴赫首创</p><p>21.交响诗是由谁首创？</p><p>交响诗是由李斯特首创，他曾受业于彻尔尼 ！</p><p>22.世界三大芭蕾舞剧为何？</p><p>世界三大芭蕾舞剧为柴可夫斯基所做的天鹅湖，睡美人及胡桃钳子</p><p>23.音乐史上最早的第一部协奏曲为何？</p><p>音乐史上最早的第一部协奏曲为科赖里所做的大协奏曲</p><p>24.古代组曲的顺序为何？</p><p>古代组曲的顺序为阿勒曼 库朗 萨拉邦 吉格</p><p>25.法国歌剧的创始人是谁？</p><p>法国歌剧的创始人是卢利</p><p>26.在西洋音乐史上有哪几位作曲家是二十世纪新音乐的开创者？</p><p>在西洋音乐史上被称为是二十世纪新音乐的开创者有德彪西、荀白克及斯特拉文斯基</p><p>27.何谓俄国五人组（强力集团）？</p><p>鲍罗丁、巴拉基列夫、居伊、穆索斯基及里姆斯基.科萨可夫被称为俄国五人组</p><p>31·谁有和声学之父之称？</p><p>法国了作曲家及理论家拉莫Rameau,Jean-Philippe (1683-1764) 有和声学之父之称，他是巴洛克时期的作曲家</p><p>32·何谓清唱剧？</p><p>清唱剧通常已故视为题材，有角色但无布景与动作的音乐</p><p>33·何谓巴黎六人组？</p><p>巴黎六人组(Les Six)为米约(Milhaud)、普朗克(Poulence)、奥里克(Auric)、迪霍(Durey)、塔乐费尔(Tailleferre)、奥乃格(Honnegar)</p><p>34·有哪些作曲家曾经编写管弦乐曲“罗密欧与朱丽叶”？</p><p>普罗科菲耶夫(Prokofiev)、柴可夫斯基(Tchaikovsky)、柏辽兹(Berlioz)三人均曾编写过管弦乐曲“罗密欧与朱丽叶”</p><p>35·谁是进行曲之王？</p><p>美国作曲家，致力于军乐队的发展，发明苏沙低音号的苏沙</p><p>36·谁是俄国音乐之父？</p><p>采用俄罗斯民谣作为主题运用欧洲式的音乐手法，创作许多民族性的音乐是俄国作曲家葛令卡</p><p>37·简谱是由谁创立的?？</p><p>简谱是由法国的医生兼音乐理论家舒威以音乐教育为目的(Cheve, Emile-Joseph-Maurice 1804～1864)所创立，所以这种简谱又称为”舒威谱式”。以阿拉伯数字中的1、2、3、4、5、6、7</p><p>38.一些美誉：音乐诗人–舒曼。</p><p>清唱剧大师–亨德尔。</p><p>乐剧工匠–瓦格纳</p><p>指挥界帝王–卡拉扬</p><p>歌剧之王–威尔第</p><p>男高音歌王–卡鲁索</p><p>高音之王–帕瓦罗蒂</p><p>小提琴之王–帕格尼尼</p><p>歌剧界女王–卡拉斯</p><p>钢琴之王（标题交响诗之父）–李斯特</p><p>现代管弦乐之父–柏辽兹</p><p>印象派大师–德彪西</p><p>法国音乐之父–保尔·莫里亚</p><p>俄罗斯音乐之父–格林卡</p><p>神弓–海菲兹</p><p>音乐绘画大师–穆索尔斯基</p><p>捷克音乐之父–德沃夏克</p><p>新捷克音乐之父–斯美塔纳</p><p>民族乐派大师–格里格</p><p>当代钢琴泰斗–鲁宾斯坦</p><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><h4 id="听辨题"><a href="#听辨题" class="headerlink" title="听辨题"></a>听辨题</h4><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%A4%96%E5%9B%BD%E7%BB%8F%E5%85%B8%E9%9F%B3%E4%B9%90%5C1.png" alt="1"></p><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%A4%96%E5%9B%BD%E7%BB%8F%E5%85%B8%E9%9F%B3%E4%B9%90%5C2.png" alt="2"></p><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><h4 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h4><h3 id="期中作业（莫扎特传电影影评or音乐会）"><a href="#期中作业（莫扎特传电影影评or音乐会）" class="headerlink" title="期中作业（莫扎特传电影影评or音乐会）"></a>期中作业（莫扎特传电影影评or音乐会）</h3><p><strong>《Amadeus》观后感</strong></p><p>关于电影。</p><p>影片中的沃尔夫冈·阿马德乌斯·莫扎特与安东尼奥·萨列里两人。</p><p>一个是上帝的宠儿，一个是信仰上帝最终却与上帝反目。</p><p>萨列里第一次遇见莫扎特是在一个非常喜剧的场景之下，那是一次大主教的宫廷乐会，萨列里因为好奇去寻找莫扎特，寻找无果于是去偷吃甜品，此时莫扎特正好在追逐嬉戏中出现了，而萨列里躲在一旁观察着他。</p><p>虽然该电影以莫扎特的中间名命名，但主角其实是莫扎特的对手——萨列里，而从萨列里的视角中，我也试着从旁观者的角度去看待莫扎特这个神话一般的音乐家。</p><p>电影主要讲述了年迈七十的维也纳宫廷乐师萨列里回忆起三十年前因嫉妒莫扎特的才华，数次从其音乐事业中作梗，精神折磨莫扎特并将其“谋杀”的故事。</p><p>莫扎特的音乐天赋和宫廷乐师父亲的严厉指导让他六岁就能写出协奏曲曲，十一岁创作了第一部歌剧，十七岁就在萨尔兹堡大主教的宫廷乐队里担任首席乐师。</p><p>而萨列里则远不如莫扎特幸运，虽然他出生在一个富商家庭，可是家里没人懂音乐，内心对音乐的渴望对他来说反而是一种折磨。直到父亲突然去世之后，萨列里才有机会挣脱束缚去学习音乐，并靠着自己的努力当上了宫廷乐长，所以他虔诚地信仰上帝。</p><p>其实萨列里更像是我们生活中的大多数人，一步步实现自己梦想的同时却又无可避免地沦为平庸，但他从未放弃对音乐的热爱，所以在遇见莫扎特的时候他又怎么能不心生嫉妒呢？他遇见的是一个幸运的音乐天才，一个只为热爱音乐而生的上帝宠儿，莫扎特可以一边放荡不羁，同时轻松地创造出吸引人的音乐。</p><p>就像德国诗人歌德曾评价莫扎特的那样：神的创造力在人间的化身，他的音乐才华是神送来的。</p><p>对于萨列里来说，莫扎特的音乐才华确实是一种打击，但同时由于他自己对音乐的热爱，他对莫扎特的嫉妒中其实也有着一种惺惺相惜。压倒骆驼最后的那根稻草，或许是他自己爱的人被莫扎特夺走的那一刻，从那一刻起，他开始彻头彻尾地嫉恨莫扎特的才华。</p><p>也难怪萨列里后来会与上帝反目，觉得上帝从未爱过世人，因为如果祂爱过，那为什么不多带点人去享享福呢，或者每个人轮着来也可以。</p><p>可是从来没有这样过。</p><p>所以我每次看到甜品出现的场景，都好像能听见有人在轻声低语“生活已经那么苦了，还是给自己加点糖吧。”</p><p>结尾处萨列里说，我代表世界所有的庸才。上帝宽恕你们。</p><p>其实看到电影结尾我反而没有多少讨厌萨列里，可能是因为他已经得到了应该得到的惩罚，并且用了一生来承受它。</p><p>但或许这也正应了那句话：人世间的苦难见多了，对那些即使是做错了事的人，也再难以说出活该二字。</p><p>关于音乐</p><p>算上这部传记电影的话，我也已经看过不少音乐相关的电影了，比如《海上钢琴师1900》《爆裂鼓手》等等，无一例外的是，我们都能从中感受到它们想向观众传达的那种特殊的情感，那就是对音乐极致般的热爱，而对音乐的热爱影响着音乐家们的一生，同时也影响了我们所有人的一生。</p><p>从电影刚开头牧师破门而入看到萨列里自杀，随即镜头切换到街上，维也纳夜晚的街头，行色匆匆，同时浮现出片名《Amadeus》，莫扎特第二十五交响曲奏起，仅凭音乐就能够感受到电影导演的用心良苦。</p><p>从萨列里面对年轻牧师回忆当初，第一首莫扎特《小夜曲》的出现使萨列里内心中仇恨的种子展露开始，再到他嘲讽莫扎特执意创作德语歌剧《后宫诱逃》、阻止《费加罗的婚礼》的上演、观看《唐璜》想到用莫扎特父亲来压垮莫扎特，音乐一步步推动着二人之间的矛盾和冲突，直至最后《安魂曲》宣告落幕，将莫扎特一生中最著名的音乐和歌剧作品贯穿全局，最终直指人物内心。</p><p>如果是对莫扎特本人或者对他的音乐有更深入了解的话，这部电影或许更加能够触动人心，而这其实也是艺术的魅力所在。无论是音乐、电影还是艺术作品，所有的艺术形式所传达出来的情感，都需要进行所谓的“二次加工”，不同的人甚至是同一个人在不同时期对同一作品会有不同的感触。我想，这或许也是它们能恒久流传至今的原因之一。</p><p>作为音乐家的莫扎特的确伟大，因为他的音乐至今仍能触动人们的心灵。</p><p>但就像他自己说的那样，“我是个低俗的人呢，但我的音乐绝不低俗”，他在音乐之外的生活上可能也只是一个普普通通的人，无法事事做到完美，而能够勇敢地面对生活不轻易屈服，并且一直对音乐报以热爱，这大概也是他人生之所以伟大的原因之一。</p><p>影片最后一幕，又响起了莫扎特那标志性的笑声，他仿佛带着他的音乐穿越时空而来，三个小时的电影已经结束，但他好像还在说：</p><p>“但我绝不会屈服，我会一直坚持，直到到达我音乐的尽头，直到你们的心里。”</p><p>​    “我，沃尔夫冈·阿玛多伊兹·莫扎特，在遭受羞辱与背叛后，向各位致敬。”</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读一篇科研论文</title>
      <link href="/2020/10/09/ru-he-yue-du-ke-yan-lun-wen/"/>
      <url>/2020/10/09/ru-he-yue-du-ke-yan-lun-wen/</url>
      
        <content type="html"><![CDATA[<h2 id="检索论文"><a href="#检索论文" class="headerlink" title="检索论文"></a>检索论文</h2><p>知网（学校资源库）、知乎、各大顶会……</p><h2 id="下载论文"><a href="#下载论文" class="headerlink" title="下载论文"></a>下载论文</h2><p><a href="https://tool.yovisun.com/scihub/" target="_blank" rel="noopener">sci-hub</a></p><h2 id="阅读论文"><a href="#阅读论文" class="headerlink" title="阅读论文"></a>阅读论文</h2><blockquote><p>拿到一篇文献后，不妨先问自己几个问题：</p><p><strong>（1）这篇文章属于什么领域或方向？</strong></p><p><strong>（2）解决了什么问题？为什么这个问题这么重要？</strong></p><p><strong>（3）使用了什么方法和模型？为什么这个方法可以解决这个问题？</strong></p><p><strong>（4）核心结论是什么？下一步还可以怎么做？</strong></p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="信号处理课程论文报告"><a href="#信号处理课程论文报告" class="headerlink" title="信号处理课程论文报告"></a>信号处理课程论文报告</h3><h4 id="报告要求"><a href="#报告要求" class="headerlink" title="报告要求"></a>报告要求</h4><p>The project report requires you to conduct a comprehensive self-proposed survey research on recent developments in the signal processing. The research topics can be relevant to the materials in your oral presentation, but not limited. You should focus on a particular topic with <strong><em>\</em>only one**</strong> particular <strong><em>\</em>journal**</strong> paper. The journal paper should be published in recent two years (2019-2020). The page limit of final project is between 10-15 with at least 10 references.</p><p><strong><em>\</em>Language:**</strong>    Mandarin (Suggested) or English (Optimal)</p><p><strong><em>\</em>Submission:**</strong> All the project report should be submitted before <strong><em>\</em>Week 11 (Nov 15th).**</strong> The upload files should include the checking report of your academic integrity, with overlapping rate less than <strong><em>\</em>20%**</strong>. <strong>Fail to upload the plagiarism checking report will not get the marks in your final exam.</strong></p><p><strong><em>\</em>Academic**</strong> <strong><em>\</em>Integrity:**</strong>    All the final report should avoid plagiarism, collusion and misconduct, which will include the checking report from the online academic integrity system. For the Mandarin version, please click    <a href="http://www.biguolunwen.com/?aid=983" target="_blank" rel="noopener">http://www.biguolunwen.com/?aid=983</a> or scan the QR code.  For English version,  please click    <a href="http://www.turnitin.com.cn/" target="_blank" rel="noopener">http://www.turnitin.com.cn/</a> or other system.</p><h4 id="选取论文"><a href="#选取论文" class="headerlink" title="选取论文"></a>选取论文</h4><p><strong><em>《Invertible Image Rescaling》</em></strong></p><p><strong>ECCV2020oral 可逆的图像变换</strong></p><p>论文地址：<a href="https://arxiv.org/pdf/2005.05650.pdf" target="_blank" rel="noopener"><strong>https://arxiv.org/pdf/2005.05650.pdf</strong></a></p><p>源码地址：<a href="https://github.com/pkuxmq/Invertible-Image-Rescaling" target="_blank" rel="noopener"><strong>https://github.com/pkuxmq/Invertible-Image-Rescaling</strong></a></p><h4 id="前言概述部分"><a href="#前言概述部分" class="headerlink" title="前言概述部分"></a>前言概述部分</h4><p>本文是对ECCV 2020 Oral论文《<strong>Invertible Image Rescaling</strong>》的解读。这篇论文提出了通过构建可逆缩放网络模型（IRN，Invertible Rescaling Net）来解决图像压缩或缩放后的还原问题，并且介绍了其相关构建方法和原理，可以从本质上缓解求解不适定问题（ill-posed problem）带来的困难。相对于前人完全忽视图像缩放中不适定问题的做法，其效果上的提升也非常显著。信息丢失(Information Loss)所导致的不适定问题（ill-posed）在现实中也大量存在，该论文提供的对丢失信息（Lost Information）进行建模的视角，相信可以对类似任务也有一定的参考价值。</p><h4 id="解读主体部分"><a href="#解读主体部分" class="headerlink" title="解读主体部分"></a>解读主体部分</h4><p><strong>研究背景</strong></p><p>信号在我们的日常生活中随处可见，例如：声音、图像、视频等。然而在信号的传输或存储过程中，往往会面临信号失真、质量变差等问题。比如，为了让图片能够适配各种不同分辨率的屏幕或者是为了节省图片的存储空间，高分辨率的图片通常会被缩减规模成低分辨率的图片，而在这个过程中发生了信息的损失，因此新的问题也随之而来，在图片被降低分辨率之后，如果要再次放大图片，就需要想办法恢复原来图片的分辨率和细节。</p><p>然而，在此之前传统的图片缩放方法由于损失了图片的高频信息所以并不是单映射的（non-injective），这就导致了图片缩减（downscale）后再扩大（upscale）的病态问题（ill-posed problem），即对降采样后图片的原图求解的病态(ill-posed)问题。</p><p>这是一个病态问题的原因是在降采样的过程中存在信息丢失(information loss)，以至于无法很好地还原回原图。而前人的做法一般是使用一个超分辨率的卷积神经网络，尝试从大量的数据中强行学习低分辨率到高分辨率的映射关系；或者使用encoder网络对原图进行降采样，同时使用decoder网络还原图片，二者进行联合训练(jointly training)达到更好的效果。但以上这些方法都没有从本质上解决病态问题，效果也不尽如人意。因此我们需要更好的方法来解决病态问题。</p><h4 id="报告PPT部分"><a href="#报告PPT部分" class="headerlink" title="报告PPT部分"></a>报告PPT部分</h4><p>不知道同学们平日里上网有没有遇到过这种情况：自己精心拍摄的高清照片/视频，想发给朋友or分享到朋友圈/微博/抖音/知乎，结果上传文件之后，直接被无良服务器压成超低分辨率渣画质。甚至有些图片/表情包在经过多次传播之后，画质已经糊到惨不忍睹。</p><p>其实，图片的降采样(缩放)可以说是对数字图像最常见的操作了，它的用处多种多样：压缩图片尺寸、节省服务器存储or带宽、适配不同分辨率的屏幕等等。像现在服务器资源这么贵，大家发微博/知乎也不交钱，顶多给各位多塞点广告，所以高清图片和视频自然是能压则压，能分得清张一山和夏雨就可以了。</p><p>如何恢复降采样后的图片是图像处理中一个非常有挑战的问题，一直没有被很好的解决。今天给大家介绍一篇在ECCV2020上最新的Oral工作，巧妙地尝试从本质上解决这个问题。</p><hr><p>这种情况是由于程序为了减轻服务器端的传输和存储压力，主动对信号进行了采样、压缩等操作，而这些操作会不可避免地引起信息丢失（information loss）的问题，造成对原始信号还原的挑战性。直到今天，信息丢失问题仍没有被很好地解决。</p><hr><p>……</p><hr><h4 id="补充文献资料部分"><a href="#补充文献资料部分" class="headerlink" title="补充文献资料部分"></a>补充文献资料部分</h4><h5 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h5><p><a href="https://zhuanlan.zhihu.com/p/22450818" target="_blank" rel="noopener">形象易懂讲解算法I——小波变换</a></p><blockquote><p>于是小波变换的出发点和STFT还是不同的。<strong>STFT是给信号加窗，分段做FFT</strong>；而小波直接把傅里叶变换的基给换了——将<strong>无限长的三角函数基</strong>换成了<strong>有限长的会衰减的小波基</strong>。这样<strong>不仅能够获取频率</strong>，还可以<strong>定位到时间</strong>了~</p></blockquote><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/xiaobobianhuan.jpg" alt="xiaobobianhuan"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/xiaobo.jpg" alt="小波"></p><h5 id="可逆神经网络模型（Invertible-NN-INN）"><a href="#可逆神经网络模型（Invertible-NN-INN）" class="headerlink" title="可逆神经网络模型（Invertible NN, INN）"></a>可逆神经网络模型（Invertible NN, INN）</h5><p><a href="https://lilianweng.github.io/lil-log/2018/10/13/flow-based-deep-generative-models.html" target="_blank" rel="noopener">可逆神经网络模型</a></p><p><a href="https://zhuanlan.zhihu.com/p/268242678" target="_blank" rel="noopener">神经网络的可逆形式</a></p><p><a href="https://www.jianshu.com/p/37c482fe4d2a" target="_blank" rel="noopener">可逆神经网络 Invertible Neural Networks</a></p><p>对于一些问题，研究人员建立了复杂的理论模型，用于实现隐式参数到可测量值的映射，这种映射称之为前向过程。逆向过程即根据测量值得到隐式参数，这也是实际需要解决的问题。但是逆向过程难以解决，因为在前向过程中丢失了一些关键信息。</p><p>如果直接用传统神经网络去训练逆向过程，则效果会很受限，因为逆向过程为一对多映射。神经网络训练出的模型，最好情况是识别最可能的解决方案；最差情况是采用多种解决方案的平均值。</p><p>INN 有三个特征：（i）从输入到输出的映射是双射的，即它的逆存在（ii）正向和反向映射都是有效可计算的（iii）映射具有易处理的雅可比行列式，因此概率可以通过变量公式明确转换。</p><p>标准NN v.s. INN</p><p>标准 NN 直接对逆向过程进行训练，但其需要一个监督损失（SL）项，来区分真正的 x 与预测的 x（我们可以暂时把 SL 理解为一个确定的代价函数），而 y-&gt;x 这种一对多映射使得传统 NN 受到很大限制。INN 只对前向过程使用 SL，而由于并没有一个确定的 x 值，因此预测的 x 属于无监督损失（USL），需要遵循之前的 p(x)；另外，潜在变量 z 需要服从高斯分布，也是属于 USL。</p><p>由于在前向过程中会丢失一些信息，因此引入了额外的潜在输出变量 z，被训练去抓获与 x 有关的但并未包含在 y 内的信息。此外，需要训练网络根据高斯分布对 p(z) 进行调整。即，p(x|y) 被调整为一个确定的函数 x = g(y,z)，这个函数将已知的分布 p(z) 在满足 y 的情况下转换到 x 空间。</p><h5 id="Encoder-Decoder-网络"><a href="#Encoder-Decoder-网络" class="headerlink" title="Encoder-Decoder 网络"></a>Encoder-Decoder 网络</h5><p><a href="https://blog.csdn.net/qq_38906523/article/details/79838000" target="_blank" rel="noopener">Encoder-Decoder模型</a></p><p>所谓<strong>encoder-decoder模型，又叫做编码-解码模型。这是一种应用于seq2seq问题的模型</strong>。</p><p>那么seq2seq又是什么呢？简单的说，就是根据一个输入序列x，来生成另一个输出序列y。seq2seq有很多的应用，例如翻译，文档摘取，问答系统等等。在翻译中，输入序列是待翻译的文本，输出序列是翻译后的文本；在问答系统中，输入序列是提出的问题，而输出序列是答案。</p><p>为了解决seq2seq问题，有人提出了encoder-decoder模型，也就是编码-解码模型。所谓编码，就是将输入序列转化成一个固定长度的向量；解码，就是将之前生成的固定向量再转化成输出序列。 </p><p><strong>encoder-decoder模型虽然非常经典，但是局限性也非常大</strong>。最大的局限性就在于编码和解码之间的唯一联系就是一个固定长度的语义向量C。也就是说，编码器要将整个序列的信息压缩进一个固定长度的向量中去。但是这样做有两个弊端，一是语义向量无法完全表示整个序列的信息，还有就是先输入的内容携带的信息会被后输入的信息稀释掉，或者说，被覆盖了。输入序列越长，这个现象就越严重。这就使得在解码的时候一开始就没有获得输入序列足够的信息， 那么解码的准确度自然也就要打个折扣了</p><h5 id="不适定问题-ill-posed-problem"><a href="#不适定问题-ill-posed-problem" class="headerlink" title="不适定问题(ill-posed problem)"></a>不适定问题(ill-posed problem)</h5><p><a href="https://blog.csdn.net/leviopku/article/details/89296455" target="_blank" rel="noopener">计算机视觉中的不适定问题</a></p><p>适定问题(well-posed problem)和不适定问题(ill-posed problem)都是数学领域的术语。</p><p>前者需满足三个条件，若有一个不满足则称为”ill-posed problem”：</p><blockquote><p>a solution exists   </p><p> 解必须存在</p><ol start="2"><li>the solution is unique    </li></ol><p>解必须唯一</p><ol start="3"><li>the solution’s behavior changes continuously with the initial conditions. </li></ol><p>解能根据初始条件连续变化，不会发生跳变，即解必须稳定</p></blockquote><p>上述来自wiki。</p><hr><p>图像处理中不适定问题（ill posed problem）或称为反问题（inverse Problem）的研究从20世纪末成为国际上的热点问题，成为现代数学家、计算机视觉和图像处理学者广为关注的研究领域。数学和物理上的反问题的研究由来已久，法国数学家阿达马早在19世纪就提出了不适定问题的概念:称一个数学物理定解问题的解存在、唯一并且稳定的则称该问题是适定的（Well Posed）.如果不满足适定性概念中的上述判据中的一条或几条，称该问题是不适定的。典型的图像处理不适定问题包括：图像去噪（Image De-nosing），图像恢复（Image Restorsion），图像放大（Image Zooming），图像修补（Image Inpainting），图像去马赛克（image Demosaicing），图像超分辨(Image super-resolution )等。<br>迄今为止，人们已经提出许多方法来解决图像处理中的不适定性。但是如何进一步刻画图像的边缘、纹理和角形等图像中重要视觉几何结构，提高该类方法在噪声抑制基础上有效保持结构和纹理能力是有待深入研究的问题。</p><hr><h5 id="Super-Resolution（超分辨率）"><a href="#Super-Resolution（超分辨率）" class="headerlink" title="Super Resolution（超分辨率）"></a>Super Resolution（超分辨率）</h5><p><a href="https://blog.csdn.net/shenziheng1/article/details/72818588/" target="_blank" rel="noopener">漫谈深度学习在Super Resolution（超分辨率）领域上的应用</a></p><p><a href="https://blog.csdn.net/sinat_39372048/article/details/81628945" target="_blank" rel="noopener">超分辨率技术（Super-Resolution, SR）</a></p><p>超分辨率技术（Super-Resolution, SR）是指从观测到的低分辨率图像重建出相应的高分辨率图像，在监控设备、卫星图像和医学影像等领域都有重要的应用价值。</p><hr><p>Super Resolution（SR），这个方向做的事情是给你一张低分辨率的小图（Low Resolution，LR），通过算法将这张LR放大成一张高分辨率的大图（High Resolution，HR）。这个事情乍一听挺简单的，普通的插值算法即可胜任，其实大有玄机，主要的难点在于细节的恢复，如下两张图，第一张图是原图，第二张图是将原图进行3倍下采样后，用Bicubic插值算法[1]进行SR恢复的图像，从图像整体来看，第二张图比第一张图要显得糊一些，如果将蝴蝶的翅膀纹路放大看可以发现，第二张图的细节已经很不清晰，纹路间的边缘已经模糊。这正是SR这个方向所面临的挑战。</p><hr><h3 id="大数据课程论文阅读Paper"><a href="#大数据课程论文阅读Paper" class="headerlink" title="大数据课程论文阅读Paper"></a>大数据课程论文阅读Paper</h3><p>这次挑了篇发表在IEEE Intelligent Systems上的文章《基于图像大数据的道路交通态势感知系统研究》，好像挺水的。</p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_0.png" alt="Image_Big_Data_00"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_1.png" alt="Image_Big_Data_01"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_2.png" alt="Image_Big_Data_02"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_03.png" alt="Image_Big_Data_03"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_04.png" alt="Image_Big_Data_04"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_05.png" alt="Image_Big_Data_05"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_06.png" alt="Image_Big_Data_06"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_07.png" alt="Image_Big_Data_07"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_big_Data_08.png" alt="Image_big_Data_08"></p><p><img src="https://gitee.com/henry-avery/my_pic_bed/raw/master/Image_Big_Data_09.png" alt="Image_Big_Data_09"></p><p><strong>我的参考文献</strong></p><p>基础目标检测算法介绍（一）：CNN、RCNN、Fast RCNN和Faster RCNN - 论智的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/46963225" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46963225</a></p><h3 id="大数据课程Project"><a href="#大数据课程Project" class="headerlink" title="大数据课程Project"></a>大数据课程Project</h3><p><a href="https://www.aclweb.org/anthology/2020.acl-main.343/" target="_blank" rel="noopener">A Chinese Multimodal Sentiment Analysis Dataset with Fine-grained Annotation of Modality</a></p><p><a href="https://github.com/thuiar/MMSA" target="_blank" rel="noopener">code</a></p><hr><blockquote><p>太南了，还是从基础做起吧。</p></blockquote><hr><p><a href="https://www.bilibili.com/video/BV1Fv411E7Vs" target="_blank" rel="noopener">aiwin的舆情分析bilibili</a></p><h2 id="论文查重"><a href="#论文查重" class="headerlink" title="论文查重"></a>论文查重</h2><p><a href="http://www.biguolunwen.com/" target="_blank" rel="noopener">中文论文查重</a></p><p><a href="http://www.turnitin.com.cn/" target="_blank" rel="noopener">英文论文查重</a></p><blockquote><p>竟然是按字符数收费，查了我二十几块钱，简直无语了，参考文献篇篇标红，把参考文献删了才能过。</p><p>一次及其糟糕的查重体验。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> 论文 </tag>
            
            <tag> 信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS使用技巧</title>
      <link href="/2020/10/07/vs-shi-yong-ji-qiao/"/>
      <url>/2020/10/07/vs-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="VS常用快捷键"><a href="#VS常用快捷键" class="headerlink" title="VS常用快捷键"></a>VS常用快捷键</h2><h3 id="变量-方法-类-相关操作"><a href="#变量-方法-类-相关操作" class="headerlink" title="[变量/方法/类] 相关操作"></a>[变量/方法/类] 相关操作</h3><blockquote><p>Ctrl + R,Ctrl + R ：变量/方法/类[重命名]</p><p>Alt+F12: ：变量/方法/类[查看相关定义(Esc退出)]</p></blockquote><h3 id="·-光标移动"><a href="#·-光标移动" class="headerlink" title="· 光标移动"></a>· 光标移动</h3><blockquote><p>Ctrl + ← / → ：按单词移动光标</p><p>Ctrl + Home / End ：移动到文档前端/末尾</p><p>Page Up/Down ：快速移动到下一页</p></blockquote><h3 id="·-文本选择"><a href="#·-文本选择" class="headerlink" title="· 文本选择"></a>· 文本选择</h3><blockquote><p>Shift + ← / → ：按字符选择文本</p><p>Ctrl + Shift + ← / → ：按单词选择文本</p><p>Ctrl + W ：选择整个单词</p><p>Shift + Home/End ：选择光标位置到本行开头/结尾的所有文本</p><p>Ctrl + Shift + Home/End ：选择光标位置到文档开头/结尾的所有文本</p></blockquote><h3 id="·-复制删除文本"><a href="#·-复制删除文本" class="headerlink" title="· 复制删除文本"></a>· 复制删除文本</h3><blockquote><p>Ctrl + Shift + V ：可选择进几次的复制内容</p><p>Ctrl + D ：快速复制一行</p><p>Shift + Delete ：删除整行</p><p>Ctrl + Delete/Backspace ：删除整个单词[从前往后/从后往前]<br>Ctrl + Enter ：在上面插入空白行[实用]<br>Ctrl + Shift + Enter ：在下面插入空白行</p></blockquote><h3 id="·-格式化代码-注释"><a href="#·-格式化代码-注释" class="headerlink" title="· 格式化代码/注释"></a>· 格式化代码/注释</h3><blockquote><p>tab ：向后缩进指定tab空间</p><p>Shift + tab ：向前缩进指定tab空间</p><p>Ctrl + K,Ctrl + D ：格式化整个文档</p><p>Ctrl + K,Ctrl + F ：格式化选中行</p><p>Ctrl + K,Ctrl + C ：注释选中行</p><p>Ctrl + K,Ctrl + U ：取消注释选中行</p><p>[工具] Power Tool for Visual Studio ：保存时格式化文档/删除未引用命名空间/重新排序命名空间</p><p>[下载] 扩展-&gt;搜索Power Command</p></blockquote><h3 id="·-跳转-展开-折叠代码"><a href="#·-跳转-展开-折叠代码" class="headerlink" title="· 跳转/展开/折叠代码"></a>· 跳转/展开/折叠代码</h3><blockquote><p>Ctrl + G ：指定跳转到某行</p><p>Ctrl + M,Ctrl + M ：展开/折叠光标所在位置的代码块</p><p>Ctrl + M,Ctrl + O ：折叠整个文档的代码块</p><p>Ctrl + M,Ctrl + L ：展开整个文档的代码块</p><p>Ctrl + K,Ctrl + S ：包裹选中的代码</p></blockquote><h3 id="·-代码片段"><a href="#·-代码片段" class="headerlink" title="· 代码片段"></a>· 代码片段</h3><blockquote><p>prop/propfull + tab + tab ：生成字段属性<br>try/tryf/class/interface/foreach/for/while/switch + tab + tab ：快捷生成相应的代码片段模板</p></blockquote><h3 id="·-选项卡和窗口"><a href="#·-选项卡和窗口" class="headerlink" title="· 选项卡和窗口"></a>· 选项卡和窗口</h3><blockquote><p>Ctrl + Tab ：正序切换选项卡</p><p>Ctrl + Shift + Tab ：倒序切换选项卡</p><p>Ctrl + F6 ：导航到下一个选项卡</p><p>Ctrl + Shift + F6 ：导航到前一个选项卡</p><p>Ctrl + F4 ：关闭当前选项卡</p><p>Alt + W + L ：关闭所有选项卡</p><p>Shift + Alt + Enter ：关闭所有选项卡</p><p>Ctrl + Alt + L : 解决方案资源管理器</p><p>Ctrl + ,Ctrl + M ：团队资源管理器</p><p>Ctrl + ,Ctrl + E ：错误列表</p><p>Ctrl + ,Ctrl + E ：任务列表</p><p>Ctrl + Alt + O ：输出窗口</p></blockquote><h3 id="·-查找替换"><a href="#·-查找替换" class="headerlink" title="· 查找替换"></a>· 查找替换</h3><blockquote><p>Ctrl + F ：查找</p><p>Ctrl + H ：查找+替换</p><p>F3 ：查找下一个</p><p>Shift + F3 ：查找上一个</p></blockquote><h3 id="·-运行和调试"><a href="#·-运行和调试" class="headerlink" title="· 运行和调试"></a>· 运行和调试</h3><blockquote><p>F5 ：调试</p><p>Ctrl + F5 ：运行（非调试）</p><p>Shift + F5 ：结束调试</p><p>F10 ：多步调试</p><p>F11 ：单步调试</p><p>Shift + F11 ：跳出当前调试的方法体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git和Github</title>
      <link href="/2020/10/03/guan-yu-git-he-github/"/>
      <url>/2020/10/03/guan-yu-git-he-github/</url>
      
        <content type="html"><![CDATA[<h2 id="关于廖雪峰的Git教程小结"><a href="#关于廖雪峰的Git教程小结" class="headerlink" title="关于廖雪峰的Git教程小结"></a>关于廖雪峰的Git教程小结</h2><p><img src="https://pic1.zhimg.com/v2-49c265e6c878e26b314702d1f1cb9ee4_b.jpg" alt="img"></p><ol><li><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol></li></ol><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p><h2 id="关于Github的使用"><a href="#关于Github的使用" class="headerlink" title="关于Github的使用"></a>关于Github的使用</h2><p><a href="https://zhuanlan.zhihu.com/p/89607964" target="_blank" rel="noopener">Github进行fork后如何与原仓库同步</a></p><p><a href="https://blog.csdn.net/zhongzunfa/article/details/80344585?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">Github fork 别人的项目源作者更新后如何同步更新</a></p><h2 id="关于Git命令"><a href="#关于Git命令" class="headerlink" title="关于Git命令"></a>关于Git命令</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Linux私房菜</title>
      <link href="/2020/09/26/wo-de-linux-si-fang-cai/"/>
      <url>/2020/09/26/wo-de-linux-si-fang-cai/</url>
      
        <content type="html"><![CDATA[<h2 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h2><p>在腾讯云买了一年的服务器和域名（henryavery.cn）,接下来要正式开始学习Linux操作系统了，在此之前先复习一下计算机概论，也顺便为下次自己装机做准备。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django后续</title>
      <link href="/2020/09/19/django-hou-xu/"/>
      <url>/2020/09/19/django-hou-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="Django后续"><a href="#Django后续" class="headerlink" title="Django后续"></a>Django后续</h1><blockquote><p>Web应用程序的核心是让任何用户都能够注册账户并能够使用它，不管用户身处何方。</p></blockquote><h2 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h2><p>创建表单、实现用户的使用功能、Django防范常见攻击、用户身份验证系统……总之就是让用户都能正常使用</p><h3 id="让用户能够输入数据"><a href="#让用户能够输入数据" class="headerlink" title="让用户能够输入数据"></a>让用户能够输入数据</h3><h4 id="添加新的主题和条目、编辑条目"><a href="#添加新的主题和条目、编辑条目" class="headerlink" title="添加新的主题和条目、编辑条目"></a>添加新的主题和条目、编辑条目</h4><p>表单，url模式，视图函数views，创建模板并链接到页面。</p><p>GET请求与POST请求，POST用于提交表单，GET用于从服务器读取数据。</p><blockquote><p>from django.urls import reverse</p><p>需要</p></blockquote><h3 id="创建用户账户"><a href="#创建用户账户" class="headerlink" title="创建用户账户"></a>创建用户账户</h3><p>建立一个用户注册和身份验证系统，先创建一个新的应用程序，然后修改模型Topic</p><h4 id="应用程序users"><a href="#应用程序users" class="headerlink" title="应用程序users"></a>应用程序users</h4><pre class="line-numbers language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py startapp users<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、将应用程序添加到settings</p><p>2、修改根目录urls.py使其包含将为应用程序定义的URL</p><h4 id="用户登录、注销与注册"><a href="#用户登录、注销与注册" class="headerlink" title="用户登录、注销与注册"></a>用户登录、注销与注册</h4><p>要老命了，百度了一下午，我愿称其为Django新版本(3.x)踩坑记录。</p><p>我还是直接把代码上传到GitHub上好了，要改的地方实在太多了。</p><h3 id="让用户拥有自己的数据"><a href="#让用户拥有自己的数据" class="headerlink" title="让用户拥有自己的数据"></a>让用户拥有自己的数据</h3><p>用户需要专属学习笔记</p><h4 id="使用-login-required限制访问"><a href="#使用-login-required限制访问" class="headerlink" title="使用@login_required限制访问"></a>使用@login_required限制访问</h4><p>全面限制。装饰器（decorator）是放在函数定义前的指令，修改函数代码的行为。</p><h4 id="数据关联用户"><a href="#数据关联用户" class="headerlink" title="数据关联用户"></a>数据关联用户</h4><ol><li>修改模型Topic</li><li>确定当前有哪些用户（启动Django shell）</li><li>迁移数据库</li></ol><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>当执行 python manage.py shell 出现错误：TypeError: <strong>init</strong>() missing 1 required positional argument: ‘on_delete’</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>定义外键的时候需要加上 on_delete=;<br>即：<code>contract = models.ForeignKey(Contract, on_delete=models.CASCADE)</code></p><h5 id="原因如下："><a href="#原因如下：" class="headerlink" title="原因如下："></a>原因如下：</h5><p>django 升级到2.0之后,表与表之间关联的时候,必须要写on_delete参数,否则会报异常:<br>TypeError: init() missing 1 required positional argument: ‘on_delete’</p><p>on_delete各个参数的含义如下：</p><pre><code>    on_delete=None,               # 删除关联表中的数据时,当前表与其关联的field的行为    on_delete=models.CASCADE,     # 删除关联数据,与之关联也删除    on_delete=models.DO_NOTHING,  # 删除关联数据,什么也不做    on_delete=models.PROTECT,     # 删除关联数据,引发错误ProtectedError    # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_NULL, blank=True, null=True)    on_delete=models.SET_NULL,    # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理）    # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_DEFAULT, default=&#39;默认值&#39;)    on_delete=models.SET_DEFAULT, # 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值,一对一同理）    on_delete=models.SET,         # 删除关联数据,     a. 与之关联的值设置为指定值,设置：models.SET(值)     b. 与之关联的值设置为可执行对象的返回值,设置：models.SET(可执行对象)1234567891011</code></pre><hr><blockquote><p>由于多对多(ManyToManyField)没有 on_delete 参数,所以以上只针对外键(ForeignKey)和一对一(OneToOneField)</p></blockquote><h4 id="完善用户功能"><a href="#完善用户功能" class="headerlink" title="完善用户功能"></a>完善用户功能</h4><p>只允许用户访问自己的主题，保护用户的主题和页面，将主题关联到当前用户。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token comment" spellcheck="true"># 确认请求的主题属于当前用户</span>    <span class="token keyword">if</span> topic<span class="token punctuation">.</span>owner <span class="token operator">!=</span> request<span class="token punctuation">.</span>user<span class="token punctuation">:</span>        <span class="token keyword">raise</span> Http404<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于某些原因（主要是“网络原因”和Windows系统的差别），后续Heroku注册和服务器部署继续太过麻烦，于是我决定换个思路，等搞清楚云服务器怎么用再试着部署到自己的服务器上，也许之后可以去备个案然后解析域名，这样就能真正上线使用了（有没有用户另说）</p><p>而且由于我的目的是正常使用应用程序，使用Bootstrap库设置应用程序的样式来进行美化，在目前阶段卡那里也就缺少必要了，可以在解决部署之后再完善。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的“学习笔记”项目就暂告一段落了，虽然我也还不想就这样结项，但是有必要进行这段时间以来的学习总结了。</p><p>首先，整个项目都是基于python开发的，并且主要是用到了Django框架——一套用于开发交互式网站的工具（还有很多类似）</p><p>虽然不是第一次接触到前端开发，但确实是第一次一个人上手开发一整个Web应用程序，借此我也大概了解了Web的整个开发流程，并且接触到了数据库和服务器的使用。</p><p>包括第一次接触正则表达式，创建表单（提交数据）以及模型定义（继承类）。</p><p>用Django创建网页三步走：定义URL，编写视图和模板。</p><p>然后让数据关联用户，功能齐备后，美化以及部署还有待完成。</p><p>最最重要的，还是在本次项目开发过程中所学到和实践使用的东西。</p><p>比如再次深入体会到使用git进行版本控制能够带来的方便，而且通过项目实践也接触到了很多之前不明白也不知道的新东西。</p><p>比如vim编辑器（举例而言，还有很多），虽然目前可能还不会使用，但就好像埋下了一颗种子，将来总有一天会生根发芽。</p><p>再就是实践过程中学到的一些习惯和方法。</p><p>根据自己的兴趣开发有意义的项目。</p><p>只要有机会，就向别人发出邀请，根据反馈改进程序。</p><p>遇到棘手问题时，想办法寻求帮助。首先认清形势（想要做什么？已尝试那些方式？结果如何？）橡皮鸭子调试法。</p><p>再试试，歇一会。</p><p>正确使用在线搜索解决问题，直接搜索报错消息，看别人的博客里的解决方案。</p><p>Stack Overflow 和官方文档文库，reddit和IRC（还没用过）</p><p>用什么学什么的精神。</p><p>peace！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门</title>
      <link href="/2020/09/11/django-ru-men/"/>
      <url>/2020/09/11/django-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Django入门"><a href="#Django入门" class="headerlink" title="Django入门"></a>Django入门</h1><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>先建立项目规范（先要立好规矩），再建立虚拟环境，以便在其中创建项目。</p><h3 id="制定规范"><a href="#制定规范" class="headerlink" title="制定规范"></a>制定规范</h3><p>只把这个项目的一些明确目标列出来，突出开发重点。</p><p>规范如下：</p><p>开始编写一个名为“学习笔记”的Web应用程序，让用户能够记录感兴趣的主题，并在学习每个主题的过程中添加日志条目。“学习笔记”的主页对这个网站进行描述，并邀请用户注册或登录。用户登录后，就可以创建主题、添加新条目以及阅读既有的条目。</p><p>学习新的主题时，记录学到的知识可以帮助跟踪和复习这些知识。优秀的应用程序让这个记录的过程简单易行。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Python从入门到实践》</p><p><a href="https://www.jianshu.com/p/c92345eea6b4" target="_blank" rel="noopener">Django新版本(2.x)踩坑记录</a></p><p><a href="https://blog.csdn.net/u012084802/article/details/79625428" target="_blank" rel="noopener">Python练习Django项目——学习笔记</a></p><p><a href="https://www.jianshu.com/p/b3267d16c245" target="_blank" rel="noopener">Python编程从入门到实践：Web应用程序 - Django入门</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">HTML 教程</a></p><p><a href="https://docs.djangoproject.com/en/2.2/ref/templates/language/#templates" target="_blank" rel="noopener">Django 官网文档 The Django template language</a></p><p><a href="https://docs.djangoproject.com/en/1.8/ref/templates/" target="_blank" rel="noopener">Django模板文档</a></p><h3 id="建立虚拟环境并激活"><a href="#建立虚拟环境并激活" class="headerlink" title="建立虚拟环境并激活"></a>建立虚拟环境并激活</h3><p>虚拟环境是系统的一个位置，把它隔离出来，这是必须的返校隔离措施，之后我们还要把它公之于众——部署到服务器上。</p><p>刚刚开始问题就出现了，Windows要怎么终端切换到目录来着？之前外星人入侵的项目明明用过，给忘了。之前就是只看了一眼，没有动手去做，所以才拖了这么久，这次让我一鼓作气搞定。</p><pre><code>C:\Users\ASUS&gt;d:D:\&gt;cd learning_logD:\learning_log&gt;</code></pre><p>原来切换目录这么简单，我只是还不会用（心虚，这我都不记得了，原因还是以前都没怎么认真用过电脑）</p><p>还有一个很蠢的问题也解决了，之前下载的是Anaconda 3，用的也一直是Anaconda 的Prompt，我这次直接cmd能有用才怪。不过好在总算是可以继续了。</p><p>现在我们为项目新建了一个目录， 将其命名为learning_log，使用如下命令成功创建名为ll_env的虚拟环境：</p><pre><code>python -m venv ll_env</code></pre><p>建立虚拟环境后， (Windows系统下)成功使用下面的命令激活它：</p><pre><code>ll_env\Scripts\activate</code></pre><p>要停止的话，使用终止命令deactivate</p><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><p>出问题了就重新来过，建立虚拟环境然后激活,然后再安装Django包：</p><pre><code>(ll_env) (base) D:\learning_log&gt; pip install DjangoCollecting Django</code></pre><p>下载可能有点慢，要等一会。</p><p>记住，Django仅在虚拟环境处于活动状态才可用。</p><p>嘛，就知道没有这么简单，下载失败了，这次又是哪里出了问题呢？更新了一下pip的版本重新下载。</p><pre><code>(ll_env) (base) D:\learning_log&gt;pip install DjangoCollecting Django  Downloading https://files.pythonhosted.org/packages/01/a5/fb3dad18422fcd4241d18460a1fe17542bfdeadcf74e3861d1a2dfc9e459/Django-3.1.1-py3-none-any.whl (7.8MB)     |████████████████████████████████| 7.8MB 12kB/sCollecting pytz (from Django)  Downloading https://files.pythonhosted.org/packages/4f/a4/879454d49688e2fad93e59d7d4efda580b783c745fd2ec2a3adf87b0808d/pytz-2020.1-py2.py3-none-any.whl (510kB)     |████████████████████████████████| 512kB 9.5kB/sCollecting asgiref~=3.2.10 (from Django)  Downloading https://files.pythonhosted.org/packages/d5/eb/64725b25f991010307fd18a9e0c1f0e6dff2f03622fc4bcbcdb2244f60d6/asgiref-3.2.10-py3-none-any.whlCollecting sqlparse&gt;=0.2.2 (from Django)  Downloading https://files.pythonhosted.org/packages/85/ee/6e821932f413a5c4b76be9c5936e313e4fc626b33f16e027866e1d60f588/sqlparse-0.3.1-py2.py3-none-any.whl (40kB)     |████████████████████████████████| 40kB 7.8kB/sInstalling collected packages: pytz, asgiref, sqlparse, DjangoSuccessfully installed Django-3.1.1 asgiref-3.2.10 pytz-2020.1 sqlparse-0.3.1WARNING: You are using pip version 19.2.3, however version 20.2.3 is available.You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command.</code></pre><p>原来是pip命令需要更新了，按照提示更新版本就成功了。</p><h3 id="创建项目以及数据库"><a href="#创建项目以及数据库" class="headerlink" title="创建项目以及数据库"></a>创建项目以及数据库</h3><pre><code>django-admin.py startproject learning_log .</code></pre><p>新建一个名为learning_log的项目，不知道又出什么问题，先到这吧，睡了睡了。</p><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h4><p>在prompt命令窗口执行上面的命令，会打开 django-admin.py 源代码</p><h4 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h4><p>*.py 的默认打开方式为 pycharm。所以自然直接打开，我没有安装pycharm，所以是用vscode打开的。</p><h4 id="3-解决"><a href="#3-解决" class="headerlink" title="3 解决"></a>3 解决</h4><p>修改一下命令</p><pre><code>django-admin startproject [项目名] .</code></pre><p>执行成功后，输入ls命令（Windows对应dir）就会发现 Django 新建好了需要的文件</p><table><thead><tr><th align="center">文件名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">settings.py</td><td align="center">指定Django如何与你的系统交互以及如何管理项目，修改其中一些设置， 并添加一些设置</td></tr><tr><td align="center">urls.py</td><td align="center">告诉Django应创建哪些网页来响应浏览器请求</td></tr><tr><td align="center">wsgi.py</td><td align="center">帮助Django提供它创建的文件， 这个文件名是web server gateway interface（Web服务器网关接口 ） 的首字母缩写。</td></tr></tbody></table><p>一大早起来直接查命令哪里出了问题，一下就解决了。接下来建立一个数据库。在这里更新了一下Django的版本。然后dir查看一下，确认后启动一个服务器，查看系统中的项目，按照响应操作打开生成的页面。</p><pre><code>python manage.py migratepython manage.py runserver</code></pre><p><img src="D:%5CBlog2%5Csource_posts%5C%E5%9F%BA%E4%BA%8EDjango%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%5C%E9%A1%B5%E9%9D%A2.png" alt="生成页面"></p><p>至此，这个项目成功建立了，耶！</p><h2 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h2><p>打开另一个终端，切换到manage.py所在目录，激活虚拟环境，执行命令startapp。</p><h3 id="定义模型并激活"><a href="#定义模型并激活" class="headerlink" title="定义模型并激活"></a>定义模型并激活</h3><p>模型告诉Django如何处理应用程序中存储的数据。 在代码层面， 模型就是一个类， 包含属性和方法。</p><p><strong>models.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment" spellcheck="true"># Create your models here.</span><span class="token comment" spellcheck="true"># 创建了一个名为Topic 的类， 它继承了Model ——Django中一个定义了模型基本功能的类。 Topic 类只有两个属性： text 和date_added 。</span><span class="token keyword">class</span> <span class="token class-name">Topic</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' 用户学习的主题'''</span>    text <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 属性text是一个CharField——由字符或文本组成的数据</span>    <span class="token comment" spellcheck="true"># https://docs.djangoproject.com/en/1.8/ref/models/fields</span>    <span class="token comment" spellcheck="true"># Django Model Field Reference 用于熟悉模型中可使用的各种字段，自己开发时可能会用到</span>    date_added <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实参auto_add_now=True 让Django将这个属性自动设置成当前日期和时间。</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""返回模型的字符串表示"""</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每当需要修改“学习笔记”管理的数据时， 都采取如下三个步骤： 修改models.py； 对learning_logs 调用makemigrations ； migrate让Django迁移项目。</p><pre class="line-numbers language-python"><code class="language-python">python manage<span class="token punctuation">.</span>py makemigrations learning_logs<span class="token comment" spellcheck="true"># 让Django修改数据库， 使其能够存储与模型Topic 相关的信息</span><span class="token comment" spellcheck="true"># 命令makemigrations 让Django确定该如何修改数据库， 使其能够存储与定义的新模型相关联的数据。</span>python manage<span class="token punctuation">.</span>py migrate<span class="token comment" spellcheck="true"># 应用这种迁移， 让Django替我们修改数据库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Django-管理网站"><a href="#Django-管理网站" class="headerlink" title="Django 管理网站"></a>Django 管理网站</h3><p>为应用程序定义模型时，Django提供的管理网站（admin site）让你能够轻松地处理模型。网站的管理员可使用管理网站，但普通用户不能使用。</p><h4 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h4><pre><code>(ll_env)learning_log&gt;python manage.py createsuperuser❶ Username (leave blank to use &#39;ehmatthes&#39;): ll_admin❷ Email address:❸ Password:  Password (again):  Superuser created successfully.</code></pre><h4 id="向管理网站注册模型"><a href="#向管理网站注册模型" class="headerlink" title="向管理网站注册模型"></a><strong>向管理网站注册模型</strong></h4><p> Django自动在管理网站中添加了一些模型，如User 和Group ，但对于我们创建的模型，必须手工进行注册。我们创建应用程序learning_logs 时，Django在models.py所在的目录中创建了一个名为admin.py的文件。</p><h4 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h4><p>在网站上测试添加主题“Chess”和“Rock Climbing”</p><h3 id="定义并迁移模型Entry"><a href="#定义并迁移模型Entry" class="headerlink" title="定义并迁移模型Entry"></a>定义并迁移模型Entry</h3><p>要记录学到的国际象棋和攀岩知识，需要为用户可在学习笔记中添加的条目定义模型。每个条目都与特定主题相关联，这种关系被称为多对一关系，即多个条目可关联到同一个主题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment" spellcheck="true"># Model是Django中一个定义了模型基本功能的类</span><span class="token keyword">class</span> <span class="token class-name">Topic</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token operator">-</span><span class="token operator">-</span>snip<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""学到的有关某个主题的具体知识"""</span>    topic <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>Topic<span class="token punctuation">,</span>on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span>    text <span class="token operator">=</span> models<span class="token punctuation">.</span>TextField<span class="token punctuation">(</span><span class="token punctuation">)</span>    date_added <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        verbose_name_plural <span class="token operator">=</span> <span class="token string">'entries'</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"..."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性topic 是一个ForeignKey 实例，外键是一个数据库术语，引用了数据库中的另一条记录； </p><p>这些代码将每个条目关联到特定的主题。每个主题创建时，都给它分配了一个键（或ID）。 需要在两项数据之间建立联系时，Django使用与每项信息相关联的键。Django2.0版本外键要求添加on_delete参数。</p><p>在Entry 类中嵌套了Meta 类。Meta 存储用于管理模型的额外信息，设置一个特殊属性，让Django需要时使用Entries表示多个条目，没有这个类将使用Entrys来表示多个条目。</p></blockquote><p>没有看明白这些想说明什么，往后看应该就会知道了。接下来迁移数据库。生成新的迁移文件。</p><p>添加一个模型，就迁移一次数据库。过程：修改models.py，执行命令python manage.py makemigrations app_name ，再执行命令python manage.py migrate 。</p><h3 id="向管理网站注册Entry"><a href="#向管理网站注册Entry" class="headerlink" title="向管理网站注册Entry"></a>向管理网站注册Entry</h3><p>修改admin.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> learning_logs<span class="token punctuation">.</span>models <span class="token keyword">import</span> Topic<span class="token punctuation">,</span> Entryadmin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Topic<span class="token punctuation">)</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Entry<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Django-shell"><a href="#Django-shell" class="headerlink" title="Django shell"></a>Django shell</h3><pre><code>python manage.py shell</code></pre><blockquote><p>Cr+Z,回车退出</p></blockquote><p>用于测试和排除故障的理想之地</p><p><a href="https：//docs.djangoproject.com/en/7.8/topics/db/queries">更多关于如何查询数据的文档</a></p><h2 id="创建网页：学习笔记主页"><a href="#创建网页：学习笔记主页" class="headerlink" title="创建网页：学习笔记主页"></a>创建网页：学习笔记主页</h2><p>定义URL、编写视图和编写模板。</p><p>urls -&gt; views -&gt; html  添加网页步骤。</p><h3 id="映射URL"><a href="#映射URL" class="headerlink" title="映射URL"></a>映射URL</h3><blockquote><p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫<em>URL</em>（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址。</p></blockquote><p>实际的URL模式是一个对函数url的调用，这个函数接受三个实参。</p><pre class="line-numbers language-python"><code class="language-python">urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">#主页</span>    <span class="token comment" spellcheck="true">#第一个是正则表达式，r让Python将接下来的字符串视为原始字符串，引号正则表达式始于和终于何处</span>    <span class="token comment" spellcheck="true">#第二个实参指定了要调用的视图函数</span>    <span class="token comment" spellcheck="true">#第三个实参将这个URL模式的名称指定为index</span>    path<span class="token punctuation">(</span>r<span class="token string">''</span><span class="token punctuation">,</span>views<span class="token punctuation">.</span>index<span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式（regex），这是个什么鬼东西？相信后面还会有很多见面的机会……</p><blockquote><p>请求的URL与正则表达式匹配时调用视图函数</p></blockquote><h3 id="编写视图和模板"><a href="#编写视图和模板" class="headerlink" title="编写视图和模板"></a>编写视图和模板</h3><p>默认的urls.py包含在文件夹learning_log中， 现在需要在文件夹learning_logs中创建另一个urls.py文件：<strong>(注意关于 Django版本更新,书上的代码需做相应修改)</strong></p><p>打开项目主文件夹learning_log中的文件urls.py， 修改为<br> <strong>learning_log/urls.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> pathurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true"># 该模块定义了可在管理网站中请求的所有URL</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'learning_logs.urls'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'learning_logs'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 代码包含实参namespace ， 让我们能够将learning_logs 的URL同项目中的其他URL区分开来</span><span class="token punctuation">]</span><span class="token triple-quoted-string string">'''Django版本更新,书上的代码需做相应修改书中源代码：from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [    url(r'^admin/', include(admin.site.urls)),    url(r'', include('learning_logs.urls', namespace='learning_logs')),]应改为：from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    path('', include('learning_logs.urls', namespace='learning_logs')),]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的urls.py包含在文件夹learning_log中， 现在需要在文件夹learning_logs中创建另一个urls.py文件：(注意关于 Django版本更新,书上的代码需做相应修改)<br> <strong>learning_logs/urls.py</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""定义learning_logs的URL模式"""</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span>re_path<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> viewsapp_name<span class="token operator">=</span><span class="token string">'learning_logs'</span> <span class="token comment" spellcheck="true"># 不能少 ，否则runserver的时候就会出错</span><span class="token comment" spellcheck="true"># https://docs.djangoproject.com/en/2.2/ref/urls/#module-django.urls.conf</span>urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># 主页</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>index<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># Django将在文件views.py中查找函数index()</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># urls -> views -> html  添加网页步骤</span><span class="token triple-quoted-string string">'''Django版本更新,书上的代码需做相应修改书中源代码：from django.conf.urls import urlfrom . import viewsurlpatterns = [     # Home page.    url(r'^$', views.index, name='index'),    # Show all topics.    url(r'^topics/$', views.topics, name='topics'),    # Detail page for a single topic.    url(r'^topics/(?P&lt;topic_id>\d+)/$', views.topic, name='topic'),]应改为：from django.urls import pathfrom . import viewsapp_name='learning_logs'urlpatterns = [    # 主页    path('', views.index, name='index'),    # 显示所有的主题    path('topics/', views.topics, name='topics'),    # 特定主题的详细页面    path("topics/(?P&lt;topic_id>\d+)/", views.topic, name='topic'),]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建其他网页"><a href="#创建其他网页" class="headerlink" title="创建其他网页"></a>创建其他网页</h2><p>确定创建网页的流程后，可以扩充“学习笔记”项目了。</p><p>接下来要创建两个显示数据的页面。</p><p>所以先创建一个父模板，其他模板都将继承它。</p><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><h4 id="父模板"><a href="#父模板" class="headerlink" title="父模板"></a>父模板</h4><p>这个文件包含所有页面都有的元素； 其他的模板都继承base.html。 当前， 所有页面都包含的元素只有顶端的标题。 将在每个页面中包含这个模板， 因此将这个标题设置为到主页的链接：</p><pre class="line-numbers language-html"><code class="language-html">{% raw %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{% url <span class="token punctuation">'</span>learning_logs:index<span class="token punctuation">'</span> %}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Learning Log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% block content %}{% endblock content %}{% endraw %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板标签用(<strong>{ % % }</strong>)表示，生成一个URL。</p><p>在简单的HTML页面中，用锚标签定义链接：</p><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link_url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>link text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要修改项目中的URL，只需要修改urls.py中的URL模式。</p><h4 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h4><p>重新编写index.html,使其继承base.html。</p><h3 id="显示所有主题的页面"><a href="#显示所有主题的页面" class="headerlink" title="显示所有主题的页面"></a>显示所有主题的页面</h3><p>urls -&gt; views -&gt; html 添加网页步骤</p><p>下面来写一个显示全部主题的页面和一个显示特定主题中条目的页面。</p><pre><code>name &#39;request&#39; is not defined</code></pre><p><strong>views.py</strong></p><p>def topics(request) 写错成 def topics(reqest)了</p><h3 id="显示特定主题的页面"><a href="#显示特定主题的页面" class="headerlink" title="显示特定主题的页面"></a>显示特定主题的页面</h3><pre><code>Reverse for &#39;topic&#39; with arguments &#39;(&#39;&#39;,)&#39; not found. 1 pattern(s) tried: [&#39;topics/(?P&lt;topic_id&gt;\\d+)/$&#39;]</code></pre><p>return render(request, ‘learning_logs/topic.html’,context)</p><p>写成了</p><p>return render(request, ‘learning_logs/topics.html’,context)</p><pre class="line-numbers language-python"><code class="language-python">  <span class="token comment" spellcheck="true"># 特定主题的详细页面</span>  <span class="token comment" spellcheck="true"># 错误</span>  <span class="token comment" spellcheck="true"># path("topics/(?P&lt;topic_id>\d+)/", views.topic, name='topic'),</span>  <span class="token comment" spellcheck="true"># 正确</span>  re_path<span class="token punctuation">(</span>r<span class="token string">'^topics/(?P&lt;topic_id>\d+)/$'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'topic'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># ?P&lt;topic_id> 将匹配的值存储到topic_id 中； 而表达式\d+ 与包含在两个斜杆内的任何数字都匹配， 不管这个数字为多少位。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天首先学习了如何使用Django框架来创建Web程序应用，相信其他语言或者框架都是大同小异。</p><p>然后制定了项目规范，列出参考资料，最后在项目完成后需要鸣谢。</p><p>在虚拟环境中安装Django，创建一个项目，并且核实已经成功立项。</p><p>学习如何创建应用程序，以及如何定义表示应用程序数据的模型。</p><p>学习了数据库，以及在修改模型后让Django来迁移数据库。</p><p>创建了可管理网站的超级用户，并使用管理网站输入了一些数据。</p><p>探索Django Shell，它能够让我在终端对话处理项目数据，排除障碍。</p><p>学习了如何定义URL、创建网络视图以及编写网页的模板。最后还使用了模板继承，让各个模板简化，使修改网站变得更加容易。</p><p>遇上了劲敌“正则表达式”和“URL模式”，而且由于Django版本更新，url（）和path（）等函数更是变得乱七八糟，最后还是靠着上网看别人写的博客才K.O了它们。</p><hr><p>下一次，我们将创建对用户友好而直观的网页，让用户无需管理网站就可以使用“学习笔记”。</p><p>我们还将添加一个用户注册系统，让用户能够注册和创建自己的学习笔记。</p><blockquote><p>“让任意数量的用户都能与之交互，是Web应用程序的核心所在。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习</title>
      <link href="/2020/09/11/matlab-xue-xi/"/>
      <url>/2020/09/11/matlab-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一周信号处理实验课"><a href="#第一周信号处理实验课" class="headerlink" title="第一周信号处理实验课"></a>第一周信号处理实验课</h2><h3 id="上课学习"><a href="#上课学习" class="headerlink" title="上课学习"></a>上课学习</h3><p>学校东区计算机学院708机房没有安装好MATLAB，而且有些机位不能联网，上课简单介绍了一下MATLAB和课后作业。</p><p>下次上课带自己的电脑去。</p><hr><h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>一些MATLAB的简单操作，课程报告第二周后再提交。</p><p>回去在自己电脑上安装好MATLAB，学校网速太慢了，而且还不稳定，百度云限速。</p><p>MATLAB安装办法自己网上找。</p><hr><h2 id="MATLAB学习"><a href="#MATLAB学习" class="headerlink" title="MATLAB学习"></a>MATLAB学习</h2><p>百度云下了我两天两夜，终于下载安装好了。</p><p>明天开始学。</p><hr><p>学了半天，看了两节课，还是不会做作业……</p><hr><h2 id="第五周信号处理实验课"><a href="#第五周信号处理实验课" class="headerlink" title="第五周信号处理实验课"></a>第五周信号处理实验课</h2><h3 id="Command-conv"><a href="#Command-conv" class="headerlink" title="Command conv"></a><strong>Command conv</strong></h3><p><em>First rule</em>: The two signals (input and impulse response) should be defined in the <strong>same time interval</strong>. </p><p><em>Second rule</em>: When a signal consists of <strong>multiple parts</strong>, the time intervals in which each part is defined must <strong>not overlap</strong>.</p><p><em>Third rule</em>: The output of the conv command has to be <strong>multiplied with the time step</strong> used in the definition of the input and impulse response signals, in order to correctly compute the output of the system. </p><p><em>Fourth rule</em>: The output of the system is plotted in the <strong>double time interval</strong> of the one in which the input and impulse response signals are defined.</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%1st  way</span> t1<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">0.01</span><span class="token punctuation">;</span> t2<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> t3<span class="token operator">=</span><span class="token number">2.01</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span> t<span class="token operator">=</span><span class="token punctuation">[</span>t1 t2 t3<span class="token punctuation">]</span><span class="token punctuation">;</span> x1<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x2<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x3<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">=</span><span class="token punctuation">[</span>x1 x2 x3<span class="token punctuation">]</span><span class="token punctuation">;</span> h<span class="token operator">=</span>x<span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token function">conv</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">axis</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">6</span> <span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'y(t)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%the two signals</span> figure <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token number">0</span><span class="token operator">-</span>t<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'x(t)'</span><span class="token punctuation">,</span><span class="token string">'h(t-\tau)=h(0-\tau)'</span><span class="token punctuation">)</span> <span class="token function">ylim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> figure <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">-</span>t<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token function">ylim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'x(t)'</span><span class="token punctuation">,</span><span class="token string">'h(t-\tau)=h(2-\tau)'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%2nd  way</span> figure t<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span> x<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> h<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token function">conv</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'y(t)'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Other-command"><a href="#Other-command" class="headerlink" title="Other command"></a>Other command</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">% syms</span><span class="token comment" spellcheck="true">% Create symbolic variables and functions</span><span class="token comment" spellcheck="true">% 符号变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>hold on是当前轴及图像保持而不被刷新，准备接受此后将绘制的图形，多图共存。即，启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。</p><p>hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即，关闭图形保持功能。</p><hr><p>area(x, y)：该函数以参数x和y绘制面积图。如果x和y为向量，则相当于函数plot(x, y)，并将0到y之间进行了填充。如果参数y为矩阵，则将y的每一列绘制面积图并进行累计求和。<br>area(y)：如果参数y为向量，则绘制面积图；如果y为矩阵则绘制每一列的面积图之和。</p><hr><p>simplify的调用格式为：simplify(S)，对表达式S进行化简</p><hr><h2 id="矩阵代数上机实验"><a href="#矩阵代数上机实验" class="headerlink" title="矩阵代数上机实验"></a>矩阵代数上机实验</h2><h3 id="第一周学习matlab"><a href="#第一周学习matlab" class="headerlink" title="第一周学习matlab"></a>第一周学习matlab</h3><p>MATLAB 使用撇号运算符 (<code>&#39;</code>) 执行复共轭转置，使用点撇号运算符 (<code>.&#39;</code>) 执行无共轭的转置。对于包含所有实数元素的矩阵，这两个运算符返回相同结果。</p><p>非共轭复数转置（其中每个元素的复数部分保留其符号）表示为 <code>z.&#39;</code>：</p><p><code>eye(n)</code> 返回 n×n 单位方阵</p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/inv.html" target="_blank" rel="noopener"><code>inv</code></a> 函数和表达式 <code>A^-1</code> 均可对矩阵求逆</p><p>有些矩阵<em>接近奇异矩阵</em>，虽然存在逆矩阵，但计算容易出现数值误差。<a href="https://ww2.mathworks.cn/help/matlab/ref/cond.html" target="_blank" rel="noopener"><code>cond</code></a> 函数计算<em>逆运算的条件数</em>，它指示矩阵求逆结果的精度。条件数的范围是从 <code>1</code>（数值稳定的矩阵）到 <code>Inf</code>（奇异矩阵）。</p><p>很少需要为某个矩阵构造显式逆矩阵。求解线性方程组 Ax = b 时，常常会误用 <code>inv</code>。从执行时间和数值精度方面而言，求解此方程的最佳方法是使用矩阵反斜杠运算符，即 <code>x = A\b</code>。有关详细信息，请参阅 <a href="https://ww2.mathworks.cn/help/matlab/ref/mldivide.html" target="_blank" rel="noopener"><code>mldivide</code></a>。</p><p><strong>Kronecker 张量积</strong></p><p>两个矩阵的 Kronecker 乘积 <code>kron(X,Y)</code> 为 <code>X</code> 的元素与 <code>Y</code> 的元素的所有可能乘积构成的较大矩阵。如果 <code>X</code> 为 m×n 且 <code>Y</code> 为 p×q，则 <code>kron(X,Y)</code> 为 mp×nq。元素以特定方式排列，呈现 <code>X</code> 的每个元素分别与整个矩阵 <code>Y</code> 相乘的结果。</p><p><strong>向量范数和矩阵范数</strong></p><p>向量 x 的 p-范数，</p><p>使用 <code>norm(x,p)</code> 进行计算。此运算是为 p &gt; 1 的任意值定义的，但最常见的 p 值为 1、2 和 ∞。默认值为 p = 2，这与<em>欧几里德长度</em>或<em>向量幅值</em>对应：</p><pre><code>v = [2 0 -1];[norm(v,1) norm(v) norm(v,inf)]ans =    3.0000    2.2361    2.0000</code></pre><p>矩阵 A 的 p-范数，</p><p>可以针对 p = 1、2 和 ∞ 通过 <code>norm(A,p)</code> 进行计算。同样，默认值也为 p = 2：</p><pre><code>A = pascal(3);[norm(A,1) norm(A) norm(A,inf)]ans =   10.0000    7.8730   10.0000</code></pre><p>如果要计算矩阵的每行或每列的范数，可以使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/vecnorm.html" target="_blank" rel="noopener"><code>vecnorm</code></a>：</p><pre><code>vecnorm(A)ans =    1.7321    3.7417    6.7823</code></pre><h3 id="第二周InverseMatrix"><a href="#第二周InverseMatrix" class="headerlink" title="第二周InverseMatrix"></a>第二周InverseMatrix</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> B<span class="token operator">=</span> <span class="token function">InverseMatrix</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> m<span class="token operator">~=</span>n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a square matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token function">rank</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a full rank matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span>C <span class="token operator">=</span> <span class="token punctuation">[</span>A <span class="token punctuation">;</span><span class="token function">eye</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%初等列变换代码</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n    <span class="token comment" spellcheck="true">%第一步对角线元素变1</span>    <span class="token comment" spellcheck="true">%第二步变A为单位矩阵</span>    d_1<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">/</span>d_1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n        <span class="token keyword">if</span> <span class="token number">i</span><span class="token operator">~=</span><span class="token number">j</span>            d_2<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">-</span>d_2<span class="token operator">.*</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span>B <span class="token operator">=</span> <span class="token function">C</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>忘了除数不为0</p></blockquote><h3 id="第三周InverseMatrixCramer"><a href="#第三周InverseMatrixCramer" class="headerlink" title="第三周InverseMatrixCramer"></a>第三周InverseMatrixCramer</h3><pre class="line-numbers language-matlab"><code class="language-matlab">n<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>A<span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>B<span class="token operator">=</span><span class="token function">InverseMatrixCramer</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token function">inv</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token keyword">function</span> B <span class="token operator">=</span> <span class="token function">InverseMatrixCramer</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> m<span class="token operator">~=</span>n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a square matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token function">rank</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'A is not a full rank matrix'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token keyword">end</span>B <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%Cramer's rule</span>C<span class="token operator">=</span><span class="token function">eye</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n    c<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    B_det<span class="token operator">=</span><span class="token function">det</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n        D<span class="token operator">=</span>A<span class="token punctuation">;</span>        <span class="token function">D</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span>c<span class="token punctuation">;</span>        B_det_j<span class="token operator">=</span><span class="token function">det</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token operator">=</span>B_det_j<span class="token operator">/</span>B_det<span class="token punctuation">;</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span>b<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span>B<span class="token operator">=</span>B<span class="token operator">'</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第四周SloveEquationKron"><a href="#第四周SloveEquationKron" class="headerlink" title="第四周SloveEquationKron"></a>第四周SloveEquationKron</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%% 可观察四个变量不同取值的变化</span>m<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> p<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> q<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>A <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> X<span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>B <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> D <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>X <span class="token operator">=</span> <span class="token function">SloveEquationKron</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%%% 验证程序是否正确</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token function">kron</span><span class="token punctuation">(</span>B<span class="token operator">'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span><span class="token operator">\</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'fro'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%正确输出0</span><span class="token function">norm</span><span class="token punctuation">(</span>A<span class="token operator">*</span>X<span class="token operator">*</span>B<span class="token operator">-</span>D<span class="token punctuation">,</span><span class="token string">'fro'</span><span class="token punctuation">)</span><span class="token keyword">function</span> X <span class="token operator">=</span> <span class="token function">SloveEquationKron</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>q<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%K=kron(B',A)</span>B_<span class="token operator">=</span>B<span class="token operator">'</span><span class="token punctuation">;</span><span class="token punctuation">[</span>ma<span class="token punctuation">,</span>na<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>B_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>mb<span class="token punctuation">,</span>nb<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>ia<span class="token punctuation">,</span>ib<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">meshgrid</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>ma<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>mb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>ja<span class="token punctuation">,</span>jb<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">meshgrid</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>na<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span>K <span class="token operator">=</span> <span class="token function">B_</span><span class="token punctuation">(</span>ia<span class="token punctuation">,</span>ja<span class="token punctuation">)</span><span class="token operator">.*</span><span class="token function">A</span><span class="token punctuation">(</span>ib<span class="token punctuation">,</span>jb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%Solve equation via kron</span>C<span class="token operator">=</span>K<span class="token punctuation">;</span>XX <span class="token operator">=</span> C<span class="token operator">\</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>X <span class="token operator">=</span> <span class="token function">reshape</span><span class="token punctuation">(</span>XX<span class="token punctuation">,</span><span class="token punctuation">[</span>p<span class="token punctuation">,</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/u010555688/article/details/37811141" target="_blank" rel="noopener">Matlab学习笔记 kron函数</a></p><h3 id="第五周SVD-my"><a href="#第五周SVD-my" class="headerlink" title="第五周SVD_my"></a>第五周SVD_my</h3><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token keyword">function</span> <span class="token punctuation">[</span>U<span class="token punctuation">,</span>D<span class="token punctuation">,</span>V<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SVD_my</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%[m,n] = size(A);</span><span class="token comment" spellcheck="true">%U=rand(m,m);</span><span class="token comment" spellcheck="true">%V=rand(n,n);</span><span class="token comment" spellcheck="true">%D=A;</span>T1 <span class="token operator">=</span> <span class="token function">null</span><span class="token punctuation">(</span>A<span class="token operator">'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%计算A共轭转置零空间的标准正交基</span>B<span class="token operator">=</span>A<span class="token operator">'</span><span class="token operator">*</span>A<span class="token punctuation">;</span><span class="token punctuation">[</span>V<span class="token punctuation">,</span>D<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">eig</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%求特征值</span><span class="token punctuation">[</span>m0<span class="token punctuation">,</span>n0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>m0        <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n0            <span class="token keyword">if</span> <span class="token number">i</span><span class="token operator">+</span><span class="token number">j</span><span class="token operator">==</span>m0<span class="token operator">+</span><span class="token number">1</span>                <span class="token function">E</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">E</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span><span class="token keyword">end</span>V<span class="token operator">=</span>V<span class="token operator">*</span>E<span class="token punctuation">;</span>D<span class="token operator">=</span>E<span class="token operator">*</span>D<span class="token operator">*</span>E<span class="token punctuation">;</span>%V1<span class="token operator">=</span>V<span class="token punctuation">;</span>T<span class="token operator">=</span><span class="token function">diag</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>T0<span class="token operator">=</span>T<span class="token punctuation">;</span>D0<span class="token operator">=</span>D<span class="token punctuation">;</span><span class="token punctuation">[</span>m1<span class="token punctuation">,</span>n1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span>m1<span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span>        <span class="token keyword">if</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">T0</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&lt;</span> <span class="token number">10</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span>                <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">V1</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">D0</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span><span class="token keyword">end</span>S<span class="token operator">=</span><span class="token function">sqrt</span><span class="token punctuation">(</span>D0<span class="token punctuation">)</span><span class="token punctuation">;</span>D1<span class="token operator">=</span><span class="token function">diag</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>U<span class="token operator">=</span>A<span class="token operator">*</span>V1<span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>D1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>md<span class="token punctuation">,</span>nd<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>z<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span>m<span class="token operator">-</span>md<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>D<span class="token operator">=</span><span class="token punctuation">[</span>S<span class="token punctuation">;</span>z<span class="token punctuation">]</span><span class="token punctuation">;</span>U<span class="token operator">=</span><span class="token punctuation">[</span>U T1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第七周满秩分解求广义逆"><a href="#第七周满秩分解求广义逆" class="headerlink" title="第七周满秩分解求广义逆"></a>第七周满秩分解求广义逆</h3><pre class="line-numbers language-matlab"><code class="language-matlab">close allclear all<span class="token comment" spellcheck="true">%m=10;   n=8;</span><span class="token comment" spellcheck="true">%A = rand(m,n);</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>A_MP<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fullrank_my</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%%% 验证程序是否正确</span><span class="token function">norm</span><span class="token punctuation">(</span>A_MP<span class="token operator">-</span><span class="token function">pinv</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'fro'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%%正确为接近于0</span><span class="token comment" spellcheck="true">%%</span><span class="token keyword">function</span> <span class="token punctuation">[</span>A_MP<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fullrank_my</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>A1 <span class="token operator">=</span> <span class="token function">rref</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%将矩阵A化成行最简形式保存在A1中</span><span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%获取矩阵A的大小：m行n列</span>B0<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%生成一个空向量</span>C0<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%生成一个空向量</span><span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>m    <span class="token comment" spellcheck="true">%依次扫描矩阵m行</span>   flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token number">j</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>n    <span class="token comment" spellcheck="true">%依次扫描矩阵n列</span>       <span class="token keyword">if</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span>    <span class="token comment" spellcheck="true">%若A1(i, j)等于1      </span>           <span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">i</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">%固定j列，扫描此列的第1行到i-1行元素</span>               <span class="token keyword">if</span> <span class="token function">A1</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">~=</span><span class="token number">0</span>    <span class="token comment" spellcheck="true">%判断是否全为0</span>                   flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%若不全为0，则将flag置为0（说明此列不是单位矩阵的列）</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token keyword">end</span>           <span class="token keyword">end</span>           <span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">i</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>m        <span class="token comment" spellcheck="true">%固定j列，扫描此列的第i+1行到m行（即最后一行）元素</span>               <span class="token keyword">if</span> <span class="token function">A1</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token operator">~=</span><span class="token number">0</span>    <span class="token comment" spellcheck="true">%判断是否全为0</span>                   flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%若不全为0，则将flag置为0（说明此列不是单位矩阵的列）</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token keyword">end</span>           <span class="token keyword">end</span>           <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token number">1</span>         <span class="token comment" spellcheck="true">%若flag为1（不为0），则说明此列是【矩阵的行最简形式矩阵】的单位矩阵的列</span>               B0<span class="token operator">=</span><span class="token punctuation">[</span>B0<span class="token punctuation">,</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">j</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%将矩阵A的j列加到B0列向量之后</span>               C0<span class="token operator">=</span><span class="token punctuation">[</span>C0<span class="token punctuation">;</span><span class="token function">A1</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%将矩阵A1的i行加到C0行向量之后，</span>           <span class="token keyword">end</span>       <span class="token keyword">end</span>         <span class="token keyword">end</span><span class="token keyword">end</span><span class="token punctuation">[</span>m1<span class="token punctuation">,</span>n1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>B0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%获取矩阵B0的大小：m1行n1列</span><span class="token punctuation">[</span>m2<span class="token punctuation">,</span>n2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">size</span><span class="token punctuation">(</span>C0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">%获取矩阵C0的大小：m2行n2列</span>B<span class="token operator">=</span><span class="token function">B0</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">%将矩阵B0的第1列到最后一列赋值给矩阵B</span>C<span class="token operator">=</span><span class="token function">C0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span>m2<span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">%将矩阵C0的第1行到最后一行赋值给矩阵C</span>L<span class="token operator">=</span>B<span class="token punctuation">;</span>R<span class="token operator">=</span>C<span class="token punctuation">;</span><span class="token comment" spellcheck="true">%A_MP=R'*(R*R')^(-1)*(L'*L)^(-1)*L';</span>A_MP<span class="token operator">=</span>R<span class="token operator">'</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>R<span class="token operator">*</span>R<span class="token operator">'</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>L<span class="token operator">'</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">*</span>L<span class="token operator">'</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h3><p><a href="https://www.bilibili.com/video/BV1GJ41137UH" target="_blank" rel="noopener">MATLAB教程_台大郭彦甫（14课=15h）</a></p><p><a href="https://zhuanlan.zhihu.com/p/77669451?utm_source=qq" target="_blank" rel="noopener">matlab入门图文教程</a></p><p><a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">matlab帮助文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHU </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Signal Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛启航</title>
      <link href="/2020/09/11/mei-sai-qi-hang/"/>
      <url>/2020/09/11/mei-sai-qi-hang/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="美国大学生数学建模竞赛（MCM-ICM）"><a href="#美国大学生数学建模竞赛（MCM-ICM）" class="headerlink" title="美国大学生数学建模竞赛（MCM/ICM）"></a>美国大学生数学建模竞赛（MCM/ICM）</h3><p>美国大学生数学建模竞赛（MCM/ICM）由美国数学及其应用联合会主办，是唯一的国际性数学建模竞赛，也是世界范围内最具影响力的数学建模竞赛。赛题内容涉及经济、管理、环境、资源、生态、医学、安全、等众多领域。竞赛要求三人（本科生）为一组，在四天时间内，就指定的问题完成从建立模型、求解、验证到论文撰写的全部工作，体现了参赛选手研究问题、解决方案的能力及团队合作精神。 为现今各类<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B" target="_blank" rel="noopener">数学建模竞赛</a>之鼻祖。</p><hr><h3 id="报名须知"><a href="#报名须知" class="headerlink" title="报名须知"></a>报名须知</h3><p>组队要求：三人（本科生）为一组（模型搭建，模型实现，论文写作）</p><p>比赛时间：2021年•2月4日——2月8日，在四天时间内，一般都是早晨到早晨，要安排好比赛的时间。比赛以美国东部时间为准，其比北京时间晚了大约13个小时。</p><p>竞赛开始时间：2021年2月4日 下午5点（美国东部时间）（北京时间2月5日早上6点）</p><p>竞赛截止：2021年2月8日 下午8点（美国东部时间）（北京时间2月9日早上9点）</p><p>论文提交截止时间：2021年2月8日 下午9点（美国东部时间）（北京时间2月9日早上10点）</p><p>竞赛结果：2021年4月30日之前</p><p>比赛题目：一共分为6种题型。分别为：连续型、离散型、大数据、运筹学/网络科学、环境科学、政策。</p><p>奖项设置及获奖比例：特等奖（Outstanding Winner） 0.14%，特等奖提名奖（Finalist） 0.17%，一等奖（Meritorious Winner）7%左右，二等奖（Honorable Mentioned） 15%左右，成功参与奖也叫三等奖（Successful Participant）</p><hr><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><h3 id="信息入口"><a href="#信息入口" class="headerlink" title="信息入口"></a>信息入口</h3><p><a href="https://www.zhihu.com/question/19714813" target="_blank" rel="noopener">知乎：如何入门参与数学建模？</a></p><hr><h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><p>写作软件：latex</p><p>编程软件：Matlab</p><p>公式编辑器：Mathtype</p><p>画图：Visio，亿图</p><hr><h3 id="数模学习"><a href="#数模学习" class="headerlink" title="数模学习"></a>数模学习</h3><p>书籍推荐：《数学建模》 姜启源 ，《数学建模算法与应用》司守奎</p><hr><h3 id="其他准备"><a href="#其他准备" class="headerlink" title="其他准备"></a>其他准备</h3><p>论文写作：往届获奖论文，论文模板等</p><p>经典的算法：待补充</p><hr><h3 id="学术搜索引擎"><a href="#学术搜索引擎" class="headerlink" title="学术搜索引擎"></a>学术搜索引擎</h3><p>1、<a href="https://link.zhihu.com/?target=http%3A//scholar.google.com/" target="_blank" rel="noopener">http://scholar.google.com/</a> </p><p>2、<a href="https://link.zhihu.com/?target=http%3A//qns.cc/" target="_blank" rel="noopener">http://qns.cc/</a> </p><p>后起之秀，科研人员的良好助手，上此网站的90%是从事科研的学生与老师。其词典搜索集成了目前市面上最好的在线英汉写作及科研词典，用此搜索引擎写作英文论文相当方便；其文献搜索集成了目前最优秀的数据库。</p><p>3、<a href="https://link.zhihu.com/?target=http%3A//www.scirus.com" target="_blank" rel="noopener">http://www.scirus.com</a> </p><p>Scirus是目前互联网上最全面、综合性最强的科技文献搜索引擎之一，由Elsevier科学出版社开发，用于搜索期刊和专利，效果很不错！Scirus覆盖的学科范围包括：农业与生物学，天文学，生物科学，化学与化工，计算机科学，地球与行星科学，经济、金融与管理科学，工程、能源与技术，环境科学，语言学，法学，生命科学，材料科学，数学，医学 ，神经系统科学，药理学，物理学，心理学，社会与行为科学，社会学等。</p><p>4、sci-hub</p><h3 id="关于Latex"><a href="#关于Latex" class="headerlink" title="关于Latex"></a>关于Latex</h3><p><a href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener">一份其实很短的 LaTeX 入门文档</a></p><p>在文档类 <code>article</code>/<code>ctexart</code> 中，定义了五个控制序列来调整行文组织结构。他们分别是</p><ul><li><code>\section{·}</code></li><li><code>\subsection{·}</code></li><li><code>\subsubsection{·}</code></li><li><code>\paragraph{·}</code></li><li><code>\subparagraph{·}</code></li></ul><pre class="line-numbers language-tex"><code class="language-tex">\documentclass{article}% 这里是导言区% 中英文混排% \documentclass[UTF8]{ctexart}% 数学模式\usepackage{amsmath}\begin{document}% 行内式Einstein 's $E=mc^2$.% 行间式\[ E=mc^2. \]% 根式与分式$\sqrt{x}$, $\frac{1}{2}$.\[ \sqrt{x}, \]\[ \frac{1}{2}. \]% 上下标，下标是_\[ z = r\cdot e^{2\pi i}. \]% 运算符\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;\geq\; \leq\; \neq\; \approx \; \equiv \]% 大型运算符$ \sum_{i=1}^n i\quad \prod_{i=1}^n $$ \sum\limits _{i=1}^n i\quad \prod\limits _{i=1}^n $\[ \lim_{x\to0}x^2 \quad \int_a^b x^2 dx \]\[ \lim\nolimits _{x\to0}x^2\quad \int\nolimits_a^b x^2 dx \]% 多重积分\[ \iint\quad \iiint\quad \iiiint\quad \idotsint \]% 定界符（括号等）\lvert\rvert\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]\[ \Biggl \{\biggl \{\Bigl \{\bigl \{\{x\}\bigr \}\Bigr \}\biggr \}\Biggr\} \]\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]% 省略号\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad\vdots\quad \ddots \]% 矩阵\[ \begin{pmatrix} a&b\\c&d \end{pmatrix} \quad\begin{bmatrix} a&b\\c&d \end{bmatrix} \quad\begin{Bmatrix} a&b\\c&d \end{Bmatrix} \quad\begin{vmatrix} a&b\\c&d \end{vmatrix} \quad\begin{Vmatrix} a&b\\c&d \end{Vmatrix} \]Marry has a little matrix $ ( \begin{smallmatrix} a&b\\c&d \end{smallmatrix} ) $.% 多行公式% 如果不需要编号，可以使用 multline* 环境代替\begin{multline}x = a+b+c+{} \\d+e+f+g\end{multline}% 对齐\[\begin{aligned}x ={}& a+b+c+{} \\&d+e+f+g\end{aligned}\]% 公式组% 无需对齐的公式组可以使用 gather 环境% 需要对齐的公式组可以使用 align 环境% 如果不需要编号可以使用带星花的版本\begin{gather}a = b+c+d \\x = y+z\end{gather}\begin{align}a &= b+c+d \\x &= y+z\end{align}% 分段函数\[ y= \begin{cases}-x,\quad x\leq 0 \\x,\quad x>0\end{cases} \]% 图片%\documentclass{article}%\usepackage{graphicx}%\begin{document}%\includegraphics{a.jpg}% \includegraphics[width = .8\textwidth]{a.jpg}% 控制大小%\end{document}% 表格\begin{tabular}{|l|c|r|} \hlinesys& release& editor\\ \hlineWindows & MikTeX & TexMakerX \\ \hlineUnix/Linux & teTeX & Kile \\ \hlineMac OS & MacTeX & TeXShop \\ \hlineuniverse& TeX Live & TeXworks \\ \hline\end{tabular}% 浮动体\begin{figure}[htbp]% [htbp]用来指定插图的理想位置，% 这几个字母分别代表 here, top, bottom, float page\centering% \centering 用来使插图居中% \includegraphics{a.jpg}\caption{the truth}% \caption 命令设置插图标题\label{fig:myphoto}% 注意 \label 应该放在标题命令之后\end{figure}\end{document}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h2><h3 id="2020美赛C题（9-25）"><a href="#2020美赛C题（9-25）" class="headerlink" title="2020美赛C题（9.25）"></a>2020美赛C题（9.25）</h3><hr><p><a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">麻省理工公开课：线性代数</a></p><p>第一次刷题试水，需要补一下数学，再补一下排版和画图</p><hr><h3 id="2020美赛D题（12-16）"><a href="#2020美赛D题（12-16）" class="headerlink" title="2020美赛D题（12.16）"></a>2020美赛D题（12.16）</h3><h4 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h4><p><a href="https://www.bilibili.com/video/BV1j7411W7FP/?spm_id_from=trigger_reload" target="_blank" rel="noopener">美赛latex排版b站视频</a></p><p><a href="https://liam.page/2016/01/27/how-to-use-mcmthesis/" target="_blank" rel="noopener">如何使用美赛模板 mcmthesis</a></p><p><a href="https://github.com/latexstudio-org/mcmthesis" target="_blank" rel="noopener">模板下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> 美赛 </tag>
            
            <tag> 数模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机书单</title>
      <link href="/2020/09/02/ji-suan-ji-shu-dan/"/>
      <url>/2020/09/02/ji-suan-ji-shu-dan/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>《现代操作系统》Andrew S.Tanenbaum &amp; Herbert Bos   </p><p>​    </p><p>《鸟哥的Linux私房菜》</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>《计算机网络》James F. Kurose &amp; Keith W.Ross</p><p>《图解TCP\IP》</p><p>《图解HTTP》</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>《大话数据结构》</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>《Python从入门到实践》</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>《Java核心技术卷Ⅰ》</p><p>《深入理解Java虚拟机》</p><h4 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h4><p>《Go语言实战》</p><p>​      </p><h4 id="程序员人生"><a href="#程序员人生" class="headerlink" title="程序员人生"></a>程序员人生</h4><p>《代码整洁之道》</p><p>​       </p><p>吴军老师的书</p><p>《浪潮之巅》</p><p>​     </p><p>《数学之美》</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《数据挖掘——实用机器学习技术》</p><p>《机器学习实战》</p><p>《机器学习》（西瓜书）周志华</p>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 书 </tag>
            
            <tag> 待更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从1开始写Blog</title>
      <link href="/2020/08/31/cong-1-kai-shi-xie-blog/"/>
      <url>/2020/08/31/cong-1-kai-shi-xie-blog/</url>
      
        <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrENiK9j7bR9qXYA11EY4TsPRZJqdImIwU1LgreNkyYn04*MFe2ZNrTrthPykK2B.ahOc0P5g1Gp1rjyBsYJnDKjU!/r" alt></p><h2 id="从1开始写Blog"><a href="#从1开始写Blog" class="headerlink" title="从1开始写Blog"></a>从1开始写Blog</h2><h3 id="写给自己"><a href="#写给自己" class="headerlink" title="写给自己"></a>写给自己</h3><h4 id="博客是什么"><a href="#博客是什么" class="headerlink" title="博客是什么"></a>博客是什么</h4><p>参见我的<a href="https://henry-avery.github.io/friends/" target="_blank" rel="noopener">友情链接</a>里的博客以及其他知名博客</p><p><a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="https://coolshell.cn/" target="_blank" rel="noopener">陈皓&amp;酷壳</a></p><p><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a></p><p><a href="https://lepture.com/" target="_blank" rel="noopener">LEPTURE</a></p><p><a href="http://www.yinwang.org/" target="_blank" rel="noopener">王垠</a></p><h4 id="要怎么写博客"><a href="#要怎么写博客" class="headerlink" title="要怎么写博客"></a>要怎么写博客</h4><p><a href="https://blog.huihut.com/2017/01/25/MarkdownTutorial/#urllink" target="_blank" rel="noopener">Markdown 简易入门教程</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰写的Git教程</a></p><p>建议window系统先参考教程安装好Git bash</p><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a></p><h4 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h4><p>可以看看《暗时间》作者刘未鹏写的这篇博客文章</p><p><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）写博客</a></p><p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrEElfJNrKjuyWae8U.db2Cr12qAfm0jJPNi8jwmhLjXfrKEBE9HoyGNcJKjczdR*jtuu3yOjfUe79vJswISqmipY!/r" alt="黄金圈法则"></p><h3 id="写给同类"><a href="#写给同类" class="headerlink" title="写给同类"></a>写给同类</h3><h4 id="为什么写博客"><a href="#为什么写博客" class="headerlink" title="为什么写博客"></a>为什么写博客</h4><p>种下一棵树最好的时间是十年以前，其次是现在。</p><p>阅读和学习是输入，写作和实践是输出，都是我们了解这个世界的途径。</p><p>阅读和写作、策划组织都是一个人的心智体现。不断阅读就需要不断主动思考，将思考的过程和结果写出来，不仅能够提高自己的心智，提高组织策划的能力，也能为他人提供参考。</p><p>为了不断超越自己。</p><p>Challenge the status quo</p><h4 id="怎么写博客"><a href="#怎么写博客" class="headerlink" title="怎么写博客"></a>怎么写博客</h4><p>搭建好博客，写下去。每周至少写完一篇发到博客上。所以平时需要多写，每天都至少要写三十分钟。</p><h4 id="博客写什么"><a href="#博客写什么" class="headerlink" title="博客写什么"></a>博客写什么</h4><p>可能写一写日常生活里值得思考的小事，或者是技术上解决的问题和信息资源的整理。</p><hr><h2 id="各种报错"><a href="#各种报错" class="headerlink" title="各种报错"></a>各种报错</h2><p><strong>hexo s</strong>报错</p><pre><code>FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error:  [Line 78, Column 29] expected variable end</code></pre><p>解决办法：<br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">官网描述</a></p><p>翻译过来就是： 转义内容 Hexo使用Nunjucks渲染帖子（较早的版本使用Swig，它们具有相似的语法）。</p><p>用<code>{ { } }</code>或<code>{ ％ ％ }</code>包装的内容将被解析，并可能导致问题。</p><p>您可以使用原始标签插件包装敏感内容。<br>找到正文里面<code>{ {</code>、<code>} }</code>、<code>{ %</code>、<code>% }</code>这样的语句，作如下修改：</p><pre><code>{% raw %}//敏感内容前加上这个Hello {{ sensitive }}l/敏感内容被包装在中间{% endraw %}    //敏感内容后加上这个</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在更 </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一复盘总结</title>
      <link href="/2020/08/25/da-yi-fu-pan-zong-jie/"/>
      <url>/2020/08/25/da-yi-fu-pan-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1456606483&auto=1&height=66"></iframe></div><p><img src="https://i.loli.net/2020/08/23/iPFjVSvNz416AQn.jpg" alt></p><hr><blockquote><p>在大二开学之前把大一复盘总结完成，拖了两个礼拜了还没写,可能拖延症又犯了。</p></blockquote><h1 id="我的大一"><a href="#我的大一" class="headerlink" title="我的大一"></a>我的大一</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><img src="http://r.photo.store.qq.com/psc?/V50yGAmm4Y7rG60gKAT73IXxN51CK3xl/TmEUgtj9EK6.7V8ajmQrEDmlLxX5p3JcMGVqq00maXeZj1EL0BlNZ39Ez98p56TknxscaiaPIitxGWIdZhgwdciiCH25KkO0BNthc.zunsQ!/r" alt="从这里开始，十八岁收到的生日礼物是大学录取通知书"></p><p>​    </p><h3 id="2019上半年"><a href="#2019上半年" class="headerlink" title="2019上半年"></a>2019上半年</h3><p>8.27  <strong>初见上大</strong></p><p>9月-11月  <strong>秋季学期</strong></p><p>11月-12月  <strong>冬季学期前六周</strong></p><p>​    </p><p>小插曲  <strong>COVID-19</strong></p><p>​    </p><hr><p>​    </p><h3 id="2020上半年"><a href="#2020上半年" class="headerlink" title="2020上半年"></a>2020上半年</h3><p>1月  <strong>寒假生活</strong></p><p>2月  <strong>疫情影响居家网课</strong></p><p>3月-7月  <strong>冬季学期春季学期网课考试分流</strong></p><p>8月  <strong>计算机实训+十天暑假</strong></p><p>8.27 <strong>返校换寝</strong></p><blockquote><p>再见了，大一！</p></blockquote><hr><h2 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h2><p>到了大学的第三周之后开始<strong>早睡早起</strong>，一开始是因为看了张萌姐姐写的《人生效率手册》，富兰克林自传里的时间规划，后来又认识了一个知乎大V王振宇，我也切身体会到了每天早上多出来三个小时自由时间到带来的好处，喜欢上了每天早起写作的感觉，就一直坚持了下来，慢慢也就形成了习惯。</p><p><strong>阅读，写书评</strong>。因为小木屋的返现活动要打卡80天，所以借此机会认真写了一些书评，不过大多数都还是很水的。但是养成了借书看书的习惯。每个月去图书馆借一次书，制定了500本书的大学四年阅读计划。按照《如何阅读一本书》训练自己的阅读能力。商业科技政治文学历史哲学均有涉猎，尤其喜欢各种传记。</p><p><strong>写作，运营公众号</strong>。通过公众号了解互联网运营中的各种策略和技巧，以管窥豹。对于流量有了更清晰的认识，不止是知乎和b站、抖音短视频等等。理解更重要的是内容创作，从每周一更到后来每月一更，不同的阶段有不同的感悟。开始用心留意之前生活中可能并不在意的东西。写作反过来又推动阅读的需求，形成欧皇飞轮，良性循环反馈。</p><p><strong>做计划，复盘总结</strong>。不停尝试新事物，把想做的事情和没做完的事情列出来，在下一个月一项一项去完成。总结自己一个月里值得记录的事情。不断更新，有了自己的个人宪法和复盘系统。每周的日程规划也帮助我很好地处理各种看似不可能完成的任务。形成了自己完成计划的个人习惯。</p><p><strong>时间管理</strong>，其实就是做计划的一部分。主要是花在手机屏幕上的时间太多，使用番茄TODO和手机应用限时减少手机使用时间。不打游戏，不把时间花在没有意义的事情上。</p><p><strong>跑步。</strong>之前是想以参加一次半马为目标，中秋节晚上跑了人生的第一个10公里，那天在宿舍看完《搏击俱乐部》，绕着学校跑了三四圈，一个小时，喜欢上了多巴胺刺激大脑的这种感觉，每个月都会跑个三四十公里，可能还是跑量不够，也没控制配速，所以速度提升不大。后来开始健身，更多了解相关知识，改变了把长跑当做训练目标的想法，制定了自己的健身计划，以提升力量为主。居家半年买了一对哑铃自己在家训练，由于器材有限主要锻炼的是前臂。效果没有达到想象中的好。但是运动成了很好的放松方式，大大提升了我的生活质量。</p><p><strong>写日记。</strong>其实也没什么好记的，有时候就是写一句话，感触深的时候写一大段直抒胸臆，晚上睡觉做的梦记录下来留作写作素材。虽然想要借此训练写作，但实施起来还是有困难，原因在于没有认真考虑过把写日记当成一项任务安排进每天的日程里。目前没有在日记里写过多少有价值的东西，最多是我自己的一些片段回忆。</p><hr><h2 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h2><p>在更……</p><hr><h2 id="信息篇"><a href="#信息篇" class="headerlink" title="信息篇"></a>信息篇</h2><h3 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h3><blockquote><p>​    “信息管理就是拓宽信道，即打开新的信息入口，接受新的信息；然后整合你收集到的信息，即对无用的信息进行降噪，并且对有用的信息进行排序，提高查找信息的效率。”</p></blockquote><hr><h3 id="信息入口"><a href="#信息入口" class="headerlink" title="信息入口"></a>信息入口</h3><h4 id="我的书单"><a href="#我的书单" class="headerlink" title="我的书单"></a>我的书单</h4><ul><li>计算机书单</li><li>待更……</li></ul><p>​    </p><h4 id="课外学习"><a href="#课外学习" class="headerlink" title="课外学习"></a>课外学习</h4><ul><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1ex411u7GV" target="_blank" rel="noopener">CS183B@Stanford/YC创业课</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">【英字】MIT公开课 概率论</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1Kt411h7Ep" target="_blank" rel="noopener">【公开课】耶鲁大学：博弈论（中英双语字幕）</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1as411o7tU" target="_blank" rel="noopener">國立清華大學開放課：科幻概論——主講：鄭運鴻</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1gE411M7Eg" target="_blank" rel="noopener">【吴恩达亲授】适用于所有人的人工智能课程（中字）</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1JE411g7XF" target="_blank" rel="noopener">李宏毅2020机器学习深度学习(完整版)国语</a></li></ul><h4 id="手机app"><a href="#手机app" class="headerlink" title="手机app"></a>手机app</h4><ul><li>豆瓣、知乎</li><li>微信读书、京东读书（校园版）、藏书馆</li><li>得到、喜马拉雅、每日英语听力</li><li>一席、TED、b站</li><li>微信公众号</li></ul><h4 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h4><ul><li>收藏网址书签<ul><li><a href="https://b-ok.cc/" target="_blank" rel="noopener">英文原版电子书1</a></li><li><a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">英文原版电子书2</a></li><li><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学MOOC</a></li><li><a href="https://open.163.com/" target="_blank" rel="noopener">网易公开课</a></li><li>优质博客</li></ul></li></ul><h4 id="社交通讯APP"><a href="#社交通讯APP" class="headerlink" title="社交通讯APP"></a>社交通讯APP</h4><ul><li>Tim</li><li>微信</li><li>QQ    </li></ul><hr><h2 id="启航篇"><a href="#启航篇" class="headerlink" title="启航篇"></a>启航篇</h2><p>待更……</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
